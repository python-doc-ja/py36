<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Unicode HOWTO &#8212; Python 3.6.0 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.0 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.0 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python HOWTO" href="index.html" />
    <link rel="next" title="urllib パッケージを使ってインターネット上のリソースを取得するには" href="urllib2.html" />
    <link rel="prev" title="ソート HOW TO" href="sorting.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/howto/unicode.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/howto/unicode.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="urllib2.html" title="urllib パッケージを使ってインターネット上のリソースを取得するには"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="ソート HOW TO"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.0</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="unicode-howto">
<span id="id1"></span><h1>Unicode HOWTO<a class="headerlink" href="#unicode-howto" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Release:</th><td class="field-body">1.12</td>
</tr>
</tbody>
</table>
<p>この HOWTO 文書は Python の Unicode サポートについて論じ、さらに Unicode を使おうというときによくでくわす多くの問題について説明します。</p>
<div class="section" id="introduction-to-unicode">
<h2>Unicode 入門<a class="headerlink" href="#introduction-to-unicode" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="history-of-character-codes">
<h3>文字コードの歴史<a class="headerlink" href="#history-of-character-codes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>1968年に American Standard Code for Information Interchange が標準化されました。これは頭文字の ASCII でよく知られています。ASCII は0から127までの、異なる文字の数値コードを定義していて、例えば、小文字の &#8216;a&#8217; にはコード値 97 が割り当てられています。</p>
<p>ASCII はアメリカの開発標準だったのでアクセント無しの文字のみを定義していて、 &#8216;e&#8217; はありましたが、 &#8216;é&#8217; や &#8216;Í&#8217; はありませんでした。つまり、アクセント付きの文字を必要とする言語は ASCII できちんと表現するとができません。 (実際には英語でもアクセントが無いために起きる問題がありました、 &#8216;naïve&#8217; や &#8216;café&#8217; のようなアクセントを含む単語や、いくつかの出版社は &#8216;coöperate&#8217; のような独自のスタイルのつづりを必要とするなど)</p>
<p>しばらくの間、人々は単にアクセント表示無しのプログラムを書いていました。1980 年代半ばに、フランス語を話す開発者によって書かれた Apple II の Basic プログラムは、次のような行を含んでいました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">PRINT</span> <span class="s2">&quot;MISE A JOUR TERMINEE&quot;</span>
<span class="n">PRINT</span> <span class="s2">&quot;PARAMETRES ENREGISTRES&quot;</span>
</pre></div>
</div>
<p>これらのメッセージはアクセントを含んでいるはず (terminée, paramètre, enregistrés) で、フランス語が読める人にとっては単なる間違いのように見られてしまいます。</p>
<p>1980 年代には、ほぼ全てのパーソナルコンピューターは 8-bit で、これは 0 から 255 までの範囲の値を保持できることを意味しました。ASCII コードは最大で 127 までだったので、あるマシンでは 128 から 255 までの値にアクセント付きの文字を割り当てていました。しかし、異なるマシンは異なる文字コードを持っていたため、ファイル交換で問題が起きるようになってきました。結局、128 から 255 まで範囲の値のセットで、よく使われるものが色々と現れました。そのうちいくつかは国際標準化機構 (International Standards Organization) によって定義された本物の標準になり、またいくつかはあちこちの会社で開発され、なんとか広まったものが <em>事実上の</em> 慣習となっていきました。</p>
<p>255文字というのは十分多い数ではありません。例えば、西ヨーロッパで使われるアクセント付き文字とロシアで使われるキリルアルファベットの両方は 128文字以上あるので、128&#8211;255の間におさめることはできません。</p>
<p>異なる文字コードを使ってファイルを作成することは可能です (持っているロシア語のファイル全てを KOI8 と呼ばれるコーディングシステムで、持っているフランス語のファイル全てを別の Latin1 と呼ばれるコーディングシステムにすることで)、しかし、ロシア語の文章を引用するフランス語の文章を書きたい場合にはどうでしょう? 1989年代にこの問題を解決したいという要望が上って、Unicode 標準化の努力が始まりました。</p>
<p>Unicord は 8-bit 文字の代わりに 16-bit 文字を使うことに取り掛かりました。16 bit ということは 2^16 = 65,536 の異なった値が使え、多くの様々なアルファベットの様々な文字を表現できるということを意味します; 最初の目標は、Unicode に人間の1つ1つの言語のアルファベットを含めることでした。しかし 16 bit でさえ、その目標を達成するためには不十分であることが判明し、最新の Unicode 規格では 0 から 1,114,111 (16進表記で <code class="docutils literal"><span class="pre">0x10FFFF</span></code> ) までのより広い範囲の文字コードを使っています。</p>
<p>関連する ISO 標準も ISO 10646 があります。Unicode と ISO 10646 は元々独立した成果でしたが、 Unicode の 1.1 リビジョンで仕様を併合しました。</p>
<p>(This discussion of Unicode&#8217;s history is highly simplified.  The
precise historical details aren&#8217;t necessary for understanding how to
use Unicode effectively, but if you&#8217;re curious, consult the Unicode
consortium site listed in the References or
the <a class="reference external" href="https://en.wikipedia.org/wiki/Unicode#History">Wikipedia entry for Unicode</a>
for more information.)</p>
</div>
<div class="section" id="definitions">
<h3>定義<a class="headerlink" href="#definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><strong>文字</strong> は文章の構成要素の中の最小のものです。&#8217;A&#8217;, &#8216;B&#8217;, &#8216;C&#8217; などは全て異なる文字です。 &#8216;È&#8217; や &#8216;Í&#8217; も同様に異なる文字です。文字は抽象的な概念で、言語や文脈に依存してさまざまに変化します。例えば、オーム(Ω) はふつう大文字ギリシャ文字のオメガ (Ω) で書かれますが (これらはいくつかのフォントで全く同じ書体かもしれません) しかし、これらは異なる意味を持つ異なる文字とみなされます。</p>
<p>Unicode 標準は文字をどのように <strong>コードポイント (code points)</strong> で表現されるのかを記述しています。コードポイントは通常 16 進数で表記される整数値です。Unicode 標準では、コードポイントは <code class="docutils literal"><span class="pre">U+12CA</span></code> という表記を使って書かれ、これは <code class="docutils literal"><span class="pre">0x12ca</span></code> (10 進表記で 4,810) という値を持つ文字ということを意味します。Unicode 標準は、文字とそれに対応するコードポイントを列挙した多くの表を含んでいます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>0061    &#39;a&#39;; LATIN SMALL LETTER A
0062    &#39;b&#39;; LATIN SMALL LETTER B
0063    &#39;c&#39;; LATIN SMALL LETTER C
...
007B    &#39;{&#39;; LEFT CURLY BRACKET
</pre></div>
</div>
<p>厳密に言うと、この定義から「これは文字 <code class="docutils literal"><span class="pre">U+12CA</span></code> です」と言うのは意味の無いことだと分かります。<code class="docutils literal"><span class="pre">U+12CA</span></code> はコードポイントであり、それはある特定の文字を表しているのです; この場合では、&#8217;ETHIOPIC SYLLABLE WI&#8217; という文字を表しています。形式ばらない文脈では、このコードポイントと文字の区別は忘れ去られることもあります。</p>
<p>文字は画面や紙面上では <strong>グリフ (glyph)</strong> と呼ばれるグラフィック要素の組で表示されます。大文字の A のグリフは例えば、厳密な形は使っているフォントによって異なりますが、斜めの線と水平の線です。たいていの Python コードではグリフの心配をする必要はありません; 一般的には表示する正しいグリフを見付けることは GUI toolkit や端末のフォントレンダラーの仕事です。</p>
</div>
<div class="section" id="encodings">
<h3>エンコーディング<a class="headerlink" href="#encodings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前の節をまとめると: Unicode 文字列はコードポイントのシーケンスであり、コードポイントとは 0 から <code class="docutils literal"><span class="pre">0x10FFFF</span></code> (10 進表記で 1,114,111) までの数値です。このシーケンスはメモリ上ではバイト (つまり 0 から 255 までの値) の集まりとして表される必要があります。Unicode 文字列をバイトのシーケンスとして翻訳する規則を <strong>エンコーディング (encoding)</strong> と呼びます。</p>
<p>まず考え付くエンコーディングは 32-bit 整数の配列でしょう。この表現では、文字列 &#8220;Python&#8221; は次のようになるでしょう:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>   P           y           t           h           o           n
0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00
   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
</pre></div>
</div>
<p>この表現は直接的でわかりやすい方法ですが、この表現を使うにはいくつかの問題があります。</p>
<ol class="arabic simple">
<li><p class="first">可搬性がない; プロセッサが異なるとバイトの順序づけも変わってしまいます。</p>
</li>
<li><p class="first">無駄な領域が多いです。多くの文書では、コードポイントは 127 未満もしくは 255 未満が多数派を占め、そのため多くの領域が <code class="docutils literal"><span class="pre">0x00</span></code> というバイトで埋め尽くされます。上の文字列は、ASCII 表現では 6 バイトなのに対し、24 バイトのサイズになっています。RAM の使用量が増加するのはそれほど問題にはなりません (デスクトップコンピュータはギガバイト単位の RAM を持っており、通常、文字列はそんな大きさにはなりません) が、ディスクとネットワーク大域が 4 倍多く使われてしまうのは我慢できるものではありません。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">strlen()</span></code> のような現存する C 関数と互換性がありません、そのためワイド文字列関数一式が新たに必要となります。</p>
</li>
<li><p class="first">多くのインターネット標準がテキストデータとして定義されていて、それらはゼロバイトの埋め込まれた内容を扱うことができません。</p>
</li>
</ol>
<p>一般的にこのエンコーディングは使わず、変わりにより効率的で便利な他のエンコーディングが選ばれています。 UTF-8 はたぶん最も一般的にサポートされているエンコーディングです。このエンコーディングについては後で説明します。</p>
<p>エンコーディングは全ての Unicode 文字を扱う必要はありませんし、多くのエンコーディングはそれをしません。Unicode 文字列を ASCII エンコーディングに変換する規則は単純です; それぞれのコードポイントに対して:</p>
<ol class="arabic simple">
<li><p class="first">コードポイントは128より小さい場合、コードポイントと同じ値です。</p>
</li>
<li><p class="first">コードポイントが128以上の場合、Unicode 文字列はエンコーディングで表示することができません。 (この場合 Python は <a class="reference internal" href="../library/exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a> 例外を送出します。)</p>
</li>
</ol>
<p>Latin-1, ISO-8859-1 として知られるエンコーディングも同様のエンコーディングです。Unicode コードポイントの 0&#8211;255 は Latin-1 の値と等価なので、このエンコーディングの変換するには、単純にコードポイントをバイト値に変換する必要があります; もしコードポイントが255より大きい場合に遭遇した場合、文字列は Latin-1 にエンコードできません。</p>
<p>エンコーディングは Latin-1 のように単純な一対一対応を持っていません。 IBM メインフレームで使われていた IBM の EBCDIC で考えてみます。文字は一つのブロックに収められていませんでした: &#8216;a&#8217; から &#8216;i&#8217; は 129 から 137 まででしたが、 &#8216;j&#8217; から &#8216;r&#8217; までは 145 から 153 までした。 EBICIC を使いたいと思ったら、おそらく変換を実行するルックアップテーブルの類を使う必要があるでしょう、これは内部の詳細のことになりますが。</p>
<p>UTF-8 は最もよく使われているエンコーディングの1つです。UTF は &#8220;Unicode Transformation Format&#8221; を表していて、&#8216;8&#8217; は 8-bit 整数がエンコーディングで使われていることを意味しています。(UTF-16 や UTF-32 というエンコーディングもありますが、それらは UTF-8 ほどには頻繁に使われません。) UTF-8 は次のようなルールを使っています:</p>
<ol class="arabic simple">
<li><p class="first">コードポイントが 128 未満だった場合、対応するバイト値で表現します。</p>
</li>
<li><p class="first">コードポイントが 128 以上の場合、128 から 255 までのバイトからなる、2、3 または 4 バイトのシーケンスに変換します。</p>
</li>
</ol>
<p>UTF-8 はいくつかの便利な性質を持っています:</p>
<ol class="arabic simple">
<li><p class="first">任意の Unicode コードポイントを扱うことができる。</p>
</li>
<li>A Unicode string is turned into a sequence of bytes containing no embedded zero
bytes.  This avoids byte-ordering issues, and means UTF-8 strings can be
processed by C functions such as <code class="docutils literal"><span class="pre">strcpy()</span></code> and sent through protocols that
can&#8217;t handle zero bytes.</li>
<li><p class="first">ASCII テキストの文字列は UTF-8 テキストとしても有効です。</p>
</li>
<li><p class="first">UTF-8 はかなりコンパクトです; よく使われている文字の大多数は 1 バイトか 2 バイトで表現できます。</p>
</li>
<li><p class="first">バイトが欠落したり、失われた場合、次の UTF-8 でエンコードされたコードポイントの開始を決定し、再同期することができる可能性があります。同様の理由でランダムな 8-bit データは正当な UTF-8 とみなされにくくなっています。</p>
</li>
</ol>
</div>
<div class="section" id="references">
<h3>参考資料<a class="headerlink" href="#references" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="http://www.unicode.org">Unicode コンソーシアムのサイト</a> には文字の図表、用語辞典、PDF 版の Unicode 仕様があります。これ読むのはそれなりに難しいので覚悟してください。Unicode の起源と発展の <a class="reference external" href="http://www.unicode.org/history/">年表</a> もサイトにあります。</p>
<p>To help understand the standard, Jukka Korpela has written <a class="reference external" href="https://www.cs.tut.fi/~jkorpela/unicode/guide.html">an introductory
guide</a> to reading the
Unicode character tables.</p>
<p>また別の <a class="reference external" href="http://www.joelonsoftware.com/articles/Unicode.html">良い入門ガイド</a> を Joel Spolsky が書いています。この HOWTO の入門を読んでも理解が明確にならなかった場合は、続きを読む前にこの記事を読んでみるとよいです。</p>
<p>Wikipedia entries are often helpful; see the entries for &#8220;<a class="reference external" href="https://en.wikipedia.org/wiki/Character_encoding">character encoding</a>&#8221; and <a class="reference external" href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, for example.</p>
</div>
</div>
<div class="section" id="python-s-unicode-support">
<h2>Python の Unicode サポート<a class="headerlink" href="#python-s-unicode-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ここまでで Unicode の基礎を学びました、ここから Python の Unicode 機能に触れます。</p>
<div class="section" id="the-string-type">
<h3>文字列型<a class="headerlink" href="#the-string-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 3.0 から、言語は <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 型を Unicode 文字から成るものとして特徴付けています、つまり <code class="docutils literal"><span class="pre">&quot;unicode</span> <span class="pre">rocks!&quot;</span></code> や <code class="docutils literal"><span class="pre">'unicode</span> <span class="pre">rocks!'</span></code> や三重クオート文字列の構文を使って作られた文字列は Unicode として格納されます。</p>
<p>Python ソースコードのデフォルトエンコーディングは UTF-8 なので、文字列リテラルの中に Unicode 文字をそのまま含めることができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/input.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
    <span class="c1"># &#39;File not found&#39; error message.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fichier non trouvé&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>特殊な形式のコメントをソースコードの1行目もしくは2行目に配置することで、UTF-8 ではないエンコーディングを使うことができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: &lt;encoding name&gt; -*-</span>
</pre></div>
</div>
<p>追記: Python3 は Unicode 文字を使った識別子もサポートしています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">répertoire</span> <span class="o">=</span> <span class="s2">&quot;/tmp/records.log&quot;</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">répertoire</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;test</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>エディタである特定の文字が入力できなかったり、とある理由でソースコードを ASCII のみに保ちたい場合は、文字列リテラルでエスケープシーケンスが使えます。(使ってるシステムによっては、u でエスケープされた文字列ではなく、実物の大文字のラムダのグリフが見えるかもしれません。):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;</span><span class="se">\N{GREEK CAPITAL LETTER DELTA}</span><span class="s2">&quot;</span>  <span class="c1"># Using the character name</span>
<span class="go">&#39;\u0394&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;</span><span class="se">\u0394</span><span class="s2">&quot;</span>                          <span class="c1"># Using a 16-bit hex value</span>
<span class="go">&#39;\u0394&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;</span><span class="se">\U00000394</span><span class="s2">&quot;</span>                      <span class="c1"># Using a 32-bit hex value</span>
<span class="go">&#39;\u0394&#39;</span>
</pre></div>
</div>
<p>加えて、 <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> クラスの <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal"><span class="pre">decode()</span></code></a> メソッドを使って文字列を作ることもできます。このメソッドは <code class="docutils literal"><span class="pre">UTF-8</span></code> のような値を <em>encoding</em> 引数に取り、オプションで <em>errors</em> 引数を取ります。</p>
<p><em>errors</em> 引数は、入力文字列に対しエンコーディングルールに従った変換ができなかったときの対応方法を指定します。この引数に使える値は <code class="docutils literal"><span class="pre">'strict'</span></code> (<a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> を送出する)、 <code class="docutils literal"><span class="pre">'replace'</span></code> (<code class="docutils literal"><span class="pre">REPLACEMENT</span> <span class="pre">CHARACTER</span></code> である <code class="docutils literal"><span class="pre">U+FFFD</span></code> を使う)、 <code class="docutils literal"><span class="pre">'ignore'</span></code> (結果となる Unicode から単に文字を除く) 、<code class="docutils literal"><span class="pre">'backslashreplace'</span></code> (エスケープシーケンス <code class="docutils literal"><span class="pre">\xNN</span></code> を挿入する) です。次の例はこれらの違いを示しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x80</span><span class="s1">abc&#39;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="s2">&quot;strict&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">UnicodeDecodeError</span>: <span class="n">&#39;utf-8&#39; codec can&#39;t decode byte 0x80 in position 0:</span>
<span class="go">  invalid start byte</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x80</span><span class="s1">abc&#39;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="s2">&quot;replace&quot;</span><span class="p">)</span>
<span class="go">&#39;\ufffdabc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x80</span><span class="s1">abc&#39;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="s2">&quot;backslashreplace&quot;</span><span class="p">)</span>
<span class="go">&#39;\\x80abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x80</span><span class="s1">abc&#39;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
</pre></div>
</div>
<p>エンコーディングはエンコーディングの名前を含んだ文字列で指定されます。 Python 3.2 はおよそ 100 の異なるエンコーディングに対応しています; 一覧は Python ライブラリリファレンスの <a class="reference internal" href="../library/codecs.html#standard-encodings"><span class="std std-ref">標準エンコーディング</span></a> を参照してください。いくつかのエンコーディングは複数の名前を持っています; 例えば、 <code class="docutils literal"><span class="pre">'latin-1'</span></code> と <code class="docutils literal"><span class="pre">'iso_8859_1'</span></code> と <code class="docutils literal"><span class="pre">'8859'</span></code> は全て同じエンコーディングの別名です。</p>
<p>Unicode 文字列の一つの文字は <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a> 組み込み関数で作成することができます、この関数は整数を引数にとり、対応するコードポイントを含む長さ1の Unicode 文字列を返します。逆の操作は <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> 組み込み関数です、この関数は一文字の Unicode 文字列を引数にとり、コードポイント値を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mi">57344</span><span class="p">)</span>
<span class="go">&#39;\ue000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\ue000</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">57344</span>
</pre></div>
</div>
</div>
<div class="section" id="converting-to-bytes">
<h3>バイト列への変換<a class="headerlink" href="#converting-to-bytes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a> とは処理が逆向きのメソッドが <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a> です。このメソッドは、 Unicode 文字列を指定された <em>encoding</em> でエンコードして、 <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> による表現で返します。</p>
<p><em>errors</em> 引数は <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a> メソッドのパラメータと同じものですが、サポートされているハンドラの数がもう少し多いです。
<code class="docutils literal"><span class="pre">'strict'</span></code> 、 <code class="docutils literal"><span class="pre">'ignore'</span></code> 、 <code class="docutils literal"><span class="pre">'replace'</span></code> (このメソッドでは、エンコードできなかった文字の代わりに疑問符を挿入する) の他に、 <code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code> (XML 文字参照を挿入する) と <code class="docutils literal"><span class="pre">backslashreplace</span></code> (エスケープシーケンス <code class="docutils literal"><span class="pre">\nNNNN</span></code> を挿入する)、 <code class="docutils literal"><span class="pre">namereplace</span></code> (エスケープシーケンス <code class="docutils literal"><span class="pre">\N{...}</span></code> を挿入する) があります。</p>
<p>次の例では、それぞれの異なる処理結果が示されています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">40960</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;abcd&#39;</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">1972</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">b&#39;\xea\x80\x80abcd\xde\xb4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">UnicodeEncodeError</span>: <span class="n">&#39;ascii&#39; codec can&#39;t encode character &#39;\ua000&#39; in</span>
<span class="go">  position 0: ordinal not in range(128)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="go">b&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
<span class="go">b&#39;?abcd?&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
<span class="go">b&#39;&amp;#40960;abcd&amp;#1972;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;backslashreplace&#39;</span><span class="p">)</span>
<span class="go">b&#39;\\ua000abcd\\u07b4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="s1">&#39;namereplace&#39;</span><span class="p">)</span>
<span class="go">b&#39;\\N{YI SYLLABLE IT}abcd\\u07b4&#39;</span>
</pre></div>
</div>
<p>利用可能なエンコーディングを登録したり、アクセスしたりする低レベルのルーチンは <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュールにあります。新しいエンコーディングを実装するには、 <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュールを理解していることも必要になります。しかし、このモジュールのエンコードやデコードの関数は、使い勝手が良いというより低レベルな関数で、新しいエンコーディングを書くのは特殊な作業なので、この HOWTO では扱わないことにします。</p>
</div>
<div class="section" id="unicode-literals-in-python-source-code">
<h3>Python ソースコード内の Unicode リテラル<a class="headerlink" href="#unicode-literals-in-python-source-code" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のソースコード内では、特定のコードポイントはエスケープシーケンス <code class="docutils literal"><span class="pre">\u</span></code> を使い、続けてコードポイントを4桁の16進数を書きます。エスケープシーケンス <code class="docutils literal"><span class="pre">\U</span></code> も同様です、ただし4桁ではなく8桁の16進数を使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;a</span><span class="se">\xac\u1234\u20ac\U00008000</span><span class="s2">&quot;</span>
<span class="gp">... </span><span class="c1">#     ^^^^ two-digit hex escape</span>
<span class="gp">... </span><span class="c1">#         ^^^^^^ four-digit Unicode escape</span>
<span class="gp">... </span><span class="c1">#                     ^^^^^^^^^^ eight-digit Unicode escape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
<span class="go">[97, 172, 4660, 8364, 32768]</span>
</pre></div>
</div>
<p>127 より大きいコードポイントに対してエスケープシーケンスを使うのは、エスケープシーケンスがあまり多くないうちは有効ですが、フランス語等のアクセントを使う言語でメッセージのような多くのアクセント文字を使う場合には邪魔になります。文字を <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a> 組み込み関数を使って組み上げることもできますが、それはさらに長くなってしまうでしょう。</p>
<p>理想的にはあなたの言語の自然なエンコーディングでリテラルを書くことでしょう。そうなれば、Python のソースコードをアクセント付きの文字を自然に表示するお気に入りのエディタで編集し、実行時に正しい文字が得られます。</p>
<p>Python はデフォルトでは UTF-8 ソースコードを書くことができます、ただしどのエンコーディングを使うかを宣言すればほとんどのエンコーディングを使えます。それはソースファイルの一行目や二行目に特別なコメントを含めることによってできます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: latin-1 -*-</span>

<span class="n">u</span> <span class="o">=</span> <span class="s1">&#39;abcdé&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>この構文は Emacs のファイル固有の変数を指定する表記から影響を受けています。Emacs は様々な変数をサポートしていますが、Python がサポートしているのは &#8216;coding&#8217; のみです。 <code class="docutils literal"><span class="pre">-*-</span></code> の記法はコメントが特別であることを示します; これは Python にとって意味はありませんが慣習です。 Python はコメント中に <code class="docutils literal"><span class="pre">coding:</span> <span class="pre">name</span></code> または <code class="docutils literal"><span class="pre">coding=name</span></code> を探します。</p>
<p>このようなコメントを含んでいない場合、すでに述べた通り、使われるデフォルトエンコーディングは UTF-8 になります。より詳しい情報は <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a> を参照してください。</p>
</div>
<div class="section" id="unicode-properties">
<h3>Unicode プロパティ<a class="headerlink" href="#unicode-properties" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unicode 仕様はコードポイントについての情報のデータベースも含んでいます。それぞれの定義されたコードポイントに対して、その情報は文字の名前、カテゴリ、適用可能であれば数値 (Unicode にはローマ数字や 1/3 や 4/5 のような分数を表す文字があります) を含んでいます。また、右から読むテキストと左から読むテキストが混在しているテキストでのそのコードポイントの読む方向や、他の表示に関連した特質もあります。</p>
<p>以下のプログラムはいくつかの文字に対する情報を表示し、特定の文字の数値を印字します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unicodedata</span>

<span class="n">u</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">233</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="mh">0x0bf2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">3972</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">6000</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">13231</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%04x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">category</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">unicodedata</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

<span class="c1"># Get numeric value of second character</span>
<span class="nb">print</span><span class="p">(</span><span class="n">unicodedata</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>実行すると、このように出力されます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE
1 0bf2 No TAMIL NUMBER ONE THOUSAND
2 0f84 Mn TIBETAN MARK HALANTA
3 1770 Lo TAGBANWA LETTER SA
4 33af So SQUARE RAD OVER S SQUARED
1000.0
</pre></div>
</div>
<p>カテゴリーコードは文字の性質を略記で表したものです。カテゴリーコードは &#8220;Letter&#8221;、&#8221;Number&#8221;、&#8221;Punctuation&#8221;、&#8221;Symbol&#8221; などのカテゴリーに分類され、さらにサブカテゴリーに細分化されます。上記の出力からコードを拾うと、<code class="docutils literal"><span class="pre">'Ll'</span></code> は &#8216;Letter, lowercase&#8217;、<code class="docutils literal"><span class="pre">'No'</span></code> は &#8220;Number, other&#8221;、<code class="docutils literal"><span class="pre">'Mn'</span></code> は &#8220;Mark, nonspacing&#8221;、<code class="docutils literal"><span class="pre">'So'</span></code> は &#8220;Symbol, other&#8221; を意味しています。カテゴリーコードの一覧は <a class="reference external" href="http://www.unicode.org/reports/tr44/#General_Category_Values">Unicode Character Database 文書の General Category Values 節</a> を参照してください。</p>
</div>
<div class="section" id="unicode-regular-expressions">
<h3>Unicode 正規表現<a class="headerlink" href="#unicode-regular-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールがサポートしている正規表現はバイト列や文字列として与えられます。 <code class="docutils literal"><span class="pre">\d</span></code> や <code class="docutils literal"><span class="pre">\w</span></code> などのいくつかの特殊な文字シーケンスは、そのパターンがバイト列として与えられたのか文字列として与えられたのかによって、異なる意味を持ちます。例えば、 <code class="docutils literal"><span class="pre">\d</span></code> はバイト列では <code class="docutils literal"><span class="pre">[0-9]</span></code> の範囲の文字と一致しますが、文字列では <code class="docutils literal"><span class="pre">'Nd'</span></code> カテゴリーにある任意の文字と一致します。</p>
<p>この例にある文字列には、タイ語の数字とアラビア数字の両方で数字の 57 が書いてあります。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Over </span><span class="se">\u0e55\u0e57</span><span class="s2"> 57 flavours&quot;</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()))</span>
</pre></div>
</div>
<p>実行すると、 <code class="docutils literal"><span class="pre">\d+</span></code> はタイ語の数字と一致し、それを出力します。フラグ <a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal"><span class="pre">re.ASCII</span></code></a> を <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> に渡した場合、 <code class="docutils literal"><span class="pre">\d+</span></code> は先程とは違って部分文字列 &#8220;57&#8221; に一致します。</p>
<p>同様に、 <code class="docutils literal"><span class="pre">\w</span></code> は非常に多くの Unicode 文字に一致しますが、バイト列の場合もしくは <a class="reference internal" href="../library/re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal"><span class="pre">re.ASCII</span></code></a> が渡された場合は <code class="docutils literal"><span class="pre">[a-zA-Z0-9_]</span></code> にしか一致しません。 <code class="docutils literal"><span class="pre">\s</span></code> は文字列では Unicode 空白文字に、バイト列では <code class="docutils literal"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> に一致します。</p>
</div>
<div class="section" id="id2">
<h3>参考資料<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python の Unicode サポートについての参考になる議論は以下の2つです:</p>
<ul class="simple">
<li><p class="first">Nick Coghlan による <a class="reference external" href="http://python-notes.curiousefficiency.org/en/latest/python3/text_file_processing.html">Processing Text Files in Python 3</a></p>
</li>
<li><p class="first">Ned Batchelder による PyCon 2012 での発表 <a class="reference external" href="http://nedbatchelder.com/text/unipain.html">Pragmatic Unicode</a></p>
</li>
</ul>
<p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 型については Python ライブラリリファレンスの <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">テキストシーケンス型 &#8212; str</span></a> で解説されています。</p>
<p><a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal"><span class="pre">unicodedata</span></code></a> モジュールについてのドキュメント。</p>
<p><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュールについてのドキュメント。</p>
<p>Marc-André Lemburg は EuroPython 2002 で <a class="reference external" href="https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf">&#8220;Python and Unicode&#8221; というタイトルのプレゼンテーション (PDF スライド)</a> を行いました。このスライドは Python 2 の Unicode 機能 (Unicode 文字列型が <code class="docutils literal"><span class="pre">unicode</span></code> と呼ばれ、リテラルは <code class="docutils literal"><span class="pre">u</span></code> で始まります) の設計について概観する素晴しい資料です。</p>
</div>
</div>
<div class="section" id="reading-and-writing-unicode-data">
<h2>Unicode データを読み書きする<a class="headerlink" href="#reading-and-writing-unicode-data" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>一旦 Unicode データに対してコードが動作するように書き終えたら、次の問題は入出力です。プログラムは Unicode 文字列をどう受けとり、どう Unicode を外部記憶装置や送受信装置に適した形式に変換するのでしょう?</p>
<p>入力ソースと出力先に依存しないような方法は可能です; アプリケーションに利用されているライブラリが Unicode をそのままサポートしているかを調べなければいけません。例えば XML パーサーは大抵 Unicode データを返します。多くのリレーショナルデータベースも Unicode 値の入ったコラムをサポートしていますし、 SQL の問い合わせで Unicode 値を返すことができます。</p>
<p>Unicode のデータはディスクに書き込まれるにあたって通常、特定のエンコーディングに変換されます。推奨はされませんが、これを手動で行うことも可能です。ファイルを開き、8バイトオブジェクトを読み込み、バイト列を <code class="docutils literal"><span class="pre">bytes.decode(encoding)</span></code> で変換することにより実現できます。</p>
<p>1つの問題はエンコーディングのマルチバイトという性質です; 1つの Unicode 文字はいくつかのバイトで表現され得ます。任意のサイズのチャンク (例えば、1024 もしくは 4096 バイト) にファイルの内容を読み込みたい場合、ある 1 つの Unicode 文字をエンコードしたバイト列が、チャンクの末尾での一部分のみ読み込まれの場合のエラー処理のためのコードを書く必要があります。1つの解決策はファイル全体をメモリに読み込み、デコード処理を実行することですが、こうしてしまうと非常に大きなファイルを処理するときの妨げになります; 2 GiB のファイルを読み込む必要がある場合、2 GiB の RAM が必要になります。(実際には、少なくともある瞬間では、エンコードされた文字列と Unicode 文字列の両方をメモリに保持する必要があるため、より多くのメモリが必要です。)</p>
<p>The solution would be to use the low-level decoding interface to catch the case
of partial coding sequences.  The work of implementing this has already been
done for you: the built-in <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> function can return a file-like object
that assumes the file&#8217;s contents are in a specified encoding and accepts Unicode
parameters for methods such as <a class="reference internal" href="../library/io.html#io.TextIOBase.read" title="io.TextIOBase.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a> and
<a class="reference internal" href="../library/io.html#io.TextIOBase.write" title="io.TextIOBase.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a>.  This works through <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>&#8216;s <em>encoding</em> and
<em>errors</em> parameters which are interpreted just like those in <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a>
and <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a>.</p>
<p>そのためファイルから Unicode を読むのは単純です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;unicode.txt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
</pre></div>
</div>
<p>読み書きの両方ができる update モードでファイルを開くことも可能です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\u4500</span><span class="s1"> blah blah blah</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Unicode 文字 <code class="docutils literal"><span class="pre">U+FEFF</span></code> は byte-order mark (BOM) として使われ、ファイルのバイト順の自動判定を支援するために、ファイルの最初の文字として書かれます。UTF-16 のようないくつかのエンコーディングは、ファイルの先頭に BOM があることを要求します; そのようなエンコーディングが使われるとき、自動的に BOM が最初の文字として書かれ、ファイルを読むときに暗黙の内に取り除かれます。これらのエンコーディングには、リトルエンディアン (little-endian) 用の &#8216;utf-16-le&#8217; やビッグエンディアン (big-endian) 用の &#8216;utf-16-be&#8217; というような変種があり、これらは特定の1つのバイト順を指定していて BOM をスキップしません。</p>
<p>いくつかの領域では、UTF-8 でエンコードされたファイルの先頭に &#8220;BOM&#8221; を利用する習慣があります; この名前はよく誤解を招きますが、UTF-8 はバイトオーダーに依存しません。&#8221;BOM&#8221; の印は単にファイルが UTF-8 でエンコーディングされていることを知らせるものです。もし、そのようなファイルを読む場合には、この印を自動的にスキップするために &#8216;utf-8-sig&#8217; コーデックを利用してください。</p>
<div class="section" id="unicode-filenames">
<h3>Unicode ファイル名<a class="headerlink" href="#unicode-filenames" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>多くの OS では現在任意の Unicode 文字を含むファイル名をサポートしています。通常 Unicode 文字列をシステム依存のエンコーディングに変換することによって実装されています。例えば、Mac OS X は UTF-8 を利用し、Windows ではエンコーディングが設定で変更することが可能です; Windows では Python は &#8220;mbcs&#8221; という名前に現在設定されているエンコーディングを問い合わせて利用します。Unix システムでは <code class="docutils literal"><span class="pre">LANG</span></code> や <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> 環境変数を設定していれば、それだけがファイルシステムのエンコーディングとなります; もしエンコーディングを設定しなければ、デフォルトエンコーディングは UTF-8 になります。</p>
<p><a class="reference internal" href="../library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code></a> 関数は現在のシステムで利用するエンコーディングを返し、エンコーディングを手動で設定したい場合利用します、ただしわざわざそうする積極的な理由はありません。読み書きのためにファイルを開く時には、ファイル名を Unicode 文字列として渡すだけで正しいエンコーディングに自動的に変更されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;filename</span><span class="se">\u4500</span><span class="s1">abc&#39;</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;blah</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a> のような <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> モジュールの関数も Unicode のファイル名を受け付けます。</p>
<p><a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">os.listdir()</span></code></a> 関数はファイル名を返しますが、ここで問題が起きます: この関数はファイル名を Unicode で返すべきでしょうか? それともエンコードされたバイト列で返すべきでしょうか? <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">os.listdir()</span></code></a> は、ディレクトリのパスをバイト列として渡したか、 Unicode 文字列として渡したかによって、どちらの形式でも返せます。パスを Unicode 文字列として渡した場合、ファイル名はファイルシステムエンコーディングを使ってデコードされ、 Unicode 文字列のリストが返されます。その一方、バイト列のパスを渡すとファイル名をバイト列として返します。例えば、デフォルトのファイルシステムエンコーディングが UTF-8 だと仮定して、以下のプログラムを実行すると:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;filename</span><span class="se">\u4500</span><span class="s1">abc&#39;</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>will produce the following output:</p>
<div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">amk:~$</span> python t.py
<span class="go">[b&#39;filename\xe4\x94\x80abc&#39;, ...]</span>
<span class="go">[&#39;filename\u4500abc&#39;, ...]</span>
</pre></div>
</div>
<p>最初のリストは UTF-8 でエンコーディングされたファイル名を含み、第二のリストは Unicode 版を含んでいます。</p>
<p>ほぼ全ての状況で Unicode API を利用すべきです。bytes API はシステムのデコードされていないファイル名が存在する場合、例えば Unix システム、でのみ利用すべきです。</p>
</div>
<div class="section" id="tips-for-writing-unicode-aware-programs">
<h3>Unicode 対応のプログラムを書くための Tips<a class="headerlink" href="#tips-for-writing-unicode-aware-programs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この章では Unicode を扱うプログラムを書くためのいくつかの提案を紹介します。</p>
<p>最も重要な助言としては:</p>
<blockquote>
<div><p>ソフトウェアは内部では Unicode 文字列のみを利用し、入力データはできるだけ早期にデコードし、出力の直前でエンコードすべきです。</p>
</div></blockquote>
<p>If you attempt to write processing functions that accept both Unicode and byte
strings, you will find your program vulnerable to bugs wherever you combine the
two different kinds of strings.  There is no automatic encoding or decoding: if
you do e.g. <code class="docutils literal"><span class="pre">str</span> <span class="pre">+</span> <span class="pre">bytes</span></code>, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> will be raised.</p>
<p>web ブラウザから来るデータやその他の信頼できないところからのデータを利用する場合、それらの文字列から生成したコマンド行の実行や、それらの文字列をデータベースに蓄える前に文字列の中に不正な文字が含まれていないか確認するのが一般的です。もしそういう状況になった場合には、エンコードされたバイトデータではなく、デコードされた文字列のチェックを入念に行なって下さい; いくつかのエンコーディングは問題となる性質を持っています、例えば全単射でなかったり、完全に ASCII 互換でないなど。入力データがエンコーディングを指定している場合でもそうして下さい、なぜなら攻撃者は巧みに悪意あるテキストをエンコードした文字列の中に隠すことができるからです。</p>
<div class="section" id="converting-between-file-encodings">
<h4>ファイルエンコーディングの変換<a class="headerlink" href="#converting-between-file-encodings" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The <a class="reference internal" href="../library/codecs.html#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> class can transparently convert between
encodings, taking a stream that returns data in encoding #1
and behaving like a stream returning data in encoding #2.</p>
<p>For example, if you have an input file <em>f</em> that&#8217;s in Latin-1, you
can wrap it with a <a class="reference internal" href="../library/codecs.html#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> to return bytes encoded in
UTF-8:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">new_f</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">StreamRecoder</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
    <span class="c1"># en/decoder: used by read() to encode its results and</span>
    <span class="c1"># by write() to decode its input.</span>
    <span class="n">codecs</span><span class="o">.</span><span class="n">getencoder</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getdecoder</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span>

    <span class="c1"># reader/writer: used to read and write to the stream.</span>
    <span class="n">codecs</span><span class="o">.</span><span class="n">getreader</span><span class="p">(</span><span class="s1">&#39;latin-1&#39;</span><span class="p">),</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getwriter</span><span class="p">(</span><span class="s1">&#39;latin-1&#39;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="files-in-an-unknown-encoding">
<h4>不明なエンコーディングのファイル<a class="headerlink" href="#files-in-an-unknown-encoding" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>What can you do if you need to make a change to a file, but don&#8217;t know
the file&#8217;s encoding?  If you know the encoding is ASCII-compatible and
only want to examine or modify the ASCII parts, you can open the file
with the <code class="docutils literal"><span class="pre">surrogateescape</span></code> error handler:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;ascii&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;surrogateescape&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># make changes to the string &#39;data&#39;</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.new&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span>
          <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;ascii&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;surrogateescape&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">surrogateescape</span></code> error handler will decode any non-ASCII bytes
as code points in the Unicode Private Use Area ranging from U+DC80 to
U+DCFF.  These private code points will then be turned back into the
same bytes when the <code class="docutils literal"><span class="pre">surrogateescape</span></code> error handler is used when
encoding the data and writing it back out.</p>
</div>
</div>
<div class="section" id="id3">
<h3>参考資料<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>One section of <a class="reference external" href="http://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o">Mastering Python 3 Input/Output</a>,
a PyCon 2010 talk by David Beazley, discusses text processing and binary data handling.</p>
<p>Marc-André Lemburg のプレゼンテーション &#8220;Writing Unicode-aware Applications in Python&#8221; の PDF スライドが &lt;<a class="reference external" href="https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf">https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf</a>&gt; から入手可能です、そして文字エンコーディングの問題と同様にアプリケーションの国際化やローカライズについても議論されています。このスライドは Python 2.x のみをカバーしています。</p>
<p><a class="reference external" href="http://pyvideo.org/video/1768/the-guts-of-unicode-in-python">The Guts of Unicode in Python</a>
is a PyCon 2013 talk by Benjamin Peterson that discusses the internal Unicode
representation in Python 3.3.</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このドキュメントの最初の草稿は Andrew Kuchling によって書かれました。それからさらに Alexander Belopolsky, Georg Brandl, Andrew Kuchling, Ezio Melotti らで改訂が重ねられています。</p>
<p>この記事中の誤りの指摘や提案を申し出てくれた以下の人々に感謝します: Éric Araujo, Nicholas Bastin, Nick Coghlan, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, Terry J. Reedy, Chad Whitacre.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Unicode HOWTO</a><ul>
<li><a class="reference internal" href="#introduction-to-unicode">Unicode 入門</a><ul>
<li><a class="reference internal" href="#history-of-character-codes">文字コードの歴史</a></li>
<li><a class="reference internal" href="#definitions">定義</a></li>
<li><a class="reference internal" href="#encodings">エンコーディング</a></li>
<li><a class="reference internal" href="#references">参考資料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#python-s-unicode-support">Python の Unicode サポート</a><ul>
<li><a class="reference internal" href="#the-string-type">文字列型</a></li>
<li><a class="reference internal" href="#converting-to-bytes">バイト列への変換</a></li>
<li><a class="reference internal" href="#unicode-literals-in-python-source-code">Python ソースコード内の Unicode リテラル</a></li>
<li><a class="reference internal" href="#unicode-properties">Unicode プロパティ</a></li>
<li><a class="reference internal" href="#unicode-regular-expressions">Unicode 正規表現</a></li>
<li><a class="reference internal" href="#id2">参考資料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reading-and-writing-unicode-data">Unicode データを読み書きする</a><ul>
<li><a class="reference internal" href="#unicode-filenames">Unicode ファイル名</a></li>
<li><a class="reference internal" href="#tips-for-writing-unicode-aware-programs">Unicode 対応のプログラムを書くための Tips</a><ul>
<li><a class="reference internal" href="#converting-between-file-encodings">ファイルエンコーディングの変換</a></li>
<li><a class="reference internal" href="#files-in-an-unknown-encoding">不明なエンコーディングのファイル</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">参考資料</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="sorting.html"
                        title="前の章へ">ソート HOW TO</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="urllib2.html"
                        title="次の章へ">urllib パッケージを使ってインターネット上のリソースを取得するには</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/howto/unicode.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="urllib2.html" title="urllib パッケージを使ってインターネット上のリソースを取得するには"
             >次へ</a> |</li>
        <li class="right" >
          <a href="sorting.html" title="ソート HOW TO"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.0</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python HOWTO</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2月 19, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>