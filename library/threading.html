<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>17.1. threading — スレッドベースの並列処理 &#8212; Python 3.6.1 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.1 ドキュメント" href="../contents.html" />
    <link rel="up" title="17. 並行実行" href="concurrency.html" />
    <link rel="next" title="17.2. multiprocessing — プロセスベースの並列処理" href="multiprocessing.html" />
    <link rel="prev" title="17. 並行実行" href="concurrency.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/threading.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/threading.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="multiprocessing.html" title="17.2. multiprocessing — プロセスベースの並列処理"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="17. 並行実行"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concurrency.html" accesskey="U">17. 並行実行</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-threading">
<span id="threading-thread-based-parallelism"></span><h1>17.1. <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> &#8212; スレッドベースの並列処理<a class="headerlink" href="#module-threading" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/threading.py">Lib/threading.py</a></p>
<hr class="docutils" />
<p>このモジュールでは、高水準のスレッドインタフェースをより低水準 な <a class="reference internal" href="_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal"><span class="pre">_thread</span></code></a> モジュールの上に構築しています。 <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">queue</span></code></a> モジュールのドキュメントも参照してください。</p>
<p>また、 <a class="reference internal" href="_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal"><span class="pre">_thread</span></code></a> がないために <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> を使えないような状況向けに <a class="reference internal" href="dummy_threading.html#module-dummy_threading" title="dummy_threading: Drop-in replacement for the threading module."><code class="xref py py-mod docutils literal"><span class="pre">dummy_threading</span></code></a> を提供しています。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">ここには載っていませんが、Python 2.x シリーズでこのモジュールの一部のメソッドや関数に使われていた <code class="docutils literal"><span class="pre">camelCase</span></code> 名は、まだこのモジュールでサポートされます。</p>
</div>
<p>このモジュールは以下の関数を定義しています:</p>
<dl class="function">
<dt id="threading.active_count">
<code class="descclassname">threading.</code><code class="descname">active_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.active_count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>生存中の <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> オブジェクトの数を返します。この数は <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> の返すリストの長さと同じです。</p>
</dd></dl>

<dl class="function">
<dt id="threading.current_thread">
<code class="descclassname">threading.</code><code class="descname">current_thread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.current_thread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数を呼び出している処理のスレッドに対応する <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> オブジェクトを返します。関数を呼び出している処理のスレッドが <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールで生成したものでない場合、限定的な機能しかもたないダミースレッドオブジェクトを返します。</p>
</dd></dl>

<dl class="function">
<dt id="threading.get_ident">
<code class="descclassname">threading.</code><code class="descname">get_ident</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.get_ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のスレッドの &#8216;スレッドID&#8217; を返します。非ゼロの整数です。この値は直接の意味を持っていません; 例えばスレッド特有のデータの辞書に索引をつけるためのような、マジッククッキーとして意図されています。スレッドが終了し、他のスレッドが作られたとき、スレッド ID は再利用されるかもしれません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="threading.enumerate">
<code class="descclassname">threading.</code><code class="descname">enumerate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.enumerate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在、生存中の <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> オブジェクト全てのリストを返します。リストには、デーモンスレッド (daemonic thread)、 <a class="reference internal" href="#threading.current_thread" title="threading.current_thread"><code class="xref py py-func docutils literal"><span class="pre">current_thread()</span></code></a> の生成するダミースレッドオブジェクト、そして主スレッドが入ります。終了したスレッドとまだ開始していないスレッドは入りません。</p>
</dd></dl>

<dl class="function">
<dt id="threading.main_thread">
<code class="descclassname">threading.</code><code class="descname">main_thread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.main_thread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>main <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> オブジェクトを返します。通常の条件では、メインスレッドはPythonインタプリタが起動したスレッドを指します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="threading.settrace">
<code class="descclassname">threading.</code><code class="descname">settrace</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.settrace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-0"><a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールを使って開始した全てのスレッドにトレース関数を設定します。 <em>func</em> は各スレッドの <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> を呼び出す前にスレッドの <a class="reference internal" href="sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal"><span class="pre">sys.settrace()</span></code></a> に渡されます。</p>
</dd></dl>

<dl class="function">
<dt id="threading.setprofile">
<code class="descclassname">threading.</code><code class="descname">setprofile</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.setprofile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-1"><a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールを使って開始した全てのスレッドにプロファイル関数を設定します。 <em>func</em> は各スレッドの <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> を呼び出す前にスレッドの <a class="reference internal" href="sys.html#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal"><span class="pre">sys.setprofile()</span></code></a> に渡されます。</p>
</dd></dl>

<dl class="function">
<dt id="threading.stack_size">
<code class="descclassname">threading.</code><code class="descname">stack_size</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.stack_size" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいスレッドを作るときのスレッドスタックサイズを返します。オプションの <em>size</em> 引数にはこれ以降に作成するスレッドのスタックサイズを指定し、0 (プラットフォームのデフォルト値または設定されたデフォルト値) か、 32,768 (32 KiB) 以上の正の整数でなければなりません。<em>size</em> が指定されない場合 0 が使われます。スレッドのスタックサイズの変更がサポートされていない場合、 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出します。不正なスタックサイズが指定された場合、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出して、スタックサイズは変更されません。32 KiB は現在のインタープリタ自身のために十分であると保証された最小のスタックサイズです。いくつかのプラットフォームではスタックサイズに対して制限があることに注意してください。例えば最小のスタックサイズが 32 KiB より大きかったり、システムのメモリページサイズ の整数倍の必要があるなどです。この制限についてはプラットフォームのドキュメントを参照してください (一般的なページサイズは 4 KiB なので、プラットフォームに関する情報がない場合は 4096 の整数倍のスタックサイズを選ぶといいかもしれません)。利用可能な環境: Windows、POSIX スレッドに対応したシステム。</p>
</dd></dl>

<p>このモジュールでは以下の定数も定義しています:</p>
<dl class="data">
<dt id="threading.TIMEOUT_MAX">
<code class="descclassname">threading.</code><code class="descname">TIMEOUT_MAX</code><a class="headerlink" href="#threading.TIMEOUT_MAX" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックする関数 (<a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">Lock.acquire()</span></code></a>, <a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">RLock.acquire()</span></code></a>, <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">Condition.wait()</span></code></a> など) の <em>timeout</em> 引数に許される最大値。これ以上の値を timeout に指定すると <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> が発生します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<p>このモジュールは多くのクラスを定義しています。それらは下記のセクションで詳しく説明されます。</p>
<p>このモジュールのおおまかな設計は Java のスレッドモデルに基づいています。とはいえ、 Java がロックと条件変数を全てのオブジェクトの基本的な挙動にしているのに対し、 Python ではこれらを別個のオブジェクトに分けています。 Python の <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> クラスがサポートしているのは Java の Thread クラスの挙動のサブセットにすぎません; 現状では、優先度 (priority)やスレッドグループがなく、スレッドの破壊 (destroy)、中断 (stop)、一時停止 (suspend)、復帰 (resume)、割り込み (interrupt) は行えません。 Java の Thread クラスにおける静的メソッドに対応する機能が実装されている場合にはモジュールレベルの関数になっています。</p>
<p>以下に説明するメソッドは全て原子的 (atomic) に実行されます。</p>
<div class="section" id="thread-local-data">
<h2>17.1.1. スレッドローカルデータ<a class="headerlink" href="#thread-local-data" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スレッドローカルデータは、その値がスレッド固有のデータです。スレッドローカルデータを管理するには、単に <a class="reference internal" href="#threading.local" title="threading.local"><code class="xref py py-class docutils literal"><span class="pre">local</span></code></a> (あるいはそのサブクラス) のインスタンスを作成して、その属性に値を設定してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">mydata</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
<span class="n">mydata</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>インスタンスの値はスレッドごとに違った値になります。</p>
<dl class="class">
<dt id="threading.local">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">local</code><a class="headerlink" href="#threading.local" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドローカルデータを表現するクラス。</p>
<p>詳細と例題については、 <code class="xref py py-mod docutils literal"><span class="pre">_threading_local</span></code> モジュールのドキュメンテーション文字列を参照してください。</p>
</dd></dl>

</div>
<div class="section" id="thread-objects">
<span id="id1"></span><h2>17.1.2. Thread オブジェクト<a class="headerlink" href="#thread-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> クラスは個別のスレッド中で実行される活動 (activity) を表現します。活動を決める方法は 2 つあり、一つは呼び出し可能オブジェクトをコンストラクタへ渡す方法、もう一つはサブクラスで <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドをオーバライドする方法です。 (コンストラクタを除く) その他のメソッドは一切サブクラスでオーバライドしてはなりません。言い換えるならば、このクラスの <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> と <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッド <em>だけ</em> をオーバライドしてくださいということです。</p>
<p>ひとたびスレッドオブジェクトを生成すると、スレッドの <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> メソッドを呼び出して活動を開始しなければなりません。 <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> メソッド はそれぞれのスレッドの <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドを起動します。</p>
<p>スレッドの活動が始まると、スレッドは &#8216;生存中 (alive)&#8217; とみなされます。 スレッドは、通常 <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドが終了するまで、もしくは捕捉されない例外が送出されるまで生存中となります。 <a class="reference internal" href="#threading.Thread.is_alive" title="threading.Thread.is_alive"><code class="xref py py-meth docutils literal"><span class="pre">is_alive()</span></code></a> メソッドは、スレッドが生存中であるかどうか調べます。</p>
<p>スレッドは他のスレッドの <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> メソッドを呼び出すことができます。このメソッドは、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> メソッドを呼ばれたスレッドが終了するまでメソッドの呼び出し元のスレッドをブロックします。</p>
<p>スレッドは名前を持っています。名前はコンストラクタに渡すことができ、 <a class="reference internal" href="#threading.Thread.name" title="threading.Thread.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> 属性を通して読み出したり変更したりできます。</p>
<p>スレッドには &#8220;デーモンスレッド (daemon thread)&#8221; であるというフラグを立てられます。 このフラグには、残っているスレッドがデーモンスレッドだけになった時に Python プログラム全体を終了させるという意味があります。フラグの初期値はスレッドを生成したスレッドから継承します。フラグの値は <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code></a> プロパティまたは <em>daemon</em> コンストラクタ引数を通して設定できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">デーモンスレッドは終了時にいきなり停止されます。デーモンスレッドで使われたリソース (開いているファイル、データベースのトランザクションなど) は適切に解放されないかもしれません。きちんと (gracefully) スレッドを停止したい場合は、スレッドを非デーモンスレッドにして、<a class="reference internal" href="#threading.Event" title="threading.Event"><code class="xref py py-class docutils literal"><span class="pre">Event</span></code></a> のような適切なシグナル送信機構を使用してください。</p>
</div>
<p>スレッドには &#8220;主スレッド (main thread)&#8221; オブジェクトがあります。主スレッドは Python プログラムを最初に制御していたスレッドです。主スレッドはデーモンスレッドではありません。</p>
<p>&#8220;ダミースレッド (dummy thread)&#8221; オブジェクトを作成することができます。 ダミースレッドは、 &#8220;外来スレッド (alien thread)&#8221; に対応するスレッドオブジェクトです。ダミースレッドは、 C コードから直接生成されたスレッドのような、 <a class="reference internal" href="#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールの外で開始された処理スレッドです。 ダミースレッドオブジェクトには限られた機能しかなく、常に生存中、かつデーモンスレッドであるとみなされ、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> できません。また、外来スレッドの終了を検出するのは不可能なので、ダミースレッドは削除できません。</p>
<dl class="class">
<dt id="threading.Thread">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Thread</code><span class="sig-paren">(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>*</em>, <em>daemon=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタは常にキーワード引数を使って呼び出さなければなりません。各引数は以下の通りです:</p>
<p><em>group</em> は <code class="docutils literal"><span class="pre">None</span></code> でなければなりません。将来 <code class="xref py py-class docutils literal"><span class="pre">ThreadGroup</span></code> クラスが実装されたときの拡張用に予約されている引数です。</p>
<p><em>target</em> は <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドによって起動される呼び出し可能オブジェクトです。デフォルトでは何も呼び出さないことを示す <code class="docutils literal"><span class="pre">None</span></code> になっています。</p>
<p><em>name</em> はスレッドの名前です。デフォルトでは、 <em>N</em> を小さな 10 進数として、 &#8220;Thread- <em>N</em>&#8221; という形式の一意な名前を生成します。</p>
<p><em>args</em> は <em>target</em> を呼び出すときの引数タプルです。デフォルトは <code class="docutils literal"><span class="pre">()</span></code> です。</p>
<p><em>kwargs</em> は <em>target</em> を呼び出すときのキーワード引数の辞書です。デフォルトは <code class="docutils literal"><span class="pre">{}</span></code> です。</p>
<p><code class="docutils literal"><span class="pre">None</span></code> でない場合、<em>daemon</em> はスレッドがデーモンかどうかを明示的に設定します。<code class="docutils literal"><span class="pre">None</span></code> の場合 (デフォルト)、デーモン属性は現在のスレッドから継承されます。</p>
<p>サブクラスでコンストラクタをオーバライドした場合、必ずスレッドが何かを始める前に基底クラスのコンストラクタ (<code class="docutils literal"><span class="pre">Thread.__init__()</span></code>) を呼び出しておかなくてはなりません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><em>daemon</em> 引数が追加されました。</p>
</div>
<dl class="method">
<dt id="threading.Thread.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.start" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドの活動を開始します。</p>
<p>このメソッドは、スレッドオブジェクトあたり一度しか呼び出してはなりません。 <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> は、オブジェクトの <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドが個別の処理スレッド中で呼び出されるように調整します。</p>
<p>同じスレッドオブジェクトに対し、このメソッドを2回以上呼び出した場合、 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドの活動をもたらすメソッドです。</p>
<p>このメソッドはサブクラスでオーバライドできます。標準の <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドでは、オブジェクトのコンストラクタの <em>target</em> 引数に呼び出し可能オブジェクトを指定した場合、 <em>args</em> および <em>kwargs</em> の引数列およびキーワード引数とともに呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドが終了するまで待機します。
このメソッドは、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を呼ばれたスレッドが正常終了あるいは処理されない例外によって終了するか、オプションのタイムアウトが発生するまで、メソッドの呼び出し元のスレッドをブロックします。</p>
<p><em>timeout</em> 引数が存在して <code class="docutils literal"><span class="pre">None</span></code> 以外の場合、それは操作に対するタイムアウト秒 (あるいは秒未満の端数) を表す浮動小数点数でなければなりません。 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> は常に <code class="docutils literal"><span class="pre">None</span></code> を返すので、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> の後に <a class="reference internal" href="#threading.Thread.is_alive" title="threading.Thread.is_alive"><code class="xref py py-meth docutils literal"><span class="pre">is_alive()</span></code></a> を呼び出してタイムアウトしたかどうかを確認しなければなりません。もしスレッドがまだ生存中であれば、 <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> はタイムアウトしています。</p>
<p><em>timeout</em> が指定されないかまたは <code class="docutils literal"><span class="pre">None</span></code> であるときは、この操作はスレッドが終了するまでブロックします。</p>
<p>一つのスレッドに対して何度でも <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> できます。</p>
<p>現在のスレッドに対して <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を呼び出そうとすると、デッドロックを引き起こすため <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。 スレッドが開始される前に <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を呼び出すことも同様のエラーのため、同じ例外が送出されます。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.name">
<code class="descname">name</code><a class="headerlink" href="#threading.Thread.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>識別のためにのみ用いられる文字列です。名前には機能上の意味づけ (semantics) はありません。複数のスレッドに同じ名前をつけてもかまいません。名前の初期値はコンストラクタで設定されます。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.getName">
<code class="descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.getName" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.Thread.setName">
<code class="descname">setName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.setName" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#threading.Thread.name" title="threading.Thread.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> に対する古い getter/setter API; 代わりにプロパティを直接使用してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.ident">
<code class="descname">ident</code><a class="headerlink" href="#threading.Thread.ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドの「スレッド識別子」または、スレッドが開始されていない場合 <code class="docutils literal"><span class="pre">None</span></code> です。これは非ゼロの整数です。 <a class="reference internal" href="_thread.html#_thread.get_ident" title="_thread.get_ident"><code class="xref py py-func docutils literal"><span class="pre">_thread.get_ident()</span></code></a> 関数を参照してください。スレッド識別子は、スレッドが終了した後で新たなスレッドが生成された場合に再利用されることがあります。スレッド識別子は、スレッドが終了した後でも利用できます。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.is_alive">
<code class="descname">is_alive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.is_alive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スレッドが生存中かどうかを返します。</p>
<p>このメソッドは、 <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドが起動する直前から <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドが終了する直後までの間 <code class="docutils literal"><span class="pre">True</span></code> を返します。モジュール関数 <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> は、全ての生存中のスレッドのリストを返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Thread.daemon">
<code class="descname">daemon</code><a class="headerlink" href="#threading.Thread.daemon" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このスレッドがデーモンスレッドか (True) か否か (False) を示すブール値。この値は <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> の呼び出し前に設定されなければなりません。さもなければ <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。初期値は生成側のスレッドから継承されます; メインスレッドはデーモンスレッドではないので、メインスレッドで作成されたすべてのスレッドは、デフォルトで <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code></a> = <code class="docutils literal"><span class="pre">False</span></code> になります。</p>
<p>デーモンでない生存中のスレッドが全てなくなると、 Python プログラム全体が終了します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Thread.isDaemon">
<code class="descname">isDaemon</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.isDaemon" title="この定義へのパーマリンク">¶</a></dt>
<dt id="threading.Thread.setDaemon">
<code class="descname">setDaemon</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Thread.setDaemon" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code></a> に対する古い getter/setter API; 代わりにプロパティを直接使用してください。</p>
</dd></dl>

</dd></dl>

<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> CPython は <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">Global Interpreter Lock</span></a> のため、ある時点で Python コードを実行できるスレッドは1つに限られます (ただし、いくつかのパフォーマンスが強く求められるライブラリはこの制限を克服しています)。アプリケーションにマルチコアマシンの計算能力をより良く利用させたい場合は、 <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールや <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal"><span class="pre">concurrent.futures.ProcessPoolExecutor</span></code></a> の利用をお勧めします。 ただし、I/Oバウンドなタスクを並行して複数走らせたい場合においては、 マルチスレッドは正しい選択肢です。</p>
</div>
</div>
<div class="section" id="lock-objects">
<span id="id2"></span><h2>17.1.3. Lock オブジェクト<a class="headerlink" href="#lock-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>プリミティブロックとは、ロックが生じた際に特定のスレッドによって所有されない同期プリミティブです。 Python では現在のところ拡張モジュール <a class="reference internal" href="_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal"><span class="pre">_thread</span></code></a> で直接実装されている最も低水準の同期プリミティブを使えます。</p>
<p>プリミティブロックは2つの状態、 &#8220;ロック&#8221; または &#8220;アンロック&#8221; があります。ロックはアンロック状態で作成されます。ロックには基本となる二つのメソッド、 <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> と <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> があります。ロックの状態がアンロックである場合、 <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> は状態をロックに変更して即座に処理を戻します。 状態がロックの場合、 <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> は他のスレッドが <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> を呼び出してロックの状態をアンロックに変更するまでブロックします。その後、 <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> 呼び出しは状態を再度ロックに設定してから処理を戻します。 <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> メソッドを呼び出すのはロック状態のときでなければなりません; このメソッドはロックの状態をアンロックに変更して、即座に処理を戻します。 アンロックの状態のロックを解放しようとすると <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>ロックは <a class="reference internal" href="#with-locks"><span class="std std-ref">コンテキストマネージメントプロトコル</span></a> もサポートします。</p>
<p>複数のスレッドにおいて <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> がアンロック状態への遷移を待っているためにブロックが起きている時に <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> を呼び出してロックの状態をアンロックにすると、一つのスレッドだけが処理を進行できます。 どのスレッドが処理を進行できるのかは定義されておらず、実装によって異なるかもしれません。</p>
<p>全てのメソッドはアトミックに実行されます。</p>
<dl class="class">
<dt id="threading.Lock">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Lock</code><a class="headerlink" href="#threading.Lock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プリミティブロック (primitive lock) オブジェクトを実装しているクラスです。スレッドが一度ロックを獲得すると、それ以後のロック獲得の試みはロックが解放されるまでブロックします。どのスレッドでもロックを解放できます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ファクトリ関数からクラスに変更されました。</p>
</div>
<dl class="method">
<dt id="threading.Lock.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>blocking=True</em>, <em>timeout=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Lock.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックあり、またはブロックなしでロックを獲得します。</p>
<p>引数 <em>blocking</em> を <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) に設定して呼び出した場合、ロックがアンロック状態になるまでブロックします。そしてそれをロック状態にしてから <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p>引数 <em>blocking</em> の値を <code class="docutils literal"><span class="pre">False</span></code> にして呼び出すとブロックしません。<em>blocking</em> を <code class="docutils literal"><span class="pre">True</span></code> にして呼び出した場合にブロックするような状況では、直ちに <code class="docutils literal"><span class="pre">False</span></code> を返します。それ以外の場合には、ロックをロック状態にして <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p>正の値に設定された浮動小数点の <em>timeout</em> 引数とともに起動された場合、ロックを得られなければ最大で <em>timeout</em> によって指定された秒数だけブロックします。<em>timeout</em> 引数の <code class="docutils literal"><span class="pre">-1</span></code> は無制限の待機を指定します。<em>blocking</em> が false の場合に <em>timeout</em> を指定することは禁止されています。</p>
<p>ロックを獲得すると <code class="docutils literal"><span class="pre">True</span></code> を、ロックを獲得できなかったとき (例えば <em>timeout</em> が過ぎた場合) には <code class="docutils literal"><span class="pre">False</span></code> を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>新しい <em>timeout</em> 引数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>POSIX ではロックの取得がシグナルに割り込まれるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Lock.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Lock.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロックを解放します。これはロックを獲得したスレッドだけでなく、任意のスレッドから呼ぶことができます。</p>
<p>ロックの状態がロックのとき、状態をアンロックにリセットして処理を戻します。他のスレッドがロックがアンロック状態になるのを待ってブロックしている場合、ただ一つのスレッドだけが処理を継続できるようにします。</p>
<p>アンロック状態のロックに対して呼び出された場合、<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>戻り値はありません。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="rlock-objects">
<span id="id3"></span><h2>17.1.4. RLock オブジェクト<a class="headerlink" href="#rlock-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>再入可能ロック (reentrant lock) とは、同じスレッドが複数回獲得できるような同期プリミティブです。再入可能ロックの内部では、プリミティブロックの使うロック／アンロック状態に加え、 &#8220;所有スレッド (owning thread)&#8221; と &#8220;再帰レベル (recursion level)&#8221; という概念を用いています。ロック状態では何らかのスレッドがロックを所有しており、アンロック状態ではいかなるスレッドもロックを所有していません。</p>
<p>このロックの状態をロックにするには、スレッドがロックの <a class="reference internal" href="#threading.RLock.acquire" title="threading.RLock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> メソッドを呼び出します。このメソッドはスレッドがロックを所有すると処理を戻します。ロックの状態をアンロックにするには <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> メソッドを呼び出します。 <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> / <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> からなるペアの呼び出しはネストできます; 最後に呼び出した <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> (最も外側の呼び出しペアの <a class="reference internal" href="#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a>) だけがロックの状態をアンロックにリセットして、 <a class="reference internal" href="#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> でブロック中の別のスレッドの処理を進行させることができます。</p>
<p>再入可能ロックは <a class="reference internal" href="#with-locks"><span class="std std-ref">コンテキストマネージメントプロトコル</span></a> もサポートします。</p>
<dl class="class">
<dt id="threading.RLock">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">RLock</code><a class="headerlink" href="#threading.RLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスは再入可能ロックオブジェクトを実装します。再入可能ロックはそれを獲得したスレッドによって解放されなければなりません。いったんスレッドが再入可能ロックを獲得すると、同じスレッドはブロックされずにもう一度それを獲得できます ; そのスレッドは獲得した回数だけ解放しなければいけません。</p>
<p><code class="docutils literal"><span class="pre">RLock</span></code> は実際にはファクトリ関数で、プラットフォームでサポートされる最も効率的なバージョンの具体的な RLock クラスのインスタンスを返すことに注意してください。</p>
<dl class="method">
<dt id="threading.RLock.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>blocking=True</em>, <em>timeout=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.RLock.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックあり、またはブロックなしでロックを獲得します。</p>
<p>引数なしで呼び出した場合: スレッドが既にロックを所有している場合、再帰レベルをインクリメントして即座に処理を戻します。それ以外の場合、他のスレッドがロックを所有していれば、そのロックの状態がアンロックになるまでブロックします。その後、ロックの状態がアンロックになる (いかなるスレッドもロックを所有しない状態になる) と、ロックの所有権を獲得し、再帰レベルを 1 にセットして処理を戻します。ロックの状態がアンロックになるのを待っているスレッドが複数ある場合、その中の一つだけがロックの所有権を獲得できます。この場合、戻り値はありません。</p>
<p>引数 <em>blocking</em> の値を true にして呼び出した場合、引数なしで呼び出したときと同じことを行ない、true を返します。</p>
<p>引数 <em>blocking</em> の値を false にして呼び出すとブロックしません。引数なしで呼び出した場合にブロックするような状況であった場合には直ちに false を返します。それ以外の場合には、引数なしで呼び出したときと同じ処理を行い true を返します。</p>
<p>正の値に設定された浮動小数点の <em>timeout</em> 引数とともに起動された場合、ロックを得られなければ最大で <em>timeout</em> によって指定された秒数だけブロックします。ロックを獲得した場合 true を返し、タイムアウトが過ぎた場合は false を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>新しい <em>timeout</em> 引数。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.RLock.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.RLock.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>再帰レベルをデクリメントしてロックを解放します。デクリメント後に再帰レベルがゼロになった場合、ロックの状態をアンロック (いかなるスレッドにも所有されていない状態) にリセットし、ロックの状態がアンロックになるのを待ってブロックしているスレッドがある場合にはその中のただ一つだけが処理を進行できるようにします。デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックのままで、呼び出し側のスレッドに所有されたままになります。</p>
<p>呼び出し側のスレッドがロックを所有しているときにのみこのメソッドを呼び出してください。ロックの状態がアンロックの時にこのメソッドを呼び出すと、 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>戻り値はありません。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="condition-objects">
<span id="id4"></span><h2>17.1.5. Condition オブジェクト<a class="headerlink" href="#condition-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>条件変数 (condition variable) は、常にある種のロックに関連付けられています; このロックは明示的に渡すことも、デフォルトで生成させることもできます。複数の条件変数で同じロックを共有しなければならない場合には、引渡しによる関連付けが便利です。ロックは条件オブジェクトの一部です: それを別々に扱う必要はありません。</p>
<p>条件変数は <a class="reference internal" href="#with-locks"><span class="std std-ref">コンテキスト管理プロトコル</span></a> に従います: <code class="docutils literal"><span class="pre">with</span></code> 文を使って囲まれたブロックの間だけ関連付けられたロックを獲得することができます。 <a class="reference internal" href="#threading.Condition.acquire" title="threading.Condition.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> メソッドと <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> メソッドは、さらに関連付けられたロックの対応するメソッドを呼び出します。</p>
<p>他のメソッドは、関連付けられたロックを保持した状態で呼び出さなければなりません。 <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> メソッドはロックを解放します。そして別のスレッドが <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> または <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></code></a> を呼ぶことによってスレッドを起こすまでブロックします。一旦起こされたなら、 <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> は再びロックを得て戻ります。タイムアウトを指定することも可能です。</p>
<p><a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> メソッドは条件変数待ちのスレッドを1つ起こします。 <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></code></a> メソッドは条件変数待ちの全てのスレッドを起こします。</p>
<p>注意: <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> と <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></code></a> はロックを解放しません; 従って、スレッドが起こされたとき、 <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> の呼び出しは即座に処理を戻すわけではなく、 <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> または <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></code></a> を呼び出したスレッドが最終的にロックの所有権を放棄したときに初めて処理を返すのです。</p>
<p>条件変数を使う典型的なプログラミングスタイルでは、何らかの共有された状態変数へのアクセスを同期させるためにロックを使います; 状態変数が特定の状態に変化したことを知りたいスレッドは、自分の望む状態になるまで繰り返し <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> を呼び出します。その一方で、状態変更を行うスレッドは、前者のスレッドが待ち望んでいる状態であるかもしれないような状態へ変更を行ったときに <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> や <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></code></a> を呼び出します。例えば、以下のコードは無制限のバッファ容量のときの一般的な生産者-消費者問題です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Consume one item</span>
<span class="k">with</span> <span class="n">cv</span><span class="p">:</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">an_item_is_available</span><span class="p">():</span>
        <span class="n">cv</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="n">get_an_available_item</span><span class="p">()</span>

<span class="c1"># Produce one item</span>
<span class="k">with</span> <span class="n">cv</span><span class="p">:</span>
    <span class="n">make_an_item_available</span><span class="p">()</span>
    <span class="n">cv</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
</pre></div>
</div>
<p>アプリケーションの条件をチェックする <code class="docutils literal"><span class="pre">while</span></code> ループは必須です。なぜなら、 <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> が任意の長時間の後で返り、 <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> 呼び出しを促した条件がもはや真でないことがありえるからです。これはマルチスレッドプログラミングに固有です。条件チェックを自動化するために <a class="reference internal" href="#threading.Condition.wait_for" title="threading.Condition.wait_for"><code class="xref py py-meth docutils literal"><span class="pre">wait_for()</span></code></a> メソッドを使うことができ、それはタイムアウトの計算を簡略化します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Consume an item</span>
<span class="k">with</span> <span class="n">cv</span><span class="p">:</span>
    <span class="n">cv</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">an_item_is_available</span><span class="p">)</span>
    <span class="n">get_an_available_item</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> と <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></code></a> のどちらを使うかは、その状態の変化に興味を持っている待ちスレッドが一つだけなのか、あるいは複数なのかで考えます。例えば、典型的な生産者-消費者問題では、バッファに1つの要素を加えた場合には消費者スレッドを 1 つしか起こさなくてかまいません。</p>
<dl class="class">
<dt id="threading.Condition">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Condition</code><span class="sig-paren">(</span><em>lock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスは条件変数 (condition variable) オブジェクトを実装します。条件変数を使うと、ある複数のスレッドを別のスレッドの通知があるまで待機させられます。</p>
<p><em>lock</em> を指定して、 <code class="docutils literal"><span class="pre">None</span></code> の値にする場合、 <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> または <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> オブジェクトでなければなりません。この場合、 <em>lock</em> は根底にあるロックオブジェクトとして使われます。それ以外の場合には新しい <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> オブジェクトを生成して使います。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ファクトリ関数からクラスに変更されました。</p>
</div>
<dl class="method">
<dt id="threading.Condition.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>根底にあるロックを獲得します。このメソッドは根底にあるロックの対応するメソッドを呼び出します。そのメソッドの戻り値を返します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>根底にあるロックを解放します。このメソッドは根底にあるロックの対応するメソッドを呼び出します。戻り値はありません。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>通知 (notify) を受けるか、タイムアウトするまで待機します。呼び出し側のスレッドがロックを獲得していないときにこのメソッドを呼び出すと <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>このメソッドは根底にあるロックを解放し、他のスレッドが同じ条件変数に対して <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> または <a class="reference internal" href="#threading.Condition.notify_all" title="threading.Condition.notify_all"><code class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></code></a> を呼び出して現在のスレッドを起こすか、オプションのタイムアウトが発生するまでブロックします。一度スレッドが起こされると、再度ロックを獲得して処理を戻します。</p>
<p><em>timeout</em> 引数を指定して、 <code class="docutils literal"><span class="pre">None</span></code> 以外の値にする場合、タイムアウトを秒 (または端数秒) を表す浮動小数点数でなければなりません。</p>
<p>根底にあるロックが <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> である場合、 <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> メソッドではロックは解放されません。というのも、ロックが再帰的に複数回獲得されている場合には、 <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> によって実際にアンロックが行われないかもしれないからです。その代わり、ロックが再帰的に複数回獲得されていても確実にアンロックを行える <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> クラスの内部インタフェースを使います。その後ロックを再獲得する時に、もう一つの内部インタフェースを使ってロックの再帰レベルを復帰します。</p>
<p>与えられた <em>timeout</em> が過ぎていなければ返り値は <code class="docutils literal"><span class="pre">True</span></code> です。タイムアウトした場合には <code class="docutils literal"><span class="pre">False</span></code> が返ります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>以前は、このメソッドは常に <code class="docutils literal"><span class="pre">None</span></code> を返していました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.wait_for">
<code class="descname">wait_for</code><span class="sig-paren">(</span><em>predicate</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.wait_for" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>条件が真と判定されるまで待ちます。
<em>predicate</em> は呼び出し可能オブジェクトでなければならず、その結果はブール値として解釈されます。
最大の待ち時間を指定する <em>timeout</em> を与えることができます。</p>
<p>このユーティリティメソッドは、述語が満たされるかタイムアウトが発生するまで <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> を繰り返し呼び出す場合があります。戻り値は述語の最後の戻り値で、もしメソッドがタイムアウトすれば、 <code class="docutils literal"><span class="pre">False</span></code> と評価されます。</p>
<p>タイムアウト機能を無視すれば、このメソッドの呼び出しは以下のように書くのとほぼ等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">():</span>
    <span class="n">cv</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>したがって、 <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> と同じルールが適用されます: 呼び出された時にロックを保持していなければならず、戻るときにロックが再度獲得されます。述語はロックを保持した状態で評価されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.notify">
<code class="descname">notify</code><span class="sig-paren">(</span><em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.notify" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルトで、この条件変数を待っている1つのスレッドを起こします。 呼び出し側のスレッドがロックを獲得していないときにこのメソッドを呼び出すと <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<p>何らかの待機中スレッドがある場合、そのうち <em>n</em> スレッドを起こします。待機中のスレッドがなければ何もしません。</p>
<p>現在の実装では、少なくとも <em>n</em> スレッドが待機中であれば、ちょうど <em>n</em> スレッドを起こします。とはいえ、この挙動に依存するのは安全ではありません。将来、実装の最適化によって、複数のスレッドを起こすようになるかもしれないからです。</p>
<p>注意: 起こされたスレッドは実際にロックを再獲得できるまで <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> 呼び出しから戻りません。 <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> はロックを解放しないので、 <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> 呼び出し側は明示的にロックを解放しなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Condition.notify_all">
<code class="descname">notify_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Condition.notify_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この条件を待っているすべてのスレッドを起こします。このメソッドは <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> のように動作しますが、 1 つではなくすべての待ちスレッドを起こします。呼び出し側のスレッドがロックを獲得していない場合、 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="semaphore-objects">
<span id="id5"></span><h2>17.1.6. Semaphore オブジェクト<a class="headerlink" href="#semaphore-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>セマフォ (semaphore) は、計算機科学史上最も古い同期プリミティブの一つ で、草創期のオランダ計算機科学者 Edsger W. Dijkstra によって発明されました (彼は <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> と <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> の代わりに <code class="docutils literal"><span class="pre">P()</span></code> と <code class="docutils literal"><span class="pre">V()</span></code> を使いました)。</p>
<p>セマフォは <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> でデクリメントされ <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> でインクリメントされるような内部カウンタを管理します。 カウンタは決してゼロより小さくはなりません; <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> は、カウンタがゼロになっている場合、他のスレッドが <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> を呼び出すまでブロックします。</p>
<p>セマフォは <a class="reference internal" href="#with-locks"><span class="std std-ref">コンテキストマネージメントプロトコル</span></a> もサポートします。</p>
<dl class="class">
<dt id="threading.Semaphore">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Semaphore</code><span class="sig-paren">(</span><em>value=1</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Semaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはセマフォ (semaphore) オブジェクトを実装します。セマフォは、 <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> を呼び出した数から <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> を呼び出した数を引き、初期値を足した値を表すカウンタを管理します。 <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> メソッドは、カウンタの値を負にせずに処理を戻せるまで必要ならば処理をブロックします。 <em>value</em> を指定しない場合、デフォルトの値は 1 になります。</p>
<p>オプションの引数には、内部カウンタの初期値を指定します。デフォルトは <code class="docutils literal"><span class="pre">1</span></code> です。与えられた <em>value</em> が 0 より小さい場合、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ファクトリ関数からクラスに変更されました。</p>
</div>
<dl class="method">
<dt id="threading.Semaphore.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>blocking=True</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Semaphore.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>セマフォを獲得します。</p>
<p>引数なしで呼び出した場合: <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> 処理に入ったときに内部カウンタがゼロより大きければ、カウンタを 1 デクリメントして即座に処理を戻します。 <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> 処理に入ったときに内部カウンタがゼロの場合、他のスレッドが <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> を呼び出してカウンタをゼロより大きくするまでブロックします。この処理は、適切なインターロック (interlock) を介して行い、複数の <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> 呼び出しがブロックされた場合、 <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> が正確に一つのスレッドだけを起こせるようにします。 実装はランダムに一つ選択してもよいので、ブロックされたスレッドが起こされる順番に依存してはなりません。 true を返します (または無期限にブロックします)。</p>
<p><em>blocking</em> を false にして呼び出すとブロックしません。引数なしで呼び出した場合にブロックするような状況であった場合には直ちに false を返します。それ以外の場合には、引数なしで呼び出したときと同じ処理を行い true を返します。</p>
<p><code class="docutils literal"><span class="pre">None</span></code> 以外の <em>timeout</em> で起動された場合、最大で <em>timeout</em> 秒ブロックします。
acquire が その間隔の間で完了しなかった場合は false が返ります。そうでなければ true が返ります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>新しい <em>timeout</em> 引数。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="threading.Semaphore.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Semaphore.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部カウンタを 1 インクリメントして、セマフォを解放します。 <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> 処理に入ったときにカウンタがゼロであり、カウンタの値がゼロより大きくなるのを待っている別のスレッドがあった場合、そのスレッドを起こします。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="threading.BoundedSemaphore">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">BoundedSemaphore</code><span class="sig-paren">(</span><em>value=1</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.BoundedSemaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>有限セマフォ (bounded semaphore) オブジェクトを実装しているクラスです。有限セマフォは、現在の値が初期値を超過しないようチェックを行います。超過を起こした場合、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。たいていの場合、セマフォは限られた容量のリソースを保護するために使われるものです。従って、あまりにも頻繁なセマフォの解放はバグが生じているしるしです。 <em>value</em> を指定しない場合、デフォルトの値は 1 になります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ファクトリ関数からクラスに変更されました。</p>
</div>
</dd></dl>

<div class="section" id="semaphore-example">
<span id="semaphore-examples"></span><h3>17.1.6.1. <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">Semaphore</span></code></a> の例<a class="headerlink" href="#semaphore-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>セマフォはしばしば、容量に限りのある資源、例えばデータベースサーバなどを保護するために使われます。リソースが固定の状況では、常に有限セマフォを使わなければなりません。主スレッドは、作業スレッドを立ち上げる前にセマフォを初期化します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">maxconnections</span> <span class="o">=</span> <span class="mi">5</span>
<span class="c1"># ...</span>
<span class="n">pool_sema</span> <span class="o">=</span> <span class="n">BoundedSemaphore</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">maxconnections</span><span class="p">)</span>
</pre></div>
</div>
<p>作業スレッドは、ひとたび立ち上がると、サーバへ接続する必要が生じたときにセマフォの <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> メソッドを呼び出します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pool_sema</span><span class="p">:</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">connectdb</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># ... use connection ...</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>有限セマフォを使うと、セマフォを獲得回数以上に解放してしまうというプログラム上の間違いを見逃しにくくします。</p>
</div>
</div>
<div class="section" id="event-objects">
<span id="id6"></span><h2>17.1.7. Event オブジェクト<a class="headerlink" href="#event-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>イベントは、あるスレッドがイベントを発信し、他のスレッドはそれを待つという、スレッド間で通信を行うための最も単純なメカニズムの一つです。</p>
<p>イベントオブジェクトは内部フラグを管理します。このフラグは <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> メソッドで値を true に、 <a class="reference internal" href="#threading.Event.clear" title="threading.Event.clear"><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code></a> メソッドで値を false にリセットします。 <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> メソッドはフラグが true になるまでブロックします。</p>
<dl class="class">
<dt id="threading.Event">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Event</code><a class="headerlink" href="#threading.Event" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イベントオブジェクトを実装しているクラスです。イベントは <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> メソッドを使うと <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> に、 <a class="reference internal" href="#threading.Event.clear" title="threading.Event.clear"><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code></a> メソッドを使うと <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> にセットされるようなフラグを管理します。 <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> メソッドは、全てのフラグが true になるまでブロックするようになっています。フラグの初期値は false です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ファクトリ関数からクラスに変更されました。</p>
</div>
<dl class="method">
<dt id="threading.Event.is_set">
<code class="descname">is_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.is_set" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値が true である場合にのみ true を返します。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.set">
<code class="descname">set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.set" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値を true にセットします。フラグの値が true になるのを待っている全てのスレッドを起こします。一旦フラグが true になると、スレッドが <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> を呼び出しても全くブロックしなくなります。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値を false にリセットします。以降は、 <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> を呼び出して再び内部フラグの値を true にセットするまで、 <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> を呼び出したスレッドはブロックするようになります。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Event.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Event.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部フラグの値が true になるまでブロックします。 <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> 処理に入った時点で内部フラグの値が true であれば、直ちに処理を戻します。そうでない場合、他のスレッドが <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> を呼び出してフラグの値を true にセットするか、オプションのタイムアウトが発生するまでブロックします。</p>
<p><em>timeout</em> 引数を指定して、 <code class="docutils literal"><span class="pre">None</span></code> 以外の値にする場合、タイムアウトを秒 (または端数秒) を表す浮動小数点数でなければなりません。</p>
<p>このメソッドは、wait 呼び出しの前あるいは wait が開始した後に、内部フラグが true にセットされている場合に限り <em>true</em> を返します。したがって、タイムアウトが与えられて操作がタイムアウトした場合を除き常に <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.1 で変更: </span>以前は、このメソッドは常に <code class="docutils literal"><span class="pre">None</span></code> を返していました。</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="timer-objects">
<span id="id7"></span><h2>17.1.8. Timer オブジェクト<a class="headerlink" href="#timer-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このクラスは、一定時間経過後に実行される活動、すなわちタイマ活動を表現します。 <a class="reference internal" href="#threading.Timer" title="threading.Timer"><code class="xref py py-class docutils literal"><span class="pre">Timer</span></code></a> は <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">Thread</span></code></a> のサブクラスであり、自作のスレッドを構築した一例でもあります。</p>
<p>タイマは <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> メソッドを呼び出すとスレッドとして作動し始めします。 (活動を開始する前に) <a class="reference internal" href="#threading.Timer.cancel" title="threading.Timer.cancel"><code class="xref py py-meth docutils literal"><span class="pre">cancel()</span></code></a> メソッドを呼び出すと、タイマを停止できます。タイマが活動を実行するまでの待ち時間は、ユーザが指定した待ち時間と必ずしも厳密には一致しません。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hello, world&quot;</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">hello</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>  <span class="c1"># after 30 seconds, &quot;hello, world&quot; will be printed</span>
</pre></div>
</div>
<dl class="class">
<dt id="threading.Timer">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Timer</code><span class="sig-paren">(</span><em>interval</em>, <em>function</em>, <em>args=None</em>, <em>kwargs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Timer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>interval</em> 秒後に引数 <em>args</em> キーワード引数 <em>kwargs</em> で <em>function</em> を実行するようなタイマを生成します。<em>args*が ``None`` (デフォルト) なら空のリストが使用されます。*kwargs</em> が <code class="docutils literal"><span class="pre">None</span></code> (デフォルト) なら空の辞書が使用されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ファクトリ関数からクラスに変更されました。</p>
</div>
<dl class="method">
<dt id="threading.Timer.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Timer.cancel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タイマをストップして、その動作の実行をキャンセルします。このメソッドはタイマがまだ活動待ち状態にある場合にのみ動作します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="barrier-objects">
<h2>17.1.9. バリアオブジェクト<a class="headerlink" href="#barrier-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<p>このクラスは、互いを待つ必要のある固定の数のスレッドで使用するための単純な同期プリミティブを提供します。それぞれのスレッドは <code class="xref py py-meth docutils literal"><span class="pre">Barrier</span> <span class="pre">.wait()</span></code> メソッドを呼ぶことによりバリアを通ろうとしてブロックします。すべてのスレッドがこのメソッドを呼び出した時点で、すべてのスレッドが同時に解放されます。</p>
<p>バリアは同じ数のスレッドに対して何度でも再利用することができます。</p>
<p>例として、クライアントとサーバの間でスレッドを同期させる単純な方法を紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Barrier</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">server</span><span class="p">():</span>
    <span class="n">start_server</span><span class="p">()</span>
    <span class="n">b</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="n">accept_connection</span><span class="p">()</span>
        <span class="n">process_server_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">client</span><span class="p">():</span>
    <span class="n">b</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="n">make_connection</span><span class="p">()</span>
        <span class="n">process_client_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="threading.Barrier">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Barrier</code><span class="sig-paren">(</span><em>parties</em>, <em>action=None</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>parties</em> 個のスレッドのためのバリアオブジェクトを作成します。 <em>action</em> は、もし提供されるなら呼び出し可能オブジェクトで、スレッドが解放される時にそのうちの1つによって呼ばれます。 <em>timeout</em> は、 <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> メソッドに対して none が指定された場合のデフォルトのタイムアウト値です。</p>
<dl class="method">
<dt id="threading.Barrier.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バリアを通ります。バリアに対するすべてのスレッドがこの関数を呼んだ時に、それらは同時にすべて解放されます。<em>timeout</em> が提供される場合、それはクラスコンストラクタに渡された値に優先して使用されます。</p>
<p>返り値は 0 から <em>parties</em> &#8211; 1 の範囲の整数で、それぞれのスレッドに対して異なります。これは、特別な後始末 (housekeeping) を行うスレッドを選択するために使用することができます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">barrier</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Only one thread needs to print this</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;passed the barrier&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>action</em> がコンストラクタに渡されていれば、スレッドのうちの1つが解放される前にそれを呼び出します。万一この呼び出しでエラーが発生した場合、バリアは broken な状態に陥ります。</p>
<p>この呼び出しがタイムアウトする場合、バリアは broken な状態に陥ります。</p>
<p>スレッドが待っている間にバリアが broken になるかリセットされた場合、このメソッドは <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code class="xref py py-class docutils literal"><span class="pre">BrokenBarrierError</span></code></a> 例外を送出するかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Barrier.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier.reset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バリアをデフォルトの空の状態に戻します。そのバリアの上で待っているすべてのスレッドは <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code class="xref py py-class docutils literal"><span class="pre">BrokenBarrierError</span></code></a> 例外を受け取ります。</p>
<p>状態が未知の他のスレッドがある場合、この関数を使用するのに何らかの外部同期を必要とするかもしれないことに注意してください。バリアが broken な場合、単にそれをそのままにして新しいものを作成する方がよいでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="threading.Barrier.abort">
<code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier.abort" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バリアを broken な状態にします。これによって、現在または将来の <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> 呼び出しが <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code class="xref py py-class docutils literal"><span class="pre">BrokenBarrierError</span></code></a> とともに失敗するようになります。これを使うと、例えば異常終了する必要がある場合にアプリケーションがデッドロックするのを避けることができます。</p>
<p>スレッドのうちの1つが返ってこないことに対して自動的に保護するように、単純に常識的な <em>timeout</em> 値でバリアを作成することは望ましいかもしれません。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Barrier.parties">
<code class="descname">parties</code><a class="headerlink" href="#threading.Barrier.parties" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バリアを通るために要求されるスレッドの数。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Barrier.n_waiting">
<code class="descname">n_waiting</code><a class="headerlink" href="#threading.Barrier.n_waiting" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在バリアの中で待っているスレッドの数。</p>
</dd></dl>

<dl class="attribute">
<dt id="threading.Barrier.broken">
<code class="descname">broken</code><a class="headerlink" href="#threading.Barrier.broken" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バリアが broken な状態である場合に <code class="docutils literal"><span class="pre">True</span></code> となるブール値。</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="threading.BrokenBarrierError">
<em class="property">exception </em><code class="descclassname">threading.</code><code class="descname">BrokenBarrierError</code><a class="headerlink" href="#threading.BrokenBarrierError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#threading.Barrier" title="threading.Barrier"><code class="xref py py-class docutils literal"><span class="pre">Barrier</span></code></a> オブジェクトがリセットされるか broken な場合に、この例外 (<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> のサブクラス) が送出されます。</p>
</dd></dl>

</div>
<div class="section" id="using-locks-conditions-and-semaphores-in-the-with-statement">
<span id="with-locks"></span><h2>17.1.10. <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文でのロック・条件変数・セマフォの使い方<a class="headerlink" href="#using-locks-conditions-and-semaphores-in-the-with-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールのオブジェクトのうち <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> メソッドと <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> メソッドを備えているものは全て <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のコンテキストマネージャ として使うことができます。 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のブロックに入るときに <code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code> メソッドが 呼び出され、ブロック脱出時には <code class="xref py py-meth docutils literal"><span class="pre">release()</span></code> メソッドが呼ばれます。したがって、次のコード:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">some_lock</span><span class="p">:</span>
    <span class="c1"># do something...</span>
</pre></div>
</div>
<p>は、以下と同じです</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">some_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># do something...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">some_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>現在のところ、 <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> 、 <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> 、 <a class="reference internal" href="#threading.Condition" title="threading.Condition"><code class="xref py py-class docutils literal"><span class="pre">Condition</span></code></a> 、 <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">Semaphore</span></code></a> 、 <a class="reference internal" href="#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal"><span class="pre">BoundedSemaphore</span></code></a> を <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のコンテキストマネージャとして使うことができます。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">17.1. <code class="docutils literal"><span class="pre">threading</span></code> &#8212; スレッドベースの並列処理</a><ul>
<li><a class="reference internal" href="#thread-local-data">17.1.1. スレッドローカルデータ</a></li>
<li><a class="reference internal" href="#thread-objects">17.1.2. Thread オブジェクト</a></li>
<li><a class="reference internal" href="#lock-objects">17.1.3. Lock オブジェクト</a></li>
<li><a class="reference internal" href="#rlock-objects">17.1.4. RLock オブジェクト</a></li>
<li><a class="reference internal" href="#condition-objects">17.1.5. Condition オブジェクト</a></li>
<li><a class="reference internal" href="#semaphore-objects">17.1.6. Semaphore オブジェクト</a><ul>
<li><a class="reference internal" href="#semaphore-example">17.1.6.1. <code class="docutils literal"><span class="pre">Semaphore</span></code> の例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-objects">17.1.7. Event オブジェクト</a></li>
<li><a class="reference internal" href="#timer-objects">17.1.8. Timer オブジェクト</a></li>
<li><a class="reference internal" href="#barrier-objects">17.1.9. バリアオブジェクト</a></li>
<li><a class="reference internal" href="#using-locks-conditions-and-semaphores-in-the-with-statement">17.1.10. <code class="docutils literal"><span class="pre">with</span></code> 文でのロック・条件変数・セマフォの使い方</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="concurrency.html"
                        title="前の章へ">17. 並行実行</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="multiprocessing.html"
                        title="次の章へ">17.2. <code class="docutils literal"><span class="pre">multiprocessing</span></code> &#8212; プロセスベースの並列処理</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/threading.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="multiprocessing.html" title="17.2. multiprocessing — プロセスベースの並列処理"
             >次へ</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="17. 並行実行"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concurrency.html" >17. 並行実行</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 7月 22, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>