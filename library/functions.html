<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. 組み込み関数 &#8212; Python 3.6.0 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.0 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.0 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python 標準ライブラリ" href="index.html" />
    <link rel="next" title="3. 組み込み定数" href="constants.html" />
    <link rel="prev" title="1. はじめに" href="intro.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/functions.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/functions.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 組み込み定数"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. はじめに"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.0</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 標準ライブラリ</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-functions">
<span id="built-in-funcs"></span><h1>2. 組み込み関数<a class="headerlink" href="#built-in-functions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Python インタプリタには数多くの関数と型が組み込まれており、いつでも利用できます。それらをここにアルファベット順に挙げます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="19%" />
<col width="20%" />
<col width="18%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head"><p class="first last">組み込み関数</p>
</th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a></td>
<td><a class="reference internal" href="#func-dict"><code class="docutils literal"><span class="pre">dict()</span></code></a></td>
<td><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal"><span class="pre">help()</span></code></a></td>
<td><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a></td>
<td><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal"><span class="pre">setattr()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal"><span class="pre">all()</span></code></a></td>
<td><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a></td>
<td><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal"><span class="pre">hex()</span></code></a></td>
<td><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a></td>
<td><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal"><span class="pre">any()</span></code></a></td>
<td><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a></td>
<td><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a></td>
<td><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal"><span class="pre">object()</span></code></a></td>
<td><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal"><span class="pre">ascii()</span></code></a></td>
<td><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a></td>
<td><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a></td>
<td><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a></td>
<td><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal"><span class="pre">bin()</span></code></a></td>
<td><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a></td>
<td><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a></td>
<td><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a></td>
<td><a class="reference internal" href="#func-str"><code class="docutils literal"><span class="pre">str()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a></td>
<td><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a></td>
<td><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a></td>
<td><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a></td>
<td><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a></td>
<td><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal"><span class="pre">filter()</span></code></a></td>
<td><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a></td>
<td><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a></td>
<td><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-func docutils literal"><span class="pre">bytes()</span></code></a></td>
<td><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a></td>
<td><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal"><span class="pre">iter()</span></code></a></td>
<td><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a></td>
<td><a class="reference internal" href="#func-tuple"><code class="docutils literal"><span class="pre">tuple()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal"><span class="pre">callable()</span></code></a></td>
<td><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a></td>
<td><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a></td>
<td><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a></td>
<td><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a></td>
<td><a class="reference internal" href="#func-frozenset"><code class="docutils literal"><span class="pre">frozenset()</span></code></a></td>
<td><a class="reference internal" href="#func-list"><code class="docutils literal"><span class="pre">list()</span></code></a></td>
<td><a class="reference internal" href="#func-range"><code class="docutils literal"><span class="pre">range()</span></code></a></td>
<td><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal"><span class="pre">vars()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a></td>
<td><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a></td>
<td><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a></td>
<td><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a></td>
<td><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a></td>
<td><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal"><span class="pre">globals()</span></code></a></td>
<td><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a></td>
<td><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a></td>
<td><a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a></td>
<td><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal"><span class="pre">hasattr()</span></code></a></td>
<td><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a></td>
<td><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal"><span class="pre">delattr()</span></code></a></td>
<td><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a></td>
<td><a class="reference internal" href="#func-memoryview"><code class="docutils literal"><span class="pre">memoryview()</span></code></a></td>
<td><a class="reference internal" href="#func-set"><code class="docutils literal"><span class="pre">set()</span></code></a></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数の絶対値を返します。引数は整数または浮動小数点数です。引数が複素数なら、その絶対値 (magnitude) が返されます。</p>
</dd></dl>

<dl class="function">
<dt id="all">
<code class="descname">all</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の全ての要素が真ならば (もしくは <em>iterable</em> が空ならば) <code class="docutils literal"><span class="pre">True</span></code> を返します。以下のコードと等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="any">
<code class="descname">any</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#any" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> のいずれかの要素が真ならば <code class="docutils literal"><span class="pre">True</span></code> を返します。<em>iterable</em> が空なら <code class="docutils literal"><span class="pre">False</span></code> を返します。以下のコードと等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ascii">
<code class="descname">ascii</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#ascii" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> と同様、オブジェクトの印字可能な表現を含む文字列を返しますが、<a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> によって返された文字列中の非 ASCII 文字は <code class="docutils literal"><span class="pre">\x</span></code> 、 <code class="docutils literal"><span class="pre">\u</span></code> 、 <code class="docutils literal"><span class="pre">\U</span></code> エスケープを使ってエスケープされます。これは Python 2 の <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> によって返されるのと同じ文字列を作ります。</p>
</dd></dl>

<dl class="function">
<dt id="bin">
<code class="descname">bin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#bin" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数を二進文字列に変換します。結果は Python の式としても使える形式になります。 <em>x</em> が Python の <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> オブジェクトでない場合、整数値を返す <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> メソッドが定義されていなければなりません。</p>
</dd></dl>

<dl class="class">
<dt id="bool">
<em class="property">class </em><code class="descname">bool</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブール値、即ち <code class="docutils literal"><span class="pre">True</span></code> または <code class="docutils literal"><span class="pre">False</span></code> のどちらかを返します。<em>x</em> は標準の <a class="reference internal" href="stdtypes.html#truth"><span class="std std-ref">真理値判定手続き</span></a> を用いて変換されます。<em>x</em> が偽または省略されている場合、この関数は <code class="docutils literal"><span class="pre">False</span></code> を返します。それ以外の場合、<code class="docutils literal"><span class="pre">True</span></code> を返します。<a class="reference internal" href="#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a> クラスは <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> クラスの派生クラスです(<a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, complex</span></a> を参照してください)。このクラスからさらに派生することはできません。ブール値のインスタンスは <code class="docutils literal"><span class="pre">False</span></code> と <code class="docutils literal"><span class="pre">True</span></code> のみです(<a class="reference internal" href="stdtypes.html#bltin-boolean-values"><span class="std std-ref">ブール値</span></a> を参照してください)。</p>
</dd></dl>

<span class="target" id="func-bytearray"><span id="index-0"></span></span><dl class="class">
<dt id="bytearray">
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいバイト配列を返します。<a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> クラスは0 &lt;= x &lt; 256の範囲の整数からなる変更可能な配列です。<a class="reference internal" href="stdtypes.html#typesseq-mutable"><span class="std std-ref">ミュータブルなシーケンス型</span></a> に記述されている変更可能な配列に対する普通のメソッドの大半を備えています。また、<a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 型が持つメソッドの大半も備えています（see <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">bytes と bytearray の操作</span></a>)。</p>
<p>オプションの <em>source</em> 引数は、配列を異なる方法で初期化するのに使われます:</p>
<ul class="simple">
<li><p class="first"><em>文字列</em> の場合、 <em>encoding</em> (と、オプションの <em>errors</em>) 引数も与えなければなりません。このとき <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a> は文字列を <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a> でバイトに変換して返します。</p>
</li>
<li><p class="first"><em>整数</em> の場合、配列はそのサイズになり、null バイトで初期化されます。</p>
</li>
<li><p class="first"><em>バッファ</em> インタフェースに適合するオブジェクトの場合、そのオブジェクトの読み込み専用バッファがバイト配列の初期化に使われます。</p>
</li>
<li><p class="first"><em>イテラブル</em> の場合、範囲 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 内の整数のイテラブルでなければならず、それらが配列の初期の内容として使われます。</p>
</li>
</ul>
<p>引数がなければ、長さ 0 の配列が生成されます。</p>
<p><a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">バイナリシーケンス型 &#8212; bytes, bytearray, memoryview</span></a> と <a class="reference internal" href="stdtypes.html#typebytearray"><span class="std std-ref">bytearray オブジェクト</span></a> も参照してください。</p>
</dd></dl>

<span class="target" id="func-bytes"></span><dl class="class">
<dt id="bytes">
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>範囲 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> の整数のイミュータブルなシーケンスである &#8220;bytes&#8221; オブジェクトを返します。 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> は <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> のイミュータブル版です。オブジェクトを変化させないようなメソッドや、インデクシングやスライシングのふるまいは、これと同様のものです。</p>
<p>従って、コンストラクタ引数は <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a> のものと同様に解釈されます。</p>
<p>バイト列オブジェクトはリテラルでも生成できます。 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">文字列およびバイト列リテラル</span></a> を参照してください。</p>
<p><a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">バイナリシーケンス型 &#8212; bytes, bytearray, memoryview</span></a>, <a class="reference internal" href="stdtypes.html#typebytes"><span class="std std-ref">bytes</span></a>, <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">bytes と bytearray の操作</span></a> も参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="callable">
<code class="descname">callable</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#callable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> 引数が呼び出し可能オブジェクトであれば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。この関数が真を返しても、呼び出しは失敗する可能性がありますが、偽であれば、 <em>object</em> の呼び出しは決して成功しません。なお、クラスは呼び出し可能 (クラスを呼び出すと新しいインスタンスを返します) です。また、インスタンスはクラスが <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドを持つなら呼び出し可能です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span>この関数は Python 3.0 で一度取り除かれましたが、Python 3.2 で復活しました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="chr">
<code class="descname">chr</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#chr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Unicode コードポイントが整数 <em>i</em> である文字を表す文字列を返します。例えば <code class="docutils literal"><span class="pre">chr(97)</span></code> は文字列 <code class="docutils literal"><span class="pre">'a'</span></code> を、 <code class="docutils literal"><span class="pre">chr(8364)</span></code> は文字列 <code class="docutils literal"><span class="pre">'€'</span></code> を返します。 <a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> の逆です。</p>
<p>引数の有効な範囲は 0 から 1,114,111 (16 進数で 0x10FFFF) です。 <em>i</em> が範囲外の場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="function">
<dt id="classmethod">
<code class="descname">classmethod</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#classmethod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>function</em> のクラスメソッドを返します。</p>
<p>クラスメソッドは、インスタンスメソッドが暗黙の第一引数としてインスタンスをとるように、第一引数としてクラスをとります。クラスメソッドを宣言するには、以下のイディオムを使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&#64;classmethod</span></code> 形式は関数デコレータ (<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>) です。詳しくは <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> の関数定義の説明を参照してください。</p>
<p>このメソッドはクラスで呼び出すこと (例えば <code class="docutils literal"><span class="pre">C.f()</span></code>) も、インスタンスとして呼び出すこと (例えば <code class="docutils literal"><span class="pre">C().f()</span></code>) もできます。インスタンスはそのクラスが何であるかを除いて無視されます。クラスメソッドが派生クラスに対して呼び出された場合、派生したクラスオブジェクトが暗黙の第一引数として渡されます。</p>
<p>クラスメソッドは C++ や Java の静的メソッドとは異なります。静的メソッドは、この節の <a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a> を参照してください。</p>
<p>クラスメソッドについて詳しい情報は、 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> の標準型階層のドキュメントを参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="compile">
<code class="descname">compile</code><span class="sig-paren">(</span><em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#compile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>source</em> をコードオブジェクト、もしくは、 AST オブジェクトにコンパイルします。 コードオブジェクトは <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> 文で実行したり、 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> 呼び出しで評価できます。 <em>source</em> は通常の文字列、 バイト列、 AST オブジェクトのいずれでもかまいません。 AST オブジェクトへの、また、 AST オブジェクトからのコンパイルの方法は、 <a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal"><span class="pre">ast</span></code></a> モジュールのドキュメントを参照してください。</p>
<p><em>filename</em> 引数には、コードの読み出し元のファイルを与えなければなりません; ファイルから読み出されるのでなければ、認識可能な値を渡して下さい (<code class="docutils literal"><span class="pre">'&lt;string&gt;'</span></code> が一般的に使われます)。</p>
<p><em>mode</em> 引数は、コンパイルされるコードの種類を指定します; <em>source</em> が一連の文から成るなら <code class="docutils literal"><span class="pre">'exec'</span></code> 、単一の式から成るなら <code class="docutils literal"><span class="pre">'eval'</span></code> 、単一の対話的文の場合 <code class="docutils literal"><span class="pre">'single'</span></code> です。(後者の場合、評価が <code class="docutils literal"><span class="pre">None</span></code> 以外である式文が印字されます)。</p>
<p>オプション引数 <em>flags</em> および <em>dont_inherit</em> は、 <em>source</em> のコンパイルにどの future 文 (<span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> 参照) を作用させるかを制御します。どちらも与えらていない (または両方ともゼロ) ならば、 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> を呼び出している側のコードで有効な future 文を有効にしてコードをコンパイルします。 <em>flags</em> が与えられていて、<em>dont_inherit</em> は与えられていない (またはゼロ) ならば、それに加えて <em>flags</em> に指定された future 文が使われます。 <em>dont_inherit</em> がゼロでない整数ならば、 <em>flags</em> の値そのものが使われ、コンパイルの呼び出して周辺で有効な future 文は無視されます。</p>
<p>future 文はビットフィールドで指定されます。ビットフィールドはビット単位の OR を取ることで複数の文を指定することができます。特定の機能を指定するために必要なビットフィールドは、<a class="reference internal" href="__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">_Feature</span></code> インスタンスにおける <code class="xref py py-attr docutils literal"><span class="pre">compiler_flag</span></code> 属性で得られます。</p>
<p>引数 <em>optimize</em> は、コンパイラの最適化レベルを指定します; デフォルトの値 <code class="docutils literal"><span class="pre">-1</span></code> は、インタプリタの <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal"><span class="pre">-O</span></code></a> オプションで与えられるのと同じ最適化レベルを選びます。明示的なレベルは、 <code class="docutils literal"><span class="pre">0</span></code> (最適化なし、 <code class="docutils literal"><span class="pre">__debug__</span></code> は真)、 <code class="docutils literal"><span class="pre">1</span></code> (assert は取り除かれ、 <code class="docutils literal"><span class="pre">__debug__</span></code> は偽)、 <code class="docutils literal"><span class="pre">2</span></code> (docstring も取り除かれる) です。</p>
<p>この関数は、コンパイルされたソースが不正である場合 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a> を、ソースがヌルバイトを含む場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<p>Python コードをパースしてその AST 表現を得たいのであれば、 <a class="reference internal" href="ast.html#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal"><span class="pre">ast.parse()</span></code></a> を参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">複数行に渡るコードの文字列を <code class="docutils literal"><span class="pre">'single'</span></code> や <code class="docutils literal"><span class="pre">'eval'</span></code> モードでコンパイルするとき、入力は一つ以上の改行文字で終端されなければなりません。これは、 <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a> モジュールで不完全な文と完全な文を検知しやすくするためです。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>Windows や Mac の改行も受け付けます。また <code class="docutils literal"><span class="pre">'exec'</span></code> モードでの入力が改行で終わっている必要もありません。<em>optimize</em> 引数が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>以前は <em>source</em> にヌルバイトがあったときに <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出していました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="complex">
<em class="property">class </em><code class="descname">complex</code><span class="sig-paren">(</span><span class="optional">[</span><em>real</em><span class="optional">[</span>, <em>imag</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#complex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値 <em>real</em> + <em>imag</em>*1j の複素数を返すか、文字列や数を複素数に変換します。第一引数が文字列なら、それが複素数と解釈され、この関数は第二引数無しで呼び出されなければなりません。第二引数は文字列であってはなりません。それぞれの引数は (複素数を含む) 任意の数値型です。 <em>imag</em> が省略された場合、標準の値はゼロで、このコンストラクタは <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> や <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> のような数値変換としてはたらきます。両方の引数が省略された場合、 <code class="docutils literal"><span class="pre">0j</span></code> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">文字列から変換するとき、その文字列は中央の <code class="docutils literal"><span class="pre">+</span></code> や <code class="docutils literal"><span class="pre">-</span></code> 演算子の周りに空白を含んではなりません。例えば、<code class="docutils literal"><span class="pre">complex('1+2j')</span></code> はいいですが、<code class="docutils literal"><span class="pre">complex('1</span> <span class="pre">+</span> <span class="pre">2j')</span></code> は <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</div>
<p>複素数型については <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, complex</span></a> に説明があります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Grouping digits with underscores as in code literals is allowed.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="delattr">
<code class="descname">delattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#delattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal"><span class="pre">setattr()</span></code></a> の親戚です。引数はオブジェクトと文字列です。文字列はオブジェクトの属性のうち一つの名前でなければなりません。この関数は、オブジェクトが許すなら、指名された属性を削除します。例えば、 <code class="docutils literal"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></code> は <code class="docutils literal"><span class="pre">del</span> <span class="pre">x.foobar</span></code> と等価です。</p>
</dd></dl>

<span class="target" id="func-dict"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>新しい辞書を作成します。 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> オブジェクトは辞書クラスです。このクラスに関するドキュメンテーションは <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> と <a class="reference internal" href="stdtypes.html#typesmapping"><span class="std std-ref">マッピング型 &#8212; dict</span></a> を参照してください。</p>
<p>他のコンテナについては、 ビルトインの <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> クラスおよび <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールを参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="dir">
<code class="descname">dir</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dir" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数がない場合、現在のローカルスコープにある名前のリストを返します。引数がある場合、そのオブジェクトの有効な属性のリストを返そうと試みます。</p>
<p>オブジェクトが <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal"><span class="pre">__dir__()</span></code></a> という名のメソッドを持つなら、そのメソッドが呼び出され、属性のリストを返さなければなりません。これにより、カスタムの <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal"><span class="pre">__getattr__()</span></code></a> や <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-func docutils literal"><span class="pre">__getattribute__()</span></code></a> 関数を実装するオブジェクトは、<a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> が属性を報告するやり方をカスタマイズできます。</p>
<p>オブジェクトが <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal"><span class="pre">__dir__()</span></code></a> を提供していない場合、定義されていればオブジェクトの <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性から、そして型オブジェクトから、情報を収集しようと試みます。結果のリストは完全であるとは限らず、また、カスタムの <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal"><span class="pre">__getattr__()</span></code></a> を持つ場合、不正確になるかもしれません。</p>
<p>デフォルトの <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> メカニズムは、完全というより最重要な情報を作成しようとするため、異なる型のオブジェクトでは異なって振る舞います:</p>
<ul class="simple">
<li><p class="first">オブジェクトがモジュールオブジェクトの場合、リストにはモジュールの属性の名前が含まれます。</p>
</li>
<li><p class="first">オブジェクトが型オブジェクトやクラスオブジェクトの場合、リストにはその属性の名前と、再帰的にたどったその基底クラスの属性が含まれます。</p>
</li>
<li><p class="first">それ以外の場合には、リストにはオブジェクトの属性名、クラス属性名、再帰的にたどった基底クラスの属性名が含まれます。</p>
</li>
</ul>
<p>返されるリストはアルファベット順に並べられています。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c1"># show the names in the module namespace</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c1"># show the names in the struct module </span>
<span class="go">[&#39;Struct&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;,</span>
<span class="go"> &#39;__initializing__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;area&#39;, &#39;location&#39;, &#39;perimeter&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> は主に対話プロンプトでの使用に便利なように提供されているので、厳密性や一貫性を重視して定義された名前のセットというよりも、むしろ興味を引くような名前のセットを返そうとします。また、この関数の細かい動作はリリース間で変わる可能性があります。例えば、引数がクラスであるとき、メタクラス属性は結果のリストに含まれません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#divmod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2 つの (複素数でない) 数を引数として取り、整数の除法を行ったときの商と剰余からなる対を返します。混合した被演算子型では、二項算術演算子での規則が適用されます。整数では、結果は  <code class="docutils literal"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> と同じです。浮動小数点数では、結果は <code class="docutils literal"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> で、ここで <em>q</em> は通常 <code class="docutils literal"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></code> ですが、それより 1 小さくなることもあります。いずれにせよ、<code class="docutils literal"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> は <em>a</em> に非常に近く、<code class="docutils literal"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> がゼロでなければその符号は <em>b</em> と同じで、<code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></code> です。</p>
</dd></dl>

<dl class="function">
<dt id="enumerate">
<code class="descname">enumerate</code><span class="sig-paren">(</span><em>iterable</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#enumerate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>enumerate オブジェクトを返します。 <em>iterable</em> は、シーケンスか <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> か、あるいはイテレーションをサポートするその他のオブジェクトでなければなりません。 <a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> によって返されたイテレータの <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドは、 (デフォルトでは 0 となる <em>start</em> からの) カウントと、 <em>iterable</em> 上のイテレーションによって得られた値を含むタプルを返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seasons</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Spring&#39;</span><span class="p">,</span> <span class="s1">&#39;Summer&#39;</span><span class="p">,</span> <span class="s1">&#39;Fall&#39;</span><span class="p">,</span> <span class="s1">&#39;Winter&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">))</span>
<span class="go">[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span>
</pre></div>
</div>
<p>次と等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span><span class="p">,</span> <span class="n">elem</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>expression</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#eval" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列とオプションの引数 <em>globals</em>、<em>locals</em> をとります。<em>globals</em> を与える場合は辞書でなくてはなりません。<em>locals</em> を与える場合は任意のマッピングオブジェクトにできます。</p>
<p><em>expression</em> 引数は Python 式 (技術的にいうと、条件のリスト) として解析され評価されます。このとき辞書 <em>globals</em> および <em>locals</em> はそれぞれグローバルおよびローカルな名前空間として使われます。 <em>globals</em> 辞書が与えられ、 &#8216;__builtins__&#8217; が欠けている場合、 <em>expression</em> が解析される前に現在のグローバル変数が <em>globals</em> にコピーされます。よって、 <em>expression</em> は通常、標準の <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> モジュールへの完全なアクセスを有し、制限された環境は伝播します。 <em>locals</em> 辞書が省略された場合、デフォルトは <em>globals</em> 辞書です。辞書が両方とも省略された場合、式は <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> が呼び出されている環境の下で実行されます。構文エラーは例外として報告されます。例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>この関数は (<a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> で生成されるような) 任意のコードオブジェクトを実行するのにも利用できます。この場合、文字列の代わりにコードオブジェクトを渡します。このコードオブジェクトが、引数 <em>mode</em> を <code class="docutils literal"><span class="pre">'exec'</span></code> としてコンパイルされている場合、 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> が返す値は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
<p>ヒント: <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> 関数により文の動的な実行がサポートされています。<a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal"><span class="pre">globals()</span></code></a> および <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> 関数は、それぞれ現在のグローバルおよびローカルな辞書を返すので、それらを <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> や <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> に渡して使うことができます。</p>
<p>リテラルだけを含む式の文字列を安全に評価できる関数、 <a class="reference internal" href="ast.html#ast.literal_eval" title="ast.literal_eval"><code class="xref py py-func docutils literal"><span class="pre">ast.literal_eval()</span></code></a> も参照してください。</p>
</dd></dl>

<span class="target" id="index-2"></span><dl class="function">
<dt id="exec">
<code class="descname">exec</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#exec" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は Python コードの動的な実行をサポートします。 <em>object</em> は文字列かコードオブジェクトでなければなりません。文字列なら、その文字列は一連の Python 文として解析され、そして (構文エラーが生じない限り) 実行されます。 <a class="footnote-reference" href="#id2" id="id1">[1]</a> コードオブジェクトなら、それは単純に実行されます。どの場合でも、実行されるコードはファイル入力として有効であることが期待されます (リファレンスマニュアルの節 &#8220;file-input&#8221; を参照)。なお、 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> および <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文は、 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> 関数に渡されたコードの文脈中においてさえ、関数定義の外では使えません。返り値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<p>いずれの場合でも、オプションの部分が省略されると、コードは現在のスコープ内で実行されます。<em>globals</em> だけが与えられたなら、辞書でなくてはならず、グローバル変数とローカル変数の両方に使われます。<em>globals</em> と <em>locals</em> が与えられたなら、それぞれグローバル変数とローカル変数として使われます。<em>locals</em> を指定する場合は何らかのマップ型オブジェクトでなければなりません。モジュールレベルでは、グローバルとローカルは同じ辞書です。exec が <em>globals</em> と <em>locals</em> として別のオブジェクトを取った場合、コードはクラス定義に埋め込まれたかのように実行されます。</p>
<p><em>globals</em> 辞書がキー <code class="docutils literal"><span class="pre">__builtins__</span></code> に対する値を含まなければ、そのキーに対して、組み込みモジュール <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> の辞書への参照が挿入されます。ですから、実行されるコードを <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> に渡す前に、 <em>globals</em> に自作の <code class="docutils literal"><span class="pre">__builtins__</span></code> 辞書を挿入することで、コードがどの組み込みを利用できるか制御できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">組み込み関数 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal"><span class="pre">globals()</span></code></a> および <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> は、それぞれ現在のグローバルおよびローカルの辞書を返すので、それらを <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> の第二、第三引数にそのまま渡して使うと便利なことがあります。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">標準では <em>locals</em> は後に述べる関数 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> のように動作します: 標準の <em>locals</em> 辞書に対する変更を試みてはいけません。 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> の呼び出しが返る時にコードが <em>locals</em> に与える影響を知りたいなら、明示的に <em>locals</em> 辞書を渡してください。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#filter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素のうち <em>function</em> が真を返すものでイテレータを構築します。<em>iterable</em> はシーケンスか、反復をサポートするコンテナか、イテレータです。<em>function</em> が <code class="docutils literal"><span class="pre">None</span></code> なら、恒等関数を仮定します。すなわち、<em>iterable</em> の偽である要素がすべて除去されます。</p>
<p>なお、<code class="docutils literal"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></code> は、関数が <code class="docutils literal"><span class="pre">None</span></code> でなければジェネレータ式 <code class="docutils literal"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item))</span></code> と同等で、関数が <code class="docutils literal"><span class="pre">None</span></code> なら <code class="docutils literal"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item)</span></code> と同等です。</p>
<p><em>function</em> が偽を返すような <em>iterable</em> の各要素を返す補完的関数は、 <a class="reference internal" href="itertools.html#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal"><span class="pre">itertools.filterfalse()</span></code></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="float">
<em class="property">class </em><code class="descname">float</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#float" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-3">数または文字列 <em>x</em> から生成された浮動小数点数を返します。</p>
<p>引数が文字列の場合、10進数を含んだ文字列にしてください。先頭に符号が付いていたり、空白中に埋め込まれていてもかまいません。符号として <code class="docutils literal"><span class="pre">'+'</span></code> か <code class="docutils literal"><span class="pre">'-'</span></code> を追加できます。<code class="docutils literal"><span class="pre">'+'</span></code> は、作られる値に何の影響も与えません。引数は NaN (not-a-number) や正負の無限大を表す文字列でもかまいません。正確には、入力は、前後の空白を取り除いた後に以下の文法に従う必要があります:</p>
<pre>
<strong id="grammar-token-sign">sign          </strong> ::=  &quot;+&quot; | &quot;-&quot;
<strong id="grammar-token-infinity">infinity      </strong> ::=  &quot;Infinity&quot; | &quot;inf&quot;
<strong id="grammar-token-nan">nan           </strong> ::=  &quot;nan&quot;
<strong id="grammar-token-numeric_value">numeric_value </strong> ::=  <a class="reference internal" href="../reference/lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="#grammar-token-infinity"><code class="xref docutils literal"><span class="pre">infinity</span></code></a> | <a class="reference internal" href="#grammar-token-nan"><code class="xref docutils literal"><span class="pre">nan</span></code></a>
<strong id="grammar-token-numeric_string">numeric_string</strong> ::=  [<a class="reference internal" href="string.html#grammar-token-sign"><code class="xref docutils literal"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-numeric_value"><code class="xref docutils literal"><span class="pre">numeric_value</span></code></a>
</pre>
<p>ここで <code class="docutils literal"><span class="pre">floatnumber</span></code> は <a class="reference internal" href="../reference/lexical_analysis.html#floating"><span class="std std-ref">浮動小数点数リテラル</span></a> で記述されている Python の浮動小数点数リテラルです。大文字か小文字かは関係なく、例えば &#8220;inf&#8221;、 &#8220;Inf&#8221;、 &#8220;INFINITY&#8221; 、 &#8220;iNfINity&#8221; は全て正の無限大として使える綴りです。</p>
<p>一方で、引数が整数または浮動小数点数なら、(Python の浮動小数点数の精度で) 同じ値の浮動小数点数が返されます。引数が Python の浮動小数点数の範囲外なら、 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> が送出されます。</p>
<p>一般の Python オブジェクト <code class="docutils literal"><span class="pre">x</span></code> に対して、<code class="docutils literal"><span class="pre">float(x)</span></code> は <code class="docutils literal"><span class="pre">x.__float__()</span></code> に委譲します。</p>
<p>引数が与えられなければ、<code class="docutils literal"><span class="pre">0.0</span></code> が返されます。</p>
<p>例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1.23&#39;</span><span class="p">)</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;   -12345</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">-12345.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;1e-003&#39;</span><span class="p">)</span>
<span class="go">0.001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1E6&#39;</span><span class="p">)</span>
<span class="go">1000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p>浮動小数点数型については、 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, complex</span></a> も参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Grouping digits with underscores as in code literals is allowed.</p>
</div>
</dd></dl>

<span class="target" id="index-4"></span><dl class="function">
<dt id="format">
<code class="descname">format</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>format_spec</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>value</em> を <em>format_spec</em> で制御される &#8220;書式化された&#8221; 表現に変換します。 <em>format_spec</em> の解釈は <em>value</em> 引数の型に依存しますが、ほとんどの組み込み型で使われる標準的な構文が存在します: <a class="reference internal" href="string.html#formatspec"><span class="std std-ref">書式指定ミニ言語仕様</span></a> 。</p>
<p>デフォルトの <em>format_spec</em> は空の文字列です。それは通常 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str(value)</span></code></a> の呼び出しと同じ結果になります。</p>
<p><code class="docutils literal"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></code> の呼び出しは、 <code class="docutils literal"><span class="pre">type(value).__format__(value,</span> <span class="pre">format_spec)</span></code> に翻訳され、これは value の <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal"><span class="pre">__format__()</span></code></a> メソッドの検索をするとき、インスタンス辞書を回避します。このメソッドの探索が <a class="reference internal" href="#object" title="object"><code class="xref py py-mod docutils literal"><span class="pre">object</span></code></a> に到達しても <em>format_spec</em> が空にならなかったり、 <em>format_spec</em> や返り値が文字列でなかったりした場合、 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><em>format_spec</em> が空の文字列でない場合 <code class="docutils literal"><span class="pre">object().__format__(format_spec)</span></code> は <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。</p>
</div>
</dd></dl>

<span class="target" id="func-frozenset"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>新しい <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> オブジェクトを返します。オプションで <em>iterable</em> から得られた要素を含みます。 <code class="docutils literal"><span class="pre">frozenset</span></code> はビルトインクラスです。このクラスに関するドキュメントは <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> と <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">set（集合）型 &#8212; set, frozenset</span></a> を参照してください。</p>
<p>他のコンテナについては、ビルトインクラス <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> や <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールを見てください。</p>
</dd></dl>

<dl class="function">
<dt id="getattr">
<code class="descname">getattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#getattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> の指名された属性の値を返します。 <em>name</em> は文字列でなくてはなりません。文字列がオブジェクトの属性の一つの名前であった場合、戻り値はその属性の値になります。例えば、 <code class="docutils literal"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></code> は <code class="docutils literal"><span class="pre">x.foobar</span></code> と等価です。指名された属性が存在しない場合、 <em>default</em> が与えられていればそれが返され、そうでない場合には <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="function">
<dt id="globals">
<code class="descname">globals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#globals" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のグローバルシンボルテーブルを表す辞書を返します。これは常に現在のモジュール (関数やメソッドの中では、それを呼び出したモジュールではなく、それを定義しているモジュール) の辞書です。</p>
</dd></dl>

<dl class="function">
<dt id="hasattr">
<code class="descname">hasattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hasattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数はオブジェクトと文字列です。文字列がオブジェクトの属性名の一つであった場合 <code class="docutils literal"><span class="pre">True</span></code> を、そうでない場合 <code class="docutils literal"><span class="pre">False</span></code> を返します。 (この関数は、 <code class="docutils literal"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code> を呼び出して <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> を送出するかどうかを見ることで実装されています。)</p>
</dd></dl>

<dl class="function">
<dt id="hash">
<code class="descname">hash</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#hash" title="この定義へのパーマリンク">¶</a></dt>
<dd><blockquote>
<div><p>オブジェクトのハッシュ値を (存在すれば) 返します。ハッシュ値は整数です。これらは辞書を検索する際に辞書のキーを高速に比較するために使われます。等しい値となる数値は等しいハッシュ値を持ちます (1 と 1.0 のように型が異なっていてもです)。</p>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">独自の <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドを実装したオブジェクトを使う場合、<a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> が実行するマシンのビット幅に合わせて戻り値を切り捨てることに注意してください。詳しくは <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を参照してください。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="help">
<code class="descname">help</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#help" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>組み込みヘルプシステムを起動します。(この関数は対話的な使用のためのものです。) 引数が与えられていない場合、対話的ヘルプシステムはインタプリタコンソール上で起動します。引数が文字列の場合、文字列はモジュール、関数、クラス、メソッド、キーワード、またはドキュメントの項目名として検索され、ヘルプページがコンソール上に印字されます。引数がその他のオブジェクトの場合、そのオブジェクトに関するヘルプページが生成されます。</p>
<p>この関数は、 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> モジュールから、組み込みの名前空間に移されました。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal"><span class="pre">pydoc</span></code></a> と <a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a> への変更により、呼び出し可能オブジェクトの報告されたシグニチャがより包括的で一貫性のあるものになりました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="hex">
<code class="descname">hex</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数を先頭に &#8220;0x&#8221; が付いた小文字の16進数文字列に変換します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="go">&#39;0xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;-0x2a&#39;</span>
</pre></div>
</div>
<p>x が Python の <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> オブジェクトでない場合、整数を返す <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> メソッドを定義していなければなりません。</p>
<p>16を底として16進数文字列を整数に変換するには <a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a> も参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">浮動小数点数の16進文字列表記を得たい場合には、 <a class="reference internal" href="stdtypes.html#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> メソッドを使って下さい。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="id">
<code class="descname">id</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#id" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの &#8220;識別値&#8221; を返します。この値は整数で、このオブジェクトの有効期間中は一意かつ定数であることが保証されています。有効期間が重ならない 2 つのオブジェクトは同じ <a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a> 値を持つかもしれません。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> This is the address of the object in memory.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="input">
<code class="descname">input</code><span class="sig-paren">(</span><span class="optional">[</span><em>prompt</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#input" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>prompt</em> が存在すれば、それが末尾の改行を除いて標準出力に書き出されます。次に、この関数は入力から 1 行を読み込み、文字列に変換して (末尾の改行を除いて) 返します。 EOF が読み込まれたとき、 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a> が送出されます。例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;--&gt; &#39;</span><span class="p">)</span>  
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p><a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">readline</span></code></a> モジュールが読み込まれていれば、 <a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a> はそれを使って精緻な行編集やヒストリ機能を提供します。</p>
</dd></dl>

<dl class="class">
<dt id="int">
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x=0</em><span class="sig-paren">)</span><a class="headerlink" href="#int" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x</em>, <em>base=10</em><span class="sig-paren">)</span></dt>
<dd><p>数値または文字列 <em>x</em> から生成された整数を返します。引数が与えられない場合には <code class="docutils literal"><span class="pre">0</span></code> を返します。 <em>x</em> が数値である場合は <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal"><span class="pre">x.__int__()</span></code></a> を返します。浮動小数点数については、小数点以下を切り捨てて 0 にします。</p>
<p><em>x</em> が数値でない、あるいは <em>base</em> が与えられた場合、 <em>x</em> は文字列、 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> インスタンス、 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> インスタンスのいずれかで、基数 <em>base</em> の <a class="reference internal" href="../reference/lexical_analysis.html#integers"><span class="std std-ref">整数リテラル</span></a> で表されたものでなければなりません。
オプションで、リテラルの前に <code class="docutils literal"><span class="pre">+</span></code> あるいは <code class="docutils literal"><span class="pre">-</span></code> を (中間のスペースなしで) 付けることができます。
また、リテラルは余白で囲むことができます。
基数 n のリテラルは、 0 から n-1 の数字に値 10-35 を持つ <code class="docutils literal"><span class="pre">a</span></code> から <code class="docutils literal"><span class="pre">z</span></code> (または <code class="docutils literal"><span class="pre">A</span></code> から <code class="docutils literal"><span class="pre">Z</span></code>) を加えたもので構成されます。
デフォルトの <em>base</em> は 10 です。
許される値は 0 と 2&#8211;36 です。
基数 2, 8, 16 のリテラルは、別の記法としてコード中の整数リテラルのように <code class="docutils literal"><span class="pre">0b</span></code>/<code class="docutils literal"><span class="pre">0B</span></code>, <code class="docutils literal"><span class="pre">0o</span></code>/<code class="docutils literal"><span class="pre">0O</span></code>, <code class="docutils literal"><span class="pre">0x</span></code>/<code class="docutils literal"><span class="pre">0X</span></code> を前に付けることができます。
基数 0 はコードリテラルとして厳密に解釈することを意味します。
その結果、実際の基数は 2, 8, 10, 16 のどれかになります。
したがって <code class="docutils literal"><span class="pre">int('010',</span> <span class="pre">0)</span></code> は有効ではありませんが、 <code class="docutils literal"><span class="pre">int('010')</span></code> や <code class="docutils literal"><span class="pre">int('010',</span> <span class="pre">8)</span></code> は有効です。</p>
<p>整数型については、 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, complex</span></a> も参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><em>base</em> が <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> のインスタンスでなく、<em>base</em> オブジェクトが <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">base.__index__</span></code></a> メソッドを持っている場合、そのメソッドを呼んで底に対する整数を得ることができます。以前のバージョンでは <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">base.__index__</span></code></a> ではなく <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal"><span class="pre">base.__int__</span></code></a> を使用していました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Grouping digits with underscores as in code literals is allowed.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="isinstance">
<code class="descname">isinstance</code><span class="sig-paren">(</span><em>object</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#isinstance" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> 引数が <em>classinfo</em> 引数のインスタンスであるか、 (直接、間接、または <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">仮想</span></a>) サブクラスのインスタンスの場合に真を返します。
<em>object</em> が与えられた型のオブジェクトでない場合、この関数は常に偽を返します。
<em>classinfo</em> が型オブジェクトのタプル (あるいは再帰的に複数のタプル) の場合、 <em>object</em> がそれらのいずれかのインスタンスであれば真を返します。
<em>classinfo</em> が型や型からなるタプル、あるいは複数のタプルのいずれでもない場合、 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
</dd></dl>

<dl class="function">
<dt id="issubclass">
<code class="descname">issubclass</code><span class="sig-paren">(</span><em>class</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#issubclass" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>class</em> が <em>classinfo</em> の (直接または間接的な、あるいは <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">virtual</span></a>) サブクラスである場合に真を返します。クラスはそれ自身のサブクラスとみなされます。 <em>classinfo</em> はクラスオブジェクトからなるタプルでもよく、この場合には <em>classinfo</em> のすべてのエントリが調べられます。その他の場合では、例外 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="function">
<dt id="iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>sentinel</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#iter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータ (<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>) オブジェクトを返します。 第二引数があるかどうかで、第一引数の解釈は大きく異なります。 第二引数がない場合、 <em>object</em> は反復プロトコル (<a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> メソッド) か、シーケンスプロトコル (引数が <code class="docutils literal"><span class="pre">0</span></code> から開始する <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッド) をサポートする集合オブジェクトでなければなりません。これらのプロトコルが両方ともサポートされていない場合、 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。 第二引数 <em>sentinel</em> が与えられているなら、 <em>object</em> は呼び出し可能オブジェクトでなければなりません。この場合に生成されるイテレータは、 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> を呼ぶ毎に <em>object</em> を引数無しで呼び出します。返された値が <em>sentinel</em> と等しければ、 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> が送出され、そうでなければ、戻り値がそのまま返されます。</p>
<p><a class="reference internal" href="stdtypes.html#typeiter"><span class="std std-ref">イテレータ型</span></a> も見てください。</p>
<p><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal"><span class="pre">iter()</span></code></a> の2つ目の形式の便利な使用法の一つは、ファイルの行を特定の行まで読み進めることです。以下の例では <a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> が空文字列を返すまでファイルを読み進めます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mydata.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">process_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="len">
<code class="descname">len</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#len" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの長さ (要素の数) を返します。引数はシーケンス (文字列、バイト列、タプル、リスト、range 等) かコレクション (辞書、集合、凍結集合等) です。</p>
</dd></dl>

<span class="target" id="func-list"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> は、実際には関数ではなくミュータブルなシーケンス型で、 <a class="reference internal" href="stdtypes.html#typesseq-list"><span class="std std-ref">リスト型 (list)</span></a> と <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">シーケンス型 &#8212; list, tuple, range</span></a> にドキュメント化されています。</p>
</dd></dl>

<dl class="function">
<dt id="locals">
<code class="descname">locals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#locals" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現在のローカルシンボルテーブルを表す辞書を更新して返します。関数ブロックで <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> を呼び出した場合自由変数が返されます、クラスブロックでは返されません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この辞書の内容は変更してはいけません; 変更しても、インタプリタが使うローカル変数や自由変数の値には影響しません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="map">
<code class="descname">map</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#map" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>function</em> を、結果を返しながら <em>iterable</em> の全ての要素に適用するイテレータを返します。追加の <em>iterable</em> 引数が渡されたなら、 <em>function</em> はその数だけの引数を取らなければならず、全てのイテラブルから並行して取られた要素に適用されます。複数のイテラブルが与えられたら、このイテレータはその中の最短のイテラブルが尽きた時点で止まります。関数の入力がすでに引数タプルに配置されている場合は、 <a class="reference internal" href="itertools.html#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal"><span class="pre">itertools.starmap()</span></code></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="max">
<code class="descname">max</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#max" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">max</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>iterable の中で最大の要素、または2つ以上の引数の中で最大のものを返します。</p>
<p>キーワード無しの引数が1つだけ与えられた場合、それはは空でない <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> でなくてはいけません。その iterable の最大の要素が返されます。2 つ以上のキーワード無しの引数が与えられた場合、その引数の中で最大のものが返されます。</p>
<p>任意のキーワード専用引数が 2 つあります。
<em>key</em> 引数は引数を 1 つ取る順序関数 (<a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> のもののように) を指定します。
<em>default</em> 引数は与えられたイテラブルが空の場合に返すオブジェクトを指定します。
イテラブルが空で <em>default</em> が与えれれていない場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<p>最大の要素が複数あるとき、この関数はそのうち最初に現れたものを返します。これは、<code class="docutils literal"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc,</span> <span class="pre">reverse=True)[0]</span></code> や <code class="docutils literal"><span class="pre">heapq.nlargest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> のような、他のソート安定性を維持するツールと両立します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加: </span><em>default</em> キーワード専用引数。</p>
</div>
</dd></dl>

<span class="target" id="func-memoryview"></span><dl class="function">
<dt>
<code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></dt>
<dd><p>与えられたオブジェクトから作られた &#8220;メモリビュー&#8221; オブジェクトを返します。詳しくは <a class="reference internal" href="stdtypes.html#typememoryview"><span class="std std-ref">メモリビュー</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="min">
<code class="descname">min</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#min" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">min</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>iterable の中で最小の要素、または2つ以上の引数の中で最小のものを返します。</p>
<p>キーワード無しの引数が1つだけ与えられた場合、それはは空でない <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> でなくてはいけません。その iterable の最小の要素が返されます。2 つ以上のキーワード無しの引数が与えられた場合、その引数の中で最小のものが返されます。</p>
<p>任意のキーワード専用引数が 2 つあります。
<em>key</em> 引数は引数を 1 つ取る順序関数 (<a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> のもののように) を指定します。
<em>default</em> 引数は与えられたイテラブルが空の場合に返すオブジェクトを指定します。
イテラブルが空で <em>default</em> が与えれれていない場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<p>最小の要素が複数あるとき、この関数はそのうち最初に現れたものを返します。これは、<code class="docutils literal"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc)[0]</span></code> や <code class="docutils literal"><span class="pre">heapq.nsmallest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> のような、他のソート安定性を維持するツールと両立します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加: </span><em>default</em> キーワード専用引数。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="next">
<code class="descname">next</code><span class="sig-paren">(</span><em>iterator</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#next" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterator</em> の <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドを呼び出すことにより、次の要素を取得します。イテレータが尽きている場合、 <em>default</em> が与えられていればそれが返され、そうでなければ <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="class">
<dt id="object">
<em class="property">class </em><code class="descname">object</code><a class="headerlink" href="#object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>特徴を持たない新しいオブジェクトを返します。 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> は全てのクラスの基底クラスです。これは、 Python のクラスの全てのインスタンスに共通のメソッド群を持ちます。この関数はいかなる引数も受け付けません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> は <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> を <em>持たない</em> ので、 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>  クラスのインスタンスに任意の属性を代入することはできません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="oct">
<code class="descname">oct</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#oct" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数を八進文字列に変換します。結果は Python の式としても使える形式になります。 <em>x</em>  が Python の <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> オブジェクトでない場合、整数値を返す <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> メソッドが定義されていなければなりません。</p>
<span class="target" id="index-5"></span></dd></dl>

<dl class="function">
<dt id="open">
<code class="descname">open</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em><span class="sig-paren">)</span><a class="headerlink" href="#open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>file</em> を開き、対応する <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">ファイルオブジェクト</span></a> を返します。ファイルを開くことができなければ、<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> が送出されます。</p>
<p><em>file</em> is a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> giving the pathname (absolute or
relative to the current working directory) of the file to be opened or an
integer file descriptor of the file to be wrapped.  (If a file descriptor is
given, it is closed when the returned I/O object is closed, unless <em>closefd</em>
is set to <code class="docutils literal"><span class="pre">False</span></code>.)</p>
<p><em>mode</em> はオプションの文字列で、ファイルが開かれるモードを指定します。デフォルトは <code class="docutils literal"><span class="pre">'r'</span></code> で、読み込み用にテキストモードで開くという意味です。その他のよく使われる値は、書き込み (ファイルがすでに存在する場合はそのファイルを切り詰めます) 用の <code class="docutils literal"><span class="pre">'w'</span></code>、排他的な生成用の <code class="docutils literal"><span class="pre">'x'</span></code>、追記用の <code class="docutils literal"><span class="pre">'a'</span></code> です (<em>いくつかの</em> Unix システムでは、<em>全て</em> の書き込みが現在のファイルシーク位置に関係なくファイルの末尾に追加されます)。テキストモードでは、<em>encoding</em> が指定されていない場合に使われるエンコーディングはプラットフォームに依存します:<code class="docutils literal"><span class="pre">locale.getpreferredencoding(False)</span></code> を使って現在のロケールエンコーディングを取得します。(rawバイト列の読み書きには、バイナリモードを使い、<em>encoding</em> は未指定のままとします) 指定可能なモードは次の表の通りです。</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">文字</p>
</th>
<th class="head"><p class="first last">意味</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td><p class="first last">読み込み用に開く (デフォルト)</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'w'</span></code></td>
<td><p class="first last">書き込み用に開き、まずファイルを切り詰める</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td><p class="first last">排他的な生成に開き、ファイルが存在する場合は失敗する</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'a'</span></code></td>
<td><p class="first last">書き込み用に開き、ファイルが存在する場合は末尾に追記する</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'b'</span></code></td>
<td><p class="first last">バイナリモード</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'t'</span></code></td>
<td><p class="first last">テキストモード (デフォルト)</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td><p class="first last">ディスクファイルを更新用に開く (読み込み／書き込み)</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'U'</span></code></td>
<td><p class="first last"><a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">ユニバーサル改行</span></a> モード (非推奨)</p>
</td>
</tr>
</tbody>
</table>
<p>デフォルトのモードは <code class="docutils literal"><span class="pre">'r'</span></code> (開いてテキストの読み込み、<code class="docutils literal"><span class="pre">'rt'</span></code> と同義) です。バイナリの読み書きアクセスについては、モード <code class="docutils literal"><span class="pre">'w+b'</span></code> はファイルを開いて 0 バイトに切り詰めます。<code class="docutils literal"><span class="pre">'r+b'</span></code> はファイルを切り詰めずに開きます。</p>
<p><a class="reference internal" href="io.html#io-overview"><span class="std std-ref">概要</span></a> で触れられているように、Python はバイナリとテキストの I/O を区別します。(<em>mode</em> 引数に <code class="docutils literal"><span class="pre">'b'</span></code> を含めて) バイナリモードで開かれたファイルは、内容をいかなるデコーディングもせずに <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>  オブジェクトとして返します。(デフォルトや、 <em>mode</em> 引数に <code class="docutils literal"><span class="pre">'t'</span></code> が含まれたときの) テキストモードでは、ファイルの内容は <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> として返され、バイト列はまず、プラットフォーム依存のエンコーディングか、<em>encoding</em> が指定された場合は指定されたエンコーディングを使ってデコードされます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python は、下層のオペレーティングシステムがテキストファイルをどう認識するかには依存しません; すべての処理は Python 自身で行われ、よってプラットフォーム非依存です。</p>
</div>
<p><em>buffering</em> はオプションの整数で、バッファリングの方針を設定するのに使われます。バッファリングを無効にする (バイナリモードでのみ有効) には 0、行単位バッファリング (テキストモードでのみ有効) には 1、固定値のチャンクバッファの大きさをバイト単位で指定するには 1 以上の整数を渡してください。<em>buffering</em> 引数が与えられていないとき、デフォルトのバッファリング方針は以下のように動作します:</p>
<ul class="simple">
<li><p class="first">バイナリファイルは固定サイズのチャンクでバッファリングされます。バッファサイズは、下層のデバイスの「ブロックサイズ」を決定するヒューリスティックを用いて選択され、それが不可能な場合は代わりに <a class="reference internal" href="io.html#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-attr docutils literal"><span class="pre">io.DEFAULT_BUFFER_SIZE</span></code></a> が使われます。多くのシステムでは、典型的なバッファサイズは 4096 か 8192 バイト長になるでしょう。</p>
</li>
<li><p class="first">「対話的な」テキストファイル (<a class="reference internal" href="io.html#io.IOBase.isatty" title="io.IOBase.isatty"><code class="xref py py-meth docutils literal"><span class="pre">isatty()</span></code></a> が <code class="docutils literal"><span class="pre">True</span></code> を返すファイル) は行バッファリングを使用します。 その他のテキストファイルは、上で説明したバイナリファイル用の方針を使用します。</p>
</li>
</ul>
<p><em>encoding</em> はファイルのエンコードやデコードに使われる <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> の名前です。このオプションはテキストモードでのみ使用してください。デフォルトエンコーディングはプラットフォーム依存 (<a class="reference internal" href="locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-func docutils literal"><span class="pre">locale.getpreferredencoding()</span></code></a> が返すもの) ですが、Pythonでサポートされているエンコーディングはどれでも使えます。詳しくは <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュール内のサポートしているエンコーディングのリストを参照してください。</p>
<p><em>errors</em> はオプションの文字列で、エンコードやデコードでのエラーをどのように扱うかを指定するものです。バイナリモードでは使用できません。様々な標準のエラーハンドラが使用可能です (<a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">エラーハンドラ</span></a> に列記されています) が、 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> に登録されているエラー処理の名前も使用可能です。標準のエラーハンドラの名前には、以下のようなものがあります:</p>
<ul class="simple">
<li><p class="first"><code class="docutils literal"><span class="pre">'strict'</span></code> はエンコーディングエラーがあると例外 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を発生させます。デフォルト値である <code class="docutils literal"><span class="pre">None</span></code> も同じ効果です。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'ignore'</span></code> はエラーを無視します。エンコーディングエラーを無視することで、データが失われる可能性があることに注意してください。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'replace'</span></code> は、不正な形式のデータが存在した場所に(<code class="docutils literal"><span class="pre">'?'</span></code> のような) 置換マーカーを挿入します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'surrogateescape'</span></code> は正しくないバイト列を、Unicode の Private Use Area (私用領域) にある U+DC80 から U+DCFF のコードポイントで示します。データを書き込む際に <code class="docutils literal"><span class="pre">surrogateescape</span></code> エラーハンドラが使われると、これらの私用コードポイントは元と同じバイト列に変換されます。これはエンコーディングが不明なファイルを処理するのに便利です。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code> はファイルへの書き込み時のみサポートされます。そのエンコーディングでサポートされない文字は、<code class="docutils literal"><span class="pre">&amp;#nnn;</span></code> 形式の適切な XML 文字参照で置換されます。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'backslashreplace'</span></code> は不正なデータを Python のバックスラッシュ付きのエスケープシーケンスで置換します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'namereplace'</span></code> (書き込み時のみサポートされています) はサポートされていない文字を <code class="docutils literal"><span class="pre">\N{...}</span></code> エスケープシーケンスで置換します。</p>
</li>
</ul>
<p id="index-6"><em>newline</em> は <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> モードの動作を制御します (テキストモードでのみ動作します)。<code class="docutils literal"><span class="pre">None</span></code>, <code class="docutils literal"><span class="pre">''</span></code>, <code class="docutils literal"><span class="pre">'\n'</span></code>, <code class="docutils literal"><span class="pre">'\r'</span></code>, <code class="docutils literal"><span class="pre">'\r\n'</span></code> のいずれかです。これは以下のように動作します:</p>
<ul class="simple">
<li><p class="first">ストリームからの入力の読み込み時、<em>newline</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合、ユニバーサル改行モードが有効になります。入力中の行は <code class="docutils literal"><span class="pre">'\n'</span></code>, <code class="docutils literal"><span class="pre">'\r'</span></code>, または <code class="docutils literal"><span class="pre">'\r\n'</span></code> で終わり、呼び出し元に返される前に <code class="docutils literal"><span class="pre">'\n'</span></code> に変換されます。 <code class="docutils literal"><span class="pre">''</span></code> の場合、ユニバーサル改行モードは有効になりますが、行末は変換されずに呼び出し元に返されます。その他の正当な値の場合、入力行は与えられた文字列でのみ終わり、行末は変換されずに呼び出し元に返されます。</p>
</li>
<li><p class="first">ストリームへの出力の書き込み時、<em>newline</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合、全ての <code class="docutils literal"><span class="pre">'\n'</span></code> 文字はシステムのデフォルトの行セパレータ <a class="reference internal" href="os.html#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal"><span class="pre">os.linesep</span></code></a> に変換されます。 <em>newline</em> が <code class="docutils literal"><span class="pre">''</span></code> または <code class="docutils literal"><span class="pre">'\n'</span></code> の場合は変換されません。<em>newline</em> がその他の正当な値の場合、全ての <code class="docutils literal"><span class="pre">'\n'</span></code> 文字は与えられた文字列に変換されます。</p>
</li>
</ul>
<p><em>closefd</em> が <code class="docutils literal"><span class="pre">False</span></code> で、ファイル名ではなくてファイル記述子が与えられた場合、下層のファイル記述子はファイルが閉じられた後も開いたままとなります。
ファイル名が与えられた場合、<em>closefd</em> は <code class="docutils literal"><span class="pre">True</span></code> (デフォルト値) でなければなりません。
そうでない場合エラーが送出されます。</p>
<p>呼び出し可能オブジェクトを <em>opener</em> として与えることで、カスタムのオープナーが使えます。そしてファイルオブジェクトの下層のファイル記述子は、<em>opener</em> を (<em>file</em>, <em>flags</em>) で呼び出して得られます。<em>opener</em> は開いたファイル記述子を返さなければなりません。 (<a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-mod docutils literal"><span class="pre">os.open</span></code></a> を <em>opener</em> として渡すと、<code class="docutils literal"><span class="pre">None</span></code> を渡したのと同様の機能になります)。</p>
<p>新たに作成されたファイルは <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">継承不可</span></a>  です。</p>
<p>次の例は <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a> 関数の <a class="reference internal" href="os.html#dir-fd"><span class="std std-ref">dir_fd</span></a> 引数を使い、与えられたディレクトリからの相対パスで指定されたファイルを開きます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dir_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">dir_fd</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;spamspam.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This will be written to somedir/spamspam.txt&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">dir_fd</span><span class="p">)</span>  <span class="c1"># don&#39;t leak a file descriptor</span>
</pre></div>
</div>
<p><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 関数が返す <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> の型はモードに依存します。 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> をファイルをテキストモード (<code class="docutils literal"><span class="pre">'w'</span></code>, <code class="docutils literal"><span class="pre">'r'</span></code>, <code class="docutils literal"><span class="pre">'wt'</span></code>, <code class="docutils literal"><span class="pre">'rt'</span></code>, など) で開くのに使ったときは <a class="reference internal" href="io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.TextIOBase</span></code></a> (特に <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal"><span class="pre">io.TextIOWrapper</span></code></a>) のサブクラスを返します。
ファイルをバッファリング付きのバイナリモードで開くのに使ったときは <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedIOBase</span></code></a> のサブクラスを返します。
実際のクラスは様々です。
読み込みバイナリモードでは <a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedReader</span></code></a> を返します。
書き込みバイナリモードや追記バイナリモードでは <a class="reference internal" href="io.html#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedWriter</span></code></a> を返します。
読み書きモードでは <a class="reference internal" href="io.html#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal"><span class="pre">io.BufferedRandom</span></code></a> を返します。
バッファリングが無効なときはrawストリーム、すなわち <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.RawIOBase</span></code></a> のサブクラスである <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">io.FileIO</span></code></a> を返します。</p>
<p id="index-7"><a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal"><span class="pre">fileinput</span></code></a> 、(<a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> が宣言された場所である) <a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> 、 <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 、 <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a> 、 <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a> 、 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a> などの、ファイル操作モジュールも参照してください。</p>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">バージョン 3.3 で変更: </span><ul class="simple">
<li>The <em>opener</em> parameter was added.</li>
<li>The <code class="docutils literal"><span class="pre">'x'</span></code> mode was added.</li>
<li><a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> used to be raised, it is now an alias of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>.</li>
<li><a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a> is now raised if the file opened in exclusive</li>
<li>creation mode (<code class="docutils literal"><span class="pre">'x'</span></code>) already exists.</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">バージョン 3.4 で変更: </span><ul class="simple">
<li><p class="first">ファイルが継承不可になりました。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="deprecated-removed">
<p>バージョン 3.4 で非推奨、バージョン 4.0 で削除予定: &#8216;U&#8217; モード。</p>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">バージョン 3.5 で変更: </span><ul class="simple">
<li><p class="first">システムコールが中断されシグナルハンドラが例外を送出しなかった場合、この関数は <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> 例外を送出する代わりにシステムコールを再試行するようになりました (論拠については <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> を参照してください)。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'namereplace'</span></code> エラーハンドラが追加されました。</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified">バージョン 3.6 で変更: </span><ul class="simple">
<li>Support added to accept objects implementing <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">os.PathLike</span></code></a>.</li>
<li>On Windows, opening a console buffer may return a subclass of
<a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.RawIOBase</span></code></a> other than <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal"><span class="pre">io.FileIO</span></code></a>.</li>
</ul>
</div></blockquote>
</div>
</dd></dl>

<dl class="function">
<dt id="ord">
<code class="descname">ord</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#ord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1 文字の Unicode 文字を表す文字列に対し、その文字の Unicode コードポイントを表す整数を返します。例えば、 <code class="docutils literal"><span class="pre">ord('a')</span></code> は整数 <code class="docutils literal"><span class="pre">97</span></code> を返し、 <code class="docutils literal"><span class="pre">ord('€')</span></code> (ユーロ記号) は <code class="docutils literal"><span class="pre">8364</span></code> を返します。これは <a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a> の逆です。</p>
</dd></dl>

<dl class="function">
<dt id="pow">
<code class="descname">pow</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の <em>y</em> 乗を返します; <em>z</em> があれば、<em>x</em> の <em>y</em> 乗に対する <em>z</em> の剰余を返します (<code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">z</span></code> より効率よく計算されます)。二引数の形式 <code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code> は、冪乗演算子を使った <code class="docutils literal"><span class="pre">x**y</span></code> と等価です。</p>
<p>引数は数値型でなくてはなりません。型混合の場合、二項算術演算における型強制規則が適用されます。 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 被演算子に対しては、第二引数が負でない限り、結果は (型強制後の) 被演算子と同じ型になります; 負の場合、全ての引数は浮動小数点に変換され、浮動小数点の結果が返されます。例えば、 <code class="docutils literal"><span class="pre">10**2</span></code> は <code class="docutils literal"><span class="pre">100</span></code> を返しますが、 <code class="docutils literal"><span class="pre">10**-2</span></code> は <code class="docutils literal"><span class="pre">0.01</span></code> を返します。第二引数が負の場合、第三引数は省略しなければなりません。 <em>z</em> がある場合、 <em>x</em> および <em>y</em> は整数型でなければならず、 <em>y</em> は非負でなくてはなりません。</p>
</dd></dl>

<dl class="function">
<dt id="print">
<code class="descname">print</code><span class="sig-paren">(</span><em>*objects</em>, <em>sep=' '</em>, <em>end='\n'</em>, <em>file=sys.stdout</em>, <em>flush=False</em><span class="sig-paren">)</span><a class="headerlink" href="#print" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>objects</em> (単数でも複数でも可) を <em>sep</em> で区切りながらテキストストリーム <em>file</em> に表示し、最後に <em>end</em> を表示します。<em>sep</em>、<em>end</em>、<em>file</em> を与える場合、キーワード引数として与える必要があります。</p>
<p>キーワードなしの引数はすべて、 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> がするように文字列に変換され、 <em>sep</em> で区切られながらストリームに書き出され、最後に <em>end</em> が続きます。 <em>sep</em> と <em>end</em> の両方とも、文字列でなければなりません。これらを <code class="docutils literal"><span class="pre">None</span></code> にすると、デフォルトの値が使われます。 <em>objects</em> が与えられなければ、 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> は <em>end</em> だけを書き出します。</p>
<p><em>file</em> 引数は、 <code class="docutils literal"><span class="pre">write(string)</span></code> メソッドを持つオブジェクトでなければなりません。指定されないか、 <code class="docutils literal"><span class="pre">None</span></code> である場合、 <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> が使われます。表示される引数は全てテキスト文字列に変換されますから、 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> はバイナリモードファイルオブジェクトには使用できません。代わりに <code class="docutils literal"><span class="pre">file.write(...)</span></code> を使ってください。</p>
<p>出力がバッファ化されるかどうかは通常 <em>file</em> で決まりますが、<em>flush</em> キーワード引数が真ならストリームは強制的にフラッシュされます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>キーワード引数 <em>flush</em> が追加されました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="property">
<em class="property">class </em><code class="descname">property</code><span class="sig-paren">(</span><em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#property" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>property 属性を返します。</p>
<p><em>fget</em> は属性値を取得するための関数です。<em>fset</em> は属性値を設定するための関数です。<em>fdel</em> は属性値を削除するための関数です。<em>doc</em> は属性の docstring を作成します。</p>
<p>典型的な使用法は、属性 <code class="docutils literal"><span class="pre">x</span></code> の処理の定義です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>c</em> が <em>C</em> のインスタンスならば、<code class="docutils literal"><span class="pre">c.x</span></code> は getter を呼び出し、<code class="docutils literal"><span class="pre">c.x</span> <span class="pre">=</span> <span class="pre">value</span></code> は setter を、<code class="docutils literal"><span class="pre">del</span> <span class="pre">c.x</span></code> は deleter を呼び出します。</p>
<p><em>doc</em> は、与えられれば property 属性のドキュメント文字列になります。与えられなければ、 property は <em>fget</em> のドキュメント文字列(もしあれば)をコピーします。そのため、 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a> をデコレータ (<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>) として使えば、読み取り専用 property を作るのは容易です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parrot</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&#64;property</span></code> デコレータは <code class="xref py py-meth docutils literal"><span class="pre">voltage()</span></code> を同じ名前のまま 読み取り専用属性の &#8220;getter&#8221; にし、<em>voltage</em> のドキュメント文字列を &#8220;Get the current voltage.&#8221; に設定します。</p>
<p>property オブジェクトは <code class="xref py py-attr docutils literal"><span class="pre">getter</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">setter</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">deleter</span></code> メソッドを持っています。これらのメソッドをデコレータとして使うと、対応するアクセサ関数がデコレートされた関数に設定された、 property のコピーを作成できます。これを一番分かりやすく説明する例があります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>このコードは最初の例と等価です。追加の関数には、必ず元の property と同じ名前 (この例では <code class="docutils literal"><span class="pre">x</span></code>) を与えて下さい。</p>
<p>返される property オブジェクトも、コンストラクタの引数に対応した <code class="docutils literal"><span class="pre">fget</span></code>, <code class="docutils literal"><span class="pre">fset</span></code>, および <code class="docutils literal"><span class="pre">fdel</span></code> 属性を持ちます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>属性オブジェクトのドックストリングが書き込み可能になりました。</p>
</div>
</dd></dl>

<span class="target" id="func-range"></span><dl class="function">
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span></dt>
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> は、実際には関数ではなくイミュータブルなシーケンス型で、 <a class="reference internal" href="stdtypes.html#typesseq-range"><span class="std std-ref">range</span></a> と <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">シーケンス型 &#8212; list, tuple, range</span></a> にドキュメント化されています。</p>
</dd></dl>

<dl class="function">
<dt id="repr">
<code class="descname">repr</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#repr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの印字可能な表現を含む文字列を返します。この関数は多くの型について、 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> に渡されたときと同じ値を持つようなオブジェクトを表す文字列を生成しようとします。そうでない場合は、山括弧に囲まれたオブジェクトの型の名前と追加の情報 (大抵の場合はオブジェクトの名前とアドレスを含みます) を返します。クラスは、 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> メソッドを定義することで、この関数によりそのクラスのインスタンスが返すものを制御することができます。</p>
</dd></dl>

<dl class="function">
<dt id="reversed">
<code class="descname">reversed</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="headerlink" href="#reversed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素を逆順に取り出すイテレータ (reverse <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>) を返します。 <em>seq</em> は <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a> メソッドを持つか、シーケンス型プロトコル (<a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> メソッド、および、 <code class="docutils literal"><span class="pre">0</span></code> 以上の整数を引数とする <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッド) をサポートするオブジェクトでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="round">
<code class="descname">round</code><span class="sig-paren">(</span><em>number</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#round" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>number</em> を小数点以下 <em>ndigits</em> 桁に丸めた浮動小数点数の値を返します。
<em>ndigits</em> が省略されたかもしくは <code class="docutils literal"><span class="pre">None</span></code> だった場合、入力に最近接の整数を返します。
<code class="docutils literal"><span class="pre">number.__round__(ndigits)</span></code> に処理を委譲します。</p>
<p><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a> をサポートする組み込み型では、値は 10 のマイナス <em>ndigits</em> 乗の倍数の中で最も近いものに丸められます; 二つの倍数が同じだけ近いなら、偶数を選ぶ方に (例えば <code class="docutils literal"><span class="pre">round(0.5)</span></code> と <code class="docutils literal"><span class="pre">round(-0.5)</span></code> は両方とも <code class="docutils literal"><span class="pre">0</span></code> に、 <code class="docutils literal"><span class="pre">round(1.5)</span></code> は <code class="docutils literal"><span class="pre">2</span></code> に) 丸められます。返り値は 1 引数で呼ばれたなら整数、そうでなければ <em>number</em> と同じ型です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">浮動小数点数に対する <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a> の振る舞いは意外なものかもしれません: 例えば、 <code class="docutils literal"><span class="pre">round(2.675,</span> <span class="pre">2)</span></code> は予想通りの <code class="docutils literal"><span class="pre">2.68</span></code> ではなく <code class="docutils literal"><span class="pre">2.67</span></code> を与えます。これはバグではありません: これはほとんどの小数が浮動小数点数で正確に表せないことの結果です。詳しくは <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">浮動小数点演算、その問題と制限</span></a> を参照してください。</p>
</div>
</dd></dl>

<span class="target" id="func-set"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>オプションで <em>iterable</em> の要素を持つ、新しい <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> オブジェクトを返します。 <code class="docutils literal"><span class="pre">set</span></code> は組み込みクラスです。このクラスについて詳しい情報は <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> や <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">set（集合）型 &#8212; set, frozenset</span></a> を参照してください。</p>
<p>他のコンテナについては <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールや組み込みの <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 、 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> 、 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 、 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> クラスを参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="setattr">
<code class="descname">setattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#setattr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> の相方です。引数はオブジェクト、文字列、それから任意の値です。文字列は既存の属性または新たな属性の名前にできます。この関数は指定したオブジェクトが許せば、値を属性に関連付けます。例えば、 <code class="docutils literal"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></code> は <code class="docutils literal"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code> と等価です。</p>
</dd></dl>

<dl class="class">
<dt id="slice">
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#slice" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p id="index-9"><code class="docutils literal"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> で指定されるインデクスの集合を表す、スライス (<a class="reference internal" href="../glossary.html#term-slice"><span class="xref std std-term">slice</span></a>) オブジェクトを返します。引数 <em>start</em> および <em>step</em> はデフォルトでは <code class="docutils literal"><span class="pre">None</span></code> です。スライスオブジェクトは読み出し専用の属性 <code class="xref py py-attr docutils literal"><span class="pre">start</span></code>、<code class="xref py py-attr docutils literal"><span class="pre">stop</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">step</span></code> を持ち、これらは単に引数で使われた 値 (またはデフォルト値) を返します。これらの値には、その他のはっきりと した機能はありません。しかしながら、これらの値は Numerical Python および、その他のサードパーティによる拡張で利用されています。スライスオブジェクトは拡張されたインデクス指定構文が使われる際にも生成されます。例えば <code class="docutils literal"><span class="pre">a[start:stop:step]</span></code> や <code class="docutils literal"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></code> です。この関数の代替となるイテレータを返す関数、<a class="reference internal" href="itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal"><span class="pre">itertools.islice()</span></code></a> も参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="sorted">
<code class="descname">sorted</code><span class="sig-paren">(</span><em>iterable[, key][, reverse]</em><span class="sig-paren">)</span><a class="headerlink" href="#sorted" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素を並べ替えた新たなリストを返します。</p>
<p>2 つのオプション引数があり、これらはキーワード引数として指定されなければなりません。</p>
<p><em>key</em> は 1 つの引数からなる関数を指定します。これはリストの各要素から比較のキーを取り出すのに使われます: <code class="docutils literal"><span class="pre">key=str.lower</span></code> 。デフォルト値は <code class="docutils literal"><span class="pre">None</span></code> です (要素を直接比較します)。</p>
<p><em>reverse</em> は真偽値です。 <code class="docutils literal"><span class="pre">True</span></code> がセットされた場合、リストの要素は個々の比較が反転したものとして並び替えられます。</p>
<p>旧式の <em>cmp</em> 関数を <em>key</em> 関数に変換するには <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></code></a> を使用してください。</p>
<p>組み込みの <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> 関数は安定なことが保証されています。同等な要素の相対順序を変更しないことが保証されていれば、ソートは安定です。これは複数のパスでソートを行なうのに役立ちます（例えば部署でソートしてから給与の等級でソートする場合）。</p>
<p>ソートの例と簡単なチュートリアルは <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">ソート HOW TO</span></a> を参照して下さい。</p>
</dd></dl>

<dl class="function">
<dt id="staticmethod">
<code class="descname">staticmethod</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#staticmethod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>function</em> の静的メソッドを返します。</p>
<p>静的メソッドは暗黙の第一引数を受け取りません。静的メソッドを宣言するには、このイディオムを使ってください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&#64;staticmethod</span></code> は関数デコレータ (<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>) 形式です。詳しくは <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> の関数定義の説明を参照してください。</p>
<p>このメソッドはクラスで呼び出すこと (例えば <code class="docutils literal"><span class="pre">C.f()</span></code> ) も、インスタンスとして呼び出すこと (例えば <code class="docutils literal"><span class="pre">C().f()</span></code>) もできます。インスタンスはそのクラスが何であるかを除いて無視されます。</p>
<p>Python における静的メソッドは Java や C++ における静的メソッドと類似しています。クラスコンストラクタの代替を生成するのに役立つ変種、 <a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> も参照してください。</p>
<p>静的メソッドについて詳しくは、 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> の標準型階層についてのドキュメントを繙いてください。</p>
</dd></dl>

<span class="target" id="func-str"><span id="index-10"></span></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p><em>object</em> の <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 版を返します。詳細は <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を参照してください。</p>
<p><code class="docutils literal"><span class="pre">str</span></code> は組み込みの文字列 <a class="reference internal" href="../glossary.html#term-class"><span class="xref std std-term">クラス</span></a> です。文字列に関する一般的な情報は、<a class="reference internal" href="stdtypes.html#textseq"><span class="std std-ref">テキストシーケンス型 &#8212; str</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>start</em> と <em>iterable</em> の要素を左から右へ合計し、総和を返します。 <em>start</em> はデフォルトで <code class="docutils literal"><span class="pre">0</span></code> です。 <em>iterable</em> の要素は通常は数値で、start の値は文字列であってはなりません。</p>
<p>使う場面によっては、 <a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a> よりもいい選択肢があります。文字列からなるシーケンスを結合する高速かつ望ましい方法は <code class="docutils literal"><span class="pre">''.join(sequence)</span></code> を呼ぶことです。浮動小数点数値を拡張された精度で加算するには、 <a class="reference internal" href="math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal"><span class="pre">math.fsum()</span></code></a> を参照してください。一連のイテラブルを連結するには、 <a class="reference internal" href="itertools.html#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal"><span class="pre">itertools.chain()</span></code></a> の使用を考えてください。</p>
</dd></dl>

<dl class="function">
<dt id="super">
<code class="descname">super</code><span class="sig-paren">(</span><span class="optional">[</span><em>type</em><span class="optional">[</span>, <em>object-or-type</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#super" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メソッドの呼び出しを <em>type</em> の親または兄弟クラスに委譲するプロキシオブジェクトを返します。これはクラスの中でオーバーライドされた継承メソッドにアクセスするのに便利です。探索の順序は、 <em>type</em> 自身が飛ばされるのをのぞいて <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> で使われるのと同じです。</p>
<p><em>type</em> の <a class="reference internal" href="stdtypes.html#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal"><span class="pre">__mro__</span></code></a> 属性は、 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> と <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> の 両方で使われる、メソッド解決の探索順序を列記します。 この属性は動的で、継承の階層構造が更新されれば、随時変化します。</p>
<p>第 2 引数が省かれたなら、返されるスーパーオブジェクトは束縛されません。第 2 引数がオブジェクトであれば、 <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> は真でなければなりません。第 2 引数が型であれば、 <code class="docutils literal"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></code> は真でなければなりません (これはクラスメソッドに役に立つでしょう)。</p>
<p><em>super</em> の典型的な用途は 2 つあります。第一に、単継承のクラス階層構造で <em>super</em> は名前を明示することなく親クラスを参照するのに使え、それゆえコードをメンテナンスしやすくなります。この用途は他のプログラミング言語で見られる <em>super</em> の用途によく似ています。</p>
<p>2 つ目の用途は、動的な実行環境下で協調的な多重継承をサポートすることです。この用途は Python に特有で、静的にコンパイルされる言語や、単継承のみをサポートする言語では見られないものです。この機能により、複数の基底クラスが同じメソッドを実装する &#8220;diamond diagram&#8221; を実装できます。このメソッドをあらゆる場合に同じ形式で呼び出せるようにするのが、良い設計です (理由は、呼び出しの順序が実行時に決定されること、呼び出しの順序がクラス階層の変更に対応すること、呼び出しの順序に実行時まで未知の兄弟クラスが含まれる場合があることです)。</p>
<p>両方の用途において、典型的なスーパークラスの呼び出しは次のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>    <span class="c1"># This does the same thing as:</span>
                               <span class="c1"># super(C, self).method(arg)</span>
</pre></div>
</div>
<p>なお、<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> は <code class="docutils literal"><span class="pre">super().__getitem__(name)</span></code> のような明示的なドット表記属性探索の束縛処理の一部として実装されています。これは、 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> メソッドを予測可能な順序でクラスを検索するように実装し、協調的な多重継承をサポートすることで実現されています。従って、 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> は文や <code class="docutils literal"><span class="pre">super()[name]</span></code> のような演算子を使った暗黙の探索向けには定義されていません。</p>
<p>また、 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> の使用は引数無しの形式を除きメソッド内部に限定されないことにも注目して下さい。2引数の形式は、必要な要素を正確に指定するので、適当な参照を作ることができます。クラス定義中における引数無しの形式は、定義されているクラスを取り出すのに必要な詳細を、通常の方法で現在のインスタンスにアクセスするようにコンパイラが埋めるのではたらきます。</p>
<p><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> を用いて協調的なクラスを設計する方法の実践的な提案は、 <a class="reference external" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">guide to using super()</a> を参照してください。</p>
</dd></dl>

<span class="target" id="func-tuple"></span><dl class="function">
<dt>
<code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> は、実際は関数ではなくイミュータブルなシーケンス型で、<a class="reference internal" href="stdtypes.html#typesseq-tuple"><span class="std std-ref">タプル型 (tuple)</span></a> と <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">シーケンス型 &#8212; list, tuple, range</span></a> にドキュメント化されています。</p>
</dd></dl>

<dl class="class">
<dt id="type">
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>name</em>, <em>bases</em>, <em>dict</em><span class="sig-paren">)</span></dt>
<dd><p id="index-11">引数が1つだけの場合、<em>object</em> の型を返します。返り値は型オブジェクトで、一般に <a class="reference internal" href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal"><span class="pre">object.__class__</span></code></a> によって返されるのと同じオブジェクトです。</p>
<p>オブジェクトの型の判定には、 <a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> 組み込み関数を使うことが推奨されます。これはサブクラスを考慮するからです。</p>
<p>引数が 3 つの場合、新しい型オブジェクトを返します。本質的には <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 文の動的な形式です。 <em>name</em> 文字列はクラス名で、 <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> 属性になります。 <em>bases</em> タプルは基底クラスの羅列で、 <a class="reference internal" href="stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal"><span class="pre">__bases__</span></code></a> 属性になります。 <em>dict</em> 辞書はクラス本体の定義を含む名前空間で、標準の辞書にコピーされて <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性になります。たとえば、以下の二つの文は同じ <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal"><span class="pre">type</span></code></a> オブジェクトを作ります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#bltin-type-objects"><span class="std std-ref">型オブジェクト</span></a> も参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Subclasses of <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal"><span class="pre">type</span></code></a> which don&#8217;t override <code class="docutils literal"><span class="pre">type.__new__</span></code> may no
longer use the one-argument form to get the type of an object.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="vars">
<code class="descname">vars</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#vars" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュール、クラス、インスタンス、あるいはそれ以外の <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性を持つオブジェクトの、 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性を返します。</p>
<p>モジュールやインスタンスのようなオブジェクトは、更新可能な <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性を持っています。ただし、それ以外のオブジェクトでは <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性への書き込みが制限されている場合があります。書き込みに制限がある例としては、辞書を直接更新されることを防ぐために <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal"><span class="pre">types.MappingProxyType</span></code></a> を使っているクラスがあります。</p>
<p>引数がなければ、<a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal"><span class="pre">vars()</span></code></a> は <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> のように振る舞います。ただし、辞書 locals への更新は無視されるため、辞書 locals は読み出し時のみ有用であることに注意してください。</p>
</dd></dl>

<dl class="function">
<dt id="zip">
<code class="descname">zip</code><span class="sig-paren">(</span><em>*iterables</em><span class="sig-paren">)</span><a class="headerlink" href="#zip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それぞれのイテラブルから要素を集めたイテレータを作ります。</p>
<p>この関数はタプルのイテレータを返し、その <em>i</em> 番目のタプルは引数シーケンスまたはイテラブルそれぞれの <em>i</em> 番目の要素を含みます。このイテレータは、入力イテラブルの中で最短のものが尽きたときに止まります。単一のイテラブル引数が与えられたときは、1 要素のタプルからなるイテレータを返します。引数がなければ、空のイテレータを返します。次と等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c1"># zip(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax By</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">iterators</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterators</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>イテラブルの左から右への評価順序は保証されています。そのため <code class="docutils literal"><span class="pre">zip(*[iter(s)]*n)</span></code> を使ってデータ系列を長さ n のグループにクラスタリングするイディオムが使えます。これは、各出力タプルがイテレータを <code class="docutils literal"><span class="pre">n</span></code> 回呼び出した結果となるよう、 <em>同じ</em> イテレータを <code class="docutils literal"><span class="pre">n</span></code> 回繰り返します。これは入力を長さ n のチャンクに分割する効果があります。</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> は、長い方のイテラブルの終端にある対にならない値を考慮したい場合は、等しくない長さの入力に対して使うべきではありません。そのような値が重要な場合、代わりに <a class="reference internal" href="itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal"><span class="pre">itertools.zip_longest()</span></code></a> を使ってください。</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> に続けて <code class="docutils literal"><span class="pre">*</span></code> 演算子を使うと、zip したリストを元に戻せます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zipped</span><span class="p">)</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="__import__">
<code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#__import__" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="admonition note" id="index-12">
<p class="first admonition-title">注釈</p>
<p class="last">これは <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> とは違い、日常の Python プログラミングでは必要ない高等な関数です。</p>
</div>
<p>この関数は <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文により呼び出されます。 (<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> モジュールをインポートして <code class="docutils literal"><span class="pre">builtins.__import__</span></code> に代入することで) この関数を置き換えて <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文のセマンティクスを変更することができますが、同様のことをするのに通常はインポートフック (<span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 参照) を利用する方が簡単で、かつデフォルトのインポート実装が使用されていることを仮定するコードとの間で問題が起きないので、このやり方は <em>強く</em> 推奨されません。 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> を直接使用することも推奨されず、 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> の方が好まれます。</p>
<p>この関数は、モジュール <em>name</em> をインポートし、 <em>globals</em> と <em>locals</em> が与えられれば、パッケージのコンテキストで名前をどう解釈するか決定するのに使います。 <em>fromlist</em> は <em>name</em> で与えられるモジュールからインポートされるべきオブジェクトまたはサブモジュールの名前を与ます。標準の実装では <em>locals</em> 引数はまったく使われず、 <em>globals</em> は <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文のパッケージコンテキストを決定するためにのみ使われます。</p>
<p><em>level</em> は絶対と相対どちらのインポートを使うかを指定します。 <code class="docutils literal"><span class="pre">0</span></code> (デフォルト) は絶対インポートのみ実行します。正の <em>level</em> の値は、 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> を呼び出したディレクトリから検索対象となる親ディレクトリの数を示します (詳細は <span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> を参照してください)。</p>
<p><em>name</em> 変数が <code class="docutils literal"><span class="pre">package.module</span></code> 形式であるとき、通常は、<em>name</em> で指名されたモジュール <em>ではなく</em>、最上位のパッケージ (最初のドットまでの名前) が返されます。しかしながら、空でない <em>fromlist</em> 引数が与えられると、 <em>name</em> で指名されたモジュールが返されます。</p>
<p>例えば、文 <code class="docutils literal"><span class="pre">import</span> <span class="pre">spam</span></code> は、以下のコードのようなバイトコードに帰結します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>文 <code class="docutils literal"><span class="pre">import</span> <span class="pre">spam.ham</span></code> は、この呼び出しになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> がどのように最上位モジュールを返しているかに注意して下さい。 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文により名前が束縛されたオブジェクトになっています。</p>
<p>一方で、文 <code class="docutils literal"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></code> は、以下となります</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</pre></div>
</div>
<p>ここで、<a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> から <code class="docutils literal"><span class="pre">spam.ham</span></code> モジュールが返されます。このオブジェクトから、インポートされる名前が取り出され、それぞれの名前として代入されます。</p>
<p>単純に名前からモジュール (パッケージの範囲内であるかも知れません) をインポートしたいなら、 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> を使ってください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>負の <em>level</em> の値はサポートされなくなりました (デフォルト値の 0 に変更されます)。</p>
</div>
</dd></dl>

<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first last">なお、パーサは Unix スタイルの行末の記法しか受け付けません。コードをファイルから読んでいるなら、必ず、改行変換モードで Windows や Mac スタイルの改行を変換してください。</p>
</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>前のトピックへ</h4>
  <p class="topless"><a href="intro.html"
                        title="前の章へ">1. はじめに</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="constants.html"
                        title="次の章へ">3. 組み込み定数</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/functions.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 組み込み定数"
             >次へ</a> |</li>
        <li class="right" >
          <a href="intro.html" title="1. はじめに"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.0</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 3月 21, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>