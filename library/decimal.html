
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>9.4. decimal — 十進固定及び浮動小数点数の算術演算 &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="9.5. fractions — 有理数" href="fractions.html" />
    <link rel="prev" title="9.3. cmath — 複素数のための数学関数" href="cmath.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/decimal.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/decimal.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="9.5. fractions — 有理数"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="9.3. cmath — 複素数のための数学関数"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" accesskey="U">9. 数値と数学モジュール</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-decimal">
<span id="decimal-decimal-fixed-point-and-floating-point-arithmetic"></span><h1>9.4. <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> — 十進固定及び浮動小数点数の算術演算<a class="headerlink" href="#module-decimal" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/decimal.py">Lib/decimal.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールは正確に丸められた十進浮動小数点算術をサポートします。 <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> には、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> データ型に比べて、以下のような利点があります:</p>
<ul>
<li><p class="first">「(Decimal は) 人々を念頭にデザインされた浮動小数点モデルを元にしており、必然的に最も重要な指針があります – コンピュータは人々が学校で習った算術と同じように動作する算術を提供しなければならない」 – 十進数演算仕様より。</p>
</li>
<li><p class="first">十進数を正確に表現できます。 <code class="xref py py-const docutils literal"><span class="pre">1.1</span></code> や <code class="xref py py-const docutils literal"><span class="pre">2.2</span></code> のような数は、二進数の浮動小数点型では正しく表現できません。エンドユーザは普通、 二進数における <code class="docutils literal"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> の近似値が <code class="xref py py-const docutils literal"><span class="pre">3.3000000000000003</span></code> だからといって、そのように表示してほしいとは考えないものです。</p>
</li>
<li><p class="first">値の正確さは算術にも及びます。十進の浮動小数点による計算では、 <code class="docutils literal"><span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">-</span> <span class="pre">0.3</span></code> は厳密にゼロに等しくなります。 二進浮動小数点では <code class="xref py py-const docutils literal"><span class="pre">5.5511151231257827e-017</span></code> になってしまいます。ゼロに近い値とはいえ、この誤差は数値間の等価性テストの信頼性を阻害します。また、誤差が蓄積されることもあります。こうした理由から、数値間の等価性を厳しく保たなければならないようなアプリケーションを考えるなら、十進数による数値表現が望ましいということになります。</p>
</li>
<li><p class="first"><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールでは、有効桁数の表記が取り入れられており、例えば <code class="docutils literal"><span class="pre">1.30</span> <span class="pre">+</span> <span class="pre">1.20</span></code> は <code class="xref py py-const docutils literal"><span class="pre">2.50</span></code> になります。すなわち、末尾のゼロは有効数字を示すために残されます。こうした仕様は通貨計算を行うアプリケーションでは慣例です。乗算の場合、「教科書的な」アプローチでは、乗算の被演算子すべての桁数を使います。例えば、 <code class="docutils literal"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> は <code class="xref py py-const docutils literal"><span class="pre">1.56</span></code> になり、 <code class="docutils literal"><span class="pre">1.30</span> <span class="pre">*</span> <span class="pre">1.20</span></code> は <code class="xref py py-const docutils literal"><span class="pre">1.5600</span></code> になります。</p>
</li>
<li><p class="first">ハードウェアによる 2 進浮動小数点表現と違い、<a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールでは計算精度をユーザが変更できます(デフォルトでは 28 桁です)。この桁数はほとんどの問題解決に十分な大きさです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1428571428571428571428571429&#39;)</span>
</pre></div>
</div>
</li>
<li><p class="first">二進と十進の浮動小数点は、いずれも広く公開されている標準仕様のもとに実装されています。組み込みの浮動小数点型では、標準仕様で提唱されている機能のほんのささやかな部分を利用できるにすぎませんが、<a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> では標準仕様が要求している全ての機能を利用できます。必要に応じて、プログラマは値の丸めやシグナル処理を完全に制御できます。この中には全ての不正確な操作を例外でブロックして正確な算術を遵守させるオプションもあります。</p>
</li>
<li><p class="first">decimal モジュールは「偏見なく、正確な丸めなしの十進算術(固定小数点算術と呼ばれることもある)と丸めありの浮動小数点数算術」(十進数演算仕様より引用)をサポートするようにデザインされました。</p>
</li>
</ul>
<p>このモジュールは、十進数型、算術コンテキスト (context for arithmetic)、そしてシグナル (signal) という三つの概念を中心に設計されています。</p>
<p>十進数型は変更不能です。これは符号、係数部、そして指数を持ちます。有効桁数を残すために、仮数部の末尾にあるゼロは切り詰められません。 <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> では、 <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>, <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>, および <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> といった特殊な値も定義されています。標準仕様では <code class="xref py py-const docutils literal"><span class="pre">-0</span></code> と <code class="xref py py-const docutils literal"><span class="pre">+0</span></code> も区別します。</p>
<p>算術コンテキストとは、精度や値丸めの規則、指数部の制限を決めている環境です。この環境では、演算結果を表すためのフラグや、演算上発生した特定のシグナルを例外として扱うかどうかを決めるトラップイネーブラも定義しています。丸め規則には <a class="reference internal" href="#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal"><span class="pre">ROUND_CEILING</span></code></a>, <a class="reference internal" href="#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal"><span class="pre">ROUND_FLOOR</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_UP</span></code></a>, <a class="reference internal" href="#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_UP</span></code></a>, および <a class="reference internal" href="#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_05UP</span></code></a> があります。</p>
<p>シグナルとは、演算の過程で生じる例外的条件です。個々のシグナルは、アプリケーションそれぞれの要求に従って、無視されたり、単なる情報とみなされたり、例外として扱われたりします。 <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールには、 <a class="reference internal" href="#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal"><span class="pre">Clamped</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal"><span class="pre">DivisionByZero</span></code></a>, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal"><span class="pre">Subnormal</span></code></a>, <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal"><span class="pre">Underflow</span></code></a>, および <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal"><span class="pre">FloatOperation</span></code></a> といったシグナルがあります。</p>
<p>各シグナルには、フラグとトラップイネーブラがあります。演算上何らかのシグナルに遭遇すると、フラグは 1 にセットされます。このとき、もしトラップイネーブラが 1 にセットされていれば、例外を送出します。フラグの値は膠着型 (sticky) なので、演算によるフラグの変化をモニタしたければ、予めフラグをリセットしておかなければなりません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<ul class="last simple">
<li>IBM による汎用十進演算仕様、<a class="reference external" href="http://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic Specification</a>。</li>
</ul>
</div>
<div class="section" id="quick-start-tutorial">
<span id="decimal-tutorial"></span><h2>9.4.1. クイックスタートチュートリアル<a class="headerlink" href="#quick-start-tutorial" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>普通、 <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> を使うときには、モジュールをインポートし、現在の演算コンテキストを <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> で調べ、必要なら、精度、丸め、有効なトラップを設定します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># Set a new precision</span>
</pre></div>
</div>
<p><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスは、整数、文字列、浮動小数点数、またはタプルから構成できます。整数や浮動小数点数からの構成は、整数や浮動小数点数の値を正確に変換します。 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> は &quot;非数 (Not a Number)&quot; を表す <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> や正負の <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> (無限大)、 <code class="xref py py-const docutils literal"><span class="pre">-0</span></code> といった特殊な値も表現できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.4142135623730951&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> シグナルがトラップされる場合、コンストラクタや順序比較において誤って decimal と float が混ざると、例外が送出されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<p>新たな <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> の有効桁数は入力の桁数だけで決まります。演算コンテキストにおける精度や値丸めの設定が影響するのは算術演算の間だけです。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.0&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85987&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85988&#39;)</span>
</pre></div>
</div>
<p>C バージョンの内部制限を超えた場合、decimal の構成は <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal"><span class="pre">InvalidOperation</span></code></a> を送出します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1e9999999999999999999&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更.</span></p>
</div>
<p>decimal はほとんどの場面で Python の他の機能とうまくやりとりできます。decimal 浮動小数点の空飛ぶサーカス (flying circus) をお見せしましょう:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),</span>
<span class="go"> Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;19.29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1.34&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal(&#39;6.70&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal(&#39;2.5058&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal(&#39;0.77&#39;)</span>
</pre></div>
</div>
<p>いくつかの数学的関数も Decimal には用意されています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.302585092994045684017991455&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&#39;1&#39;)</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> メソッドは位を固定して数値を丸めます。このメソッドは、結果を固定の桁数で丸めることがよくある、金融アプリケーションで便利です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal(&#39;7.32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal(&#39;8&#39;)</span>
</pre></div>
</div>
<p>前述のように、 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> 関数を使うと現在の演算コンテキストにアクセスでき、設定を変更できます。ほとんどのアプリケーションはこのアプローチで十分です。</p>
<p>より高度な作業を行う場合、 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-func docutils literal"><span class="pre">Context()</span></code></a> コンストラクタを使って別の演算コンテキストを作っておくと便利なことがあります。別の演算コンテキストをアクティブにしたければ、 <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> を使います。</p>
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールでは、標準仕様に従って、すぐ利用できる二つの標準コンテキスト、 <a class="reference internal" href="#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal"><span class="pre">BasicContext</span></code></a> および <a class="reference internal" href="#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal"><span class="pre">ExtendedContext</span></code></a> を提供しています。前者はほとんどのトラップが有効になっており、とりわけデバッグの際に便利です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857143&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#143&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>演算コンテキストには、演算中に遭遇した例外的状況をモニタするためのシグナルフラグがあります。フラグが一度セットされると、明示的にクリアするまで残り続けます。そのため、フラグのモニタを行いたいような演算の前には <code class="xref py py-meth docutils literal"><span class="pre">clear_flags()</span></code> メソッドでフラグをクリアしておくのがベストです。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14159292&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div>
</div>
<p><em>flags</em> エントリから、 <code class="xref py py-const docutils literal"><span class="pre">Pi</span></code> の有理数による近似値が丸められた (コンテキスト内で決められた精度を超えた桁数が捨てられた) ことと、計算結果が厳密でない (無視された桁の値に非ゼロのものがあった) ことがわかります。</p>
<p>コンテキストの <code class="xref py py-attr docutils literal"><span class="pre">traps</span></code> フィールドに入っている辞書を使うと、個々のトラップをセットできます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#112&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>ほとんどのプログラムでは、開始時に一度だけ現在の演算コンテキストを修正します。また、多くのアプリケーションでは、データから <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> への変換はループ内で一度だけキャストして行います。コンテキストを設定し、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> オブジェクトを生成できたら、ほとんどのプログラムは他の Python 数値型と全く変わらないかのように <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> を操作できます。</p>
</div>
<div class="section" id="decimal-objects">
<span id="decimal-decimal"></span><h2>9.4.2. Decimal オブジェクト<a class="headerlink" href="#decimal-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="decimal.Decimal">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Decimal</code><span class="sig-paren">(</span><em>value=&quot;0&quot;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>value</em> に基づいて新たな <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> オブジェクトを構築します。</p>
<p><em>value</em> は整数、文字列、タプル、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> および他の <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> オブジェクトにできます。 <em>value</em> を指定しない場合、 <code class="docutils literal"><span class="pre">Decimal('0')</span></code> を返します。 <em>value</em> が文字列の場合、先頭と末尾の空白および全てのアンダースコアを取り除いた後には以下の 10進数文字列の文法に従わなければなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;-&#39;</span>
<span class="n">digit</span>          <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;0&#39;</span> <span class="o">|</span> <span class="s1">&#39;1&#39;</span> <span class="o">|</span> <span class="s1">&#39;2&#39;</span> <span class="o">|</span> <span class="s1">&#39;3&#39;</span> <span class="o">|</span> <span class="s1">&#39;4&#39;</span> <span class="o">|</span> <span class="s1">&#39;5&#39;</span> <span class="o">|</span> <span class="s1">&#39;6&#39;</span> <span class="o">|</span> <span class="s1">&#39;7&#39;</span> <span class="o">|</span> <span class="s1">&#39;8&#39;</span> <span class="o">|</span> <span class="s1">&#39;9&#39;</span>
<span class="n">indicator</span>      <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;e&#39;</span> <span class="o">|</span> <span class="s1">&#39;E&#39;</span>
<span class="n">digits</span>         <span class="p">::</span><span class="o">=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">::</span><span class="o">=</span>  <span class="n">digits</span> <span class="s1">&#39;.&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;Infinity&#39;</span> <span class="o">|</span> <span class="s1">&#39;Inf&#39;</span>
<span class="n">nan</span>            <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;NaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">&#39;sNaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">::</span><span class="o">=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div>
</div>
<p>他の Unicode 数字も上の <code class="docutils literal"><span class="pre">digit</span></code> の場所に使うことができます。つまり各書記体系における(アラビア-インド系やデーヴァナーガリーなど)の数字や、全角数字０(<code class="docutils literal"><span class="pre">'\uff10'</span></code>)から９(<code class="docutils literal"><span class="pre">'\uff19'</span></code>)までなどです。</p>
<p><em>value</em> を <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> にする場合、タプルは三つの要素を持ち、それぞれ符号 (正なら <code class="xref py py-const docutils literal"><span class="pre">0</span></code> 、負なら <code class="xref py py-const docutils literal"><span class="pre">1</span></code>)、仮数部を表す数字の <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 、そして指数を表す整数でなければなりません。例えば、 <code class="docutils literal"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code> は <code class="docutils literal"><span class="pre">Decimal('1.414')</span></code> を返します。</p>
<p><em>value</em> を <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> にする場合、二進浮動小数点数値が損失なく正確に等価な Decimal に変換されます。この変換はしばしば 53 桁以上の精度を要求します。例えば、 <code class="docutils literal"><span class="pre">Decimal(float('1.1'))</span></code> は <code class="docutils literal"><span class="pre">Decimal('1.100000000000000088817841970012523233890533447265625')</span></code> に変換されます。</p>
<p><em>context</em> の精度 (precision) は、記憶される桁数には影響しません。桁数は <em>value</em> に指定した桁数だけから決定されます。例えば、演算コンテキストに指定された精度が 3 桁しかなくても、<code class="docutils literal"><span class="pre">Decimal('3.00000')</span></code> は 5 つのゼロを全て記憶します。</p>
<p><em>context</em> 引数の目的は、 <em>value</em> が正しくない形式の文字列であった場合に行う処理を決めることにあります; 演算コンテキストが <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a> をトラップするようになっていれば、例外を送出します。それ以外の場合には、コンストラクタは値が <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> の <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> を返します。</p>
<p>一度生成すると、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> オブジェクトは変更不能 (immutable) になります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>コンストラクタに対する引数に <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> インスタンスも許されるようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> トラップがセットされていた場合 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 引数は例外を送出します。デフォルトでトラップはオフです。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>コード中の整数リテラルや浮動小数点リテラルと同様に、アンダースコアを用いて桁をグルーピングできます。</p>
</div>
<p>十進浮動小数点オブジェクトは、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> や <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> のような他の組み込み型と多くの点で似ています。通常の数学演算や特殊メソッドを適用できます。また、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> オブジェクトはコピーでき、pickle 化でき、print で出力でき、辞書のキーにでき、集合の要素にでき、比較、保存、他の型 (<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> や <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) への型強制を行えます。</p>
<p>十進オブジェクトの算術演算と整数や浮動小数点数の算術演算には少々違いがあります。十進オブジェクトに対して剰余演算を適用すると、計算結果の符号は除数の符号ではなく <em>被除数</em> の符号と一致します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-3&#39;)</span>
</pre></div>
</div>
<p>整数除算演算子 <code class="docutils literal"><span class="pre">//</span></code> も同様に、実際の商の切り捨てではなく (0に近付くように丸めた) 整数部分を返します。そうすることで通常の恒等式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> が保持されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>演算子 <code class="docutils literal"><span class="pre">%</span></code> と演算子 <code class="docutils literal"><span class="pre">//</span></code> は (それぞれ) 仕様にあるような <code class="docutils literal"><span class="pre">剰余</span></code> 操作と <code class="docutils literal"><span class="pre">整数除算</span></code> 操作を実装しています。</p>
<p>Decimal オブジェクトは一般に、算術演算で浮動小数点数や <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> オブジェクトと組み合わせることができません。例えば、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> に <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> を足そうとすると、 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。ただし、Python の比較演算子を使って <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンス <code class="docutils literal"><span class="pre">x</span></code> と別の数 <code class="docutils literal"><span class="pre">y</span></code> を比較することができます。これにより、異なる型の数間の等価比較の際に、紛らわしい結果を避けます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスと他の数値型が混在する比較が完全にサポートされるようになりました。</p>
</div>
<p>こうした標準的な数値型の特性の他に、十進浮動小数点オブジェクトには様々な特殊メソッドがあります:</p>
<dl class="method">
<dt id="decimal.Decimal.adjusted">
<code class="descname">adjusted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.adjusted" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>仮数の先頭の一桁だけが残るように右側の数字を追い出す桁シフトを行い、その結果の指数部を返します: <code class="docutils literal"><span class="pre">Decimal('321e+5').adjusted()</span></code> は 7 を返します。最上桁の小数点からの相対位置を調べる際に使います。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.as_integer_ratio">
<code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_integer_ratio" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスを、既約分数で分母が正数の分数として表現した整数のペア <code class="docutils literal"><span class="pre">(n,</span> <span class="pre">d)</span></code> を返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
<p>変換は正確に行われます。無限大に対してはOverflowErrorを、NaNに対してはValueError を送出します。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
<dl class="method">
<dt id="decimal.Decimal.as_tuple">
<code class="descname">as_tuple</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_tuple" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値を表現するための名前付きタプル(<a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>): <code class="docutils literal"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digittuple,</span> <span class="pre">exponent)</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.canonical">
<code class="descname">canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.canonical" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数の標準的(canonical)エンコーディングを返します。現在のところ、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスのエンコーディングは常に標準的なので、この操作は引数に手を加えずに返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの Decimal インスタンスの値を比較します。 <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a> は Decimal インスタンスを返し、被演算子のどちらかが NaN ならば結果は NaN です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">NaN</span>  <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_signal">
<code class="descname">compare_signal</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_signal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この演算は <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a> とほとんど同じですが、全ての NaN がシグナルを送るところが異なります。すなわち、どちらの比較対象も発信 (signaling) NaN でないならば無言 (quiet) NaN である比較対象があたかも発信 NaN であるかのように扱われます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_total">
<code class="descname">compare_total</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの対象を数値によらず抽象表現によって比較します。 <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a> に似ていますが、結果は <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> に全順序を与えます。この順序づけによると、数値的に等しくても異なった表現を持つ二つの <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスの比較は等しくなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>無言 NaN と発信 NaN もこの全順序に位置付けられます。この関数の結果は、もし比較対象が同じ表現を持つならば <code class="docutils literal"><span class="pre">Decimal('0')</span></code> であり、一つめの比較対象が二つめより下位にあれば <code class="docutils literal"><span class="pre">Decimal('-1')</span></code>、上位にあれば <code class="docutils literal"><span class="pre">Decimal('1')</span></code> です。全順序の詳細については仕様を参照してください。</p>
<p>この演算はコンテキストに影響されず、静かです。すなわち、フラグは変更されず、丸めは行われません。例外として、2番目の比較対象の厳密な変換ができない場合、C バージョンのライブラリでは InvalidOperation 例外を送出するかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_total_mag">
<code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total_mag" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの対象を <a class="reference internal" href="#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal"><span class="pre">compare_total()</span></code></a> のように数値によらず抽象表現によって比較しますが、両者の符号を無視します。 <code class="docutils literal"><span class="pre">x.compare_total_mag(y)</span></code> は <code class="docutils literal"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code> と等価です。</p>
<p>この演算はコンテキストに影響されず、静かです。すなわち、フラグは変更されず、丸めは行われません。例外として、2番目の比較対象の厳密な変換ができない場合、C バージョンのライブラリでは InvalidOperation 例外を送出するかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.conjugate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>self を返すだけです。このメソッドは十進演算仕様に適合するためだけのものです。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_abs">
<code class="descname">copy_abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_abs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数の絶対値を返します。この演算はコンテキストに影響されず、静かです。すなわち、フラグは変更されず、丸めは行われません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_negate">
<code class="descname">copy_negate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_negate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数の符号を変えて返します。この演算はコンテキストに影響されず、静かです。すなわち、フラグは変更されず、丸めは行われません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_sign">
<code class="descname">copy_sign</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_sign" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の演算対象のコピーに二つめと同じ符号を付けて返します。たとえば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1.5&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2.3&#39;)</span>
</pre></div>
</div>
<p>この演算はコンテキストに影響されず、静かです。すなわち、フラグは変更されず、丸めは行われません。例外として、2番目の比較対象の厳密な変換ができない場合、C バージョンのライブラリでは InvalidOperation 例外を送出するかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.exp" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた数での(自然)指数関数 <code class="docutils literal"><span class="pre">e**x</span></code> の値を返します。結果は <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 丸めモードで正しく丸められます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.561702493119680037517373933E+139&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.from_float">
<code class="descname">from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.from_float" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数を正確に小数に変換するクラスメソッドです。</p>
<p>なお、<cite>Decimal.from_float(0.1)</cite> は <cite>Decimal('0.1')</cite> と同じではありません。0.1 は二進浮動小数点数で正確に表せないので、その値は表現できる最も近い値、<cite>0x1.999999999999ap-4</cite> として記憶されます。浮動小数点数での等価な値は <cite>0.1000000000000000055511151231257827021181583404541015625</cite> です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python 3.2 以降では、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスは <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> から直接構成できるようになりました。</p>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.fma">
<code class="descname">fma</code><span class="sig-paren">(</span><em>other</em>, <em>third</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.fma" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>融合積和(fused multiply-add)です。self*other+third を途中結果の積 self*other で丸めを行わずに計算して返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal(&#39;11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_canonical">
<code class="descname">is_canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_canonical" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が標準的(canonical)ならば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を返し、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。現在のところ、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> のインスタンスは常に標準的なのでこのメソッドの結果はいつでも <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_finite">
<code class="descname">is_finite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_finite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が有限の数値ならば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、無限大か NaN ならば <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_infinite">
<code class="descname">is_infinite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_infinite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が正または負の無限大ならば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_nan">
<code class="descname">is_nan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_nan" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が (無言か発信かは問わず) NaN であれば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_normal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が <em>正規(normal)</em> の有限数値ならば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を返します。引数がゼロ、非正規(subnormal)、無限大または NaN であれば <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_qnan">
<code class="descname">is_qnan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_qnan" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が無言 NaN であれば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_signed">
<code class="descname">is_signed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_signed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数に負の符号がついていれば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。注意すべきはゼロや NaN なども符号を持ち得ることです。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_snan">
<code class="descname">is_snan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_snan" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が発信 NaN であれば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_subnormal">
<code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_subnormal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が非正規数(subnormal)であれば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_zero">
<code class="descname">is_zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_zero" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数が(正または負の)ゼロであれば <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を、そうでなければ <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.ln">
<code class="descname">ln</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.ln" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>演算対象の自然対数(底 e の対数)を返します。結果は <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 丸めモードで正しく丸められます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.log10" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>演算対象の底 10 の対数を返します。結果は <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 丸めモードで正しく丸められます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logb">
<code class="descname">logb</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logb" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>非零の数値については、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスとして調整された指数を返します。演算対象がゼロだった場合、 <code class="docutils literal"><span class="pre">Decimal('-Infinity')</span></code> が返され <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal"><span class="pre">DivisionByZero</span></code></a> フラグが送出されます。演算対象が無限大だった場合、 <code class="docutils literal"><span class="pre">Decimal('Infinity')</span></code> が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_and">
<code class="descname">logical_and</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_and" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal"><span class="pre">logical_and()</span></code></a> は二つの <em>論理引数</em> (<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">論理引数</span></a> 参照)を取る論理演算です。結果は二つの引数の数字ごとの <code class="docutils literal"><span class="pre">and</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_invert">
<code class="descname">logical_invert</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_invert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal"><span class="pre">logical_invert()</span></code></a> は論理演算です。結果は引数の数字ごとの反転です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_or">
<code class="descname">logical_or</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_or" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal"><span class="pre">logical_or()</span></code></a> は二つの <em>論理引数</em> (<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">論理引数</span></a> 参照)を取る論理演算です。結果は二つの引数の数字ごとの <code class="docutils literal"><span class="pre">or</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_xor">
<code class="descname">logical_xor</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_xor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal"><span class="pre">logical_xor()</span></code></a> は二つの <em>論理引数</em> (<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">論理引数</span></a> 参照)を取る論理演算です。結果は二つの引数の数字ごとの排他的論理和です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">max(self,</span> <span class="pre">other)</span></code> と同じですが、値を返す前に現在のコンテキストに即した丸め規則を適用します。また、 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> に対して、(コンテキストの設定と、発信か無言どちらのタイプであるかに応じて) シグナルを発行するか無視します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.max_mag">
<code class="descname">max_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max_mag" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal"><span class="pre">max()</span></code></a> メソッドに似ていますが、比較は絶対値で行われます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">min(self,</span> <span class="pre">other)</span></code> と同じですが、値を返す前に現在のコンテキストに即した丸め規則を適用します。また、 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> に対して、(コンテキストの設定と、発信か無言どちらのタイプであるかに応じて) シグナルを発行するか無視します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.min_mag">
<code class="descname">min_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min_mag" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal"><span class="pre">min()</span></code></a> メソッドに似ていますが、比較は絶対値で行われます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_minus">
<code class="descname">next_minus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_minus" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたコンテキスト(またはコンテキストが渡されなければ現スレッドのコンテキスト)において表現可能な、操作対象より小さい最大の数を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_plus">
<code class="descname">next_plus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_plus" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたコンテキスト(またはコンテキストが渡されなければ現スレッドのコンテキスト)において表現可能な、操作対象より大きい最小の数を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_toward">
<code class="descname">next_toward</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_toward" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの比較対象が等しくなければ、一つめの対象に最も近く二つめの対象へ近付く方向の数を返します。もし両者が数値的に等しければ、二つめの対象の符号を採った一つめの対象のコピーを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.normalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値を正規化 (normalize) して、右端に連続しているゼロを除去し、 <code class="xref py py-const docutils literal"><span class="pre">Decimal('0')</span></code> と同じ結果はすべて <code class="xref py py-const docutils literal"><span class="pre">Decimal('0e0')</span></code> に変換します。等価クラスの属性から基準表現を生成する際に用います。たとえば、 <code class="docutils literal"><span class="pre">Decimal('32.100')</span></code> と <code class="docutils literal"><span class="pre">Decimal('0.321000e+2')</span></code> の正規化は、いずれも同じ値 <code class="docutils literal"><span class="pre">Decimal('32.1')</span></code> になります。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.number_class">
<code class="descname">number_class</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.number_class" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>操作対象の <em>クラス</em> を表す文字列を返します。返されるのは以下の10種類のいずれかです。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&quot;-Infinity&quot;</span></code>, 負の無限大であることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;-Normal&quot;</span></code>, 負の通常数であることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;-Subnormal&quot;</span></code>, 負の非正規数であることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;-Zero&quot;</span></code>, 負のゼロであることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;+Zero&quot;</span></code>, 正のゼロであることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;+Subnormal&quot;</span></code>, 正の非正規数であることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;+Normal&quot;</span></code>, 正の通常数であることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;+Infinity&quot;</span></code>, 正の無限大であることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;NaN&quot;</span></code>, 無言 (quiet) NaN (Not a Number) であることを示します。</li>
<li><code class="docutils literal"><span class="pre">&quot;sNaN&quot;</span></code>, 発信(signaling) NaN であることを示します。</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.quantize">
<code class="descname">quantize</code><span class="sig-paren">(</span><em>exp</em>, <em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.quantize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つ目の操作対象と同じ指数を持つように丸めを行った、一つめの操作対象と等しい値を返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.41421356&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.000&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.414&#39;)</span>
</pre></div>
</div>
<p>他の操作と違い、打ち切り(quantize)操作後の係数の長さが精度を越えた場合には、 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a> がシグナルされます。これによりエラー条件がない限り打ち切られた指数が常に右側の引数と同じになることが保証されます。</p>
<p>同様に、他の操作と違い、quantize は Underflow を、たとえ結果が非正規になったり不正確になったとしても、シグナルしません。</p>
<p>二つ目の演算対象の指数が一つ目のそれよりも大きければ丸めが必要かもしれません。この場合、丸めモードは以下のように決められます。<code class="docutils literal"><span class="pre">rounding</span></code> 引数が与えられていればそれが使われます。そうでなければ <code class="docutils literal"><span class="pre">context</span></code> 引数で決まります。どちらの引数も渡されなければ現在のスレッドのコンテキストの丸めモードが使われます。</p>
<p>処理結果の指数が <code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code> よりも大きい場合や <code class="xref py py-attr docutils literal"><span class="pre">Etiny</span></code> よりも小さい場合にエラーが返されます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.radix">
<code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.radix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">Decimal(10)</span></code> つまり <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> クラスがその全ての算術を実行する基数を返します。仕様との互換性のために取り入れられています。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.remainder_near">
<code class="descname">remainder_near</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.remainder_near" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>self</em> を <em>other</em> で割った剰余を返します。これは <code class="docutils literal"><span class="pre">self</span> <span class="pre">%</span> <span class="pre">other</span></code> とは違って、剰余の絶対値を小さくするように符号が選ばれます。より詳しく言うと、<code class="docutils literal"><span class="pre">n</span></code> を <code class="docutils literal"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code> の正確な値に最も近い整数としたときの <code class="docutils literal"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code> が返り値になります。最も近い整数が2つある場合には偶数のものが選ばれます。</p>
<p>結果が0になる場合の符号は <em>self</em> の符号と同じになります。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.rotate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一つ目の演算対象の数字を二つ目で指定された量だけ巡回(rotate)した結果を返します。二つめの演算対象は -precision から precision までの範囲の整数でなければなりません。この二つ目の演算対象の絶対値を何桁ずらすかを決めます。そしてもし正の数ならば巡回の方向は左に、そうでなければ右になります。一つ目の演算対象の仮数部は必要ならば精度いっぱいまでゼロで埋められます。符号と指数は変えられません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.same_quantum">
<code class="descname">same_quantum</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.same_quantum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>self</em> と <em>other</em> が同じ指数を持っているか、あるいは双方とも <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> である場合に真を返します。</p>
<p>この演算はコンテキストに影響されず、静かです。すなわち、フラグは変更されず、丸めは行われません。例外として、2番目の比較対象の厳密な変換ができない場合、C バージョンのライブラリでは InvalidOperation 例外を送出するかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.scaleb">
<code class="descname">scaleb</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.scaleb" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つ目の演算対象で調整された指数の一つ目の演算対象を返します。同じことですが、一つめの演算対象を <code class="docutils literal"><span class="pre">10**other</span></code> 倍したものを返します。二つ目の演算対象は整数でなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.shift" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一つ目の演算対象の数字を二つ目で指定された量だけシフトした結果を返します。二つ目の演算対象は -precision から precision までの範囲の整数でなければなりません。この二つ目の演算対象の絶対値が何桁ずらすかを決めます。そしてもし正の数ならばシフトの方向は左に、そうでなければ右になります。一つ目の演算対象の係数は必要ならば精度いっぱいまでゼロで埋められます。符号と指数は変えられません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.sqrt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数の平方根を最大精度で求めます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_eng_string">
<code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_eng_string" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列に変換します。指数が必要なら工学表記が使われます。</p>
<p>工学表記法では指数は 3 の倍数になります。これにより、基数の小数部には最大で 3 桁までの数字が残されるとともに、末尾に 1 つまたは 2 つの 0 の付加が必要とされるかもしれません。</p>
<p>たとえば、<code class="docutils literal"><span class="pre">Decimal('123E+1')</span></code> は <code class="docutils literal"><span class="pre">Decimal('1.23E+3')</span></code> に変換されます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral">
<code class="descname">to_integral</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal"><span class="pre">to_integral_value()</span></code></a> メソッドと同じです。<code class="docutils literal"><span class="pre">to_integral</span></code> の名前は古いバージョンとの互換性のために残されています。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral_exact">
<code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_exact" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最近傍の整数に値を丸め、丸めが起こった場合には <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a> または <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a> のシグナルを適切に出します。丸めモードは以下のように決められます。 <code class="docutils literal"><span class="pre">rounding</span></code> 引数が与えられていればそれが使われます。そうでなければ <code class="docutils literal"><span class="pre">context</span></code> 引数で決まります。どちらの引数も渡されなければ現在のスレッドのコンテキストの丸めモードが使われます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral_value">
<code class="descname">to_integral_value</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a> や <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a> といったシグナルを出さずに最近傍の整数に値を丸めます。 <em>rounding</em> が指定されていれば適用されます; それ以外の場合、値丸めの方法は <em>context</em> の設定か現在のコンテキストの設定になります。</p>
</dd></dl>

</dd></dl>

<div class="section" id="logical-operands">
<span id="logical-operands-label"></span><h3>9.4.2.1. 論理引数<a class="headerlink" href="#logical-operands" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref py py-meth docutils literal"><span class="pre">logical_and()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">logical_invert()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">logical_or()</span></code>, および <code class="xref py py-meth docutils literal"><span class="pre">logical_xor()</span></code> メソッドはその引数が <em>論理引数</em> であると想定しています。 <em>論理引数</em> とは <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスで指数と符号は共にゼロであり、各桁の数字が <code class="xref py py-const docutils literal"><span class="pre">0</span></code> か <code class="xref py py-const docutils literal"><span class="pre">1</span></code> であるものです。</p>
</div>
</div>
<div class="section" id="context-objects">
<span id="decimal-context"></span><h2>9.4.3. Context オブジェクト<a class="headerlink" href="#context-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>コンテキスト (context) とは、算術演算における環境設定です。コンテキストは計算精度を決定し、値丸めの方法を設定し、シグナルのどれが例外になるかを決め、指数の範囲を制限しています。</p>
<p>多重スレッドで処理を行う場合には各スレッドごとに現在のコンテキストがあり、 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> や <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> といった関数でアクセスしたり設定変更できます:</p>
<dl class="function">
<dt id="decimal.getcontext">
<code class="descclassname">decimal.</code><code class="descname">getcontext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.getcontext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アクティブなスレッドの現在のコンテキストを返します。</p>
</dd></dl>

<dl class="function">
<dt id="decimal.setcontext">
<code class="descclassname">decimal.</code><code class="descname">setcontext</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.setcontext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アクティブなスレッドのコンテキストを <em>c</em> に設定します。</p>
</dd></dl>

<p><a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文と <a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">localcontext()</span></code></a> 関数を使って実行するコンテキストを一時的に変更することもできます。</p>
<dl class="function">
<dt id="decimal.localcontext">
<code class="descclassname">decimal.</code><code class="descname">localcontext</code><span class="sig-paren">(</span><em>ctx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.localcontext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>with 文の入口でアクティブなスレッドのコンテキストを <em>ctx</em> のコピーに設定し、with 文を抜ける時に元のコンテキストに復旧する、コンテキストマネージャを返します。コンテキストが指定されなければ、現在のコンテキストのコピーが使われます。</p>
<p>たとえば、以下のコードでは精度を42桁に設定し、計算を実行し、そして元のコンテキストに復帰します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># Perform a high precision calculation</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># Round the final result back to the default precision</span>
</pre></div>
</div>
</dd></dl>

<p>新たなコンテキストは、以下で説明する <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> コンストラクタを使って生成できます。その他にも、 <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールでは作成済みのコンテキストを提供しています:</p>
<dl class="class">
<dt id="decimal.BasicContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">BasicContext</code><a class="headerlink" href="#decimal.BasicContext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>汎用十進演算仕様で定義されている標準コンテキストの一つです。精度は 9 桁に設定されています。丸め規則は <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_UP</span></code></a> です。すべての演算結果フラグはクリアされています。 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal"><span class="pre">Subnormal</span></code></a> を除く全ての演算エラートラップが有効 (例外として扱う) になっています。</p>
<p>多くのトラップが有効になっているので、デバッグの際に便利なコンテキストです。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.ExtendedContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">ExtendedContext</code><a class="headerlink" href="#decimal.ExtendedContext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>汎用十進演算仕様で定義されている標準コンテキストの一つです。精度は 9 桁に設定されています。丸め規則は <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> です。すべての演算結果フラグはクリアされています。トラップは全て無効(演算中に一切例外を送出しない) になっています。</p>
<p>トラップが無効になっているので、エラーの伴う演算結果を <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> や <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> にし、例外を送出しないようにしたいアプリケーションに向いたコンテキストです。このコンテキストを使うと、他の場合にはプログラムが停止してしまうような状況があっても実行を完了させられます。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DefaultContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DefaultContext</code><a class="headerlink" href="#decimal.DefaultContext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> コンストラクタが新たなコンテキストを作成するさいに雛形にするコンテキストです。このコンテキストのフィールド (精度の設定など) を変更すると、 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> コンストラクタが生成する新たなコンテキストに影響を及ぼします。</p>
<p>このコンテキストは、主に多重スレッド環境で便利です。スレッドを開始する前に何らかのフィールドを変更しておくと、システム全体のデフォルト設定に効果を及ぼすことができます。スレッドを開始した後にフィールドを変更すると、競合条件を抑制するためにスレッドを同期化しなければならないので、推奨しません。</p>
<p>単一スレッドの環境では、このコンテキストを使わないよう薦めます。下で述べるように明示的にコンテキストを作成してください。</p>
<p>デフォルトの値は、 <code class="xref py py-attr docutils literal"><span class="pre">prec</span></code>=<code class="xref py py-const docutils literal"><span class="pre">28</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">rounding</span></code>=<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> で、トラップ <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal"><span class="pre">InvalidOperation</span></code></a>, および <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal"><span class="pre">DivisionByZero</span></code></a> が有効になっています。</p>
</dd></dl>

<p>上に挙げた三つのコンテキストに加え、 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> コンストラクタを使って新たなコンテキストを生成できます。</p>
<dl class="class">
<dt id="decimal.Context">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Context</code><span class="sig-paren">(</span><em>prec=None</em>, <em>rounding=None</em>, <em>Emin=None</em>, <em>Emax=None</em>, <em>capitals=None</em>, <em>clamp=None</em>, <em>flags=None</em>, <em>traps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新たなコンテキストを生成します。あるフィールドが定義されていないか <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> であれば、 <a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal"><span class="pre">DefaultContext</span></code></a> からデフォルト値をコピーします。 <em>flags</em> フィールドが設定されていいか <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> の場合には、全てのフラグがクリアされます。</p>
<p><em>prec</em> フィールドは範囲 [<code class="xref py py-const docutils literal"><span class="pre">1</span></code>, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal"><span class="pre">MAX_PREC</span></code></a>] 内の整数で、コンテキストにおける算術演算の計算精度を設定します。</p>
<p><em>rounding</em> オプションは、節 <a class="reference internal" href="#rounding-modes">丸めモード</a> で挙げられる定数の一つです。</p>
<p><em>traps</em> および <em>flags</em> フィールドには、セットしたいシグナルを列挙します。一般的に、新たなコンテキストを作成するときにはトラップだけを設定し、フラグはクリアしておきます。</p>
<p><em>Emin</em> および <em>Emax</em> フィールドは、許容する指数の外限を指定する整数です。 <em>Emin</em> は範囲 [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal"><span class="pre">MIN_EMIN</span></code></a>, <code class="xref py py-const docutils literal"><span class="pre">0</span></code>] 内で、 <em>Emax</em> は範囲 [<code class="xref py py-const docutils literal"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal"><span class="pre">MAX_EMAX</span></code></a>] 内でなければなりません。</p>
<p><em>capitals</em> フィールドは <code class="xref py py-const docutils literal"><span class="pre">0</span></code> または <code class="xref py py-const docutils literal"><span class="pre">1</span></code> (デフォルト) にします。 <code class="xref py py-const docutils literal"><span class="pre">1</span></code> に設定すると、指数記号を大文字 <code class="xref py py-const docutils literal"><span class="pre">E</span></code> で出力します。それ以外の場合には <code class="xref py py-const docutils literal"><span class="pre">Decimal('6.02e+23')</span></code> のように <code class="xref py py-const docutils literal"><span class="pre">e</span></code> を使います。</p>
<p><em>clamp</em> フィールドは、 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> (デフォルト) または <code class="xref py py-const docutils literal"><span class="pre">1</span></code> です。 <code class="xref py py-const docutils literal"><span class="pre">1</span></code> に設定されると、このコンテキストにおける <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスの指数 <code class="docutils literal"><span class="pre">e</span></code> は厳密に範囲 <code class="docutils literal"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> に制限されます。 <em>clamp</em> が <code class="xref py py-const docutils literal"><span class="pre">0</span></code> なら、それより弱い条件が支配します: 調整された <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスの指数は最大で <code class="docutils literal"><span class="pre">Emax</span></code> です。 <em>clamp</em> が <code class="xref py py-const docutils literal"><span class="pre">1</span></code> なら、大きな正規数は、可能なら、指数が減らされ、対応する数の 0 が係数に加えられ、指数の制約に合わせられます; これは数の値を保存しますが、有効な末尾の 0 に関する情報を失います。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.23e999&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.23000E+999&#39;)</span>
</pre></div>
</div>
<p><em>clamp</em> の値 <code class="xref py py-const docutils literal"><span class="pre">1</span></code> は、IEEE 754 で規定された固定幅十進交換形式と互換にできます。</p>
<p><a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> クラスでは、いくつかの汎用のメソッドの他、現在のコンテキストで算術演算を直接行うためのメソッドを数多く定義しています。加えて、 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> の各メソッドについて(<code class="xref py py-meth docutils literal"><span class="pre">adjusted()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">as_tuple()</span></code> メソッドを例外として)対応する <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> のメソッドが存在します。たとえば、 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> インスタンス  <code class="docutils literal"><span class="pre">C</span></code> と <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンス <code class="docutils literal"><span class="pre">x</span></code> に対して、 <code class="docutils literal"><span class="pre">C.exp(x)</span></code> は <code class="docutils literal"><span class="pre">x.exp(context=C)</span></code> と等価です。それぞれの <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> メソッドは、Decimal インスタンスが受け付けられるところならどこでも、Python の整数 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> のインスタンス) を受け付けます。</p>
<dl class="method">
<dt id="decimal.Context.clear_flags">
<code class="descname">clear_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_flags" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フラグを全て <code class="xref py py-const docutils literal"><span class="pre">0</span></code> にリセットします。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.clear_traps">
<code class="descname">clear_traps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_traps" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>トラップを全て <code class="xref py py-const docutils literal"><span class="pre">0</span></code> にリセットします。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストの複製を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_decimal">
<code class="descname">copy_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_decimal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Decimal インスタンス num のコピーを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.create_decimal">
<code class="descname">create_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>self</em> をコンテキストとする新たな Decimal インスタンスを <em>num</em> から生成します。 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> コンストラクタと違い、数値を変換する際にコンテキストの精度、値丸め方法、フラグ、トラップを適用します。</p>
<p>定数値はしばしばアプリケーションの要求よりも高い精度を持っているため、このメソッドが役に立ちます。また、値丸めを即座に行うため、例えば以下のように、入力値に値丸めを行わないために合計値にゼロの加算を追加するだけで結果が変わってしまうといった、現在の精度よりも細かい値の影響が紛れ込む問題を防げるという恩恵もあります。以下の例は、丸められていない入力を使うということは和にゼロを加えると結果が変わり得るという見本です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.44&#39;)</span>
</pre></div>
</div>
<p>このメソッドは IBM 仕様の to-number 演算を実装したものです。引数が文字列の場合、前や後ろに余計な空白を付けたり、アンダースコアを含めたりすることは許されません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.create_decimal_from_float">
<code class="descname">create_decimal_from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal_from_float" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数 <em>f</em> から新しい Decimal インスタンスを生成しますが、 <em>self</em> をコンテキストとして丸めます。 <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal"><span class="pre">Decimal.from_float()</span></code></a> クラスメソッドとは違い、変換にコンテキストの精度、丸めメソッド、フラグ、そしてトラップが適用されます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.Etiny">
<code class="descname">Etiny</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etiny" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> に等しい値を返します。演算結果の劣化が起こる桁の最小値です。アンダーフローが起きた場合、指数は <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal"><span class="pre">Etiny</span></code></a> に設定されます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.Etop">
<code class="descname">Etop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> に等しい値を返します。</p>
</dd></dl>

<p><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> を使った処理を行う場合、通常は <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> インスタンスを生成して、算術演算を適用するというアプローチをとります。演算はアクティブなスレッドにおける現在のコンテキストの下で行われます。もう一つのアプローチは、コンテキストのメソッドを使った特定のコンテキスト下での計算です。コンテキストのメソッドは <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> クラスのメソッドに似ているので、ここでは簡単な説明にとどめます。</p>
<dl class="method">
<dt id="decimal.Context.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.abs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の絶対値を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> と <em>y</em> の和を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.canonical">
<code class="descname">canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.canonical" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>同じ Decimal オブジェクト <em>x</em> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> と <em>y</em> を数値として比較します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_signal">
<code class="descname">compare_signal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_signal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの演算対象の値を数値として比較します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_total">
<code class="descname">compare_total</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの演算対象を抽象的な表現を使って比較します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_total_mag">
<code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total_mag" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの演算対象を抽象的な表現を使い符号を無視して比較します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_abs">
<code class="descname">copy_abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_abs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> のコピーの符号を 0 にセットして返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_negate">
<code class="descname">copy_negate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_negate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> のコピーの符号を反転して返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_sign">
<code class="descname">copy_sign</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_sign" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>y</em> から <em>x</em> に符号をコピーします。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divide">
<code class="descname">divide</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> を <em>y</em> で除算した値を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divide_int">
<code class="descname">divide_int</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide_int" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> を <em>y</em> で除算した値を整数に切り捨てて返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divmod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの数値間の除算を行い、結果の整数部を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.exp" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><cite>e ** x</cite> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.fma">
<code class="descname">fma</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.fma" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> を <em>y</em> 倍したものに <em>z</em> を加えて返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_canonical">
<code class="descname">is_canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_canonical" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が標準的(canonical)ならば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_finite">
<code class="descname">is_finite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_finite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が有限ならば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_infinite">
<code class="descname">is_infinite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_infinite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が無限ならば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_nan">
<code class="descname">is_nan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_nan" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が qNaN か sNaN であれば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_normal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が通常の数ならば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_qnan">
<code class="descname">is_qnan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_qnan" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が無言 NaN であれば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_signed">
<code class="descname">is_signed</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_signed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が負の数であれば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_snan">
<code class="descname">is_snan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_snan" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が発信 NaN であれば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_subnormal">
<code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_subnormal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> が非正規数であれば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_zero">
<code class="descname">is_zero</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_zero" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> がゼロであれば <code class="docutils literal"><span class="pre">True</span></code> を返します。そうでなければ <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.ln">
<code class="descname">ln</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.ln" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の自然対数(底 e の対数)を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.log10" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の底 10 の対数を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logb">
<code class="descname">logb</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logb" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>演算対象の MSD の大きさの指数部を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_and">
<code class="descname">logical_and</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_and" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それぞれの桁に論理演算 <em>and</em> を当てはめます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_invert">
<code class="descname">logical_invert</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_invert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の全ての桁を反転させます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_or">
<code class="descname">logical_or</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_or" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それぞれの桁に論理演算 <em>or</em> を当てはめます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_xor">
<code class="descname">logical_xor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_xor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それぞれの桁に論理演算 <em>xor</em> を当てはめます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの値を数値として比較し、大きいほうを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.max_mag">
<code class="descname">max_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max_mag" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値を符号を無視して数値として比較します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>二つの値を数値として比較し、小さいほうを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.min_mag">
<code class="descname">min_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min_mag" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値を符号を無視して数値として比較します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.minus">
<code class="descname">minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.minus" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python における単項マイナス演算子に対応する演算です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.multiply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> と <em>y</em> の積を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_minus">
<code class="descname">next_minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_minus" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> より小さい最大の表現可能な数を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_plus">
<code class="descname">next_plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_plus" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> より大きい最小の表現可能な数を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_toward">
<code class="descname">next_toward</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_toward" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> に <em>y</em> の方向に向かって最も近い数を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.normalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> をもっとも単純な形にします。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.number_class">
<code class="descname">number_class</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.number_class" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> のクラスを指し示すものを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.plus">
<code class="descname">plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.plus" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python における単項のプラス演算子に対応する演算です。コンテキストにおける精度や値丸めを適用するので、等値 (identity) 演算とは <em>違います</em>。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.power">
<code class="descname">power</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>modulo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">x</span></code> の <code class="docutils literal"><span class="pre">y</span></code> 乗を計算します。<code class="docutils literal"><span class="pre">modulo</span></code> が指定されていればモジュロを取ります。</p>
<p>引数が 2 つの場合、 <code class="docutils literal"><span class="pre">x**y</span></code> を計算します。<code class="docutils literal"><span class="pre">x</span></code> が負の場合、 <code class="docutils literal"><span class="pre">y</span></code> は整数でなければなりません。<code class="docutils literal"><span class="pre">y</span></code> が整数、結果が有限、結果が 'precision' 桁で正確に表現できる、という条件をすべて満たさない場合、結果は不正確になります。結果はコンテキストの丸めモードを使って丸められます。結果は常に、Python バージョンにおいて正しく丸められます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>C モジュールは <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal"><span class="pre">power()</span></code></a> を適切に丸められた <a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal"><span class="pre">exp()</span></code></a> および <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal"><span class="pre">ln()</span></code></a> 関数によって計算します。結果は well-defined ですが、「ほとんどの場合には適切に丸められる」だけです。</p>
</div>
<p>引数が 3 つの場合、 <code class="docutils literal"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> を計算します。この 3 引数の形式の場合、引数には以下の制限が課せられます。</p>
<blockquote>
<div><ul class="simple">
<li>全ての引数は整数</li>
<li><code class="docutils literal"><span class="pre">y</span></code> は非負でなければならない</li>
<li><code class="docutils literal"><span class="pre">x</span></code> と <code class="docutils literal"><span class="pre">y</span></code> の少なくともどちらかはゼロでない</li>
<li><code class="docutils literal"><span class="pre">modulo</span></code> は非零で大きくても 'precision' 桁</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> で得られる値は <code class="docutils literal"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> を精度無制限で計算して得られるものと同じ値ですが、より効率的に計算されます。結果の指数は <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">y</span></code>, <code class="docutils literal"><span class="pre">modulo</span></code> の指数に関係なくゼロです。この計算は常に正確です。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.quantize">
<code class="descname">quantize</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.quantize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> に値丸めを適用し、指数を <em>y</em> にした値を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.radix">
<code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.radix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>単に 10 を返します。何せ十進ですから :)</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.remainder">
<code class="descname">remainder</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数除算の剰余を返します。</p>
<p>剰余がゼロでない場合、符号は割られる数の符号と同じになります。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.remainder_near">
<code class="descname">remainder_near</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder_near" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code> を返します。ここで <em>n</em> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> の正確な値に一番近い整数です (この結果が 0 ならばその符号は <em>x</em> の符号と同じです)。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.rotate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の <em>y</em> 回巡回したコピーを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.same_quantum">
<code class="descname">same_quantum</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.same_quantum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>2つの演算対象が同じ指数を持っている場合に <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.scaleb">
<code class="descname">scaleb</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.scaleb" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>一つめの演算対象の指数部に二つめの値を加えたものを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.shift" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> を <em>y</em> 回シフトしたコピーを返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.sqrt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> の平方根を精度いっぱいまで求めます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.subtract">
<code class="descname">subtract</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.subtract" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>x</em> と <em>y</em> の間の差を返します。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_eng_string">
<code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_eng_string" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列に変換します。指数が必要なら工学表記が使われます。</p>
<p>工学表記法では指数は 3 の倍数になります。これにより、基数の小数部には最大で 3 桁までの数字が残されるとともに、末尾に 1 つまたは 2 つの 0 の付加が必要とされるかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_integral_exact">
<code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_integral_exact" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最近傍の整数に値を丸めます。</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_sci_string">
<code class="descname">to_sci_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_sci_string" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値を科学表記で文字列に変換します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="constants">
<span id="decimal-rounding-modes"></span><h2>9.4.4. 定数<a class="headerlink" href="#constants" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節の定数は C モジュールにのみ意味があります。互換性のために、pure Python 版も含まれます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="29%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">32-bit</th>
<th class="head">64-bit</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><dl class="first last data">
<dt id="decimal.MAX_PREC">
<code class="descclassname">decimal.</code><code class="descname">MAX_PREC</code><a class="headerlink" href="#decimal.MAX_PREC" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">425000000</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">999999999999999999</span></code></td>
</tr>
<tr class="row-odd"><td><dl class="first last data">
<dt id="decimal.MAX_EMAX">
<code class="descclassname">decimal.</code><code class="descname">MAX_EMAX</code><a class="headerlink" href="#decimal.MAX_EMAX" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">425000000</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">999999999999999999</span></code></td>
</tr>
<tr class="row-even"><td><dl class="first last data">
<dt id="decimal.MIN_EMIN">
<code class="descclassname">decimal.</code><code class="descname">MIN_EMIN</code><a class="headerlink" href="#decimal.MIN_EMIN" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">-425000000</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">-999999999999999999</span></code></td>
</tr>
<tr class="row-odd"><td><dl class="first last data">
<dt id="decimal.MIN_ETINY">
<code class="descclassname">decimal.</code><code class="descname">MIN_ETINY</code><a class="headerlink" href="#decimal.MIN_ETINY" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">-849999999</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">-1999999999999999997</span></code></td>
</tr>
</tbody>
</table>
<dl class="data">
<dt id="decimal.HAVE_THREADS">
<code class="descclassname">decimal.</code><code class="descname">HAVE_THREADS</code><a class="headerlink" href="#decimal.HAVE_THREADS" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デフォルト値は <code class="docutils literal"><span class="pre">True</span></code> です。Python がスレッド無しでコンパイルされている場合、C 版は自動的にコストがかかるスレッドローカルなコンテキスト機構を使用不可にします。この場合、値は <code class="docutils literal"><span class="pre">False</span></code> です。</p>
</dd></dl>

</div>
<div class="section" id="rounding-modes">
<h2>9.4.5. 丸めモード<a class="headerlink" href="#rounding-modes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="data">
<dt id="decimal.ROUND_CEILING">
<code class="descclassname">decimal.</code><code class="descname">ROUND_CEILING</code><a class="headerlink" href="#decimal.ROUND_CEILING" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> 方向に丸めます。</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_DOWN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_DOWN</code><a class="headerlink" href="#decimal.ROUND_DOWN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ゼロ方向に丸めます。</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_FLOOR">
<code class="descclassname">decimal.</code><code class="descname">ROUND_FLOOR</code><a class="headerlink" href="#decimal.ROUND_FLOOR" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code> 方向に丸めます。</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_DOWN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_DOWN</code><a class="headerlink" href="#decimal.ROUND_HALF_DOWN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>近い方に、引き分けはゼロ方向に向けて丸めます。</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_EVEN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_EVEN</code><a class="headerlink" href="#decimal.ROUND_HALF_EVEN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>近い方に、引き分けは偶数整数方向に向けて丸めます。</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_UP</code><a class="headerlink" href="#decimal.ROUND_HALF_UP" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>近い方に、引き分けはゼロから遠い方向に向けて丸めます。</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_UP</code><a class="headerlink" href="#decimal.ROUND_UP" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ゼロから遠い方向に丸めます。</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_05UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_05UP</code><a class="headerlink" href="#decimal.ROUND_05UP" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ゼロ方向に丸めた後の最後の桁が 0 または 5 ならばゼロから遠い方向に、そうでなければゼロ方向に丸めます。</p>
</dd></dl>

</div>
<div class="section" id="signals">
<span id="decimal-signals"></span><h2>9.4.6. シグナル<a class="headerlink" href="#signals" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>シグナルは、計算中に生じた様々なエラー条件を表現します。各々のシグナルは一つのコンテキストフラグと一つのトラップイネーブラに対応しています。</p>
<p>コンテキストフラグは、該当するエラー条件に遭遇するたびにセットされます。演算後にフラグを調べれば、演算に関する情報 (例えば計算が厳密だったかどうか) がわかります。フラグを調べたら、次の計算を始める前にフラグを全てクリアするようにしてください。</p>
<p>あるコンテキストのトラップイネーブラがあるシグナルに対してセットされている場合、該当するエラー条件が生じると Python の例外を送出します。例えば、 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal"><span class="pre">DivisionByZero</span></code></a> が設定されていると、エラー条件が生じた際に <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal"><span class="pre">DivisionByZero</span></code></a> 例外を送出します。</p>
<dl class="class">
<dt id="decimal.Clamped">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Clamped</code><a class="headerlink" href="#decimal.Clamped" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値の表現上の制限に沿わせるために指数部が変更されたことを通知します。</p>
<p>通常、クランプ (clamp) は、指数部がコンテキストにおける指数桁の制限値 <code class="xref py py-attr docutils literal"><span class="pre">Emin</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code> を越えた場合に発生します。可能な場合には、係数部にゼロを加えた表現に合わせて指数部を減らします。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DecimalException">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DecimalException</code><a class="headerlink" href="#decimal.DecimalException" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>他のシグナルの基底クラスで、 <a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code></a> のサブクラスです。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DivisionByZero">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DivisionByZero</code><a class="headerlink" href="#decimal.DivisionByZero" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>有限値をゼロで除算したときのシグナルです。</p>
<p>除算やモジュロ除算、数を負の値で累乗した場合に起きることがあります。このシグナルをトラップしない場合、演算結果は <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> または <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code> になり、その符号は演算に使った入力に基づいて決まります。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Inexact">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Inexact</code><a class="headerlink" href="#decimal.Inexact" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値の丸めによって演算結果から厳密さが失われたことを通知します。</p>
<p>このシグナルは値丸め操作中にゼロでない桁を無視した際に生じます。演算結果は値丸め後の値です。シグナルのフラグやトラップは、演算結果の厳密さが失われたことを検出するために使えるだけです。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.InvalidOperation">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">InvalidOperation</code><a class="headerlink" href="#decimal.InvalidOperation" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>無効な演算が実行されたことを通知します。</p>
<p>ユーザが有意な演算結果にならないような操作を要求したことを示します。このシグナルをトラップしない場合、 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> を返します。このシグナルの発生原因として考えられるのは、以下のような状況です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="decimal.Overflow">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Overflow</code><a class="headerlink" href="#decimal.Overflow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>数値オーバフローを示すシグナルです。</p>
<p>このシグナルは、値丸めを行った後の指数部が <code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code> より大きいことを示します。シグナルをトラップしない場合、演算結果は値丸めのモードにより、表現可能な最大の数値になるように内側へ引き込んで丸めを行った値か、 <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> になるように外側に丸めた値のいずれかになります。いずれの場合も、 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal"><span class="pre">Inexact</span></code></a> および <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal"><span class="pre">Rounded</span></code></a> が同時にシグナルされます。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Rounded">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Rounded</code><a class="headerlink" href="#decimal.Rounded" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>情報が全く失われていない場合も含み、値丸めが起きたときのシグナルです。</p>
<p>このシグナルは、値丸めによって桁がなくなると常に発生します。なくなった桁がゼロ (例えば <code class="xref py py-const docutils literal"><span class="pre">5.00</span></code> を丸めて <code class="xref py py-const docutils literal"><span class="pre">5.0</span></code> になった場合) であってもです。このシグナルをトラップしなければ、演算結果をそのまま返します。このシグナルは有効桁数の減少を検出する際に使います。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Subnormal">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Subnormal</code><a class="headerlink" href="#decimal.Subnormal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値丸めを行う前に指数部が <code class="xref py py-attr docutils literal"><span class="pre">Emin</span></code> より小さかったことを示すシグナルです。</p>
<p>演算結果が微小である場合 (指数が小さすぎる場合) に発生します。このシグナルをトラップしなければ、演算結果をそのまま返します。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Underflow">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Underflow</code><a class="headerlink" href="#decimal.Underflow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>演算結果が値丸めによってゼロになった場合に生じる数値アンダフローです。</p>
<p>演算結果が微小なため、値丸めによってゼロになった場合に発生します。 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal"><span class="pre">Inexact</span></code></a> および <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal"><span class="pre">Subnormal</span></code></a> シグナルも同時に発生します。</p>
</dd></dl>

<dl class="class">
<dt id="decimal.FloatOperation">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">FloatOperation</code><a class="headerlink" href="#decimal.FloatOperation" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>float と Decimal の混合の厳密なセマンティクスを有効にします。</p>
<p>シグナルがトラップされなかった場合 (デフォルト)、<a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> コンストラクタ、 <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal"><span class="pre">create_decimal()</span></code></a> 、およびすべての比較演算子において float と Decimal の混合が許されます。変換も比較も正確です。コンテキストフラグ内に <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> を設定することで、混合操作は現れるたびに暗黙に記録されます。 <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal"><span class="pre">from_float()</span></code></a> や <a class="reference internal" href="#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal"><span class="pre">create_decimal_from_float()</span></code></a> による明示的な変換はフラグを設定しません。</p>
<p>そうでなければ (シグナルがトラップされれば)、等価性比較および明示的な変換のみが静かにに行われ、その他の混合演算は <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> を送出します。</p>
</dd></dl>

<p>これらのシグナルの階層構造をまとめると、以下の表のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="floating-point-notes">
<span id="decimal-notes"></span><h2>9.4.7. 浮動小数点数に関する注意<a class="headerlink" href="#floating-point-notes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="mitigating-round-off-error-with-increased-precision">
<h3>9.4.7.1. 精度を上げて丸め誤差を抑制する<a class="headerlink" href="#mitigating-round-off-error-with-increased-precision" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>十進浮動小数点数を使うと、十進数表現による誤差を抑制できます (<code class="xref py py-const docutils literal"><span class="pre">0.1</span></code> を正確に表現できるようになります); しかし、ゼロでない桁が一定の精度を越えている場合には、演算によっては依然として値丸めによる誤差を引き起こします。</p>
<p>値丸めによる誤差の影響は、桁落ちを生じるような、ほとんど相殺される量での加算や減算によって増幅されます。Knuth は、十分でない計算精度の下で値丸めを伴う浮動小数点演算を行った結果、加算の結合則や分配則における恒等性が崩れてしまう例を二つ示しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;9.5111111&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.01&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.0060000&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールでは、最下桁を失わないように十分に計算精度を広げることで、上で問題にしたような恒等性をとりもどせます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="special-values">
<h3>9.4.7.2. 特殊値<a class="headerlink" href="#special-values" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールの数体系では、 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>, <code class="xref py py-const docutils literal"><span class="pre">sNaN</span></code>, <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>, および二つのゼロ、 <code class="xref py py-const docutils literal"><span class="pre">+0</span></code> と <code class="xref py py-const docutils literal"><span class="pre">-0</span></code> といった特殊な値を提供しています。</p>
<p>無限大 (Infinity) は <code class="docutils literal"><span class="pre">Decimal('Infinity')</span></code> で直接構築できます。また、 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal"><span class="pre">DivisionByZero</span></code></a> をトラップせずにゼロで除算を行った場合にも出てきます。同様に、 <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal"><span class="pre">Overflow</span></code></a> シグナルをトラップしなければ、表現可能な最大の数値の制限を越えた値を丸めたときに出てきます。</p>
<p>無限大には符号があり (アフィン: affine であり)、算術演算に使用でき、非常に巨大で不確定の(indeterminate)値として扱われます。例えば、無限大に何らかの定数を加算すると、演算結果は別の無限大になります。</p>
<p>演算によっては結果が不確定になるものがあり、 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> を返します。ただし、 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal"><span class="pre">InvalidOperation</span></code></a> シグナルをトラップするようになっていれば例外を送出します。例えば、 <code class="docutils literal"><span class="pre">0/0</span></code> は <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> を返します。 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> は「非数値 (not a number)」を表します。このような <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> は暗黙のうちに生成され、一度生成されるとそれを他の計算にも流れてゆき、関係する個々の演算全てが個別の <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> を返すようになります。この挙動は、たまに入力値が欠けるような状況で一連の計算を行う際に便利です — 特定の計算に対しては無効な結果を示すフラグを立てつつ計算を進められるからです。</p>
<p>一方、 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> の変種である <code class="xref py py-const docutils literal"><span class="pre">sNaN</span></code> は関係する全ての演算で演算後にシグナルを送出します。 <code class="xref py py-const docutils literal"><span class="pre">sNaN</span></code> は、無効な演算結果に対して特別な処理を行うために計算を停止する必要がある場合に便利です。</p>
<p>Python の比較演算は <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> が関わってくると少し驚くようなことがあります。等価性のテストの一方の対象が無言または発信 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> である場合いつでも <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返し(たとえ <code class="docutils literal"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code> でも)、一方で不等価をテストするといつでも <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を返します。二つの Decimal を <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> または <code class="docutils literal"><span class="pre">&gt;=</span></code> を使って比較する試みは一方が <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> である場合には <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal"><span class="pre">InvalidOperation</span></code></a> シグナルを送出し、このシグナルをトラップしなければ結果は <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> に終わります。汎用十進演算仕様は直接の比較の振る舞いについて定めていないことに注意しておきましょう。ここでの <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> が関係する比較ルールは IEEE 854 標準から持ってきました (section 5.7 の Table 3 を見て下さい)。厳格に標準遵守を貫くなら、 <code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">compare-signal()</span></code> メソッドを代わりに使いましょう。</p>
<p>アンダフローの起きた計算は、符号付きのゼロ (signed zero) を返すことがあります。符号は、より高い精度で計算を行った結果の符号と同じになります。符号付きゼロの大きさはやはりゼロなので、正のゼロと負のゼロは等しいとみなされ、符号は単なる参考にすぎません。</p>
<p>二つの符号付きゼロが区別されているのに等価であることに加えて、異なる精度におけるゼロの表現はまちまちなのに、値は等価とみなされるということがあります。これに慣れるには多少時間がかかります。正規化浮動小数点表現に目が慣れてしまうと、以下の計算でゼロに等しい値が返っているとは即座に分かりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;0E-1000026&#39;)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="working-with-threads">
<span id="decimal-threads"></span><h2>9.4.8. スレッドを使った処理<a class="headerlink" href="#working-with-threads" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> は、スレッド毎に別々の <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> オブジェクトにアクセスします。別のスレッドコンテキストを持つということは、複数のスレッドが互いに影響を及ぼさずに (<code class="docutils literal"><span class="pre">getcontext().prec=10</span></code> のような) 変更を適用できるということです。</p>
<p>同様に、<a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> 関数は自動的に引数のコンテキストを現在のスレッドのコンテキストに設定します。</p>
<p><a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> を呼び出す前に <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> が呼び出されていなければ、現在のスレッドで使うための新たなコンテキストを生成するために <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> が自動的に呼び出されます。</p>
<p>新たなコンテキストは、<em>DefaultContext</em> と呼ばれる雛形からコピーされます。アプリケーションを通じて全てのスレッドに同じ値を使うようにデフォルトを設定したければ、<em>DefaultContext</em> オブジェクトを直接変更します。 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> を呼び出すスレッド間で競合条件が生じないようにするため、<em>DefaultContext</em> への変更はいかなるスレッドを開始するよりも <em>前に</em> 行わなければなりません。以下に例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Set applicationwide defaults for all threads about to be launched</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># Afterwards, the threads can be started</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="recipes">
<span id="decimal-recipes"></span><h2>9.4.9. レシピ<a class="headerlink" href="#recipes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> クラスの利用を実演している例をいくつか示します。これらはユーティリティ関数としても利用できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Decimal to a money formatted string.</span>

<span class="sd">    places:  required number of places after the decimal point</span>
<span class="sd">    curr:    optional currency symbol before the sign (may be blank)</span>
<span class="sd">    sep:     optional grouping separator (comma, period, space, or blank)</span>
<span class="sd">    dp:      decimal point indicator (comma or period)</span>
<span class="sd">             only specify as blank when places is zero</span>
<span class="sd">    pos:     optional sign for positive numbers: &#39;+&#39;, space or blank</span>
<span class="sd">    neg:     optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank</span>
<span class="sd">    trailneg:optional trailing minus indicator:  &#39;-&#39;, &#39;)&#39;, space or blank</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)</span>
<span class="sd">    &#39;-$1,234,567.89&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)</span>
<span class="sd">    &#39;1.234.568-&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)</span>
<span class="sd">    &#39;($1,234,567.89)&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)</span>
<span class="sd">    &#39;123 456 789.00&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)</span>
<span class="sd">    &#39;&lt;0.02&gt;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; &#39;0.01&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute Pi to the current precision.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># extra digits for intermediate steps</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># substitute &quot;three=3.0&quot; for regular floats</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># unary plus applies the new precision</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return e raised to the power of x.  Result type matches input type.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the cosine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the sine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="decimal-faq">
<span id="id1"></span><h2>9.4.10. Decimal FAQ<a class="headerlink" href="#decimal-faq" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Q. <code class="docutils literal"><span class="pre">decimal.Decimal('1234.5')</span></code> などと打ち込むのは煩わしいのですが、対話式インタプリタを使う際にタイプ量を少なくする方法はありませんか?</p>
<p>A. コンストラクタを1文字に縮める人もいるようです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">&#39;1.23&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;3.45&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.68&#39;)</span>
</pre></div>
</div>
<p>Q. 小数点以下2桁の固定小数点数のアプリケーションの中で、いくつかの入力が余計な桁を保持しているのでこれを丸めなければなりません。その他のものに余計な桁はなくそのまま使えます。どのメソッドを使うのがいいでしょうか?</p>
<p>A. <code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> メソッドで固定した桁に丸められます。 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a> トラップを設定しておけば、確認にも有用です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># same as Decimal(&#39;0.01&#39;)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Round to two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Validate that a number does not exceed two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<p>Q. 正当な2桁の入力が得られたとして、その正当性をアプリケーション実行中も変わらず保ち続けるにはどうすればいいでしょうか?</p>
<p>A. 加減算あるいは整数との乗算のような演算は自動的に固定小数点を守ります。その他の除算や整数以外の乗算などは小数点以下の桁を変えてしまいますので実行後は <code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> ステップが必要です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;102.72&#39;</span><span class="p">)</span>           <span class="c1"># Initial fixed-point values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.17&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># Addition preserves fixed-point</span>
<span class="go">Decimal(&#39;105.89&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal(&#39;99.55&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># So does integer multiplication</span>
<span class="go">Decimal(&#39;4314.24&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># Must quantize non-integer multiplication</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># And quantize division</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>固定小数点のアプリケーションを開発する際は、 <code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> の段階を扱う関数を定義しておくと便利です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># Automatically preserve fixed-point</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>Q. 一つの値に対して多くの表現方法があります。 <code class="xref py py-const docutils literal"><span class="pre">200</span></code> と <code class="xref py py-const docutils literal"><span class="pre">200.000</span></code> と <code class="xref py py-const docutils literal"><span class="pre">2E2</span></code> と <code class="xref py py-const docutils literal"><span class="pre">02E+4</span></code> は全て同じ値で違った精度の数です。これらをただ一つの正規化された値に変換することはできますか?</p>
<p>A. <code class="xref py py-meth docutils literal"><span class="pre">normalize()</span></code> メソッドは全ての等しい値をただ一つの表現に直します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;200 200.000 2E2 .02E+4&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</span>
</pre></div>
</div>
<p>Q. ある種の十進数値はいつも指数表記で表示されます。指数表記以外の表示にする方法はありますか?</p>
<p>A. 値によっては、指数表記だけが有効桁数を表せる表記法なのです。たとえば、 <code class="xref py py-const docutils literal"><span class="pre">5.0E+3</span></code> を <code class="xref py py-const docutils literal"><span class="pre">5000</span></code> と表してしまうと、値は変わりませんが元々の2桁という有効数字が反映されません。</p>
<p>もしアプリケーションが有効数字の追跡を等閑視するならば、指数部や末尾のゼロを取り除き、有効数字を忘れ、しかし値を変えずにおくことは容易です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;5E+3&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;5000&#39;)</span>
</pre></div>
</div>
<p>Q. 普通の float を <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> に変換できますか?</p>
<p>A. はい。どんな 2 進浮動小数点数も Decimal として正確に表現できます。ただし、正確な変換は直感的に考えたよりも多い桁になることがあります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</span>
</pre></div>
</div>
<p>Q. 複雑な計算の中で、精度不足や丸めの異常で間違った結果になっていないことをどうやって保証すれば良いでしょうか。</p>
<p>A. decimal モジュールでは検算は容易です。一番良い方法は、大きめの精度や様々な丸めモードで再計算してみることです。大きく異なった結果が出てきたら、精度不足や丸めの問題や悪条件の入力、または数値計算的に不安定なアルゴリズムを示唆しています。</p>
<p>Q. コンテキストの精度は計算結果には適用されていますが入力には適用されていないようです。様々に異なる精度の入力値を混ぜて計算する時に注意すべきことはありますか?</p>
<p>A. はい。原則として入力値は正確であると見做しておりそれらの値を使った計算も同様です。結果だけが丸められます。入力の強みは &quot;what you type is what you get&quot; (打ち込んだ値が得られる値)という点にあります。入力が丸められないということを忘れていると結果が奇妙に見えるというのは弱点です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.20&#39;)</span>
</pre></div>
</div>
<p>解決策は、精度を増やすか、単項プラス演算子を使って入力の丸めを強制することです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23456789&#39;</span><span class="p">)</span>      <span class="c1"># unary plus triggers rounding</span>
<span class="go">Decimal(&#39;1.23&#39;)</span>
</pre></div>
</div>
<p>もしくは、入力を <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal"><span class="pre">Context.create_decimal()</span></code></a> を使って生成時に丸めてしまうこともできます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.2345678&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.2345&#39;)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.4. <code class="docutils literal"><span class="pre">decimal</span></code> — 十進固定及び浮動小数点数の算術演算</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">9.4.1. クイックスタートチュートリアル</a></li>
<li><a class="reference internal" href="#decimal-objects">9.4.2. Decimal オブジェクト</a><ul>
<li><a class="reference internal" href="#logical-operands">9.4.2.1. 論理引数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">9.4.3. Context オブジェクト</a></li>
<li><a class="reference internal" href="#constants">9.4.4. 定数</a></li>
<li><a class="reference internal" href="#rounding-modes">9.4.5. 丸めモード</a></li>
<li><a class="reference internal" href="#signals">9.4.6. シグナル</a></li>
<li><a class="reference internal" href="#floating-point-notes">9.4.7. 浮動小数点数に関する注意</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">9.4.7.1. 精度を上げて丸め誤差を抑制する</a></li>
<li><a class="reference internal" href="#special-values">9.4.7.2. 特殊値</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">9.4.8. スレッドを使った処理</a></li>
<li><a class="reference internal" href="#recipes">9.4.9. レシピ</a></li>
<li><a class="reference internal" href="#decimal-faq">9.4.10. Decimal FAQ</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="cmath.html"
                        title="前の章へ">9.3. <code class="docutils literal"><span class="pre">cmath</span></code> — 複素数のための数学関数</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="fractions.html"
                        title="次の章へ">9.5. <code class="docutils literal"><span class="pre">fractions</span></code> — 有理数</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/decimal.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="9.5. fractions — 有理数"
             >次へ</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="9.3. cmath — 複素数のための数学関数"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" >9. 数値と数学モジュール</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 4月 18, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>