<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>17.2. multiprocessing — プロセスベースの並列処理 &#8212; Python 3.6.0 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.0 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.0 ドキュメント" href="../contents.html" />
    <link rel="up" title="17. 並行実行" href="concurrency.html" />
    <link rel="next" title="17.3. concurrent パッケージ" href="concurrent.html" />
    <link rel="prev" title="17.1. threading — スレッドベースの並列処理" href="threading.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/multiprocessing.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/multiprocessing.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="concurrent.html" title="17.3. concurrent パッケージ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="threading.html" title="17.1. threading — スレッドベースの並列処理"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.0</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concurrency.html" accesskey="U">17. 並行実行</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-multiprocessing">
<span id="multiprocessing-process-based-parallelism"></span><h1>17.2. <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> &#8212; プロセスベースの並列処理<a class="headerlink" href="#module-multiprocessing" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/multiprocessing/">Lib/multiprocessing/</a></p>
<hr class="docutils" />
<div class="section" id="introduction">
<h2>17.2.1. はじめに<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> は、 <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> と似た API で複数のプロセスの生成をサポートするパッケージです。 <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> パッケージは、ローカルとリモート両方の並行処理を提供します。また、このパッケージはスレッドの代わりにサブプロセスを使用することにより、<a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">グローバルインタープリタロック</span></a> の問題を避ける工夫が行われています。このような特徴があるため <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールを使うことで、マルチプロセッサーマシンの性能を最大限に活用することができるでしょう。なお、このモジュールは Unix と Windows の両方で動作します。</p>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールでは、<a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールには似たものが存在しない API も導入されています。その最たるものが <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">Pool</span></code></a> オブジェクトです。これは複数の入力データに対して、サブプロセス群に入力データを分配 (データ並列) して関数を並列実行するのに便利な手段を提供します。以下の例では、モジュール内で関数を定義して、子プロセスがそのモジュールを正常にインポートできるようにする一般的な方法を示します。 <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">Pool</span></code></a> を用いたデータ並列の基礎的な例は次の通りです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>標準出力に以下が出力されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="the-process-class">
<h3>17.2.1.1. <code class="xref py py-class docutils literal"><span class="pre">Process</span></code> クラス<a class="headerlink" href="#the-process-class" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールでは、プロセスは以下の手順によって生成されます。はじめに <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> のオブジェクトを作成し、続いて <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> メソッドを呼び出します。この <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> クラスは <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">threading.Thread</span></code></a> クラスと同様の API を持っています。まずは、簡単な例をもとにマルチプロセスを使用したプログラムについてみていきましょう</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>実行された個々のプロセス ID を表示するために拡張したサンプルコードを以下に示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;module name:&#39;</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parent process:&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;process id:&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">info</span><span class="p">(</span><span class="s1">&#39;function f&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">info</span><span class="p">(</span><span class="s1">&#39;main line&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>なぜ <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> という記述が必要かは <a class="reference internal" href="#multiprocessing-programming"><span class="std std-ref">プログラミングガイドライン</span></a> を参照してください。</p>
</div>
<div class="section" id="contexts-and-start-methods">
<h3>17.2.1.2. コンテキストと開始方式<a class="headerlink" href="#contexts-and-start-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="multiprocessing-start-methods">プラットフォームにもよりますが、<a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> はプロセスを開始するために 3 つの方法をサポートしています。それら <em>開始方式</em> は以下のとおりです</p>
<blockquote>
<div><dl class="docutils">
<dt><em>spawn</em></dt>
<dd><p class="first">親プロセスは新たに python インタープリタープロセスを開始します。子プロセスはプロセスオブジェクトの <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドの実行に必要なリソースのみ継承します。特に、親プロセスからの不要なファイル記述子とハンドルは継承されません。この方式を使用したプロセスの開始は <em>fork</em> や <em>forkserver</em> に比べ遅くなります。</p>
<p class="last">Unix と Windows で利用可能。Windows でのデフォルト。</p>
</dd>
<dt><em>fork</em></dt>
<dd><p class="first">親プロセスは <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">os.fork()</span></code></a> を使用して Python インタープリターをフォークします。子プロセスはそれが開始されるとき、事実上親プロセスと同一になります。親プロセスのリソースはすべて子プロセスに継承されます。マルチスレッドプロセスのフォークは安全性に問題があることに注意してください。</p>
<p class="last">Unix でのみ利用可能。Unix でのデフォルト。</p>
</dd>
<dt><em>forkserver</em></dt>
<dd><p class="first">プログラムを開始するとき <em>forkserver</em> 方式を選択した場合、サーバープロセスが開始されます。それ以降、新しいプロセスが必要になったときはいつでも、親プロセスはサーバーに接続し、新しいプロセスのフォークを要求します。フォークサーバープロセスはシングルスレッドなので <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">os.fork()</span></code></a> の使用に関しても安全です。不要なリソースは継承されません。</p>
<p class="last">Unix パイプを経由したファイル記述子の受け渡しをサポートする Unix で利用可能。</p>
</dd>
</dl>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>すべての Unix プラットフォームで <em>spawn</em> が、一部のプラットフォームで <em>forkserver</em> が追加されました。Windows では親プロセスの継承可能な全ハンドルが子プロセスに継承されることがなくなりました。</p>
</div>
<p>Unix で開始方式に <em>spawn</em> あるいは <em>forkserver</em> を使用した場合は、プログラムのプロセスによって作成されたリンクされていない名前付きセマフォを追跡する <em>セマフォトラッカー</em> プロセスも開始されます。全プロセスが終了したときにセマフォトラッカーは残っているあらゆるセマフォのリンクを解除します。通常そういったことはないのですが、プロセスがシグナルによって kill されたときに &#8220;漏れた&#8221; セマフォが発生する場合があります。(名前付きセマフォのリンク解除は、システムが個数の上限のみ許可している場合に深刻な問題になるため、それらは再起動されるまで自動的にリンク解除されることはありません。)</p>
<p>開始方式はメインモジュールの <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 節内で、関数 <a class="reference internal" href="#multiprocessing.set_start_method" title="multiprocessing.set_start_method"><code class="xref py py-func docutils literal"><span class="pre">set_start_method()</span></code></a> によって指定します。以下に例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">mp</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>関数 <a class="reference internal" href="#multiprocessing.set_start_method" title="multiprocessing.set_start_method"><code class="xref py py-func docutils literal"><span class="pre">set_start_method()</span></code></a> はプログラム内で複数回使用してはいけません。</p>
<p>もうひとつの方法として、<a class="reference internal" href="#multiprocessing.get_context" title="multiprocessing.get_context"><code class="xref py py-func docutils literal"><span class="pre">get_context()</span></code></a> を使用してコンテキストオブジェクトを取得することができます。コンテキストオブジェクトは multiprocessing モジュールと同じ API を持ち、同じプログラム内で複数の開始方式を使用できます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>あるコンテキストに関連したオブジェクトは異なるコンテキストのプロセスとは互換性がない場合があることに注意してください。特に、<em>fork</em> コンテキストを使用して作成されたロックは、<em>spawn</em> あるいは <em>forkserver</em> を使用して開始されたプロセスに渡すことはできません。</p>
<p>特定の開始方式の使用を要求するライブラリは <a class="reference internal" href="#multiprocessing.get_context" title="multiprocessing.get_context"><code class="xref py py-func docutils literal"><span class="pre">get_context()</span></code></a> を使用してライブラリ利用者の選択を阻害しないようにするべきです。</p>
</div>
<div class="section" id="exchanging-objects-between-processes">
<h3>17.2.1.3. プロセス間でのオブジェクト交換<a class="headerlink" href="#exchanging-objects-between-processes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールでは、プロセス間通信の手段が2つ用意されています。それぞれ以下に詳細を示します:</p>
<p><strong>キュー (Queue)</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> クラスは <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">queue.Queue</span></code></a> クラスとほとんど同じように使うことができます。以下に例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">])</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>    <span class="c1"># prints &quot;[42, None, &#39;hello&#39;]&quot;</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>キューはスレッドセーフであり、プロセスセーフです。</p>
</div></blockquote>
<p><strong>パイプ (Pipe)</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal"><span class="pre">Pipe()</span></code></a> 関数はパイプで繋がれたコネクションオブジェクトのペアを返します。デフォルトでは双方向性パイプを返します。以下に例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">])</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">parent_conn</span><span class="p">,</span> <span class="n">child_conn</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">child_conn</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">parent_conn</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>   <span class="c1"># prints &quot;[42, None, &#39;hello&#39;]&quot;</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>パイプのそれぞれの端を表す2つのコネクションオブジェクトが <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal"><span class="pre">Pipe()</span></code></a> 関数から返されます。各コネクションオブジェクトには、 <a class="reference internal" href="#multiprocessing.Connection.send" title="multiprocessing.Connection.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a>、 <a class="reference internal" href="#multiprocessing.Connection.recv" title="multiprocessing.Connection.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a>、その他のメソッドがあります。2つのプロセス (またはスレッド) がパイプの <em>同じ</em> 端で同時に読み込みや書き込みを行うと、パイプ内のデータが破損してしまうかもしれないことに注意してください。もちろん、各プロセスがパイプの別々の端を同時に使用するならば、データが破壊される危険性はありません。</p>
</div></blockquote>
</div>
<div class="section" id="synchronization-between-processes">
<h3>17.2.1.4. プロセス間の同期<a class="headerlink" href="#synchronization-between-processes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> は <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールと等価な同期プリミティブを備えています。以下の例では、ロックを使用して、一度に1つのプロセスしか標準出力に書き込まないようにしています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">l</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">l</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>ロックを使用しないで標準出力に書き込んだ場合は、各プロセスからの出力がごちゃまぜになってしまいます。</p>
</div>
<div class="section" id="sharing-state-between-processes">
<h3>17.2.1.5. プロセス間での状態の共有<a class="headerlink" href="#sharing-state-between-processes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これまでの話の流れで触れたとおり、並行プログラミングを行うときには、できるかぎり状態を共有しないのが定石です。複数のプロセスを使用するときは特にそうでしょう。</p>
<p>しかし、どうしてもプロセス間のデータ共有が必要な場合のために <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールには2つの方法が用意されています。</p>
<p><strong>共有メモリ (Shared memory)</strong></p>
<blockquote>
<div><p>データを共有メモリ上に保持するために <a class="reference internal" href="#multiprocessing.Value" title="multiprocessing.Value"><code class="xref py py-class docutils literal"><span class="pre">Value</span></code></a> クラス、もしくは <a class="reference internal" href="#multiprocessing.Array" title="multiprocessing.Array"><code class="xref py py-class docutils literal"><span class="pre">Array</span></code></a> クラスを使用することができます。以下のサンプルコードを使って、この機能についてみていきましょう</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Array</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">3.1415927</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">arr</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:])</span>
</pre></div>
</div>
<p>このサンプルコードを実行すると以下のように表示されます</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="mf">3.1415927</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">num</span></code> と <code class="docutils literal"><span class="pre">arr</span></code> を生成するときに使用されている、引数 <code class="docutils literal"><span class="pre">'d'</span></code> と <code class="docutils literal"><span class="pre">'i'</span></code> は <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> モジュールにより使用される種別の型コードです。ここで使用されている <code class="docutils literal"><span class="pre">'d'</span></code> は倍精度浮動小数、 <code class="docutils literal"><span class="pre">'i'</span></code> は符号付整数を表します。これらの共有オブジェクトは、プロセスセーフでありスレッドセーフです。</p>
<p>共有メモリを使用して、さらに柔軟なプログラミングを行うには <a class="reference internal" href="#module-multiprocessing.sharedctypes" title="multiprocessing.sharedctypes: Allocate ctypes objects from shared memory."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.sharedctypes</span></code></a> モジュールを使用します。このモジュールは共有メモリから割り当てられた任意の ctypes オブジェクトの生成をサポートします。</p>
</div></blockquote>
<p><strong>サーバープロセス (Server process)</strong></p>
<blockquote>
<div><p><code class="xref py py-func docutils literal"><span class="pre">Manager()</span></code> 関数により生成されたマネージャーオブジェクトはサーバープロセスを管理します。マネージャーオブジェクトは Python のオブジェクトを保持して、他のプロセスがプロキシ経由でその Python オブジェクトを操作することができます。</p>
<p><code class="xref py py-func docutils literal"><span class="pre">Manager()</span></code> 関数が返すマネージャは <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#multiprocessing.managers.Namespace" title="multiprocessing.managers.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a>, <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a>, <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a>, <a class="reference internal" href="#multiprocessing.Semaphore" title="multiprocessing.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">Semaphore</span></code></a>, <a class="reference internal" href="#multiprocessing.BoundedSemaphore" title="multiprocessing.BoundedSemaphore"><code class="xref py py-class docutils literal"><span class="pre">BoundedSemaphore</span></code></a>, <a class="reference internal" href="#multiprocessing.Condition" title="multiprocessing.Condition"><code class="xref py py-class docutils literal"><span class="pre">Condition</span></code></a>, <a class="reference internal" href="#multiprocessing.Event" title="multiprocessing.Event"><code class="xref py py-class docutils literal"><span class="pre">Event</span></code></a>, <a class="reference internal" href="#multiprocessing.Barrier" title="multiprocessing.Barrier"><code class="xref py py-class docutils literal"><span class="pre">Barrier</span></code></a>, <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a>, <a class="reference internal" href="#multiprocessing.Value" title="multiprocessing.Value"><code class="xref py py-class docutils literal"><span class="pre">Value</span></code></a>, <a class="reference internal" href="#multiprocessing.Array" title="multiprocessing.Array"><code class="xref py py-class docutils literal"><span class="pre">Array</span></code></a> をサポートします。 以下にサンプルコードを示します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Manager</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">d</span><span class="p">[</span><span class="mf">0.25</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</pre></div>
</div>
<p>このサンプルコードを実行すると以下のように表示されます</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mf">0.25</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>サーバープロセスのマネージャーオブジェクトは共有メモリのオブジェクトよりも柔軟であるといえます。それは、どのような型のオブジェクトでも使えるからです。また、1つのマネージャーオブジェクトはネットワーク経由で他のコンピューター上のプロセスによって共有することもできます。しかし、共有メモリより動作が遅いという欠点があります。</p>
</div></blockquote>
</div>
<div class="section" id="using-a-pool-of-workers">
<h3>17.2.1.6. ワーカープロセスのプールを使用<a class="headerlink" href="#using-a-pool-of-workers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">Pool</span></code></a> クラスは、ワーカープロセスをプールする機能を備えています。このクラスには、異なる方法でワーカープロセスへタスクを割り当てるいくつかのメソッドがあります。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="ne">TimeoutError</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># start 4 worker processes</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>

        <span class="c1"># print &quot;[0, 1, 4,..., 81]&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>

        <span class="c1"># print same numbers in arbitrary order</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># evaluate &quot;f(20)&quot; asynchronously</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,))</span>      <span class="c1"># runs in *only* one process</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>             <span class="c1"># prints &quot;400&quot;</span>

        <span class="c1"># evaluate &quot;os.getpid()&quot; asynchronously</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">,</span> <span class="p">())</span> <span class="c1"># runs in *only* one process</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>             <span class="c1"># prints the PID of that process</span>

        <span class="c1"># launching multiple evaluations asynchronously *may* use more processes</span>
        <span class="n">multiple_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">,</span> <span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">multiple_results</span><span class="p">])</span>

        <span class="c1"># make a single worker sleep for 10 secs</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We lacked patience and got a multiprocessing.TimeoutError&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For the moment, the pool remains available for more work&quot;</span><span class="p">)</span>

    <span class="c1"># exiting the &#39;with&#39;-block has stopped the pool</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now the pool is closed and no longer available&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>プールオブジェクトのメソッドは、そのプールを作成したプロセスのみが呼び出すべきです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>このパッケージに含まれる機能を使用するためには、子プロセスから <code class="docutils literal"><span class="pre">__main__</span></code> モジュールをインポートできる必要があります。このことについては <a class="reference internal" href="#multiprocessing-programming"><span class="std std-ref">プログラミングガイドライン</span></a> で触れていますが、ここであらためて強調しておきます。なぜかというと、いくつかのサンプルコード、例えば <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">multiprocessing.pool.Pool</span></code></a> のサンプルはインタラクティブシェル上では動作しないからです。以下に例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">Process PoolWorker-1:</span>
<span class="go">Process PoolWorker-2:</span>
<span class="go">Process PoolWorker-3:</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;module&#39; object has no attribute &#39;f&#39;</span>
<span class="go">AttributeError: &#39;module&#39; object has no attribute &#39;f&#39;</span>
<span class="go">AttributeError: &#39;module&#39; object has no attribute &#39;f&#39;</span>
</pre></div>
</div>
<p class="last">(このサンプルを試すと、3つのトレースバックすべてがほぼランダムに交互に重なって表示されます。そうなったら、なんとかしてマスタープロセスを止めましょう。)</p>
</div>
</div>
</div>
<div class="section" id="reference">
<h2>17.2.2. リファレンス<a class="headerlink" href="#reference" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> パッケージは <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールの API とほとんど同じです。</p>
<div class="section" id="process-and-exceptions">
<h3>17.2.2.1. <code class="xref py py-class docutils literal"><span class="pre">Process</span></code> クラスと例外<a class="headerlink" href="#process-and-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="multiprocessing.Process">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Process</code><span class="sig-paren">(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>*</em>, <em>daemon=None</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Process オブジェクトは各プロセスの処理を表します。 <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> クラスは <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">threading.Thread</span></code></a> クラスのすべてのメソッドと同じインタフェースを提供します。</p>
<p>コンストラクターは必ずキーワード引数で呼び出すべきです。引数 <em>group</em> には必ず <code class="docutils literal"><span class="pre">None</span></code> を渡してください。 この引数は <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">threading.Thread</span></code></a> クラスとの互換性のためだけに残されています。引数 <em>target</em> には、 <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドから呼び出される callable オブジェクトを渡します。この引数はデフォルトで <code class="docutils literal"><span class="pre">None</span></code> となっており、何も呼び出されません。引数 <em>name</em> にはプロセス名を渡します (詳細は <a class="reference internal" href="#multiprocessing.Process.name" title="multiprocessing.Process.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> を見てください)。 <em>args</em> は対象の呼び出しに対する引数のタプルを渡します。 <em>kwargs</em> は対象の呼び出しに対するキーワード引数の辞書を渡します。もし提供されれば、キーワードのみの <em>daemon</em> 引数はプロセスの <a class="reference internal" href="#multiprocessing.Process.daemon" title="multiprocessing.Process.daemon"><code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code></a> フラグを <code class="docutils literal"><span class="pre">True</span></code> または <code class="docutils literal"><span class="pre">False</span></code> にセットします。 <code class="docutils literal"><span class="pre">None</span></code> の場合 (デフォルト)、このフラグは作成するプロセスから継承されます。</p>
<p>デフォルトでは、<em>target</em> には引数が渡されないようになっています。</p>
<p>サブクラスがコンストラクターをオーバーライドする場合は、そのプロセスに対する処理を行う前に基底クラスのコンストラクター (<code class="xref py py-meth docutils literal"><span class="pre">Process.__init__()</span></code>) を実行しなければなりません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><em>daemon</em> 引数が追加されました。</p>
</div>
<dl class="method">
<dt id="multiprocessing.Process.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.run" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスが実行する処理を表すメソッドです。</p>
<p>このメソッドはサブクラスでオーバーライドすることができます。標準の <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドは、コンストラクターの target 引数として渡された呼び出し可能オブジェクトを呼び出します。もしコンストラクターに <em>args</em> もしくは <em>kwargs</em> 引数が渡されていれば、呼び出すオブジェクトにこれらの引数を渡します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Process.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.start" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスの処理を開始するためのメソッドです。</p>
<p>各 Process オブジェクトに対し、このメソッドが2回以上呼び出されてはいけません。各プロセスでオブジェクトの <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> メソッドを呼び出す準備を行います。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Process.join">
<code class="descname">join</code><span class="sig-paren">(</span><span class="optional">[</span><em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプションの引数 <em>timeout</em> が <code class="docutils literal"><span class="pre">None</span></code> (デフォルト) の場合、 <a class="reference internal" href="#multiprocessing.Process.join" title="multiprocessing.Process.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> メソッドが呼ばれたプロセスは処理が終了するまでブロックします。
<em>timeout</em> が正の数である場合、最大 <em>timeout</em> 秒ブロックします。
プロセスが終了あるいはタイムアウトした場合、メソッドは <code class="docutils literal"><span class="pre">None</span></code> を返すことに注意してください。
プロセスの <a class="reference internal" href="#multiprocessing.Process.exitcode" title="multiprocessing.Process.exitcode"><code class="xref py py-attr docutils literal"><span class="pre">exitcode</span></code></a> を確認し終了したかどうかを判断してください。</p>
<p>1つのプロセスは何回も join されることができます。</p>
<p>プロセスは自分自身を join することはできません。それはデッドロックを引き起こすことがあるからです。プロセスが start される前に join しようとするとエラーが発生します。</p>
</dd></dl>

<dl class="attribute">
<dt id="multiprocessing.Process.name">
<code class="descname">name</code><a class="headerlink" href="#multiprocessing.Process.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスの名前。名前は識別のためだけに使用される文字列です。それ自体には特別な意味はありません。複数のプロセスに同じ名前が与えられても構いません。</p>
<p>最初の名前はコンストラクターによってセットされます。コンストラクターに明示的な名前が渡されない場合、 &#8216;Process-N<sub>1</sub>:N<sub>2</sub>:...:N<sub>k</sub>&#8216; 形式の名前が構築されます。ここでそれぞれの N<sub>k</sub> はその親のN番目の子供です。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Process.is_alive">
<code class="descname">is_alive</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.is_alive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスが実行中かを判別します。</p>
<p>おおまかに言って、プロセスオブジェクトは <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> メソッドを呼び出してから子プロセス終了までの期間が実行中となります。</p>
</dd></dl>

<dl class="attribute">
<dt id="multiprocessing.Process.daemon">
<code class="descname">daemon</code><a class="headerlink" href="#multiprocessing.Process.daemon" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デーモンプロセスであるかのフラグであり、ブール値です。この属性は <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> が呼び出される前に設定されている必要があります。</p>
<p>初期値は作成するプロセスから継承します。</p>
<p>あるプロセスが終了するとき、そのプロセスはその子プロセスであるデーモンプロセスすべてを終了させようとします。</p>
<p>デーモンプロセスは子プロセスを作成できないことに注意してください。もし作成できてしまうと、そのデーモンプロセスの親プロセスが終了したときにデーモンプロセスの子プロセスが孤児になってしまう場合があるからです。さらに言えば、デーモンプロセスはUnix デーモンやサービスでは <strong>なく</strong> 通常のプロセスであり、非デーモンプロセスが終了すると終了されます (そして join されません)。</p>
</dd></dl>

<p><a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal"><span class="pre">threading.Thread</span></code></a> クラスの API に加えて <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> クラスのオブジェクトには以下の属性およびメソッドがあります:</p>
<dl class="attribute">
<dt id="multiprocessing.Process.pid">
<code class="descname">pid</code><a class="headerlink" href="#multiprocessing.Process.pid" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスIDを返します。プロセスの生成前は <code class="docutils literal"><span class="pre">None</span></code> が設定されています。</p>
</dd></dl>

<dl class="attribute">
<dt id="multiprocessing.Process.exitcode">
<code class="descname">exitcode</code><a class="headerlink" href="#multiprocessing.Process.exitcode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>子プロセスの終了コードです。子プロセスがまだ終了していない場合は <code class="docutils literal"><span class="pre">None</span></code> が返されます。負の値 <em>-N</em> は子プロセスがシグナル <em>N</em> で終了したことを表します。</p>
</dd></dl>

<dl class="attribute">
<dt id="multiprocessing.Process.authkey">
<code class="descname">authkey</code><a class="headerlink" href="#multiprocessing.Process.authkey" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスの認証キーです (バイト文字列です)。</p>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールがメインプロセスにより初期化される場合には、 <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal"><span class="pre">os.urandom()</span></code></a> 関数を使用してランダムな値が設定されます。</p>
<p><a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> クラスのオブジェクトの作成時にその親プロセスから認証キーを継承します。もしくは <a class="reference internal" href="#multiprocessing.Process.authkey" title="multiprocessing.Process.authkey"><code class="xref py py-attr docutils literal"><span class="pre">authkey</span></code></a> に別のバイト文字列を設定することもできます。</p>
<p>詳細は <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">認証キー</span></a> を参照してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="multiprocessing.Process.sentinel">
<code class="descname">sentinel</code><a class="headerlink" href="#multiprocessing.Process.sentinel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスが終了するときに &#8220;ready&#8221; となるシステムオブジェクトの数値ハンドル。</p>
<p><a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal"><span class="pre">multiprocessing.connection.wait()</span></code></a> を使用していくつかのイベントを同時に wait したい場合はこの値を使うことができます。それ以外の場合は <a class="reference internal" href="#multiprocessing.Process.join" title="multiprocessing.Process.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を呼ぶ方がより単純です。</p>
<p>Windows においては、これは <code class="docutils literal"><span class="pre">WaitForSingleObject</span></code> および <code class="docutils literal"><span class="pre">WaitForMultipleObjects</span></code> ファミリーの API 呼び出しで使用可能な OS ハンドルです。 Unix においては、これは <a class="reference internal" href="select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal"><span class="pre">select</span></code></a> モジュールのプリミティブで使用可能なファイル記述子です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Process.terminate">
<code class="descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.terminate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスを終了します。Unix 環境では <code class="docutils literal"><span class="pre">SIGTERM</span></code> シグナルを、 Windows 環境では <code class="xref c c-func docutils literal"><span class="pre">TerminateProcess()</span></code> を使用して終了させます。終了ハンドラーや finally 節などは、実行されないことに注意してください。</p>
<p>このメソッドにより終了するプロセスの子孫プロセスは、終了 <em>しません</em> 。そういった子孫プロセスは単純に孤児になります。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">このメソッドの使用時に、関連付けられたプロセスがパイプやキューを使用している場合には、使用中のパイプやキューが破損して他のプロセスから使用できなくなる可能性があります。同様に、プロセスがロックやセマフォなどを取得している場合には、このプロセスが終了してしまうと他のプロセスのデッドロックの原因になるでしょう。</p>
</div>
</dd></dl>

<p>プロセスオブジェクトが作成したプロセスのみが <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a>, <a class="reference internal" href="#multiprocessing.Process.join" title="multiprocessing.Process.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a>, <a class="reference internal" href="#multiprocessing.Process.is_alive" title="multiprocessing.Process.is_alive"><code class="xref py py-meth docutils literal"><span class="pre">is_alive()</span></code></a>, <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal"><span class="pre">terminate()</span></code></a> と <a class="reference internal" href="#multiprocessing.Process.exitcode" title="multiprocessing.Process.exitcode"><code class="xref py py-attr docutils literal"><span class="pre">exitcode</span></code></a> のメソッドを呼び出すべきです。</p>
<p>以下の例では <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> のメソッドの使い方を示しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">multiprocessing</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">is_alive</span><span class="p">())</span>
<span class="go">&lt;Process(Process-1, initial)&gt; False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">is_alive</span><span class="p">())</span>
<span class="go">&lt;Process(Process-1, started)&gt; True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">is_alive</span><span class="p">())</span>
<span class="go">&lt;Process(Process-1, stopped[SIGTERM])&gt; False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">exitcode</span> <span class="o">==</span> <span class="o">-</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="exception">
<dt id="multiprocessing.ProcessError">
<em class="property">exception </em><code class="descclassname">multiprocessing.</code><code class="descname">ProcessError</code><a class="headerlink" href="#multiprocessing.ProcessError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>すべての <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> 例外の基底クラスです。</p>
</dd></dl>

<dl class="exception">
<dt id="multiprocessing.BufferTooShort">
<em class="property">exception </em><code class="descclassname">multiprocessing.</code><code class="descname">BufferTooShort</code><a class="headerlink" href="#multiprocessing.BufferTooShort" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この例外は <a class="reference internal" href="#multiprocessing.Connection.recv_bytes_into" title="multiprocessing.Connection.recv_bytes_into"><code class="xref py py-meth docutils literal"><span class="pre">Connection.recv_bytes_into()</span></code></a> によって発生し、バッファーオブジェクトが小さすぎてメッセージが読み込めないことを示します。</p>
<p><code class="docutils literal"><span class="pre">e</span></code> が <a class="reference internal" href="#multiprocessing.BufferTooShort" title="multiprocessing.BufferTooShort"><code class="xref py py-exc docutils literal"><span class="pre">BufferTooShort</span></code></a> のインスタンスであるとすると、 <code class="docutils literal"><span class="pre">e.args[0]</span></code> はそのメッセージをバイト文字列で与えるものです。</p>
</dd></dl>

<dl class="exception">
<dt id="multiprocessing.AuthenticationError">
<em class="property">exception </em><code class="descclassname">multiprocessing.</code><code class="descname">AuthenticationError</code><a class="headerlink" href="#multiprocessing.AuthenticationError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証エラーがあった場合に送出されます。</p>
</dd></dl>

<dl class="exception">
<dt id="multiprocessing.TimeoutError">
<em class="property">exception </em><code class="descclassname">multiprocessing.</code><code class="descname">TimeoutError</code><a class="headerlink" href="#multiprocessing.TimeoutError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タイムアウトをサポートするメソッドでタイムアウトが過ぎたときに送出されます。</p>
</dd></dl>

</div>
<div class="section" id="pipes-and-queues">
<h3>17.2.2.2. パイプ (Pipe) とキュー (Queue)<a class="headerlink" href="#pipes-and-queues" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数のプロセスを使う場合、一般的にはメッセージパッシングをプロセス間通信に使用し、ロックのような同期プリミティブを使用しないようにします。</p>
<p>メッセージのやりとりのために <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal"><span class="pre">Pipe()</span></code></a> (2つのプロセス間の通信用)、もしくはキュー (複数のメッセージ生成プロセス (producer)、消費プロセス (consumer) の実現用) を使うことができます。</p>
<p>The <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a>, <a class="reference internal" href="#multiprocessing.SimpleQueue" title="multiprocessing.SimpleQueue"><code class="xref py py-class docutils literal"><span class="pre">SimpleQueue</span></code></a> and <a class="reference internal" href="#multiprocessing.JoinableQueue" title="multiprocessing.JoinableQueue"><code class="xref py py-class docutils literal"><span class="pre">JoinableQueue</span></code></a> types
are multi-producer, multi-consumer <abbr title="first-in, first-out">FIFO</abbr>
queues modelled on the <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">queue.Queue</span></code></a> class in the
standard library.  They differ in that <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> lacks the
<a class="reference internal" href="queue.html#queue.Queue.task_done" title="queue.Queue.task_done"><code class="xref py py-meth docutils literal"><span class="pre">task_done()</span></code></a> and <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> methods introduced
into Python 2.5&#8217;s <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">queue.Queue</span></code></a> class.</p>
<p>もし <a class="reference internal" href="#multiprocessing.JoinableQueue" title="multiprocessing.JoinableQueue"><code class="xref py py-class docutils literal"><span class="pre">JoinableQueue</span></code></a> を使用するなら、キューから削除される各タスクのために <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal"><span class="pre">JoinableQueue.task_done()</span></code></a> を呼び出さなければ <strong>なりません</strong> 。さもないと、いつか完了していないタスクを数えるためのセマフォがオーバーフローし、例外を発生させるでしょう。</p>
<p>管理オブジェクトを使用することで共有キューを作成できることも覚えておいてください。詳細は <a class="reference internal" href="#multiprocessing-managers"><span class="std std-ref">マネージャー</span></a> を参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> は、タイムアウトを伝えるために、通常の <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal"><span class="pre">queue.Empty</span></code></a> と <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal"><span class="pre">queue.Full</span></code></a> 例外を使用します。それらは <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> の名前空間では利用できないため、<a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">queue</span></code></a> からインポートする必要があります。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>オブジェクトがキューに追加される際、そのオブジェクトは pickle 化されています。そのため、バックグラウンドのスレッドが後になって下位層のパイプに pickle 化されたデータをフラッシュすることがあります。これにより、少し驚くような結果になりますが、実際に問題になることはないはずです。これが問題になるような状況では、かわりに <a class="reference internal" href="#multiprocessing-managers"><span class="std std-ref">manager</span></a> を使ってキューを作成することができるからです。</p>
<ol class="last arabic simple">
<li><p class="first">空のキューの中にオブジェクトを追加した後、キューの <a class="reference internal" href="#multiprocessing.Queue.empty" title="multiprocessing.Queue.empty"><code class="xref py py-meth docutils literal"><span class="pre">empty()</span></code></a> メソッドが <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返すまでの間にごくわずかな遅延が起きることがあり、<a class="reference internal" href="#multiprocessing.Queue.get_nowait" title="multiprocessing.Queue.get_nowait"><code class="xref py py-meth docutils literal"><span class="pre">get_nowait()</span></code></a> が <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal"><span class="pre">queue.Empty</span></code></a> を発生させることなく制御が呼び出し元に返ってしまうことがあります。</p>
</li>
<li><p class="first">複数のプロセスがオブジェクトをキューに詰めている場合、キューの反対側ではオブジェクトが詰められたのとは違う順序で取得される可能性があります。ただし、同一のプロセスから詰め込まれたオブジェクトは、それらのオブジェクト間では、必ず期待どおりの順序になります。</p>
</li>
</ol>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> を利用しようとしている最中にプロセスを <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal"><span class="pre">Process.terminate()</span></code></a> や <a class="reference internal" href="os.html#os.kill" title="os.kill"><code class="xref py py-func docutils literal"><span class="pre">os.kill()</span></code></a> で終了させる場合、キューにあるデータは破損し易くなります。終了した後で他のプロセスがキューを利用しようとすると、例外を発生させる可能性があります。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>上述したように、もし子プロセスがキューへ要素を追加するなら (かつ <a class="reference internal" href="#multiprocessing.Queue.cancel_join_thread" title="multiprocessing.Queue.cancel_join_thread"><code class="xref py py-meth docutils literal"><span class="pre">JoinableQueue.cancel_join_thread</span></code></a> を使用しないなら) そのプロセスはバッファーされたすべての要素がパイプへフラッシュされるまで終了しません。</p>
<p>これは、そのプロセスを join しようとする場合、キューに追加されたすべての要素が消費されたことが確実でないかぎり、デッドロックを発生させる可能性があることを意味します。似たような現象で、子プロセスが非デーモンプロセスの場合、親プロセスは終了時に非デーモンのすべての子プロセスを join しようとしてハングアップする可能性があります。</p>
<p class="last">マネージャーを使用して作成されたキューではこの問題はありません。詳細は <a class="reference internal" href="#multiprocessing-programming"><span class="std std-ref">プログラミングガイドライン</span></a> を参照してください。</p>
</div>
<p>プロセス間通信におけるキューの使用例を知りたいなら <a class="reference internal" href="#multiprocessing-examples"><span class="std std-ref">使用例</span></a> を参照してください。</p>
<dl class="function">
<dt id="multiprocessing.Pipe">
<code class="descclassname">multiprocessing.</code><code class="descname">Pipe</code><span class="sig-paren">(</span><span class="optional">[</span><em>duplex</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Pipe" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>パイプの両端を表す <a class="reference internal" href="#multiprocessing.Connection" title="multiprocessing.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> オブジェクトのペア <code class="docutils literal"><span class="pre">(conn1,</span> <span class="pre">conn2)</span></code> を返します。</p>
<p><em>duplex</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) ならパイプは双方向性です。<em>duplex</em> が <code class="docutils literal"><span class="pre">False</span></code> ならパイプは一方向性で、<code class="docutils literal"><span class="pre">conn1</span></code> はメッセージの受信専用、<code class="docutils literal"><span class="pre">conn2</span></code> はメッセージの送信専用になります。</p>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.Queue">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Queue</code><span class="sig-paren">(</span><span class="optional">[</span><em>maxsize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>パイプや2～3個のロック/セマフォを使用して実装されたプロセス共有キューを返します。あるプロセスが最初に要素をキューへ追加するとき、バッファーからパイプの中へオブジェクトを転送する供給スレッドが開始されます。</p>
<p>標準ライブラリの <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">queue</span></code></a> モジュールの通常の <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal"><span class="pre">queue.Empty</span></code></a> や <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal"><span class="pre">queue.Full</span></code></a> 例外がタイムアウトを伝えるために送出されます。</p>
<p><a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> は <a class="reference internal" href="queue.html#queue.Queue.task_done" title="queue.Queue.task_done"><code class="xref py py-meth docutils literal"><span class="pre">task_done()</span></code></a> や <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を除く <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">queue.Queue</span></code></a> のすべてのメソッドを実装します。</p>
<dl class="method">
<dt id="multiprocessing.Queue.qsize">
<code class="descname">qsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.qsize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>おおよそのキューのサイズを返します。マルチスレッディング/マルチプロセスの特性上、この数値は信用できません。</p>
<p>これは <code class="docutils literal"><span class="pre">sem_getvalue()</span></code> が実装されていない Mac OS X のような Unix プラットホーム上で <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を発生させる可能性があることを覚えておいてください。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.empty">
<code class="descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.empty" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューが空っぽなら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。マルチスレッディング/マルチプロセシングの特性上、これは信用できません。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.full">
<code class="descname">full</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.full" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューがいっぱいなら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。マルチスレッディング/マルチプロセシングの特性上、これは信用できません。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>block</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.put" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューの中へ obj を追加します。オプションの引数 <em>block</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) 且つ <em>timeout</em> が <code class="docutils literal"><span class="pre">None</span></code> (デフォルト) なら、空きスロットが利用可能になるまで必要であればブロックします。 <em>timeout</em> が正の数なら、最大 <em>timeout</em> 秒ブロックして、その時間内に空きスロットが利用できなかったら <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal"><span class="pre">queue.Full</span></code></a> 例外を発生させます。それ以外 (<em>block</em> が <code class="docutils literal"><span class="pre">False</span></code>) で、空きスロットがすぐに利用可能な場合はキューに要素を追加します。そうでなければ <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal"><span class="pre">queue.Full</span></code></a> 例外が発生します(その場合 <em>timeout</em> は無視されます)。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.put_nowait">
<code class="descname">put_nowait</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.put_nowait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">put(obj,</span> <span class="pre">False)</span></code> と等価です。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.get">
<code class="descname">get</code><span class="sig-paren">(</span><span class="optional">[</span><em>block</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューから要素を取り出して削除します。オプションの引数 <em>block</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) 且つ <em>timeout</em> が <code class="docutils literal"><span class="pre">None</span></code> (デフォルト) なら、要素が取り出せるまで必要であればブロックします。 <em>timeout</em> が正の数なら、最大 <em>timeout</em> 秒ブロックして、その時間内に要素が取り出せなかったら <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal"><span class="pre">queue.Empty</span></code></a> 例外を発生させます。それ以外 (<em>block</em> が <code class="docutils literal"><span class="pre">False</span></code>) で、要素がすぐに取り出せる場合は要素を返します。そうでなければ <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal"><span class="pre">queue.Empty</span></code></a> 例外が発生します(その場合 <em>timeout</em> は無視されます)。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.get_nowait">
<code class="descname">get_nowait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.get_nowait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">get(False)</span></code> と等価です。</p>
</dd></dl>

<p><a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">multiprocessing.Queue</span></code></a> は <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">queue.Queue</span></code></a> にはない追加メソッドがあります。 これらのメソッドは通常、ほとんどのコードに必要ありません:</p>
<dl class="method">
<dt id="multiprocessing.Queue.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>カレントプロセスからこのキューへそれ以上データが追加されないことを表します。バックグラウンドスレッドはパイプへバッファーされたすべてのデータをフラッシュするとすぐに終了します。これはキューがガベージコレクトされるときに自動的に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.join_thread">
<code class="descname">join_thread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.join_thread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バックグラウンドスレッドを join します。このメソッドは <a class="reference internal" href="#multiprocessing.Queue.close" title="multiprocessing.Queue.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> が呼び出された後でのみ使用されます。バッファーされたすべてのデータがパイプへフラッシュされるのを保証するため、バックグラウンドスレッドが終了するまでブロックします。</p>
<p>デフォルトでは、あるプロセスがキューを作成していない場合、終了時にキューのバックグラウンドスレッドを join しようとします。そのプロセスは <a class="reference internal" href="#multiprocessing.Queue.join_thread" title="multiprocessing.Queue.join_thread"><code class="xref py py-meth docutils literal"><span class="pre">join_thread()</span></code></a> が何もしないように <a class="reference internal" href="#multiprocessing.Queue.cancel_join_thread" title="multiprocessing.Queue.cancel_join_thread"><code class="xref py py-meth docutils literal"><span class="pre">cancel_join_thread()</span></code></a> を呼び出すことができます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Queue.cancel_join_thread">
<code class="descname">cancel_join_thread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.cancel_join_thread" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.Queue.join_thread" title="multiprocessing.Queue.join_thread"><code class="xref py py-meth docutils literal"><span class="pre">join_thread()</span></code></a> がブロッキングするのを防ぎます。特にこれはバックグラウンドスレッドがそのプロセスの終了時に自動的に join されるのを防ぎます。詳細は <a class="reference internal" href="#multiprocessing.Queue.join_thread" title="multiprocessing.Queue.join_thread"><code class="xref py py-meth docutils literal"><span class="pre">join_thread()</span></code></a> を参照してください。</p>
<p>このメソッドは <code class="docutils literal"><span class="pre">allow_exit_without_flush()</span></code> という名前のほうがよかったかもしれません。キューに追加されたデータが失われてしまいがちなため、このメソッドを使う必要はほぼ確実にないでしょう。本当にこれが必要になるのは、キューに追加されたデータを下位層のパイプにフラッシュすることなくカレントプロセスを直ちに終了する必要があり、かつ失われるデータに関心がない場合です。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このクラスに含まれる機能には、ホストとなるオペレーティングシステム上で動作している共有セマフォ (shared semaphore) を使用しているものがあります。これが使用できない場合には、このクラスが無効になり、 <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> をインスタンス化する時に <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> が発生します。詳細は <a class="reference external" href="https://bugs.python.org/issue3770">bpo-3770</a> を参照してください。同様のことが、以下に列挙されている特殊なキューでも成り立ちます。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.SimpleQueue">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">SimpleQueue</code><a class="headerlink" href="#multiprocessing.SimpleQueue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>単純化された <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> 型です。ロックされた <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-class docutils literal"><span class="pre">Pipe</span></code></a> と非常に似ています。</p>
<dl class="method">
<dt id="multiprocessing.SimpleQueue.empty">
<code class="descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.SimpleQueue.empty" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューが空ならば <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.SimpleQueue.get">
<code class="descname">get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.SimpleQueue.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューから要素を削除して返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.SimpleQueue.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.SimpleQueue.put" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>item</em> をキューに追加します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="multiprocessing.JoinableQueue">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">JoinableQueue</code><span class="sig-paren">(</span><span class="optional">[</span><em>maxsize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.JoinableQueue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.JoinableQueue" title="multiprocessing.JoinableQueue"><code class="xref py py-class docutils literal"><span class="pre">JoinableQueue</span></code></a> は <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> のサブクラスであり、 <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal"><span class="pre">task_done()</span></code></a> や <a class="reference internal" href="#multiprocessing.JoinableQueue.join" title="multiprocessing.JoinableQueue.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> メソッドが追加されているキューです。</p>
<dl class="method">
<dt id="multiprocessing.JoinableQueue.task_done">
<code class="descname">task_done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.JoinableQueue.task_done" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>以前にキューへ追加されたタスクが完了したことを表します。キューのコンシューマによって使用されます。 タスクをフェッチするために使用されるそれぞれの <a class="reference internal" href="#multiprocessing.Queue.get" title="multiprocessing.Queue.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a> に対して、 後続の <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal"><span class="pre">task_done()</span></code></a> 呼び出しはタスクの処理が完了したことをキューへ伝えます。</p>
<p>もし <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> がブロッキング状態なら、 すべての要素が処理されたときに復帰します( <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal"><span class="pre">task_done()</span></code></a> 呼び出しが すべての要素からキュー内へ <a class="reference internal" href="#multiprocessing.Queue.put" title="multiprocessing.Queue.put"><code class="xref py py-meth docutils literal"><span class="pre">put()</span></code></a> されたと受け取ったことを意味します)。</p>
<p>キューにある要素より多く呼び出された場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が発生します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.JoinableQueue.join">
<code class="descname">join</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.JoinableQueue.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューにあるすべてのアイテムが取り出されて処理されるまでブロックします。</p>
<p>キューに要素が追加されると未完了タスク数が増えます。コンシューマがキューの要素が取り出されてすべての処理が完了したことを表す <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal"><span class="pre">task_done()</span></code></a> を呼び出すと数が減ります。 未完了タスク数がゼロになると <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> はブロッキングを解除します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="miscellaneous">
<h3>17.2.2.3. その他<a class="headerlink" href="#miscellaneous" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="multiprocessing.active_children">
<code class="descclassname">multiprocessing.</code><code class="descname">active_children</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.active_children" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>カレントプロセスのすべてのアクティブな子プロセスのリストを返します。</p>
<p>これを呼び出すと &#8220;join&#8221; してすでに終了しているプロセスには副作用があります。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.cpu_count">
<code class="descclassname">multiprocessing.</code><code class="descname">cpu_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.cpu_count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the number of CPUs in the system.</p>
<p>This number is not equivalent to the number of CPUs the current process can
use.  The number of usable CPUs can be obtained with
<code class="docutils literal"><span class="pre">len(os.sched_getaffinity(0))</span></code></p>
<p>May raise <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="os.html#os.cpu_count" title="os.cpu_count"><code class="xref py py-func docutils literal"><span class="pre">os.cpu_count()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.current_process">
<code class="descclassname">multiprocessing.</code><code class="descname">current_process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.current_process" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>カレントプロセスに対応する <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> オブジェクトを返します。</p>
<p><a class="reference internal" href="threading.html#threading.current_thread" title="threading.current_thread"><code class="xref py py-func docutils literal"><span class="pre">threading.current_thread()</span></code></a> とよく似た関数です。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.freeze_support">
<code class="descclassname">multiprocessing.</code><code class="descname">freeze_support</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.freeze_support" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> を使用しているプログラムをフリーズして Windows の実行可能形式を生成するためのサポートを追加します。(<strong>py2exe</strong> , <strong>PyInstaller</strong> や <strong>cx_Freeze</strong> でテストされています。)</p>
<p>メインモジュールの <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> の直後にこの関数を呼び出す必要があります。以下に例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">freeze_support</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello world!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>もし <code class="docutils literal"><span class="pre">freeze_support()</span></code> の行がない場合、フリーズされた実行可能形式を実行しようとすると <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を発生させます。</p>
<p><code class="docutils literal"><span class="pre">freeze_support()</span></code> の呼び出しは Windows 以外の OS では効果がありません。さらに、もしモジュールが Windows の通常の Python インタプリタによって実行されているならば（プログラムがフリーズされていなければ） <code class="docutils literal"><span class="pre">freeze_support()</span></code> は効果がありません。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.get_all_start_methods">
<code class="descclassname">multiprocessing.</code><code class="descname">get_all_start_methods</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_all_start_methods" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サポートしている開始方式のリストを返します。先頭の要素がデフォルトを意味します。利用可能な開始方式には <code class="docutils literal"><span class="pre">'fork'</span></code>、<code class="docutils literal"><span class="pre">'spawn'</span></code> および <code class="docutils literal"><span class="pre">'forkserver'</span></code> があります。Windows では <code class="docutils literal"><span class="pre">'spawn'</span></code> のみが利用可能です。Unix では <code class="docutils literal"><span class="pre">'fork'</span></code> および <code class="docutils literal"><span class="pre">'spawn'</span></code> は常にサポートされており、<code class="docutils literal"><span class="pre">'fork'</span></code> がデフォルトになります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.get_context">
<code class="descclassname">multiprocessing.</code><code class="descname">get_context</code><span class="sig-paren">(</span><em>method=None</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールと同じ属性を持つコンテキストオブジェクトを返します。</p>
<p><em>method</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合、デフォルトのコンテキストが返されます。その他の場合 <em>method</em> は <code class="docutils literal"><span class="pre">'fork'</span></code>、<code class="docutils literal"><span class="pre">'spawn'</span></code> あるいは <code class="docutils literal"><span class="pre">'forkserver'</span></code> でなければなりません。指定された開始方式が利用できない場合は <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.get_start_method">
<code class="descclassname">multiprocessing.</code><code class="descname">get_start_method</code><span class="sig-paren">(</span><em>allow_none=False</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_start_method" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>開始するプロセスで使用する開始方式名を返します。</p>
<p>開始方式がまだ確定しておらず、<em>allow_none</em> の値が偽の場合、開始方式はデフォルトに確定され、その名前が返されます。開始方式が確定しておらず、<em>allow_none</em> の値が真の場合、 <code class="docutils literal"><span class="pre">None</span></code> が返されます。</p>
<p>返り値は <code class="docutils literal"><span class="pre">'fork'</span></code>、<code class="docutils literal"><span class="pre">'spawn'</span></code>、<code class="docutils literal"><span class="pre">'forkserver'</span></code> あるいは <code class="docutils literal"><span class="pre">None</span></code> になります。Unix では <code class="docutils literal"><span class="pre">'fork'</span></code> が、Windows では <code class="docutils literal"><span class="pre">'spawn'</span></code> がデフォルトになります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.set_executable">
<code class="descclassname">multiprocessing.</code><code class="descname">set_executable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.set_executable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>子プロセスを開始するときに、使用する Python インタープリターのパスを設定します。(デフォルトでは <a class="reference internal" href="sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal"><span class="pre">sys.executable</span></code></a> が使用されます)。コードに組み込むときは、おそらく次のようにする必要があります</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">set_executable</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exec_prefix</span><span class="p">,</span> <span class="s1">&#39;pythonw.exe&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>子プロセスを作成する前に行ってください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Unix で開始方式に <code class="docutils literal"><span class="pre">'spawn'</span></code> を使用している場合にサポートされました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.set_start_method">
<code class="descclassname">multiprocessing.</code><code class="descname">set_start_method</code><span class="sig-paren">(</span><em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.set_start_method" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>子プロセスの開始方式を指定します。<em>method</em> には <code class="docutils literal"><span class="pre">'fork'</span></code>、<code class="docutils literal"><span class="pre">'spawn'</span></code> あるいは <code class="docutils literal"><span class="pre">'forkserver'</span></code> を指定できます。</p>
<p>これは一度しか呼び出すことができず、その場所もメインモジュールの <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> 節内で保護された状態でなければなりません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> には <a class="reference internal" href="threading.html#threading.active_count" title="threading.active_count"><code class="xref py py-func docutils literal"><span class="pre">threading.active_count()</span></code></a>, <a class="reference internal" href="threading.html#threading.enumerate" title="threading.enumerate"><code class="xref py py-func docutils literal"><span class="pre">threading.enumerate()</span></code></a>, <a class="reference internal" href="threading.html#threading.settrace" title="threading.settrace"><code class="xref py py-func docutils literal"><span class="pre">threading.settrace()</span></code></a>, <a class="reference internal" href="threading.html#threading.setprofile" title="threading.setprofile"><code class="xref py py-func docutils literal"><span class="pre">threading.setprofile()</span></code></a>, <a class="reference internal" href="threading.html#threading.Timer" title="threading.Timer"><code class="xref py py-class docutils literal"><span class="pre">threading.Timer</span></code></a> や <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal"><span class="pre">threading.local</span></code></a> のような関数はありません。</p>
</div>
</div>
<div class="section" id="connection-objects">
<h3>17.2.2.4. Connection オブジェクト<a class="headerlink" href="#connection-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Connection オブジェクトは pickle でシリアライズ可能なオブジェクトか文字列を送ったり、受け取ったりします。そういったオブジェクトはメッセージ指向の接続ソケットと考えられます。</p>
<p>Connection オブジェクトは通常は <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal"><span class="pre">Pipe()</span></code></a> を使用して作成されます。詳細は <a class="reference internal" href="#multiprocessing-listeners-clients"><span class="std std-ref">リスナーとクライアント</span></a> も参照してください。</p>
<dl class="class">
<dt id="multiprocessing.Connection">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Connection</code><a class="headerlink" href="#multiprocessing.Connection" title="この定義へのパーマリンク">¶</a></dt>
<dd><dl class="method">
<dt id="multiprocessing.Connection.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションの相手側へ <a class="reference internal" href="#multiprocessing.Connection.recv" title="multiprocessing.Connection.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> を使用して読み込むオブジェクトを送ります。</p>
<p>オブジェクトは pickle でシリアライズ可能でなければなりません。 pickle が極端に大きすぎる (OS にも依りますが、およそ 32 MB+) と、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外が送出されることがあります。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Connection.recv">
<code class="descname">recv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.recv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションの相手側から <a class="reference internal" href="#multiprocessing.Connection.send" title="multiprocessing.Connection.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> を使用して送られたオブジェクトを返します。 何か受け取るまでブロックします。何も受け取らずにコネクションの相手側でクローズされた場合 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a> が発生します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Connection.fileno">
<code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.fileno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションが使用するハンドラーか、ファイル記述子を返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Connection.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションをクローズします。</p>
<p>コネクションがガベージコレクトされるときに自動的に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Connection.poll">
<code class="descname">poll</code><span class="sig-paren">(</span><span class="optional">[</span><em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.poll" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>読み込み可能なデータがあるかどうかを返します。</p>
<p><em>timeout</em> が指定されていなければすぐに返します。 <em>timeout</em> に数値を指定すると、最大指定した秒数をブロッキングします。 <em>timeout</em> に <code class="docutils literal"><span class="pre">None</span></code> を指定するとタイムアウトせずにずっとブロッキングします。</p>
<p><a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal"><span class="pre">multiprocessing.connection.wait()</span></code></a> を使って複数のコネクションオブジェクトを同時にポーリングできることに注意してください。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Connection.send_bytes">
<code class="descname">send_bytes</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>offset</em><span class="optional">[</span>, <em>size</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.send_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> から完全なメッセージとしてバイトデータを送ります。</p>
<p><em>offset</em> が指定されると <em>buffer</em> のその位置からデータが読み込まれます。 <em>size</em> が指定されるとバッファーからその量のデータが読み込まれます。非常に大きなバッファー (OS に依存しますが、およそ 32MB+) を指定すると、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外が発生するかもしれません。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Connection.recv_bytes">
<code class="descname">recv_bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>maxlength</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.recv_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションの相手側から送られたバイトデータの完全なメッセージを文字列として返します。何か受け取るまでブロックします。受け取るデータが何も残っておらず、相手側がコネクションを閉じていた場合、 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a> が送出されます。</p>
<p><em>maxlength</em> を指定していて、かつメッセージが <em>maxlength</em> より長い場合、 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> が発生してコネクションからそれ以上読めなくなります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>この関数は以前は <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> を送出していました。今では <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> の別名です。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Connection.recv_bytes_into">
<code class="descname">recv_bytes_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Connection.recv_bytes_into" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションの相手側から送られたバイトデータを <em>buffer</em> に読み込み、メッセージのバイト数を返します。 何か受け取るまでブロックします。何も受け取らずにコネクションの相手側でクローズされた場合 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a> が発生します。</p>
<p><em>buffer</em> は書き込み可能な <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> でなければなりません。 <em>offset</em> が与えられたら、その位置からバッファーへメッセージが書き込まれます。 オフセットは <em>buffer</em> バイトよりも小さい正の数でなければなりません。</p>
<p>バッファーがあまりに小さいと <a class="reference internal" href="#multiprocessing.BufferTooShort" title="multiprocessing.BufferTooShort"><code class="xref py py-exc docutils literal"><span class="pre">BufferTooShort</span></code></a> 例外が発生します。 <code class="docutils literal"><span class="pre">e</span></code> が例外インスタンスとすると完全なメッセージは <code class="docutils literal"><span class="pre">e.args[0]</span></code> で確認できます。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="#multiprocessing.Connection.send" title="multiprocessing.Connection.send"><code class="xref py py-meth docutils literal"><span class="pre">Connection.send()</span></code></a> と <a class="reference internal" href="#multiprocessing.Connection.recv" title="multiprocessing.Connection.recv"><code class="xref py py-meth docutils literal"><span class="pre">Connection.recv()</span></code></a> を使用して Connection オブジェクト自体をプロセス間で転送できるようになりました。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span>Connection オブジェクトがコンテキストマネージメント・プロトコルをサポートするようになりました。 &#8211; <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> を参照してください。 <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> は Connection オブジェクトを返します。また <a class="reference internal" href="stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> は <a class="reference internal" href="#multiprocessing.Connection.close" title="multiprocessing.Connection.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> を呼び出します。</p>
</div>
</dd></dl>

<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pipe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="go">[1, &#39;hello&#39;, None]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;thank you&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">recv_bytes</span><span class="p">()</span>
<span class="go">b&#39;thank you&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr1</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr2</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">recv_bytes_into</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="o">*</span> <span class="n">arr1</span><span class="o">.</span><span class="n">itemsize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr2</span>
<span class="go">array(&#39;i&#39;, [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p><a class="reference internal" href="#multiprocessing.Connection.recv" title="multiprocessing.Connection.recv"><code class="xref py py-meth docutils literal"><span class="pre">Connection.recv()</span></code></a> メソッドは受信したデータを自動的に unpickle 化します。それはメッセージを送ったプロセスが信頼できる場合を除いてセキュリティリスクになります。</p>
<p class="last">そのため <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal"><span class="pre">Pipe()</span></code></a> を使用してコネクションオブジェクトを生成する場合を除いて、何らかの認証処理を実行した後で <a class="reference internal" href="#multiprocessing.Connection.recv" title="multiprocessing.Connection.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a> や <a class="reference internal" href="#multiprocessing.Connection.send" title="multiprocessing.Connection.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> メソッドのみを使用すべきです。詳細は <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">認証キー</span></a> を参照してください。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">もしプロセスがパイプの読み込みまたは書き込み中に kill されると、メッセージの境界がどこなのか分からなくなってしまうので、そのパイプ内のデータは破損してしまいがちです。</p>
</div>
</div>
<div class="section" id="synchronization-primitives">
<h3>17.2.2.5. 同期プリミティブ<a class="headerlink" href="#synchronization-primitives" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一般的にマルチプロセスプログラムは、マルチスレッドプログラムほどは同期プリミティブを必要としません。詳細は <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールのドキュメントを参照してください。</p>
<p>マネージャーオブジェクトを使用して同期プリミティブを作成できることも覚えておいてください。詳細は <a class="reference internal" href="#multiprocessing-managers"><span class="std std-ref">マネージャー</span></a> を参照してください。</p>
<dl class="class">
<dt id="multiprocessing.Barrier">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Barrier</code><span class="sig-paren">(</span><em>parties</em><span class="optional">[</span>, <em>action</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Barrier" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バリアーオブジェクト: <a class="reference internal" href="threading.html#threading.Barrier" title="threading.Barrier"><code class="xref py py-class docutils literal"><span class="pre">threading.Barrier</span></code></a> のクローンです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.BoundedSemaphore">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">BoundedSemaphore</code><span class="sig-paren">(</span><span class="optional">[</span><em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.BoundedSemaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>有限セマフォオブジェクト: <a class="reference internal" href="threading.html#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal"><span class="pre">threading.BoundedSemaphore</span></code></a> の類似物です。</p>
<p>よく似た <a class="reference internal" href="threading.html#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal"><span class="pre">threading.BoundedSemaphore</span></code></a>  とは、次の一点だけ異なります。 <code class="docutils literal"><span class="pre">acquire</span></code> メソッドの第一引数名は <em>block</em> で、<a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">Lock.acquire()</span></code></a> と一致しています。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Mac OS X では <code class="docutils literal"><span class="pre">sem_getvalue()</span></code> が実装されていないので <a class="reference internal" href="#multiprocessing.Semaphore" title="multiprocessing.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">Semaphore</span></code></a> と区別がつきません。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.Condition">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Condition</code><span class="sig-paren">(</span><span class="optional">[</span><em>lock</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Condition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>状態変数: <a class="reference internal" href="threading.html#threading.Condition" title="threading.Condition"><code class="xref py py-class docutils literal"><span class="pre">threading.Condition</span></code></a> の別名です。</p>
<p><em>lock</em> を指定するなら <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> の <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> か <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> オブジェクトにすべきです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="threading.html#threading.Condition.wait_for" title="threading.Condition.wait_for"><code class="xref py py-meth docutils literal"><span class="pre">wait_for()</span></code></a> メソッドが追加されました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.Event">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Event</code><a class="headerlink" href="#multiprocessing.Event" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="threading.html#threading.Event" title="threading.Event"><code class="xref py py-class docutils literal"><span class="pre">threading.Event</span></code></a> のクローンです。</p>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.Lock">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Lock</code><a class="headerlink" href="#multiprocessing.Lock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>再帰しないロックオブジェクトで、 <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">threading.Lock</span></code></a> 相当のものです。プロセスやスレッドがロックをいったん獲得 (acquire) すると、それに続くほかのプロセスやスレッドが獲得しようとする際、それが解放 (release) されるまではブロックされます。解放はどのプロセス、スレッドからも行えます。スレッドに対して適用される <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">threading.Lock</span></code></a> のコンセプトと振る舞いは、特筆すべきものがない限り、プロセスとスレッドに適用される <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">multiprocessing.Lock</span></code></a> に引き継がれています。</p>
<p><a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> は実際にはファクトリ関数で、デフォルトコンテキストで初期化された <code class="docutils literal"><span class="pre">multiprocessing.synchronize.Lock</span></code> のインスタンスを返すことに注意してください。</p>
<p><a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> は <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> プロトコルをサポートしています。つまり <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文で使うことができます。</p>
<dl class="method">
<dt id="multiprocessing.Lock.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>block=True</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Lock.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックあり、またはブロックなしでロックを獲得します。</p>
<p>引数 <em>block</em> を <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) に設定して呼び出した場合、ロックがアンロック状態になるまでブロックします。ブロックから抜けるとそれをロック状態にしてから <code class="docutils literal"><span class="pre">True</span></code> を返します。 <a class="reference internal" href="threading.html#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">threading.Lock.acquire()</span></code></a> の最初の引数とは名前が違っているので注意してください。</p>
<p>引数 <em>block</em> の値を <code class="docutils literal"><span class="pre">False</span></code> にして呼び出すとブロックしません。 現在ロック状態であれば、直ちに <code class="docutils literal"><span class="pre">False</span></code> を返します。それ以外の場合には、ロックをロック状態にして <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p><em>timeout</em> として正の浮動小数点数を与えて呼び出すと、ロックが獲得できない限り、指定された秒数だけブロックします。 <em>timeout</em> 値に負数を与えると、ゼロを与えた場合と同じになります。 <em>timeout</em> 値の <code class="docutils literal"><span class="pre">None</span></code> (デフォルト) を与えると、無限にブロックします。 <em>timeout</em> 引数の負数と <code class="docutils literal"><span class="pre">None</span></code> の扱いは、 <a class="reference internal" href="threading.html#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">threading.Lock.acquire()</span></code></a> に実装された動作と異なるので注意してください。 <em>block</em> が <code class="docutils literal"><span class="pre">False</span></code> の場合、 <em>timeout</em> は実際的な意味を持たなくなるので無視されます。ロックを獲得した場合は <code class="docutils literal"><span class="pre">True</span></code> 、タイムアウトした場合は <code class="docutils literal"><span class="pre">False</span></code> で戻ります。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.Lock.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Lock.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロックを解放します。これはロックを獲得したプロセスやスレッドだけでなく、任意のプロセスやスレッドから呼ぶことができます。</p>
<p><a class="reference internal" href="threading.html#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal"><span class="pre">threading.Lock.release()</span></code></a> と同じように振舞いますが、ロックされていない場合に呼び出すと <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> となる点だけが違います。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="multiprocessing.RLock">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">RLock</code><a class="headerlink" href="#multiprocessing.RLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>再帰ロックオブジェクトで、 <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">threading.RLock</span></code></a> 相当のものです。再帰ロックオブジェクトはそれを獲得 (acquire) したプロセスやスレッドが解放 (release) しなければなりません。プロセスやスレッドがロックをいったん獲得すると、同じプロセスやスレッドはブロックされずに再度獲得出来ます。そのプロセスやスレッドは獲得した回数ぶん解放しなければなりません。</p>
<p><a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> は実際にはファクトリ関数で、デフォルトコンテキストで初期化された <code class="docutils literal"><span class="pre">multiprocessing.synchronize.Lock</span></code> のインスタンスを返すことに注意してください。</p>
<p><a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> は <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> プロトコルをサポートしています。つまり <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文で使うことができます。</p>
<dl class="method">
<dt id="multiprocessing.RLock.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>block=True</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.RLock.acquire" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックあり、またはブロックなしでロックを獲得します。</p>
<p><em>block</em> 引数を <code class="docutils literal"><span class="pre">True</span></code> にして呼び出した場合、ロックが既にカレントプロセスもしくはカレントスレッドが既に所有していない限りは、アンロック状態 (どのプロセス、スレッドも所有していない状態) になるまでブロックします。ブロックから抜けるとカレントプロセスもしくはカレントスレッドが (既に持っていなければ) 所有権を得て、再帰レベルをインクリメントし、 <code class="docutils literal"><span class="pre">True</span></code> で戻ります。 <a class="reference internal" href="threading.html#threading.RLock.acquire" title="threading.RLock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">threading.RLock.acquire()</span></code></a> の実装とはこの最初の引数の振る舞いが、その名前自身を始めとしていくつか違うので注意してください。</p>
<p><em>block</em> 引数を <code class="docutils literal"><span class="pre">False</span></code> にして呼び出した場合、ブロックしません。ロックが他のプロセスもしくはスレッドにより獲得済み (つまり所有されている) であれば、カレントプロセスまたはカレントスレッドは所有権を得ず、再帰レベルも変更せずに、 <code class="docutils literal"><span class="pre">False</span></code> で戻ります。ロックがアンロック状態の場合、カレントプロセスもしくはカレントスレッドは所有権を得て再帰レベルがインクリメントされ、 <code class="docutils literal"><span class="pre">True</span></code> で戻ります。(&#8212;訳注: <em>block</em> の True/False 関係なくここでの説明では「所有権を持っている場合の2度目以降の aquire」の説明が欠けています。2度目以降の acquire では再帰レベルがインクリメントされて即座に返ります。全体読めばわかるとは思いますが一応。&#8212;)</p>
<p><em>timeout</em> 引数の使い方と振る舞いは <a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">Lock.acquire()</span></code></a> と同じです。 <em>timeout</em> 引数の振る舞いがいくつかの点で <a class="reference internal" href="threading.html#threading.RLock.acquire" title="threading.RLock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">threading.RLock.acquire()</span></code></a> と異なるので注意してください。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.RLock.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.RLock.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>再帰レベルをデクリメントしてロックを解放します。デクリメント後に再帰レベルがゼロになった場合、ロックの状態をアンロック (いかなるプロセス、いかなるスレッドにも所有されていない状態) にリセットし、ロックの状態がアンロックになるのを待ってブロックしているプロセスもしくはスレッドがある場合にはその中のただ一つだけが処理を進行できるようにします。デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックのままで、呼び出し側のプロセスもしくはスレッドに所有されたままになります。</p>
<p>このメソッドは呼び出しプロセスあるいはスレッドがロックを所有している場合に限り呼び出してください。所有者でないプロセスもしくはスレッドによって呼ばれるか、あるいはアンロック (未所有) 状態で呼ばれた場合、 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> が送出されます。同じ状況での <a class="reference internal" href="threading.html#threading.RLock.release" title="threading.RLock.release"><code class="xref py py-meth docutils literal"><span class="pre">threading.RLock.release()</span></code></a> 実装とは例外の型が異なるので注意してください。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="multiprocessing.Semaphore">
<em class="property">class </em><code class="descclassname">multiprocessing.</code><code class="descname">Semaphore</code><span class="sig-paren">(</span><span class="optional">[</span><em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Semaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>セマフォオブジェクト: <a class="reference internal" href="threading.html#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">threading.Semaphore</span></code></a> のクローンです。</p>
<p>よく似た <a class="reference internal" href="threading.html#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal"><span class="pre">threading.BoundedSemaphore</span></code></a>  とは、次の一点だけ異なります。 <code class="docutils literal"><span class="pre">acquire</span></code> メソッドの第一引数名は <em>block</em> で、<a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">Lock.acquire()</span></code></a> と一致しています。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Mac OS X では <code class="docutils literal"><span class="pre">sem_timedwait</span></code> がサポートされていないので、<code class="docutils literal"><span class="pre">acquire()</span></code> にタイムアウトを与えて呼ぶと、ループ内でスリープすることでこの関数がエミュレートされます。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>メインスレッドが <code class="xref py py-meth docutils literal"><span class="pre">BoundedSemaphore.acquire()</span></code>, <a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">Lock.acquire()</span></code></a>, <a class="reference internal" href="#multiprocessing.RLock.acquire" title="multiprocessing.RLock.acquire"><code class="xref py py-meth docutils literal"><span class="pre">RLock.acquire()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">Semaphore.acquire()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">Condition.acquire()</span></code> 又は <code class="xref py py-meth docutils literal"><span class="pre">Condition.wait()</span></code> を呼び出してブロッキング状態のときに <code class="kbd docutils literal"><span class="pre">Ctrl-C</span></code> で生成される SIGINT シグナルを受け取ると、その呼び出しはすぐに中断されて <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> が発生します。</p>
<p class="last">これは同等のブロッキング呼び出しが実行中のときに SIGINT が無視される <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> の振る舞いとは違っています。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このパッケージに含まれる機能には、ホストとなるオペレーティングシステム上で動作している共有セマフォを使用しているものがあります。これが使用できない場合には、<code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.synchronize</span></code> モジュールが無効になり、このモジュールのインポート時に <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> が発生します。詳細は <a class="reference external" href="https://bugs.python.org/issue3770">bpo-3770</a> を参照してください。</p>
</div>
</div>
<div class="section" id="shared-ctypes-objects">
<h3>17.2.2.6. 共有 <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> オブジェクト<a class="headerlink" href="#shared-ctypes-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>子プロセスにより継承される共有メモリを使用する共有オブジェクトを作成することができます。</p>
<dl class="function">
<dt id="multiprocessing.Value">
<code class="descclassname">multiprocessing.</code><code class="descname">Value</code><span class="sig-paren">(</span><em>typecode_or_type</em>, <em>*args</em>, <em>lock=True</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有メモリから割り当てられた <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> オブジェクトを返します。 デフォルトでは、返り値は実際のオブジェクトの同期ラッパーです。オブジェクトそれ自身は、 <a class="reference internal" href="#multiprocessing.Value" title="multiprocessing.Value"><code class="xref py py-class docutils literal"><span class="pre">Value</span></code></a> の <em>value</em> 属性によってアクセスできます。</p>
<p><em>typecode_or_type</em> は返されるオブジェクトの型を決めます。それは ctypes の型か <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> モジュールで使用されるような1文字の型コードかのどちらか一方です。 <em>*args</em> は型のコンストラクターへ渡されます。</p>
<p><em>lock</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) なら、値へ同期アクセスするために新たに再帰的なロックオブジェクトが作成されます。 <em>lock</em> が <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> か <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> なら値への同期アクセスに使用されます。 <em>lock</em> が <code class="docutils literal"><span class="pre">False</span></code> なら、返されたオブジェクトへのアクセスはロックにより自動的に保護されません。そのため、必ずしも &#8220;プロセスセーフ&#8221; ではありません。</p>
<p><code class="docutils literal"><span class="pre">+=</span></code> のような演算は、読み込みと書き込みを含むためアトミックでありません。このため、たとえば自動的に共有の値を増加させたい場合、以下のようにするのでは不十分です</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>関連するロックが再帰的 (それがデフォルトです) なら、かわりに次のようにします</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">counter</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
    <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p><em>lock</em> はキーワード引数でのみ指定することに注意してください。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.Array">
<code class="descclassname">multiprocessing.</code><code class="descname">Array</code><span class="sig-paren">(</span><em>typecode_or_type</em>, <em>size_or_initializer</em>, <em>*</em>, <em>lock=True</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Array" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有メモリから割り当てられた ctypes 配列を返します。デフォルトでは、返り値は実際の配列の同期ラッパーです。</p>
<p><em>typecode_or_type</em> は返される配列の要素の型を決めます。それは ctypes の型か <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> モジュールで使用されるような1文字の型コードかのどちらか一方です。 <em>size_or_initializer</em> が整数なら、配列の長さを決定し、その配列はゼロで初期化されます。別の使用方法として <em>size_or_initializer</em> は配列の初期化に使用されるシーケンスになり、そのシーケンス長が配列の長さを決定します。</p>
<p><em>lock</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) なら、値へ同期アクセスするために新たなロックオブジェクトが作成されます。 <em>lock</em> が <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> か <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> なら値への同期アクセスに使用されます。 <em>lock</em> が <code class="docutils literal"><span class="pre">False</span></code> なら、返されたオブジェクトへのアクセスはロックにより自動的に保護されません。そのため、必ずしも &#8220;プロセスセーフ&#8221; ではありません。</p>
<p><em>lock</em> はキーワード引数としてのみ利用可能なことに注意してください。</p>
<p><a class="reference internal" href="ctypes.html#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-data docutils literal"><span class="pre">ctypes.c_char</span></code></a> の配列は文字列を格納して取り出せる <em>value</em> と <em>raw</em> 属性を持っていることを覚えておいてください。</p>
</dd></dl>

<div class="section" id="module-multiprocessing.sharedctypes">
<span id="the-multiprocessing-sharedctypes-module"></span><h4>17.2.2.6.1. <a class="reference internal" href="#module-multiprocessing.sharedctypes" title="multiprocessing.sharedctypes: Allocate ctypes objects from shared memory."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.sharedctypes</span></code></a> モジュール<a class="headerlink" href="#module-multiprocessing.sharedctypes" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#module-multiprocessing.sharedctypes" title="multiprocessing.sharedctypes: Allocate ctypes objects from shared memory."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.sharedctypes</span></code></a> モジュールは子プロセスに継承される共有メモリの <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> オブジェクトを割り当てる関数を提供します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">共有メモリのポインターを格納することは可能ではありますが、特定プロセスのアドレス空間の位置を参照するということを覚えておいてください。しかし、そのポインターは別のプロセスのコンテキストにおいて無効になる確率が高いです。そして、別のプロセスからそのポインターを逆参照しようとするとクラッシュを引き起こす可能性があります。</p>
</div>
<dl class="function">
<dt id="multiprocessing.sharedctypes.RawArray">
<code class="descclassname">multiprocessing.sharedctypes.</code><code class="descname">RawArray</code><span class="sig-paren">(</span><em>typecode_or_type</em>, <em>size_or_initializer</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.RawArray" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有メモリから割り当てられた ctypes 配列を返します。</p>
<p><em>typecode_or_type</em> は返される配列の要素の型を決めます。それは ctypes の型か <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> モジュールで使用されるような1文字の型コードのどちらか一方です。 <em>size_or_initializer</em> が整数なら、それが配列の長さになり、その配列はゼロで初期化されます。別の使用方法として <em>size_or_initializer</em> には配列の初期化に使用されるシーケンスを設定することもでき、その場合はシーケンスの長さが配列の長さになります。</p>
<p>要素を取得したり設定したりすることは潜在的に非アトミックであることに注意してください。ロックを使用して自動的に同期化されたアクセスを保証するには <a class="reference internal" href="#multiprocessing.sharedctypes.Array" title="multiprocessing.sharedctypes.Array"><code class="xref py py-func docutils literal"><span class="pre">Array()</span></code></a> を使用してください。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.sharedctypes.RawValue">
<code class="descclassname">multiprocessing.sharedctypes.</code><code class="descname">RawValue</code><span class="sig-paren">(</span><em>typecode_or_type</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.RawValue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有メモリから割り当てられた ctypes オブジェクトを返します。</p>
<p><em>typecode_or_type</em> は返されるオブジェクトの型を決めます。それは ctypes の型か <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> モジュールで使用されるような1文字の型コードかのどちらか一方です。 <em>*args</em> は型のコンストラクターへ渡されます。</p>
<p>値を取得したり設定したりすることは潜在的に非アトミックであることに注意してください。ロックを使用して自動的に同期化されたアクセスを保証するには <a class="reference internal" href="#multiprocessing.sharedctypes.Value" title="multiprocessing.sharedctypes.Value"><code class="xref py py-func docutils literal"><span class="pre">Value()</span></code></a> を使用してください。</p>
<p><a class="reference internal" href="ctypes.html#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-data docutils literal"><span class="pre">ctypes.c_char</span></code></a> の配列は文字列を格納して取り出せる <code class="docutils literal"><span class="pre">value</span></code> と <code class="docutils literal"><span class="pre">raw</span></code> 属性を持っていることを覚えておいてください。詳細は <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.sharedctypes.Array">
<code class="descclassname">multiprocessing.sharedctypes.</code><code class="descname">Array</code><span class="sig-paren">(</span><em>typecode_or_type</em>, <em>size_or_initializer</em>, <em>*</em>, <em>lock=True</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.Array" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.sharedctypes.RawArray" title="multiprocessing.sharedctypes.RawArray"><code class="xref py py-func docutils literal"><span class="pre">RawArray()</span></code></a> と同様ですが、 <em>lock</em> の値によっては ctypes 配列をそのまま返す代わりに、プロセスセーフな同期ラッパーが返されます。</p>
<p><em>lock</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) なら、値へ同期アクセスするために新たな ロックオブジェクトが作成されます。 <em>lock</em> が <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> か <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> なら値への同期アクセスに使用されます。 <em>lock</em> が <code class="docutils literal"><span class="pre">False</span></code> なら、返された オブジェクトへのアクセスはロックにより自動的に保護されません。 そのため、必ずしも &#8220;プロセスセーフ&#8221; ではありません。</p>
<p><em>lock</em> はキーワード引数でのみ指定することに注意してください。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.sharedctypes.Value">
<code class="descclassname">multiprocessing.sharedctypes.</code><code class="descname">Value</code><span class="sig-paren">(</span><em>typecode_or_type</em>, <em>*args</em>, <em>lock=True</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.Value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.sharedctypes.RawValue" title="multiprocessing.sharedctypes.RawValue"><code class="xref py py-func docutils literal"><span class="pre">RawValue()</span></code></a> と同様ですが、 <em>lock</em> の値によっては ctypes オブジェクトをそのまま返す代わりに、プロセスセーフな同期ラッパーが返されます。</p>
<p><em>lock</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルト) なら、値へ同期アクセスするために新たな ロックオブジェクトが作成されます。 <em>lock</em> が <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal"><span class="pre">Lock</span></code></a> か <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">RLock</span></code></a> なら値への同期アクセスに使用されます。 <em>lock</em> が <code class="docutils literal"><span class="pre">False</span></code> なら、返された オブジェクトへのアクセスはロックにより自動的に保護されません。 そのため、必ずしも &#8220;プロセスセーフ&#8221; ではありません。</p>
<p><em>lock</em> はキーワード引数でのみ指定することに注意してください。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.sharedctypes.copy">
<code class="descclassname">multiprocessing.sharedctypes.</code><code class="descname">copy</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有メモリから割り当てられた ctypes オブジェクト <em>obj</em> をコピーしたオブジェクトを返します。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.sharedctypes.synchronized">
<code class="descclassname">multiprocessing.sharedctypes.</code><code class="descname">synchronized</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>lock</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.synchronized" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>同期アクセスに <em>lock</em> を使用する ctypes オブジェクトのためにプロセスセーフなラッパーオブジェクトを返します。 <em>lock</em> が <code class="docutils literal"><span class="pre">None</span></code> (デフォルト) なら、 <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal"><span class="pre">multiprocessing.RLock</span></code></a> オブジェクトが自動的に作成されます。</p>
<p>同期ラッパーがラップするオブジェクトに加えて2つのメソッドがあります。 <code class="xref py py-meth docutils literal"><span class="pre">get_obj()</span></code> はラップされたオブジェクトを返します。 <code class="xref py py-meth docutils literal"><span class="pre">get_lock()</span></code> は同期のために使用されるロックオブジェクトを返します。</p>
<p>ラッパー経由で ctypes オブジェクトにアクセスすることは raw ctypes オブジェクトへアクセスするよりずっと遅くなることに注意してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>synchronized オブジェクトは <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">コンテクストマネージャ</span></a> プロトコルをサポートしています。</p>
</div>
</dd></dl>

<p>次の表は通常の ctypes 構文で共有メモリから共有 ctypes オブジェクトを作成するための構文を比較します。 (<code class="docutils literal"><span class="pre">MyStruct</span></code> テーブル内には <a class="reference internal" href="ctypes.html#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal"><span class="pre">ctypes.Structure</span></code></a> のサブクラスがあります。)</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="36%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ctypes</th>
<th class="head"><p class="first last">type を使用する sharedctypes</p>
</th>
<th class="head"><p class="first last">typecode を使用する sharedctypes</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>c_double(2.4)</td>
<td>RawValue(c_double, 2.4)</td>
<td>RawValue(&#8216;d&#8217;, 2.4)</td>
</tr>
<tr class="row-odd"><td>MyStruct(4, 6)</td>
<td>RawValue(MyStruct, 4, 6)</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>(c_short * 7)()</td>
<td>RawArray(c_short, 7)</td>
<td>RawArray(&#8216;h&#8217;, 7)</td>
</tr>
<tr class="row-odd"><td>(c_int * 3)(9, 2, 8)</td>
<td>RawArray(c_int, (9, 2, 8))</td>
<td>RawArray(&#8216;i&#8217;, (9, 2, 8))</td>
</tr>
</tbody>
</table>
<p>以下に子プロセスが多くの ctypes オブジェクトを変更する例を紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">multiprocessing.sharedctypes</span> <span class="k">import</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Array</span>
<span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">c_double</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">c_double</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">c_double</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
    <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">**=</span> <span class="mi">2</span>
    <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">**=</span> <span class="mi">2</span>
    <span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">**=</span> <span class="mi">2</span>
        <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">**=</span> <span class="mi">2</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="n">c_double</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;hello world&#39;</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="p">[(</span><span class="mf">1.875</span><span class="p">,</span><span class="o">-</span><span class="mf">6.25</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">5.75</span><span class="p">,</span><span class="mf">2.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.375</span><span class="p">,</span><span class="mf">9.5</span><span class="p">)],</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">modify</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">([(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">])</span>
</pre></div>
</div>
<p>結果は以下のように表示されます</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>49
0.1111111111111111
HELLO WORLD
[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]
</pre></div>
</div>
</div>
</div>
<div class="section" id="managers">
<span id="multiprocessing-managers"></span><h3>17.2.2.7. マネージャー<a class="headerlink" href="#managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マネージャーは異なるプロセス間で共有されるデータの作成方法を提供します。これには別のマシン上で走るプロセス間のネットワーク越しの共有も含まれます。マネージャーオブジェクトは <em>共有オブジェクト</em> を管理するサーバープロセスを制御します。他のプロセスはプロキシ経由で共有オブジェクトへアクセスすることができます。</p>
<dl class="function">
<dt id="multiprocessing.sharedctypes.multiprocessing.Manager">
<code class="descclassname">multiprocessing.</code><code class="descname">Manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.multiprocessing.Manager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセス間でオブジェクトを共有するために使用される <a class="reference internal" href="#multiprocessing.managers.SyncManager" title="multiprocessing.managers.SyncManager"><code class="xref py py-class docutils literal"><span class="pre">SyncManager</span></code></a> オブジェクトを返します。返されたマネージャーオブジェクトは生成される子プロセスに対応付けられ、共有オブジェクトを作成するメソッドや、共有オブジェクトに対応するプロキシを返すメソッドを持ちます。</p>
</dd></dl>

<span class="target" id="module-multiprocessing.managers"></span><p>マネージャープロセスは親プロセスが終了するか、ガベージコレクトされると停止します。マネージャークラスは <a class="reference internal" href="#module-multiprocessing.managers" title="multiprocessing.managers: Share data between process with shared objects."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.managers</span></code></a> モジュールで定義されています:</p>
<dl class="class">
<dt id="multiprocessing.managers.BaseManager">
<em class="property">class </em><code class="descclassname">multiprocessing.managers.</code><code class="descname">BaseManager</code><span class="sig-paren">(</span><span class="optional">[</span><em>address</em><span class="optional">[</span>, <em>authkey</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>BaseManager オブジェクトを作成します。</p>
<p>作成後、<a class="reference internal" href="#multiprocessing.managers.BaseManager.start" title="multiprocessing.managers.BaseManager.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> または <code class="docutils literal"><span class="pre">get_server().serve_forever()</span></code> を呼び出して、マネージャーオブジェクトが、開始されたマネージャープロセスを確実に参照するようにしてください。</p>
<p><em>address</em> はマネージャープロセスが新たなコネクションを待ち受けるアドレスです。<em>address</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合、任意のアドレスが設定されます。</p>
<p><em>authkey</em> はサーバープロセスへ接続しようとするコネクションの正当性を検証するために 使用される認証キーです。<em>authkey</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合 <code class="docutils literal"><span class="pre">current_process().authkey</span></code> が使用されます。<em>authkey</em> を使用する場合はバイト文字列でなければなりません。</p>
<dl class="method">
<dt id="multiprocessing.managers.BaseManager.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="optional">[</span><em>initializer</em><span class="optional">[</span>, <em>initargs</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.start" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マネージャーを開始するためにサブプロセスを開始します。<em>initializer</em> が <code class="docutils literal"><span class="pre">None</span></code> でなければ、サブプロセスは開始時に <code class="docutils literal"><span class="pre">initializer(*initargs)</span></code> を呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.BaseManager.get_server">
<code class="descname">get_server</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.get_server" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マネージャーの制御下にある実際のサーバーを表す <code class="xref py py-class docutils literal"><span class="pre">Server</span></code> オブジェクトを返します。 <code class="xref py py-class docutils literal"><span class="pre">Server</span></code> オブジェクトは <code class="xref py py-meth docutils literal"><span class="pre">serve_forever()</span></code> メソッドをサポートします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">BaseManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">server</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">get_server</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">Server</span></code> はさらに <a class="reference internal" href="#multiprocessing.managers.BaseManager.address" title="multiprocessing.managers.BaseManager.address"><code class="xref py py-attr docutils literal"><span class="pre">address</span></code></a> 属性も持っています。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.BaseManager.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.connect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローカルからリモートのマネージャーオブジェクトへ接続します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">BaseManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.BaseManager.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.shutdown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マネージャーが使用するプロセスを停止します。これはサーバープロセスを開始するために <a class="reference internal" href="#multiprocessing.managers.BaseManager.start" title="multiprocessing.managers.BaseManager.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> が使用された場合のみ有効です。</p>
<p>これは複数回呼び出すことができます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.BaseManager.register">
<code class="descname">register</code><span class="sig-paren">(</span><em>typeid</em><span class="optional">[</span>, <em>callable</em><span class="optional">[</span>, <em>proxytype</em><span class="optional">[</span>, <em>exposed</em><span class="optional">[</span>, <em>method_to_typeid</em><span class="optional">[</span>, <em>create_method</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.register" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マネージャークラスで呼び出し可能オブジェクト(callable)や型を登録するために使用されるクラスメソッドです。</p>
<p><em>typeid</em> は特に共有オブジェクトの型を識別するために使用される &#8220;型識別子&#8221; です。これは文字列でなければなりません。</p>
<p><em>callable</em> はこの型識別子のオブジェクトを作成するために使用される呼び出し可能オブジェクトです。マネージャーインスタンスが <a class="reference internal" href="#multiprocessing.managers.BaseManager.connect" title="multiprocessing.managers.BaseManager.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a> メソッドを使ってサーバーに接続されているか、 <em>create_method</em> 引数が <code class="docutils literal"><span class="pre">False</span></code> の場合は、 <code class="docutils literal"><span class="pre">None</span></code> でも構いません。</p>
<p><em>proxytype</em> はこの <em>typeid</em> で共有オブジェクトのプロキシを作成するために使用される <a class="reference internal" href="#multiprocessing.managers.BaseProxy" title="multiprocessing.managers.BaseProxy"><code class="xref py py-class docutils literal"><span class="pre">BaseProxy</span></code></a> のサブクラスです。 <code class="docutils literal"><span class="pre">None</span></code> の場合、プロキシクラスは自動的に作成されます。</p>
<p><em>exposed</em> は <a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal"><span class="pre">BaseProxy._callmethod()</span></code></a> を使用したアクセスが許されるべき typeid をプロキシするメソッド名のシーケンスを指定するために使用されます (<em>exposed</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合 <code class="xref py py-attr docutils literal"><span class="pre">proxytype._exposed_</span></code> が存在すればそれが代わりに使用されます)。<em>exposed</em> リストが指定されない場合、共有オブジェクトのすべての &#8220;パブリックメソッド&#8221; がアクセス可能になります。 (ここでいう &#8220;パブリックメソッド&#8221; とは <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドを持つものと名前が <code class="docutils literal"><span class="pre">'_'</span></code> で始まらないあらゆる属性を意味します。)</p>
<p><em>method_to_typeid</em> はプロキシが返す exposed メソッドの返り値の型を指定するために使用されるマッピングで、メソッド名を typeid 文字列にマップします。 (<em>method_to_typeid</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合 <code class="xref py py-attr docutils literal"><span class="pre">proxytype._method_to_typeid_</span></code> が存在すれば、それが代わりに使用されます。) メソッド名がこのマッピングのキーではないか、マッピングが <code class="docutils literal"><span class="pre">None</span></code> の場合、そのメソッドによって返されるオブジェクトが値として (by value) コピーされます。</p>
<p><em>create_method</em> は、共有オブジェクトを作成し、それに対するプロキシを返すようサーバープロセスに伝える、名前 <em>typeid</em> のメソッドを作成するかを決定します。デフォルトでは <code class="docutils literal"><span class="pre">True</span></code> です。</p>
</dd></dl>

<p><a class="reference internal" href="#multiprocessing.managers.BaseManager" title="multiprocessing.managers.BaseManager"><code class="xref py py-class docutils literal"><span class="pre">BaseManager</span></code></a> インスタンスも読み取り専用属性を1つ持っています:</p>
<dl class="attribute">
<dt id="multiprocessing.managers.BaseManager.address">
<code class="descname">address</code><a class="headerlink" href="#multiprocessing.managers.BaseManager.address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>マネージャーが使用するアドレスです。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>マネージャーオブジェクトはコンテキストマネージメント・プロトコルをサポートします &#8211; <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> を参照してください。 <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> は (まだ開始していない場合) サーバープロセスを開始してから、マネージャーオブジェクトを返します。 <a class="reference internal" href="stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> は <a class="reference internal" href="#multiprocessing.managers.BaseManager.shutdown" title="multiprocessing.managers.BaseManager.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></code></a> を呼び出します。</p>
<p>旧バージョンでは、 <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> はマネージャーのサーバープロセスがまだ開始していなかった場合でもプロセスを開始しませんでした。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.managers.SyncManager">
<em class="property">class </em><code class="descclassname">multiprocessing.managers.</code><code class="descname">SyncManager</code><a class="headerlink" href="#multiprocessing.managers.SyncManager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセス間の同期のために使用される <a class="reference internal" href="#multiprocessing.managers.BaseManager" title="multiprocessing.managers.BaseManager"><code class="xref py py-class docutils literal"><span class="pre">BaseManager</span></code></a> のサブクラスです。 <code class="xref py py-func docutils literal"><span class="pre">multiprocessing.Manager()</span></code> はこの型のオブジェクトを返します。</p>
<p>Its methods create and return <a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Proxy オブジェクト</span></a> for a
number of commonly used data types to be synchronized across processes.
This notably includes shared lists and dictionaries.</p>
<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Barrier">
<code class="descname">Barrier</code><span class="sig-paren">(</span><em>parties</em><span class="optional">[</span>, <em>action</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Barrier" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="threading.html#threading.Barrier" title="threading.Barrier"><code class="xref py py-class docutils literal"><span class="pre">threading.Barrier</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.BoundedSemaphore">
<code class="descname">BoundedSemaphore</code><span class="sig-paren">(</span><span class="optional">[</span><em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.BoundedSemaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="threading.html#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal"><span class="pre">threading.BoundedSemaphore</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Condition">
<code class="descname">Condition</code><span class="sig-paren">(</span><span class="optional">[</span><em>lock</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Condition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="threading.html#threading.Condition" title="threading.Condition"><code class="xref py py-class docutils literal"><span class="pre">threading.Condition</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
<p><em>lock</em> が提供される場合 <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">threading.Lock</span></code></a> か <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">threading.RLock</span></code></a> オブジェクトのためのプロキシになります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="threading.html#threading.Condition.wait_for" title="threading.Condition.wait_for"><code class="xref py py-meth docutils literal"><span class="pre">wait_for()</span></code></a> メソッドが追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Event">
<code class="descname">Event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Event" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="threading.html#threading.Event" title="threading.Event"><code class="xref py py-class docutils literal"><span class="pre">threading.Event</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Lock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">threading.Lock</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Namespace">
<code class="descname">Namespace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Namespace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="#multiprocessing.managers.Namespace" title="multiprocessing.managers.Namespace"><code class="xref py py-class docutils literal"><span class="pre">Namespace</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Queue">
<code class="descname">Queue</code><span class="sig-paren">(</span><span class="optional">[</span><em>maxsize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Queue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">queue.Queue</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.RLock">
<code class="descname">RLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.RLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">threading.RLock</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Semaphore">
<code class="descname">Semaphore</code><span class="sig-paren">(</span><span class="optional">[</span><em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Semaphore" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有 <a class="reference internal" href="threading.html#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal"><span class="pre">threading.Semaphore</span></code></a> オブジェクトを作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Array">
<code class="descname">Array</code><span class="sig-paren">(</span><em>typecode</em>, <em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Array" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>配列を作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.Value">
<code class="descname">Value</code><span class="sig-paren">(</span><em>typecode</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>書き込み可能な <code class="docutils literal"><span class="pre">value</span></code> 属性を作成して、そのプロキシを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.dict">
<code class="descname">dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.dict" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span></dt>
<dt>
<code class="descname">dict</code><span class="sig-paren">(</span><em>sequence</em><span class="sig-paren">)</span></dt>
<dd><p>Create a shared <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.SyncManager.list">
<code class="descname">list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.list" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">list</code><span class="sig-paren">(</span><em>sequence</em><span class="sig-paren">)</span></dt>
<dd><p>Create a shared <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Shared objects are capable of being nested.  For example, a shared
container object such as a shared list can contain other shared objects
which will all be managed and synchronized by the <a class="reference internal" href="#multiprocessing.managers.SyncManager" title="multiprocessing.managers.SyncManager"><code class="xref py py-class docutils literal"><span class="pre">SyncManager</span></code></a>.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.managers.Namespace">
<em class="property">class </em><code class="descclassname">multiprocessing.managers.</code><code class="descname">Namespace</code><a class="headerlink" href="#multiprocessing.managers.Namespace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.managers.SyncManager" title="multiprocessing.managers.SyncManager"><code class="xref py py-class docutils literal"><span class="pre">SyncManager</span></code></a> に登録することのできる型です。</p>
<p>Namespace オブジェクトにはパブリックなメソッドはありませんが、書き込み可能な属性を持ちます。そのオブジェクト表現はその属性の値を表示します。</p>
<p>しかし、Namespace オブジェクトのためにプロキシを使用するとき <code class="docutils literal"><span class="pre">'_'</span></code> が先頭に付く属性はプロキシの属性になり、参照対象の属性にはなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Namespace</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span><span class="o">.</span><span class="n">_z</span> <span class="o">=</span> <span class="mf">12.3</span>    <span class="c1"># this is an attribute of the proxy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Global</span><span class="p">)</span>
<span class="go">Namespace(x=10, y=&#39;hello&#39;)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="customized-managers">
<h4>17.2.2.7.1. カスタマイズされたマネージャー<a class="headerlink" href="#customized-managers" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>独自のマネージャーを作成するには、<a class="reference internal" href="#multiprocessing.managers.BaseManager" title="multiprocessing.managers.BaseManager"><code class="xref py py-class docutils literal"><span class="pre">BaseManager</span></code></a> のサブクラスを作成して、 マネージャークラスで呼び出し可能なオブジェクトか新たな型を登録するために <a class="reference internal" href="#multiprocessing.managers.BaseManager.register" title="multiprocessing.managers.BaseManager.register"><code class="xref py py-meth docutils literal"><span class="pre">register()</span></code></a> クラスメソッドを使用します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span>

<span class="k">class</span> <span class="nc">MathsClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

<span class="k">class</span> <span class="nc">MyManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;Maths&#39;</span><span class="p">,</span> <span class="n">MathsClass</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">MyManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
        <span class="n">maths</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Maths</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">maths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>         <span class="c1"># prints 7</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">maths</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>         <span class="c1"># prints 56</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-remote-manager">
<h4>17.2.2.7.2. リモートマネージャーを使用する<a class="headerlink" href="#using-a-remote-manager" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>あるマシン上でマネージャーサーバーを実行して、他のマシンからそのサーバーを使用するクライアントを持つことができます(ファイアウォールを通過できることが前提)。</p>
<p>次のコマンドを実行することでリモートクライアントからアクセスを受け付ける1つの共有キューのためにサーバーを作成します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">queue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">,</span> <span class="n">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">queue</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_server</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>あるクライアントからサーバーへのアクセスは次のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;foo.bar.org&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>別のクライアントもそれを使用することができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;foo.bar.org&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">&#39;hello&#39;</span>
</pre></div>
</div>
<p>ローカルプロセスもそのキューへアクセスすることができます。クライアント上で上述のコードを使用してアクセスします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">(</span><span class="n">Worker</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;local hello&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">,</span> <span class="n">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">queue</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_server</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="proxy-objects">
<span id="multiprocessing-proxy-objects"></span><h3>17.2.2.8. Proxy オブジェクト<a class="headerlink" href="#proxy-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>プロキシは別のプロセスで(おそらく)有効な共有オブジェクトを <em>参照する</em> オブジェクトです。共有オブジェクトはプロキシの <em>参照対象</em> になるということができます。複数のプロキシオブジェクトが同じ参照対象を持つ可能性もあります。</p>
<p>A proxy object has methods which invoke corresponding methods of its referent
(although not every method of the referent will necessarily be available through
the proxy).  In this way, a proxy can be used just like its referent can:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Manager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="go">&lt;ListProxy object, typeid &#39;list&#39; at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[4, 9, 16]</span>
</pre></div>
</div>
<p>プロキシに <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を適用すると参照対象のオブジェクト表現を返すのに対して、 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> を適用するとプロキシのオブジェクト表現を返すことに注意してください。</p>
<p>An important feature of proxy objects is that they are picklable so they can be
passed between processes.  As such, a referent can contain
<a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Proxy オブジェクト</span></a>.  This permits nesting of these managed
lists, dicts, and other <a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Proxy オブジェクト</span></a>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>         <span class="c1"># referent of a now contains referent of b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">[&lt;ListProxy object, typeid &#39;list&#39; at ...&gt;] []</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
<span class="go">[&#39;hello&#39;] [&#39;hello&#39;]</span>
</pre></div>
</div>
<p>Similarly, dict and list proxies may be nested inside one another:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l_outer</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">([</span> <span class="n">manager</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_first_inner</span> <span class="o">=</span> <span class="n">l_outer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_first_inner</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_first_inner</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l_outer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l_outer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l_outer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l_outer</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{&#39;c&#39;: 3, &#39;z&#39;: 26}</span>
</pre></div>
</div>
<p>If standard (non-proxy) <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> or <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> objects are contained
in a referent, modifications to those mutable values will not be propagated
through the manager because the proxy has no way of knowing when the values
contained within are modified.  However, storing a value in a container proxy
(which triggers a <code class="docutils literal"><span class="pre">__setitem__</span></code> on the proxy object) does propagate through
the manager and so to effectively modify such an item, one could re-assign the
modified value to the container proxy:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># create a list proxy and append a mutable object (a dictionary)</span>
<span class="n">lproxy</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="n">lproxy</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
<span class="c1"># now mutate the dictionary</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">lproxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># at this point, the changes to d are not yet synced, but by</span>
<span class="c1"># updating the dictionary, the proxy is notified of the change</span>
<span class="n">lproxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>This approach is perhaps less convenient than employing nested
<a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Proxy オブジェクト</span></a> for most use cases but also
demonstrates a level of control over the synchronization.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> のプロキシ型は値による比較に対して何もサポートしません。そのため、例えば以下のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="last">比較を行いたいときは参照対象のコピーを使用してください。</p>
</div>
<dl class="class">
<dt id="multiprocessing.managers.BaseProxy">
<em class="property">class </em><code class="descclassname">multiprocessing.managers.</code><code class="descname">BaseProxy</code><a class="headerlink" href="#multiprocessing.managers.BaseProxy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシオブジェクトは <a class="reference internal" href="#multiprocessing.managers.BaseProxy" title="multiprocessing.managers.BaseProxy"><code class="xref py py-class docutils literal"><span class="pre">BaseProxy</span></code></a> のサブクラスのインスタンスです。</p>
<dl class="method">
<dt id="multiprocessing.managers.BaseProxy._callmethod">
<code class="descname">_callmethod</code><span class="sig-paren">(</span><em>methodname</em><span class="optional">[</span>, <em>args</em><span class="optional">[</span>, <em>kwds</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy._callmethod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシの参照対象のメソッドの実行結果を返します。</p>
<p><code class="docutils literal"><span class="pre">proxy</span></code> がプロキシで、プロキシ内の参照対象が <code class="docutils literal"><span class="pre">obj</span></code> ならこの式</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">proxy</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="n">methodname</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p>はこの式を評価します</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">methodname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p>(マネージャープロセス内の)。</p>
<p>返される値はその呼び出し結果のコピーか、新たな共有オブジェクトに対するプロキシになります。詳細は <a class="reference internal" href="#multiprocessing.managers.BaseManager.register" title="multiprocessing.managers.BaseManager.register"><code class="xref py py-meth docutils literal"><span class="pre">BaseManager.register()</span></code></a> の <em>method_to_typeid</em> 引数のドキュメントを参照してください。</p>
<p>その呼び出しによって例外が発生した場合、<a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal"><span class="pre">_callmethod()</span></code></a> によってその例外は再送出されます。他の例外がマネージャープロセスで発生したなら、<code class="xref py py-exc docutils literal"><span class="pre">RemoteError</span></code> 例外に変換されたものが <a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal"><span class="pre">_callmethod()</span></code></a> によって送出されます。</p>
<p>特に <em>methodname</em> が <em>公開</em> されていない場合は例外が発生することに注意してください。</p>
<p><a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal"><span class="pre">_callmethod()</span></code></a> の使用例になります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__len__&#39;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),))</span> <span class="c1"># equivalent to l[2:7]</span>
<span class="go">[2, 3, 4, 5, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,))</span>          <span class="c1"># equivalent to l[20]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">list index out of range</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.BaseProxy._getvalue">
<code class="descname">_getvalue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy._getvalue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>参照対象のコピーを返します。</p>
<p>参照対象が unpickle 化できるなら例外を発生します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.BaseProxy.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy.__repr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシオブジェクトのオブジェクト表現を返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.managers.BaseProxy.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy.__str__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>参照対象のオブジェクト表現を返します。</p>
</dd></dl>

</dd></dl>

<div class="section" id="cleanup">
<h4>17.2.2.8.1. クリーンアップ<a class="headerlink" href="#cleanup" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>プロキシオブジェクトは弱参照(weakref)コールバックを使用します。プロキシオブジェクトがガベージコレクトされるときにその参照対象が所有するマネージャーからその登録を取り消せるようにするためです。</p>
<p>共有オブジェクトはプロキシが参照しなくなったときにマネージャープロセスから削除されます。</p>
</div>
</div>
<div class="section" id="module-multiprocessing.pool">
<span id="process-pools"></span><h3>17.2.2.9. プロセスプール<a class="headerlink" href="#module-multiprocessing.pool" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">Pool</span></code></a> クラスでタスクを実行するプロセスのプールを作成することができます。</p>
<dl class="class">
<dt id="multiprocessing.pool.Pool">
<em class="property">class </em><code class="descclassname">multiprocessing.pool.</code><code class="descname">Pool</code><span class="sig-paren">(</span><span class="optional">[</span><em>processes</em><span class="optional">[</span>, <em>initializer</em><span class="optional">[</span>, <em>initargs</em><span class="optional">[</span>, <em>maxtasksperchild</em><span class="optional">[</span>, <em>context</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロセスプールオブジェクトは、ジョブを送り込めるワーカープロセスのプールを制御します。タイムアウトやコールバックのある非同期の実行をサポートし、並列 map 実装を持ちます。</p>
<p><em>processes</em> は使用するワーカープロセスの数です。<em>processes</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合 <a class="reference internal" href="os.html#os.cpu_count" title="os.cpu_count"><code class="xref py py-func docutils literal"><span class="pre">os.cpu_count()</span></code></a> が返す値を使用します。</p>
<p><em>initializer</em> が <code class="docutils literal"><span class="pre">None</span></code> ではない場合、各ワーカープロセスは開始時に <code class="docutils literal"><span class="pre">initializer(*initargs)</span></code> を呼び出します。</p>
<p><em>maxtasksperchild</em> は、ワーカープロセスが exit して新たなワーカープロセスと置き替えられるまでの間に、ワーカープロセスが完了することのできるタスクの数です。この設定により未利用のリソースが解放されるようなります。デフォルトの <em>maxtasksperchild</em> は <code class="docutils literal"><span class="pre">None</span></code> で、これはワーカープロセスがプールと同じ期間だけ生き続けるということを意味します。</p>
<p><em>context</em> はワーカープロセスを開始するために使用されるコンテキストの指定に使用できます。通常プールは関数 <code class="xref py py-func docutils literal"><span class="pre">multiprocessing.Pool()</span></code> かコンテキストオブジェクトの <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-meth docutils literal"><span class="pre">Pool()</span></code></a> メソッドを使用して作成されます。どちらの場合でも <em>context</em> は適切に設定されます。</p>
<p>プールオブジェクトのメソッドは、そのプールを作成したプロセスのみが呼び出すべきです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span><em>maxtasksperchild</em></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加: </span><em>context</em></p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">Pool</span></code></a> 中のワーカープロセスは、典型的にはプールのワークキューの存続期間とちょうど同じだけ生き続けます。ワーカーに確保されたリソースを解放するために (Apache, mod_wsgi, などのような) 他のシステムによく見られるパターンは、プール内のワーカーが設定された量だけの仕事を完了したら exit とクリーンアップを行い、古いプロセスを置き換えるために新しいプロセスを生成するというものです。 <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">Pool</span></code></a> の <em>maxtasksperchild</em> 引数は、この能力をエンドユーザーに提供します。</p>
</div>
<dl class="method">
<dt id="multiprocessing.pool.Pool.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>func</em><span class="optional">[</span>, <em>args</em><span class="optional">[</span>, <em>kwds</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.apply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>args</em> とキーワード引数 <em>kwds</em> を伴って <em>func</em> を呼びます。結果が準備できるまでブロックします。このブロックがあるため、 <a class="reference internal" href="#multiprocessing.pool.Pool.apply_async" title="multiprocessing.pool.Pool.apply_async"><code class="xref py py-meth docutils literal"><span class="pre">apply_async()</span></code></a> の方が並行作業により適しています。加えて、 <em>func</em> は、プール内の1つのワーカーだけで実行されます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.apply_async">
<code class="descname">apply_async</code><span class="sig-paren">(</span><em>func</em><span class="optional">[</span>, <em>args</em><span class="optional">[</span>, <em>kwds</em><span class="optional">[</span>, <em>callback</em><span class="optional">[</span>, <em>error_callback</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.apply_async" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.pool.Pool.apply" title="multiprocessing.pool.Pool.apply"><code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code></a> メソッドの派生版で結果オブジェクトを返します。</p>
<p><em>callback</em> が指定された場合、それは単一の引数を受け取る呼び出し可能オブジェクトでなければなりません。結果を返せるようになったときに <em>callback</em> が結果オブジェクトに対して適用されます。ただし呼び出しが失敗した場合は、代わりに <em>error_callback</em> が適用されます。</p>
<p><em>error_callback</em> が指定された場合、それは単一の引数を受け取る呼び出し可能オブジェクトでなければなりません。対象の関数が失敗した場合、例外インスタンスを伴って <em>error_callback</em> が呼ばれます。</p>
<p>コールバックは直ちに完了すべきです。なぜなら、そうしなければ、結果を扱うスレッドがブロックするからです。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>func</em>, <em>iterable</em><span class="optional">[</span>, <em>chunksize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.map" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> 組み込み関数の並列版です (<em>iterable</em> な引数を1つだけサポートするという違いはありますが)。結果が出るまでブロックします。</p>
<p>このメソッドはイテラブルをいくつものチャンクに分割し、プロセスプールにそれぞれ独立したタスクとして送ります。(概算の) チャンクサイズは <em>chunksize</em> を正の整数に設定することで指定できます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.map_async">
<code class="descname">map_async</code><span class="sig-paren">(</span><em>func</em>, <em>iterable</em><span class="optional">[</span>, <em>chunksize</em><span class="optional">[</span>, <em>callback</em><span class="optional">[</span>, <em>error_callback</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.map_async" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.pool.Pool.map" title="multiprocessing.pool.Pool.map"><code class="xref py py-meth docutils literal"><span class="pre">map()</span></code></a> メソッドの派生版で結果オブジェクトを返します。</p>
<p><em>callback</em> が指定された場合、それは単一の引数を受け取る呼び出し可能オブジェクトでなければなりません。結果を返せるようになったときに <em>callback</em> が結果オブジェクトに対して適用されます。ただし呼び出しが失敗した場合は、代わりに <em>error_callback</em> が適用されます。</p>
<p><em>error_callback</em> が指定された場合、それは単一の引数を受け取る呼び出し可能オブジェクトでなければなりません。対象の関数が失敗した場合、例外インスタンスを伴って <em>error_callback</em> が呼ばれます。</p>
<p>コールバックは直ちに完了すべきです。なぜなら、そうしなければ、結果を扱うスレッドがブロックするからです。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.imap">
<code class="descname">imap</code><span class="sig-paren">(</span><em>func</em>, <em>iterable</em><span class="optional">[</span>, <em>chunksize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.imap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-meth docutils literal"><span class="pre">map()</span></code></a> の遅延評価版です。</p>
<p><em>chunksize</em> 引数は <a class="reference internal" href="#multiprocessing.pool.Pool.map" title="multiprocessing.pool.Pool.map"><code class="xref py py-meth docutils literal"><span class="pre">map()</span></code></a> メソッドで使用されるものと同じです。 引数 iterable がとても長いなら <em>chunksize</em> に大きな値を指定して使用する方がデフォルト値の <code class="docutils literal"><span class="pre">1</span></code> を使用するよりもジョブの完了が <strong>かなり</strong> 速くなります。</p>
<p>また <em>chunksize</em> が <code class="docutils literal"><span class="pre">1</span></code> の場合 <a class="reference internal" href="#multiprocessing.pool.Pool.imap" title="multiprocessing.pool.Pool.imap"><code class="xref py py-meth docutils literal"><span class="pre">imap()</span></code></a> メソッドが返すイテレーターの <code class="xref py py-meth docutils literal"><span class="pre">next()</span></code> メソッドはオプションで <em>timeout</em> パラメーターを持ちます。 <code class="docutils literal"><span class="pre">next(timeout)</span></code> は、その結果が <em>timeout</em> 秒以内に返されないときに <a class="reference internal" href="#multiprocessing.TimeoutError" title="multiprocessing.TimeoutError"><code class="xref py py-exc docutils literal"><span class="pre">multiprocessing.TimeoutError</span></code></a> を発生させます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.imap_unordered">
<code class="descname">imap_unordered</code><span class="sig-paren">(</span><em>func</em>, <em>iterable</em><span class="optional">[</span>, <em>chunksize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.imap_unordered" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレーターが返す結果の順番が任意の順番で良いと見なされることを除けば <a class="reference internal" href="#multiprocessing.pool.Pool.imap" title="multiprocessing.pool.Pool.imap"><code class="xref py py-meth docutils literal"><span class="pre">imap()</span></code></a> と同じです。 (ワーカープロセスが1つしかない場合のみ &#8220;正しい&#8221; 順番になることが保証されます。)</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.starmap">
<code class="descname">starmap</code><span class="sig-paren">(</span><em>func</em>, <em>iterable</em><span class="optional">[</span>, <em>chunksize</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.starmap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> の要素が、引数として unpack されるイテレート可能オブジェクトであると期待される以外は、 <a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-meth docutils literal"><span class="pre">map()</span></code></a> と似ています。</p>
<p>そのため、<em>iterable</em> が <code class="docutils literal"><span class="pre">[(1,2),</span> <span class="pre">(3,</span> <span class="pre">4)]</span></code> なら、結果は <code class="docutils literal"><span class="pre">[func(1,2),</span> <span class="pre">func(3,4)]</span></code> になります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.starmap_async">
<code class="descname">starmap_async</code><span class="sig-paren">(</span><em>func</em>, <em>iterable</em><span class="optional">[</span>, <em>chunksize</em><span class="optional">[</span>, <em>callback</em><span class="optional">[</span>, <em>error_back</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.starmap_async" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.pool.Pool.starmap" title="multiprocessing.pool.Pool.starmap"><code class="xref py py-meth docutils literal"><span class="pre">starmap()</span></code></a> と <a class="reference internal" href="#multiprocessing.pool.Pool.map_async" title="multiprocessing.pool.Pool.map_async"><code class="xref py py-meth docutils literal"><span class="pre">map_async()</span></code></a> の組み合わせです。 イテレート可能オブジェクトの <em>iterable</em> をイテレートして、 unpack したイテレート可能オブジェクトを伴って <em>func</em> を呼び出します。結果オブジェクトを返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これ以上プールでタスクが実行されないようにします。すべてのタスクが完了した後でワーカープロセスが終了します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.terminate">
<code class="descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.terminate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行中の処理を完了させずにワーカープロセスをすぐに停止します。プールオブジェクトがガベージコレクトされるときに <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal"><span class="pre">terminate()</span></code></a> が呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.Pool.join">
<code class="descname">join</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ワーカープロセスが終了するのを待ちます。 <a class="reference internal" href="#multiprocessing.pool.Pool.join" title="multiprocessing.pool.Pool.join"><code class="xref py py-meth docutils literal"><span class="pre">join()</span></code></a> を使用する前に <a class="reference internal" href="#multiprocessing.pool.Pool.close" title="multiprocessing.pool.Pool.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> か <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal"><span class="pre">terminate()</span></code></a> を呼び出さなければなりません。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span>Pool オブジェクトがコンテキストマネージメント・プロトコルをサポートするようになりました。 &#8211; <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> を参照してください。 <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> は Pool オブジェクトを返します。また <a class="reference internal" href="stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> は <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal"><span class="pre">terminate()</span></code></a> を呼び出します。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.pool.AsyncResult">
<em class="property">class </em><code class="descclassname">multiprocessing.pool.</code><code class="descname">AsyncResult</code><a class="headerlink" href="#multiprocessing.pool.AsyncResult" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.pool.Pool.apply_async" title="multiprocessing.pool.Pool.apply_async"><code class="xref py py-meth docutils literal"><span class="pre">Pool.apply_async()</span></code></a> や <a class="reference internal" href="#multiprocessing.pool.Pool.map_async" title="multiprocessing.pool.Pool.map_async"><code class="xref py py-meth docutils literal"><span class="pre">Pool.map_async()</span></code></a> で返される結果のクラスです。</p>
<dl class="method">
<dt id="multiprocessing.pool.AsyncResult.get">
<code class="descname">get</code><span class="sig-paren">(</span><span class="optional">[</span><em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>結果を受け取ったときに返します。 <em>timeout</em> が <code class="docutils literal"><span class="pre">None</span></code> ではなくて、その結果が <em>timeout</em> 秒以内に受け取れない場合 <a class="reference internal" href="#multiprocessing.TimeoutError" title="multiprocessing.TimeoutError"><code class="xref py py-exc docutils literal"><span class="pre">multiprocessing.TimeoutError</span></code></a> が発生します。リモートの呼び出しが例外を発生させる場合、その例外は <a class="reference internal" href="#multiprocessing.pool.AsyncResult.get" title="multiprocessing.pool.AsyncResult.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a> が再発生させます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.AsyncResult.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><span class="optional">[</span><em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>その結果が有効になるか <em>timeout</em> 秒経つまで待ちます。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.AsyncResult.ready">
<code class="descname">ready</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.ready" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>その呼び出しが完了しているかどうかを返します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.pool.AsyncResult.successful">
<code class="descname">successful</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.successful" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>その呼び出しが例外を発生させることなく完了したかどうかを返します。その結果が返せる状態でない場合 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> が発生します。</p>
</dd></dl>

</dd></dl>

<p>次の例はプールの使用例を紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>         <span class="c1"># start 4 worker processes</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,))</span> <span class="c1"># evaluate &quot;f(10)&quot; asynchronously in a single process</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        <span class="c1"># prints &quot;100&quot; unless your computer is *very* slow</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>       <span class="c1"># prints &quot;[0, 1, 4,..., 81]&quot;</span>

        <span class="n">it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>                     <span class="c1"># prints &quot;0&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>                     <span class="c1"># prints &quot;1&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>           <span class="c1"># prints &quot;4&quot; unless your computer is *very* slow</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        <span class="c1"># raises multiprocessing.TimeoutError</span>
</pre></div>
</div>
</div>
<div class="section" id="module-multiprocessing.connection">
<span id="listeners-and-clients"></span><span id="multiprocessing-listeners-clients"></span><h3>17.2.2.10. リスナーとクライアント<a class="headerlink" href="#module-multiprocessing.connection" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>通常、プロセス間でメッセージを渡すにはキューを使用するか <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal"><span class="pre">Pipe()</span></code></a> が返す <a class="reference internal" href="#multiprocessing.Connection" title="multiprocessing.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> オブジェクトを使用します。</p>
<p>しかし <a class="reference internal" href="#module-multiprocessing.connection" title="multiprocessing.connection: API for dealing with sockets."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.connection</span></code></a> モジュールにはさらに柔軟な仕組みがあります。 このモジュールは、基本的にはソケットもしくは Windows の名前付きパイプを扱う高レベルのメッセージ指向 API を提供します。また、 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal"><span class="pre">hmac</span></code></a> モジュールを使用した <em>ダイジェスト認証</em> や同時の複数接続のポーリングもサポートします。</p>
<dl class="function">
<dt id="multiprocessing.connection.deliver_challenge">
<code class="descclassname">multiprocessing.connection.</code><code class="descname">deliver_challenge</code><span class="sig-paren">(</span><em>connection</em>, <em>authkey</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.deliver_challenge" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ランダム生成したメッセージをコネクションの相手側へ送信して応答を待ちます。</p>
<p>その応答がキーとして <em>authkey</em> を使用するメッセージのダイジェストと一致する場合、 コネクションの相手側へ歓迎メッセージを送信します。 そうでなければ <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal"><span class="pre">AuthenticationError</span></code></a> を発生させます。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.connection.answer_challenge">
<code class="descclassname">multiprocessing.connection.</code><code class="descname">answer_challenge</code><span class="sig-paren">(</span><em>connection</em>, <em>authkey</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.answer_challenge" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージを受信して、そのキーとして <em>authkey</em> を使用するメッセージのダイジェストを計算し、ダイジェストを送り返します。</p>
<p>歓迎メッセージを受け取れない場合 <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal"><span class="pre">AuthenticationError</span></code></a> が発生します。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.connection.Client">
<code class="descclassname">multiprocessing.connection.</code><code class="descname">Client</code><span class="sig-paren">(</span><em>address</em><span class="optional">[</span>, <em>family</em><span class="optional">[</span>, <em>authenticate</em><span class="optional">[</span>, <em>authkey</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Client" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>address</em> で渡したアドレスを使用するリスナーに対してコネクションを確立しようとして <a class="reference internal" href="#multiprocessing.Connection" title="multiprocessing.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> を返します。</p>
<p>コネクション種別は <em>family</em> 引数で決定しますが、一般的には <em>address</em> のフォーマットから推測できるので、これは指定されません。 (<a class="reference internal" href="#multiprocessing-address-formats"><span class="std std-ref">アドレスフォーマット</span></a> を参照してください)</p>
<p><em>authenticate</em> が <code class="docutils literal"><span class="pre">True</span></code> か <em>authkey</em> がバイト文字列の場合、 ダイジェスト認証が使用されます。認証に使用されるキーは <em>authkey</em> 、または <em>authkey</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合は <code class="docutils literal"><span class="pre">current_process().authkey</span></code> のどちらかです。 認証が失敗した場合 <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal"><span class="pre">AuthenticationError</span></code></a> が発生します。 <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">認証キー</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="multiprocessing.connection.Listener">
<em class="property">class </em><code class="descclassname">multiprocessing.connection.</code><code class="descname">Listener</code><span class="sig-paren">(</span><span class="optional">[</span><em>address</em><span class="optional">[</span>, <em>family</em><span class="optional">[</span>, <em>backlog</em><span class="optional">[</span>, <em>authenticate</em><span class="optional">[</span>, <em>authkey</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Listener" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コネクションを &#8216;待ち受ける&#8217; 束縛されたソケットか Windows の名前付きパイプのラッパーです。</p>
<p><em>address</em> はリスナーオブジェクトの束縛されたソケットか名前付きパイプが使用するアドレスです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">&#8216;0.0.0.0&#8217; のアドレスを使用する場合、Windows 上の終点へ接続することができません。終点へ接続したい場合は &#8216;127.0.0.1&#8217; を使用すべきです。</p>
</div>
<p><em>family</em> は使用するソケット(名前付きパイプ)の種別です。これは <code class="docutils literal"><span class="pre">'AF_INET'</span></code> (TCP ソケット), <code class="docutils literal"><span class="pre">'AF_UNIX'</span></code> (Unix ドメインソケット) または <code class="docutils literal"><span class="pre">'AF_PIPE'</span></code> (Windows 名前付きパイプ) という文字列のどれか1つになります。これらのうち <code class="docutils literal"><span class="pre">'AF_INET'</span></code> のみが利用可能であることが保証されています。 <em>family</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合 <em>address</em> のフォーマットから推測されたものが使用されます。 <em>address</em> も <code class="docutils literal"><span class="pre">None</span></code> の場合はデフォルトが選択されます。詳細は <a class="reference internal" href="#multiprocessing-address-formats"><span class="std std-ref">アドレスフォーマット</span></a> を参照してください。 <em>family</em> が <code class="docutils literal"><span class="pre">'AF_UNIX'</span></code> で <em>address</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合 <a class="reference internal" href="tempfile.html#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal"><span class="pre">tempfile.mkstemp()</span></code></a> を使用して作成されたプライベートな一時ディレクトリにソケットが作成されます。</p>
<p>リスナーオブジェクトがソケットを使用する場合、ソケットに束縛されるときに <em>backlog</em> (デフォルトでは1つ) がソケットの <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a> メソッドに対して渡されます。</p>
<p><em>authenticate</em> が <code class="docutils literal"><span class="pre">True</span></code> (デフォルトでは <code class="docutils literal"><span class="pre">False</span></code>) か <em>authkey</em> が <code class="docutils literal"><span class="pre">None</span></code> ではない場合、ダイジェスト認証が使用されます。</p>
<p><em>authkey</em> がバイト文字列の場合、認証キーとして使用されます。そうでない場合は <code class="docutils literal"><span class="pre">None</span></code> でなければいけません。</p>
<p><em>authkey</em> が <code class="docutils literal"><span class="pre">None</span></code> かつ <em>authenticate</em> が <code class="docutils literal"><span class="pre">True</span></code> の場合 <code class="docutils literal"><span class="pre">current_process().authkey</span></code> が認証キーとして使用されます。 <em>authkey</em> が <code class="docutils literal"><span class="pre">None</span></code> かつ <em>authenticate</em> が <code class="docutils literal"><span class="pre">False</span></code> の場合、認証は行われません。 もし認証が失敗した場合 <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal"><span class="pre">AuthenticationError</span></code></a> が発生します。 詳細については <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">認証キー</span></a> を参照してください。</p>
<dl class="method">
<dt id="multiprocessing.connection.Listener.accept">
<code class="descname">accept</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Listener.accept" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーオブジェクトの名前付きパイプか束縛されたソケット上でコネクションを受け付けて <a class="reference internal" href="#multiprocessing.Connection" title="multiprocessing.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> オブジェクトを返します。認証が失敗した場合 <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal"><span class="pre">AuthenticationError</span></code></a> が発生します。</p>
</dd></dl>

<dl class="method">
<dt id="multiprocessing.connection.Listener.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Listener.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーオブジェクトの名前付きパイプか束縛されたソケットをクローズします。これはリスナーがガベージコレクトされるときに自動的に呼ばれます。そうは言っても、明示的に close() を呼び出す方が望ましいです。</p>
</dd></dl>

<p>リスナーオブジェクトは次の読み取り専用属性を持っています:</p>
<dl class="attribute">
<dt id="multiprocessing.connection.Listener.address">
<code class="descname">address</code><a class="headerlink" href="#multiprocessing.connection.Listener.address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーオブジェクトが使用中のアドレスです。</p>
</dd></dl>

<dl class="attribute">
<dt id="multiprocessing.connection.Listener.last_accepted">
<code class="descname">last_accepted</code><a class="headerlink" href="#multiprocessing.connection.Listener.last_accepted" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最後にコネクションを受け付けたアドレスです。有効なアドレスがない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span>Listener オブジェクトがコンテキストマネージメント・プロトコルをサポートするようになりました。 &#8211; <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> を参照してください。 <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> はリスナーオブジェクトを返します。また <a class="reference internal" href="stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> は <a class="reference internal" href="#multiprocessing.connection.Listener.close" title="multiprocessing.connection.Listener.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> を呼び出します。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.connection.wait">
<code class="descclassname">multiprocessing.connection.</code><code class="descname">wait</code><span class="sig-paren">(</span><em>object_list</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object_list</em> 中のオブジェクトが準備ができるまで待機します。準備ができた <em>object_list</em> 中のオブジェクトのリストを返します。<em>timeout</em> が浮動小数点なら、最大でその秒数だけ呼び出しがブロックします。<em>timeout</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合、無制限の期間ブロックします。負のタイムアウトは0と等価です。</p>
<p>Unix と Windows の両方で、 <em>object_list</em> には以下のオブジェクトを含めることが出来ます</p>
<ul class="simple">
<li><p class="first">読み取り可能な <a class="reference internal" href="#multiprocessing.Connection" title="multiprocessing.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> オブジェクト;</p>
</li>
<li><p class="first">接続された読み取り可能な <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> オブジェクト; または</p>
</li>
<li><p class="first"><a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> オブジェクトの <a class="reference internal" href="#multiprocessing.Process.sentinel" title="multiprocessing.Process.sentinel"><code class="xref py py-attr docutils literal"><span class="pre">sentinel</span></code></a> 属性。</p>
</li>
</ul>
<p>読み取ることのできるデータがある場合、あるいは相手側の端が閉じられている場合、コネクションまたはソケットオブジェクトは準備ができています。</p>
<p><strong>Unix</strong>: <code class="docutils literal"><span class="pre">wait(object_list,</span> <span class="pre">timeout)</span></code> は <code class="docutils literal"><span class="pre">select.select(object_list,</span> <span class="pre">[],</span> <span class="pre">[],</span> <span class="pre">timeout)</span></code> とほとんど等価です。違いは、 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select.select()</span></code></a> がシグナルによって中断される場合、 <code class="docutils literal"><span class="pre">EINTR</span></code> のエラー番号付きで <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> を上げるということです。 <a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a> はそのようなことは行いません。</p>
<p><strong>Windows</strong>: <em>object_list</em> の要素は、 (Win32 関数 <code class="docutils literal"><span class="pre">WaitForMultipleObjects()</span></code> のドキュメントで使われている定義から) wait 可能な整数ハンドルか、ソケットハンドルまたはパイプハンドルを返す <code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code> メソッドを持つオブジェクトのどちらかでなければなりません。 (パイプハンドルとソケットハンドラーは wait 可能なハンドルでは <strong>ない</strong> ことに注意してください。)</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<p><strong>例</strong></p>
<p>次のサーバーコードは認証キーとして <code class="docutils literal"><span class="pre">'secret</span> <span class="pre">password'</span></code> を使用するリスナーを作成します。このサーバーはコネクションを待ってクライアントへデータを送信します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="k">import</span> <span class="n">Listener</span>
<span class="kn">from</span> <span class="nn">array</span> <span class="k">import</span> <span class="n">array</span>

<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">6000</span><span class="p">)</span>     <span class="c1"># family is deduced to be &#39;AF_INET&#39;</span>

<span class="k">with</span> <span class="n">Listener</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;secret password&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">listener</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">listener</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connection accepted from&#39;</span><span class="p">,</span> <span class="n">listener</span><span class="o">.</span><span class="n">last_accepted</span><span class="p">)</span>

        <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="mf">2.25</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;junk&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>

        <span class="n">conn</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

        <span class="n">conn</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">1729</span><span class="p">]))</span>
</pre></div>
</div>
<p>次のコードはサーバーへ接続して、サーバーからデータを受信します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="k">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">array</span> <span class="k">import</span> <span class="n">array</span>

<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">6000</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Client</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;secret password&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>                  <span class="c1"># =&gt; [2.25, None, &#39;junk&#39;, float]</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv_bytes</span><span class="p">())</span>            <span class="c1"># =&gt; &#39;hello&#39;</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv_bytes_into</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>    <span class="c1"># =&gt; 8</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>                          <span class="c1"># =&gt; array(&#39;i&#39;, [42, 1729, 0, 0, 0])</span>
</pre></div>
</div>
<p>次のコードは <a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a> を使って複数のプロセスからのメッセージを同時に待ちます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">current_process</span>
<span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="k">import</span> <span class="n">wait</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">w</span><span class="o">.</span><span class="n">send</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    <span class="n">w</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">readers</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">readers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="p">,))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="c1"># We close the writable end of the pipe now to be sure that</span>
        <span class="c1"># p is the only process which owns a handle for it.  This</span>
        <span class="c1"># ensures that when p closes its handle for the writable end,</span>
        <span class="c1"># wait() will promptly report the readable end as being ready.</span>
        <span class="n">w</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">readers</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">wait</span><span class="p">(</span><span class="n">readers</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
                <span class="n">readers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="address-formats">
<span id="multiprocessing-address-formats"></span><h4>17.2.2.10.1. アドレスフォーマット<a class="headerlink" href="#address-formats" title="このヘッドラインへのパーマリンク">¶</a></h4>
<ul class="simple">
<li><p class="first"><code class="docutils literal"><span class="pre">'AF_INET'</span></code> アドレスは <code class="docutils literal"><span class="pre">(hostname,</span> <span class="pre">port)</span></code> のタプルになります。 <em>hostname</em> は文字列で <em>port</em> は整数です。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'AF_UNIX'</span></code> アドレスはファイルシステム上のファイル名の文字列です。</p>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">'AF_PIPE'</span></code> アドレスは、次の形式を持つ文字列です</dt>
<dd><p class="first last"><code class="samp docutils literal"><span class="pre">r'\\.\pipe\</span><em><span class="pre">PipeName</span></em><span class="pre">'</span></code> 。 <em>ServerName</em> という名前のリモートコンピューター上の名前付きパイプに接続するために <a class="reference internal" href="#multiprocessing.connection.Client" title="multiprocessing.connection.Client"><code class="xref py py-func docutils literal"><span class="pre">Client()</span></code></a> を使用するには、代わりに <code class="samp docutils literal"><span class="pre">r'\\</span><em><span class="pre">ServerName</span></em><span class="pre">\pipe\</span><em><span class="pre">PipeName</span></em><span class="pre">'</span></code> 形式のアドレスを使用する必要があります。</p>
</dd>
</dl>
</li>
</ul>
<p>デフォルトでは、2つのバックスラッシュで始まる文字列は <code class="docutils literal"><span class="pre">'AF_UNIX'</span></code> よりも <code class="docutils literal"><span class="pre">'AF_PIPE'</span></code> として推測されることに注意してください。</p>
</div>
</div>
<div class="section" id="authentication-keys">
<span id="multiprocessing-auth-keys"></span><h3>17.2.2.11. 認証キー<a class="headerlink" href="#authentication-keys" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#multiprocessing.Connection.recv" title="multiprocessing.Connection.recv"><code class="xref py py-meth docutils literal"><span class="pre">Connection.recv</span></code></a> を使用するとき、データは自動的に unpickle されて受信します。信頼できない接続元からのデータを unpickle することはセキュリティリスクがあります。そのため <a class="reference internal" href="#multiprocessing.connection.Listener" title="multiprocessing.connection.Listener"><code class="xref py py-class docutils literal"><span class="pre">Listener</span></code></a> や <a class="reference internal" href="#multiprocessing.connection.Client" title="multiprocessing.connection.Client"><code class="xref py py-func docutils literal"><span class="pre">Client()</span></code></a> はダイジェスト認証を提供するために <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal"><span class="pre">hmac</span></code></a> モジュールを使用します。</p>
<p>認証キーはパスワードとして見なされるバイト文字列です。コネクションが確立すると、双方の終点で正しい接続先であることを証明するために 知っているお互いの認証キーを要求します。(双方の終点が同じキーを使用して通信しようとしても、コネクション上でそのキーを送信することは <strong>できません</strong>。)</p>
<p>認証が要求されているにもかかわらず認証キーが指定されていない場合 <code class="docutils literal"><span class="pre">current_process().authkey</span></code> の返す値が使用されます。 (詳細は <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> を参照してください。) この値はカレントプロセスを作成する <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> オブジェクトによって自動的に継承されます。 これは(デフォルトでは)複数プロセスのプログラムの全プロセスが相互にコネクションを 確立するときに使用される1つの認証キーを共有することを意味します。</p>
<p>適当な認証キーを <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal"><span class="pre">os.urandom()</span></code></a> を使用して生成することもできます。</p>
</div>
<div class="section" id="logging">
<h3>17.2.2.12. ログ記録<a class="headerlink" href="#logging" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ロギングのためにいくつかの機能が利用可能です。しかし <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> パッケージは、 (ハンドラー種別に依存して)違うプロセスからのメッセージがごちゃ混ぜになるので、プロセスの共有ロックを使用しないことに注意してください。</p>
<dl class="function">
<dt id="multiprocessing.get_logger">
<code class="descclassname">multiprocessing.</code><code class="descname">get_logger</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_logger" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> が使用するロガーを返します。必要に応じて新たなロガーを作成します。</p>
<p>最初に作成するとき、ロガーはレベルに <code class="xref py py-data docutils literal"><span class="pre">logging.NOTSET</span></code> が設定されていてデフォルトハンドラーがありません。このロガーへ送られるメッセージはデフォルトではルートロガーへ伝播されません。</p>
<p>Windows 上では子プロセスが親プロセスのロガーレベルを継承しないことに注意してください。さらにその他のロガーのカスタマイズ内容もすべて継承されません。</p>
</dd></dl>

<dl class="function">
<dt id="multiprocessing.log_to_stderr">
<code class="descclassname">multiprocessing.</code><code class="descname">log_to_stderr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.log_to_stderr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="#multiprocessing.get_logger" title="multiprocessing.get_logger"><code class="xref py py-func docutils literal"><span class="pre">get_logger()</span></code></a> に対する呼び出しを実行しますが、 get_logger によって作成されるロガーを返すことに加えて、 <code class="docutils literal"><span class="pre">'[%(levelname)s/%(processName)s]</span> <span class="pre">%(message)s'</span></code> のフォーマットを使用して <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a> へ出力を送るハンドラーを追加します。</p>
</dd></dl>

<p>以下にロギングを有効にした例を紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">multiprocessing</span><span class="o">,</span> <span class="nn">logging</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logger</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;doomed&#39;</span><span class="p">)</span>
<span class="go">[WARNING/MainProcess] doomed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
<span class="go">[INFO/SyncManager-...] child process calling self.run()</span>
<span class="go">[INFO/SyncManager-...] created temp directory /.../pymp-...</span>
<span class="go">[INFO/SyncManager-...] manager serving at &#39;/.../listener-...&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">m</span>
<span class="go">[INFO/MainProcess] sending shutdown message to manager</span>
<span class="go">[INFO/SyncManager-...] manager exiting with exitcode 0</span>
</pre></div>
</div>
<p>完全なロギングレベルの表については <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> モジュールを参照してください。</p>
</div>
<div class="section" id="module-multiprocessing.dummy">
<span id="the-multiprocessing-dummy-module"></span><h3>17.2.2.13. <a class="reference internal" href="#module-multiprocessing.dummy" title="multiprocessing.dummy: Dumb wrapper around threading."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.dummy</span></code></a> モジュール<a class="headerlink" href="#module-multiprocessing.dummy" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-multiprocessing.dummy" title="multiprocessing.dummy: Dumb wrapper around threading."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing.dummy</span></code></a> は <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> の API を複製しますが <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールのラッパーでしかありません。</p>
</div>
</div>
<div class="section" id="programming-guidelines">
<span id="multiprocessing-programming"></span><h2>17.2.3. プログラミングガイドライン<a class="headerlink" href="#programming-guidelines" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> を使用するときに守るべき一定のガイドラインとイディオムを挙げます。</p>
<div class="section" id="all-start-methods">
<h3>17.2.3.1. すべての開始方式について<a class="headerlink" href="#all-start-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下はすべての開始方式に当てはまります。</p>
<p>共有状態を避ける</p>
<blockquote>
<div><p>できるだけプロセス間で巨大なデータを移動することは避けるようにすべきです。</p>
<p>プロセス間の通信には、<a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールの低レベルな同期プリミティブを使うのではなく、キューやパイプを使うのが良いでしょう。</p>
</div></blockquote>
<p>pickle 化の可能性</p>
<blockquote>
<div><p>プロキシのメソッドへの引数は、 pickle 化できるものにしてください。</p>
</div></blockquote>
<p>プロキシのスレッドセーフ性</p>
<blockquote>
<div><p>1 つのプロキシオブジェクトは、ロックで保護しないかぎり、2 つ以上のスレッドから使用してはいけません。</p>
<p>(異なるプロセスで <em>同じ</em> プロキシを使用することは問題ではありません。)</p>
</div></blockquote>
<p>ゾンビプロセスを join する</p>
<blockquote>
<div><p>Unix 上ではプロセスが終了したときに join しないと、そのプロセスはゾンビになります。新たなプロセスが開始する (または <a class="reference internal" href="#multiprocessing.active_children" title="multiprocessing.active_children"><code class="xref py py-func docutils literal"><span class="pre">active_children()</span></code></a> が呼ばれる) ときに、join されていないすべての完了プロセスが join されるので、あまり多くにはならないでしょう。また、終了したプロセスの <a class="reference internal" href="#multiprocessing.Process.is_alive" title="multiprocessing.Process.is_alive"><code class="xref py py-meth docutils literal"><span class="pre">Process.is_alive</span></code></a> はそのプロセスを join します。そうは言っても、自分で開始したすべてのプロセスを明示的に join することはおそらく良いプラクティスです。</p>
</div></blockquote>
<p>pickle/unpickle より継承する方が良い</p>
<blockquote>
<div><p>開始方式に <em>spawn</em> あるいは <em>forkserver</em> を使用している場合、<a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> から多くの型を pickle 化する必要があるため子プロセスはそれらを使うことができます。しかし、一般にパイプやキューを使用して共有オブジェクトを他のプロセスに送信することは避けるべきです。代わりに、共有リソースにアクセスする必要のあるプロセスは上位プロセスからそれらを継承するようにすべきです。</p>
</div></blockquote>
<p>プロセスの強制終了を避ける</p>
<blockquote>
<div><p>あるプロセスを停止するために <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal"><span class="pre">Process.terminate</span></code></a> メソッドを使用すると、そのプロセスが現在使用されている (ロック、セマフォ、パイプやキューのような) 共有リソースを破壊したり他のプロセスから利用できない状態を引き起こし易いです。</p>
<p>そのため、共有リソースを使用しないプロセスでのみ <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal"><span class="pre">Process.terminate</span></code></a> を使用することを考慮することがおそらく最善の方法です。</p>
</div></blockquote>
<p>キューを使用するプロセスを join する</p>
<blockquote>
<div><p>キューに要素を追加するプロセスは、すべてのバッファーされた要素が &#8220;feeder&#8221; スレッドによって下位層のパイプに対してフィードされるまで終了を待つということを覚えておいてください。 (子プロセスはこの動作を避けるためにキューの <a class="reference internal" href="#multiprocessing.Queue.cancel_join_thread" title="multiprocessing.Queue.cancel_join_thread"><code class="xref py py-meth docutils literal"><span class="pre">Queue.cancel_join_thread</span></code></a> メソッドを呼ぶことができます。)</p>
<p>これはキューを使用するときに、キューに追加されたすべての要素が最終的にそのプロセスが join される前に削除されていることを確認する必要があることを意味します。そうしないと、そのキューに要素が追加したプロセスの終了を保証できません。デーモンではないプロセスは自動的に join されることも覚えておいてください。</p>
<p>次の例はデッドロックを引き起こします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;X&#39;</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>                    <span class="c1"># this deadlocks</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>修正するには最後の2行を入れ替えます(または単純に <code class="docutils literal"><span class="pre">p.join()</span></code> の行を削除します)。</p>
</div></blockquote>
<p>明示的に子プロセスへリソースを渡す</p>
<blockquote>
<div><p>Unix で開始方式に <em>fork</em> を使用している場合、子プロセスはグローバルリソースを使用した親プロセス内で作成された共有リソースを使用できます。しかし、オブジェクトを子プロセスのコンストラクターに引数として渡すべきです。</p>
<p>Windows や他の開始方式と (将来的にでも) 互換性のあるコードを書く場合は別として、これは子プロセスが実行中である限りは親プロセス内でオブジェクトがガベージコレクトされないことも保証します。これは親プロセス内でオブジェクトがガベージコレクトされたときに一部のリソースが開放されてしまう場合に重要かもしれません。</p>
<p>そのため、例えば</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span> <span class="n">do</span> <span class="n">something</span> <span class="n">using</span> <span class="s2">&quot;lock&quot;</span> <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>は、次のように書き直すべきです</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">do</span> <span class="n">something</span> <span class="n">using</span> <span class="s2">&quot;l&quot;</span> <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">lock</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p><a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a> を file-like オブジェクトに置き換えることに注意する</p>
<blockquote>
<div><p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> は元々無条件に:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
</pre></div>
</div>
<p>を <code class="xref py py-meth docutils literal"><span class="pre">multiprocessing.Process._bootstrap()</span></code> メソッドの中で呼び出していました &#8212; これはプロセス内プロセス (processes-in-processes) で問題が起こしてしまいます。そこで、これは以下のように変更されました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">sys</span><span class="o">.</span><span class="n">stdin</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">),</span> <span class="n">closefd</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>これによってプロセス同士が衝突して bad file descripter エラーを起こすという根本的な問題は解決しましたが、アプリケーションの出力バッファーを <a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-func docutils literal"><span class="pre">sys.stdin()</span></code></a> から &#8220;file-like オブジェクト&#8221; に置き換えるという潜在的危険を持ち込んでしまいました。危険というのは、複数のプロセスが file-like オブジェクトの <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> を呼び出すと、オブジェクトに同じデータが何度もフラッシュされ、破損してしまう可能性がある、というものです。</p>
<p>もし file-like オブジェクトを書いて独自のキャッシュを実装するなら、キャッシュするときに常に pid を記録しておき、pid が変わったらキュッシュを捨てることで、フォークセーフにできます。例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pid</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pid</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pid</span> <span class="o">=</span> <span class="n">pid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
</pre></div>
</div>
<p>より詳しい情報は <a class="reference external" href="https://bugs.python.org/issue5155">bpo-5155</a> 、 <a class="reference external" href="https://bugs.python.org/issue5313">bpo-5313</a> 、 <a class="reference external" href="https://bugs.python.org/issue5331">bpo-5331</a> を見てください</p>
</div></blockquote>
</div>
<div class="section" id="the-spawn-and-forkserver-start-methods">
<h3>17.2.3.2. 開始方式が <em>spawn</em> および <em>forkserver</em> の場合<a class="headerlink" href="#the-spawn-and-forkserver-start-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>開始方式に <em>fork</em> を適用しない場合にいくつかの追加の制限事項があります。</p>
<p>さらなる pickle 化の可能性</p>
<blockquote>
<div><p><code class="xref py py-meth docutils literal"><span class="pre">Process.__init__()</span></code> へのすべての引数は pickle 化できることを確認してください。また <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal"><span class="pre">Process</span></code></a> をサブクラス化する場合、そのインスタンスが <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal"><span class="pre">Process.start</span></code></a> メソッドが呼ばれたときに pickle 化できるようにしてください。</p>
</div></blockquote>
<p>グローバル変数</p>
<blockquote>
<div><p>子プロセスで実行されるコードがグローバル変数にアクセスしようとする場合、子プロセスが見るその値は <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal"><span class="pre">Process.start</span></code></a> が呼ばれたときの親プロセスの値と同じではない可能性があります。</p>
<p>しかし、単にモジュールレベルの定数であるグローバル変数なら問題にはなりません。</p>
</div></blockquote>
<p>メインモジュールの安全なインポート</p>
<blockquote>
<div><p>新たな Python インタプリタによるメインモジュールのインポートが、意図しない副作用 (新たなプロセスを開始する等) を起こさずできるようにしてください。</p>
<p>例えば、開始方式に <em>spawn</em> あるいは <em>forkserver</em> を使用した場合に以下のモジュールを実行すると <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> で失敗します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>代わりに、次のように <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code> を使用してプログラムの &#8220;エントリポイント&#8221; を保護すべきです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">freeze_support</span><span class="p">,</span> <span class="n">set_start_method</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>(プログラムをフリーズせずに通常通り実行するなら <code class="docutils literal"><span class="pre">freeze_support()</span></code> 行は取り除けます。)</p>
<p>これは新たに生成された Python インタープリターがそのモジュールを安全にインポートして、モジュールの <code class="docutils literal"><span class="pre">foo()</span></code> 関数を実行します。</p>
<p>プールまたはマネージャーがメインモジュールで作成される場合に似たような制限が適用されます。</p>
</div></blockquote>
</div>
</div>
<div class="section" id="examples">
<span id="multiprocessing-examples"></span><h2>17.2.4. 使用例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>カスタマイズされたマネージャーやプロキシの作成方法と使用方法を紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">freeze_support</span>
<span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="k">import</span> <span class="n">BaseManager</span><span class="p">,</span> <span class="n">BaseProxy</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="c1">##</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you called Foo.f()&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you called Foo.g()&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_h</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you called Foo._h()&#39;</span><span class="p">)</span>

<span class="c1"># A simple generator function</span>
<span class="k">def</span> <span class="nf">baz</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span>

<span class="c1"># Proxy type for generator objects</span>
<span class="k">class</span> <span class="nc">GeneratorProxy</span><span class="p">(</span><span class="n">BaseProxy</span><span class="p">):</span>
    <span class="n">_exposed_</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__next__&#39;</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__next__&#39;</span><span class="p">)</span>

<span class="c1"># Function to return the operator module</span>
<span class="k">def</span> <span class="nf">get_operator_module</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">operator</span>

<span class="c1">##</span>

<span class="k">class</span> <span class="nc">MyManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># register the Foo class; make `f()` and `g()` accessible via proxy</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;Foo1&#39;</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>

<span class="c1"># register the Foo class; make `g()` and `_h()` accessible via proxy</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;Foo2&#39;</span><span class="p">,</span> <span class="n">Foo</span><span class="p">,</span> <span class="n">exposed</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;_h&#39;</span><span class="p">))</span>

<span class="c1"># register the generator function baz; use `GeneratorProxy` to make proxies</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">baz</span><span class="p">,</span> <span class="n">proxytype</span><span class="o">=</span><span class="n">GeneratorProxy</span><span class="p">)</span>

<span class="c1"># register get_operator_module(); make public functions accessible via proxy</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;operator&#39;</span><span class="p">,</span> <span class="n">get_operator_module</span><span class="p">)</span>

<span class="c1">##</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">MyManager</span><span class="p">()</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">f1</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Foo1</span><span class="p">()</span>
    <span class="n">f1</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
    <span class="n">f1</span><span class="o">.</span><span class="n">g</span><span class="p">()</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="s1">&#39;_h&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">_exposed_</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Foo2</span><span class="p">()</span>
    <span class="n">f2</span><span class="o">.</span><span class="n">g</span><span class="p">()</span>
    <span class="n">f2</span><span class="o">.</span><span class="n">_h</span><span class="p">()</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">_exposed_</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;_h&#39;</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">it</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">baz</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;</span><span class="si">%d</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">operator</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;op.add(23, 45) =&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">45</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;op.pow(2, 94) =&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">94</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;op._exposed_ =&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">_exposed_</span><span class="p">)</span>

<span class="c1">##</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal"><span class="pre">Pool</span></code></a> を使用する例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1">#</span>
<span class="c1"># Functions used by test code</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> says that </span><span class="si">%s%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">result</span>
        <span class="p">)</span>

<span class="k">def</span> <span class="nf">calculatestar</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">calculate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">5.0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pow3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span>

<span class="k">def</span> <span class="nf">noop</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1">#</span>
<span class="c1"># Test code</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">PROCESSES</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating pool with </span><span class="si">%d</span><span class="s1"> processes</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">PROCESSES</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">PROCESSES</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="c1"># Tests</span>
        <span class="c1">#</span>

        <span class="n">TASKS</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span> <span class="o">+</span> \
                <span class="p">[(</span><span class="n">plus</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">calculate</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">TASKS</span><span class="p">]</span>
        <span class="n">imap_it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">)</span>
        <span class="n">imap_unordered_it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ordered results using pool.apply_async():&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ordered results using pool.imap():&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">imap_it</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unordered results using pool.imap_unordered():&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">imap_unordered_it</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ordered results using pool.map() --- will block till complete:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="c1">#</span>
        <span class="c1"># Test error handling</span>
        <span class="c1">#</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing error handling:&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)))</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from pool.apply()&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from pool.map()&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))))</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from list(pool.imap())&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="n">it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">9</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from IMapIterator.next()&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="c1">#</span>
        <span class="c1"># Testing timeouts</span>
        <span class="c1">#</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing ApplyResult.get() with timeout:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">calculate</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mf">0.02</span><span class="p">))</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing IMapIterator.next() with timeout:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">)</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mf">0.02</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>ワーカープロセスのコレクションに対してタスクをフィードしてその結果をまとめるキューの使い方の例を紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">current_process</span><span class="p">,</span> <span class="n">freeze_support</span>

<span class="c1">#</span>
<span class="c1"># Function run by worker processes</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="s1">&#39;STOP&#39;</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">calculate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Function used to calculate result</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> says that </span><span class="si">%s%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> \
        <span class="p">(</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Functions referenced by tasks</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">NUMBER_OF_PROCESSES</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">TASKS1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
    <span class="n">TASKS2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">plus</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

    <span class="c1"># Create queues</span>
    <span class="n">task_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">done_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="c1"># Submit tasks</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">TASKS1</span><span class="p">:</span>
        <span class="n">task_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="c1"># Start worker processes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUMBER_OF_PROCESSES</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">task_queue</span><span class="p">,</span> <span class="n">done_queue</span><span class="p">))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># Get and print results</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unordered results:&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TASKS1</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">done_queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="c1"># Add more tasks using `put()`</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">TASKS2</span><span class="p">:</span>
        <span class="n">task_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="c1"># Get and print some more results</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TASKS2</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">done_queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="c1"># Tell child processes to stop</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUMBER_OF_PROCESSES</span><span class="p">):</span>
        <span class="n">task_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;STOP&#39;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">17.2. <code class="docutils literal"><span class="pre">multiprocessing</span></code> &#8212; プロセスベースの並列処理</a><ul>
<li><a class="reference internal" href="#introduction">17.2.1. はじめに</a><ul>
<li><a class="reference internal" href="#the-process-class">17.2.1.1. <code class="docutils literal"><span class="pre">Process</span></code> クラス</a></li>
<li><a class="reference internal" href="#contexts-and-start-methods">17.2.1.2. コンテキストと開始方式</a></li>
<li><a class="reference internal" href="#exchanging-objects-between-processes">17.2.1.3. プロセス間でのオブジェクト交換</a></li>
<li><a class="reference internal" href="#synchronization-between-processes">17.2.1.4. プロセス間の同期</a></li>
<li><a class="reference internal" href="#sharing-state-between-processes">17.2.1.5. プロセス間での状態の共有</a></li>
<li><a class="reference internal" href="#using-a-pool-of-workers">17.2.1.6. ワーカープロセスのプールを使用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">17.2.2. リファレンス</a><ul>
<li><a class="reference internal" href="#process-and-exceptions">17.2.2.1. <code class="docutils literal"><span class="pre">Process</span></code> クラスと例外</a></li>
<li><a class="reference internal" href="#pipes-and-queues">17.2.2.2. パイプ (Pipe) とキュー (Queue)</a></li>
<li><a class="reference internal" href="#miscellaneous">17.2.2.3. その他</a></li>
<li><a class="reference internal" href="#connection-objects">17.2.2.4. Connection オブジェクト</a></li>
<li><a class="reference internal" href="#synchronization-primitives">17.2.2.5. 同期プリミティブ</a></li>
<li><a class="reference internal" href="#shared-ctypes-objects">17.2.2.6. 共有 <code class="docutils literal"><span class="pre">ctypes</span></code> オブジェクト</a><ul>
<li><a class="reference internal" href="#module-multiprocessing.sharedctypes">17.2.2.6.1. <code class="docutils literal"><span class="pre">multiprocessing.sharedctypes</span></code> モジュール</a></li>
</ul>
</li>
<li><a class="reference internal" href="#managers">17.2.2.7. マネージャー</a><ul>
<li><a class="reference internal" href="#customized-managers">17.2.2.7.1. カスタマイズされたマネージャー</a></li>
<li><a class="reference internal" href="#using-a-remote-manager">17.2.2.7.2. リモートマネージャーを使用する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proxy-objects">17.2.2.8. Proxy オブジェクト</a><ul>
<li><a class="reference internal" href="#cleanup">17.2.2.8.1. クリーンアップ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-multiprocessing.pool">17.2.2.9. プロセスプール</a></li>
<li><a class="reference internal" href="#module-multiprocessing.connection">17.2.2.10. リスナーとクライアント</a><ul>
<li><a class="reference internal" href="#address-formats">17.2.2.10.1. アドレスフォーマット</a></li>
</ul>
</li>
<li><a class="reference internal" href="#authentication-keys">17.2.2.11. 認証キー</a></li>
<li><a class="reference internal" href="#logging">17.2.2.12. ログ記録</a></li>
<li><a class="reference internal" href="#module-multiprocessing.dummy">17.2.2.13. <code class="docutils literal"><span class="pre">multiprocessing.dummy</span></code> モジュール</a></li>
</ul>
</li>
<li><a class="reference internal" href="#programming-guidelines">17.2.3. プログラミングガイドライン</a><ul>
<li><a class="reference internal" href="#all-start-methods">17.2.3.1. すべての開始方式について</a></li>
<li><a class="reference internal" href="#the-spawn-and-forkserver-start-methods">17.2.3.2. 開始方式が <em>spawn</em> および <em>forkserver</em> の場合</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">17.2.4. 使用例</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="threading.html"
                        title="前の章へ">17.1. <code class="docutils literal"><span class="pre">threading</span></code> &#8212; スレッドベースの並列処理</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="concurrent.html"
                        title="次の章へ">17.3. <code class="docutils literal"><span class="pre">concurrent</span></code> パッケージ</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/multiprocessing.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="concurrent.html" title="17.3. concurrent パッケージ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="threading.html" title="17.1. threading — スレッドベースの並列処理"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.0</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concurrency.html" >17. 並行実行</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2月 27, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>