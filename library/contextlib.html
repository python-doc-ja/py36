
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>29.6. contextlib — with 文コンテキスト用ユーティリティ &#8212; Python 3.6.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="29.7. abc — 抽象基底クラス" href="abc.html" />
    <link rel="prev" title="29.5. warnings — 警告の制御" href="warnings.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/contextlib.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/contextlib.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="abc.html" title="29.7. abc — 抽象基底クラス"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="warnings.html" title="29.5. warnings — 警告の制御"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" accesskey="U">29. Python ランタイムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-contextlib">
<span id="contextlib-utilities-for-with-statement-contexts"></span><h1>29.6. <a class="reference internal" href="#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> — <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文コンテキスト用ユーティリティ<a class="headerlink" href="#module-contextlib" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/contextlib.py">Lib/contextlib.py</a></p>
<hr class="docutils" />
<p>このモジュールは <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文に関わる一般的なタスクのためのユーティリティを提供します。詳しい情報は、 <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> と <a class="reference internal" href="../reference/datamodel.html#context-managers"><span class="std std-ref">with文とコンテキストマネージャ</span></a> を参照してください。</p>
<div class="section" id="utilities">
<h2>29.6.1. ユーティリティ<a class="headerlink" href="#utilities" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数とクラスを提供しています:</p>
<dl class="class">
<dt id="contextlib.AbstractContextManager">
<em class="property">class </em><code class="descclassname">contextlib.</code><code class="descname">AbstractContextManager</code><a class="headerlink" href="#contextlib.AbstractContextManager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> for classes that implement
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">object.__enter__()</span></code></a> and <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">object.__exit__()</span></code></a>. A default
implementation for <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">object.__enter__()</span></code></a> is provided which returns
<code class="docutils literal"><span class="pre">self</span></code> while <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">object.__exit__()</span></code></a> is an abstract method which by default
returns <code class="docutils literal"><span class="pre">None</span></code>. See also the definition of <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="contextlib.contextmanager">
<code class="descclassname">&#64;</code><code class="descclassname">contextlib.</code><code class="descname">contextmanager</code><a class="headerlink" href="#contextlib.contextmanager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文コンテキストマネージャのファクトリ関数を定義するために利用できる <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">デコレータ</span></a> です。新しいクラスや <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドを別々に定義しなくても、ファクトリ関数を定義することができます。</p>
<p>簡単な例（実際に HTML を生成する方法としてはお勧めできません!）:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;/</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">tag</span><span class="p">(</span><span class="s2">&quot;h1&quot;</span><span class="p">):</span>
<span class="o">...</span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="n">foo</span>
<span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>デコレート対象の関数は呼び出されたときに <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">ジェネレータ</span></a>-イテレータを返す必要があります。このイテレータは必ず値を1つ yield しなければなりません。 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節が存在するなら、その値は as 節のターゲットへ束縛されることになります。</p>
<p>ジェネレータが yield を実行した箇所で <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のネストされたブロックが実行されます。ブロックから抜けた後でジェネレータは再開されます。ブロック内で処理されない例外が発生した場合は、ジェネレータ内部の yield を実行した箇所で例外が再送出されます。なので、(もしあれば) エラーを捕捉したり、クリーンアップ処理を確実に実行したりするために、<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>…<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a>…<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 構文を使用できます。例外を捕捉する目的が、(完全に例外を抑制してしまうのではなく) 単に例外のログをとるため、もしくはあるアクションを実行するためなら、ジェネレータはその例外を再送出しなければなりません。例外を再送出しない場合、ジェネレータのコンテキストマネージャは <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文に対して例外が処理されたことを示し、<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の直後の文から実行を再開します。</p>
<p><a class="reference internal" href="#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-func docutils literal"><span class="pre">contextmanager()</span></code></a> は <a class="reference internal" href="#contextlib.ContextDecorator" title="contextlib.ContextDecorator"><code class="xref py py-class docutils literal"><span class="pre">ContextDecorator</span></code></a> を使っているので、 <a class="reference internal" href="#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-func docutils literal"><span class="pre">contextmanager()</span></code></a> で作ったコンテキストマネージャは <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文だけでなくデコレータとしても利用できます。デコレーターとして利用された場合、新しい generator インスタンスが関数呼び出しのたびに暗黙に生成されます (このことによって、 <a class="reference internal" href="#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-func docutils literal"><span class="pre">contextmanager()</span></code></a> によって作られたなにがしか「単発」コンテキストマネージャを、コンテキストマネージャがデコレータとして使われるためには多重に呼び出されることをサポートする必要がある、という要件に合致させることが出来ます。)</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><a class="reference internal" href="#contextlib.ContextDecorator" title="contextlib.ContextDecorator"><code class="xref py py-class docutils literal"><span class="pre">ContextDecorator</span></code></a> の使用。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="contextlib.closing">
<code class="descclassname">contextlib.</code><code class="descname">closing</code><span class="sig-paren">(</span><em>thing</em><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.closing" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブロックの完了時に <em>thing</em> を close するコンテキストマネージャを返します。これは基本的に以下と等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">closing</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">thing</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">thing</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>そして、明示的に <code class="docutils literal"><span class="pre">page</span></code> を close する必要なしに、次のように書くことができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">closing</span>
<span class="kn">from</span> <span class="nn">urllib.request</span> <span class="k">import</span> <span class="n">urlopen</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">page</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">page</span></code> を明示的に close する必要は無く、エラーが発生した場合でも、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> ブロックを出るときに <code class="docutils literal"><span class="pre">page.close()</span></code> が呼ばれます。</p>
</dd></dl>

<dl class="function">
<dt id="contextlib.suppress">
<code class="descclassname">contextlib.</code><code class="descname">suppress</code><span class="sig-paren">(</span><em>*exceptions</em><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.suppress" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意の例外リストを受け取り、with ブロック内でいずれかが起こると with ブロックの直後から黙って実行を再開するコンテキストマネージャを返します。</p>
<p>ほかの完全に例外を抑制するメカニズム同様、このコンテキストマネージャは、黙ってプログラム実行を続けることが正しいことであるとわかっている、非常に限定的なエラーをカバーする以上の使い方はしてはいけません。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">suppress</span>

<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;someotherfile.tmp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは以下と等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;someotherfile.tmp&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>このコンテキストマネージャは <a class="reference internal" href="#reentrant-cms"><span class="std std-ref">再入可能(リエントラント)</span></a> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="contextlib.redirect_stdout">
<code class="descclassname">contextlib.</code><code class="descname">redirect_stdout</code><span class="sig-paren">(</span><em>new_target</em><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.redirect_stdout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Context manager for temporarily redirecting <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> to
another file or file-like object.</p>
<p>This tool adds flexibility to existing functions or classes whose output
is hardwired to stdout.</p>
<p>For example, the output of <a class="reference internal" href="functions.html#help" title="help"><code class="xref py py-func docutils literal"><span class="pre">help()</span></code></a> normally is sent to <em>sys.stdout</em>.
You can capture that output in a string by redirecting the output to an
<a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> object:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<p>To send the output of <a class="reference internal" href="functions.html#help" title="help"><code class="xref py py-func docutils literal"><span class="pre">help()</span></code></a> to a file on disk, redirect the output
to a regular file:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;help.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
</pre></div>
</div>
<p>To send the output of <a class="reference internal" href="functions.html#help" title="help"><code class="xref py py-func docutils literal"><span class="pre">help()</span></code></a> to <em>sys.stderr</em>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">):</span>
    <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the global side effect on <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> means that this
context manager is not suitable for use in library code and most threaded
applications. It also has no effect on the output of subprocesses.
However, it is still a useful approach for many utility scripts.</p>
<p>このコンテキストマネージャは <a class="reference internal" href="#reentrant-cms"><span class="std std-ref">再入可能(リエントラント)</span></a> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="contextlib.redirect_stderr">
<code class="descclassname">contextlib.</code><code class="descname">redirect_stderr</code><span class="sig-paren">(</span><em>new_target</em><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.redirect_stderr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#contextlib.redirect_stdout" title="contextlib.redirect_stdout"><code class="xref py py-func docutils literal"><span class="pre">redirect_stdout()</span></code></a> but redirecting
<a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a> to another file or file-like object.</p>
<p>このコンテキストマネージャは <a class="reference internal" href="#reentrant-cms"><span class="std std-ref">再入可能(リエントラント)</span></a> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="contextlib.ContextDecorator">
<em class="property">class </em><code class="descclassname">contextlib.</code><code class="descname">ContextDecorator</code><a class="headerlink" href="#contextlib.ContextDecorator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャをデコレータとしても使用できるようにする基底クラスです。</p>
<p><code class="docutils literal"><span class="pre">ContextDecorator</span></code> から継承したコンテキストマネージャは、通常のコンテキストマネージャーと同じく <code class="docutils literal"><span class="pre">__enter__</span></code> および <code class="docutils literal"><span class="pre">__exit__</span></code> を実装する必要があります。<code class="docutils literal"><span class="pre">__exit__</span></code> はデコレータとして使用された場合でも例外をオプションの引数として受け取ります。</p>
<p><a class="reference internal" href="#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-func docutils literal"><span class="pre">contextmanager()</span></code></a> は <code class="docutils literal"><span class="pre">ContextDecorator</span></code> を利用しているので、自動的にデコレーターとしても利用できるようになります。</p>
<p><code class="docutils literal"><span class="pre">ContextDecorator</span></code> の例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ContextDecorator</span>

<span class="k">class</span> <span class="nc">mycontext</span><span class="p">(</span><span class="n">ContextDecorator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finishing&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nd">@mycontext</span><span class="p">()</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">function</span><span class="p">():</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The bit in the middle&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">function</span><span class="p">()</span>
<span class="n">Starting</span>
<span class="n">The</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">middle</span>
<span class="n">Finishing</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">mycontext</span><span class="p">():</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The bit in the middle&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">Starting</span>
<span class="n">The</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">middle</span>
<span class="n">Finishing</span>
</pre></div>
</div>
<p>これは次のような形のコードに対するシンタックスシュガーになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">cm</span><span class="p">():</span>
        <span class="c1"># Do stuff</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">ContextDecorator</span></code> を使うと代わりに次のように書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nd">@cm</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c1"># Do stuff</span>
</pre></div>
</div>
<p>デコレーターを使うと、<code class="docutils literal"><span class="pre">cm</span></code> が関数の一部ではなく全体に適用されていることが明確になります (インデントレベルを1つ節約できるのもメリットです)。</p>
<p>すでに基底クラスを持っているコンテキストマネージャーも、<code class="docutils literal"><span class="pre">ContextDecorator</span></code> を mixin クラスとして利用することで拡張できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ContextDecorator</span>

<span class="k">class</span> <span class="nc">mycontext</span><span class="p">(</span><span class="n">ContextBaseClass</span><span class="p">,</span> <span class="n">ContextDecorator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">デコレートされた関数が複数回呼び出せるように、内部のコンテキストマネージャーは複数の <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文に対応する必要があります。そうでないなら、明示的な <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文を関数内で利用するべきです。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="contextlib.ExitStack">
<em class="property">class </em><code class="descclassname">contextlib.</code><code class="descname">ExitStack</code><a class="headerlink" href="#contextlib.ExitStack" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>他の、特にオプションであったり入力に依存するようなコンテキストマネージャーやクリーンアップ関数を動的に組み合わせるためのコンテキストマネージャーです。</p>
<p>例えば、複数のファイルを1つの with 文で簡単に扱うことができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">]</span>
    <span class="c1"># All opened files will automatically be closed at the end of</span>
    <span class="c1"># the with statement, even if attempts to open files later</span>
    <span class="c1"># in the list raise an exception</span>
</pre></div>
</div>
<p>各インスタンスは登録されたコールバックのスタックを管理し、インスタンスが (明示的に、あるいは <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の終わりに暗黙的に)  close されるときに逆順でそれを呼び出します。コンテキストスタックのインスタンスが暗黙的にガベージコレクトされたときには callback は呼び出され <strong>ません</strong> 。</p>
<p>このスタックモデルは、(file オブジェクトのように) <code class="docutils literal"><span class="pre">__init__</span></code> メソッドでリソースを確保するコンテキストマネージャーを正しく扱うためのものです。</p>
<p>登録されたコールバックが登録の逆順で実行されるので、複数のネストされた <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文を利用するのと同じ振る舞いをします。これは例外処理にも適用されます。内側のコールバックが例外を抑制したり置き換えたりした場合、外側のコールバックには更新された状態に応じた引数が渡されます。</p>
<p>これは正しく exit callback の stack を巻き戻すための、比較的低レベルな API です。アプリケーション独自のより高レベルなコンテキストマネージャーを作るための基板として使うのに適しています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="method">
<dt id="contextlib.ExitStack.enter_context">
<code class="descname">enter_context</code><span class="sig-paren">(</span><em>cm</em><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.ExitStack.enter_context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新しいコンテキストマネージャーに enter し、その <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> method をコールバックスタックに追加します。渡されたコンテキストマネージャーの <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドの戻り値を返します。</p>
<p>コンテキストマネージャーは、普段 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文で利用された時と同じように、例外を抑制することができます。</p>
</dd></dl>

<dl class="method">
<dt id="contextlib.ExitStack.push">
<code class="descname">push</code><span class="sig-paren">(</span><em>exit</em><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.ExitStack.push" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャーの <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドをコールバックスタックに追加します。</p>
<p>このメソッドは <code class="docutils literal"><span class="pre">__enter__</span></code> を <strong>呼び出さない</strong> ので、コンテキストマネージャーを実装するときに、 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> の実装の一部を自身の <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドでカバーするために利用できます。</p>
<p>コンテキストマネージャーではないオブジェクトが渡された場合、このメソッドはそのオブジェクトをコンテキストマネージャーの <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドと同じシグネチャを持つコールバック関数だと仮定して、直接コールバックスタックに追加します。</p>
<p>それらのコールバック関数も、コンテキストマネージャーの <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> と同じく、 true 値を返すことで例外を抑制することができます。</p>
<p>この関数はデコレータとしても使えるように、受け取ったオブジェクトをそのまま返します。</p>
</dd></dl>

<dl class="method">
<dt id="contextlib.ExitStack.callback">
<code class="descname">callback</code><span class="sig-paren">(</span><em>callback</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.ExitStack.callback" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意の関数と引数を受け取り、コールバックスタックに追加します。</p>
<p>他のメソッドと異なり、このメソッドで追加されたコールバックは例外を抑制しません (例外の詳細も渡されません)。</p>
<p>この関数はデコレータとしても使えるように、受け取った callback をそのまま返します。</p>
</dd></dl>

<dl class="method">
<dt id="contextlib.ExitStack.pop_all">
<code class="descname">pop_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.ExitStack.pop_all" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コールバックスタックを新しい <a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> インスタンスに移して、それを返します。このメソッドは callback を実行しません。代わりに、新しい stack が (明示的に、あるいは <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の終わりに暗黙的に) close されるときに実行されます。</p>
<p>例えば、複数のファイルを &quot;all or nothing&quot; に開く処理を次のように書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">]</span>
    <span class="c1"># Hold onto the close method, but don&#39;t call it yet.</span>
    <span class="n">close_files</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop_all</span><span class="p">()</span><span class="o">.</span><span class="n">close</span>
    <span class="c1"># If opening any file fails, all previously opened files will be</span>
    <span class="c1"># closed automatically. If all files are opened successfully,</span>
    <span class="c1"># they will remain open even after the with statement ends.</span>
    <span class="c1"># close_files() can then be invoked explicitly to close them all.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="contextlib.ExitStack.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextlib.ExitStack.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>すぐにコールバックスタックを巻き戻し、コールバック関数を登録の逆順に呼び出します。登録されたすべてのコンテキストマネージャーと終了 callback に、例外が起こらなかった場合の引数が渡されます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples-and-recipes">
<h2>29.6.2. 例とレシピ<a class="headerlink" href="#examples-and-recipes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションでは、 <a class="reference internal" href="#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> が提供するツールの効果的な使い方を示す例とレシピを紹介します。</p>
<div class="section" id="supporting-a-variable-number-of-context-managers">
<h3>29.6.2.1. 可変数個のコンテキストマネージャーをサポートする<a class="headerlink" href="#supporting-a-variable-number-of-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> の第一のユースケースは、クラスのドキュメントにかかれている通り、一つの <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文で可変数個のコンテキストマネージャーや他のクリーンアップ関数をサポートすることです。ユーザーの入力 (指定された複数個のファイルを開く場合など) に応じて複数個のコンテキストマネージャーが必要となる場合や、いくつかのコンテキストマネージャーがオプションとなる場合に、可変数個のコンテキストマネージャーが必要になります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">resource</span> <span class="ow">in</span> <span class="n">resources</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">need_special_resource</span><span class="p">():</span>
        <span class="n">special</span> <span class="o">=</span> <span class="n">acquire_special_resource</span><span class="p">()</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">release_special_resource</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="c1"># Perform operations that use the acquired resources</span>
</pre></div>
</div>
<p>上の例にあるように、 <a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> はコンテキストマネージャープロトコルをサポートしていないリソースの管理を <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文を使って簡単に行えるようにします。</p>
</div>
<div class="section" id="simplifying-support-for-single-optional-context-managers">
<h3>29.6.2.2. 1つのオプションのコンテキストマネージャーを簡潔にサポートする<a class="headerlink" href="#simplifying-support-for-single-optional-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>1つのオプションのコンテキストマネージャーを使う場合、 <a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> を何もしないコンテキストマネージャーとして利用することで、ソースコードの構造を変更することなく1つのコンテキストマネージャーを省略することができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">debug_trace</span><span class="p">(</span><span class="n">details</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TraceContext</span><span class="p">(</span><span class="n">details</span><span class="p">)</span>
    <span class="c1"># Don&#39;t do anything special with the context in release mode</span>
    <span class="k">return</span> <span class="n">ExitStack</span><span class="p">()</span>

<span class="k">with</span> <span class="n">debug_trace</span><span class="p">():</span>
    <span class="c1"># Suite is traced in debug mode, but runs normally otherwise</span>
</pre></div>
</div>
</div>
<div class="section" id="catching-exceptions-from-enter-methods">
<h3>29.6.2.3. <code class="docutils literal"><span class="pre">__enter__</span></code> メソッドからの例外をキャッチする<a class="headerlink" href="#catching-exceptions-from-enter-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>稀に、 <code class="docutils literal"><span class="pre">__enter__</span></code> メソッドからの例外を、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の body やコンテキストマネージャーの <code class="docutils literal"><span class="pre">__exit__</span></code> メソッドからの例外は間違えて捕まえないように、 catch したい場合があります。 <a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> を使って、コンテキストマネージャープロトコル内のステップを分離することができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">stack</span> <span class="o">=</span> <span class="n">ExitStack</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="c1"># handle __enter__ exception</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">stack</span><span class="p">:</span>
        <span class="c1"># Handle normal case</span>
</pre></div>
</div>
<p>実際のところ、このようなコードが必要になるのならば、利用している API 側で <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>/<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a>/<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 文を使った直接的なリソース管理インタフェースを提供するべきです。しかし、すべての API がそのようによく設計されているとは限りません。もしコンテキストマネージャーが提供されている唯一のリソース管理APIであるなら、 <a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> を使って <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文を使って処理することができない様々なシチュエーションの処理をすることができます。</p>
</div>
<div class="section" id="cleaning-up-in-an-enter-implementation">
<h3>29.6.2.4. <code class="docutils literal"><span class="pre">__enter__</span></code> 実装内のクリーンアップ<a class="headerlink" href="#cleaning-up-in-an-enter-implementation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#contextlib.ExitStack.push" title="contextlib.ExitStack.push"><code class="xref py py-meth docutils literal"><span class="pre">ExitStack.push()</span></code></a> のドキュメントで言及したとおり、このメソッドはすでに獲得したリソースを、 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドの残りのステップが失敗した時にクリーンアップするために利用することができます。</p>
<p>次の例では、リソースの確保と開放の関数に加えて、オプションのバリデーション関数を受け取るコンテキストマネージャーで、この方法を使ってコンテキストマネージャープロトコルを提供しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span><span class="p">,</span> <span class="n">AbstractContextManager</span><span class="p">,</span> <span class="n">ExitStack</span>

<span class="k">class</span> <span class="nc">ResourceManager</span><span class="p">(</span><span class="n">AbstractContextManager</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acquire_resource</span><span class="p">,</span> <span class="n">release_resource</span><span class="p">,</span> <span class="n">check_resource_ok</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acquire_resource</span> <span class="o">=</span> <span class="n">acquire_resource</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release_resource</span> <span class="o">=</span> <span class="n">release_resource</span>
        <span class="k">if</span> <span class="n">check_resource_ok</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">check_resource_ok</span><span class="p">(</span><span class="n">resource</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_resource_ok</span> <span class="o">=</span> <span class="n">check_resource_ok</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">_cleanup_on_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">yield</span>
            <span class="c1"># The validation check passed and didn&#39;t raise an exception</span>
            <span class="c1"># Accordingly, we want to keep the resource, and pass it</span>
            <span class="c1"># back to our caller</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">pop_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">resource</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire_resource</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_on_error</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_resource_ok</span><span class="p">(</span><span class="n">resource</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Failed validation for </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">resource</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">resource</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_details</span><span class="p">):</span>
        <span class="c1"># We don&#39;t need to duplicate any of our resource release logic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release_resource</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="replacing-any-use-of-try-finally-and-flag-variables">
<h3>29.6.2.5. <code class="docutils literal"><span class="pre">try-finally</span></code> + flag 変数パターンを置き換える<a class="headerlink" href="#replacing-any-use-of-try-finally-and-flag-variables" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">try-finally</span></code> 文に、<code class="docutils literal"><span class="pre">finally</span></code> 句の内容を実行するかどうかを示すフラグ変数を組み合わせたパターンを目にすることがあるかもしれません。一番シンプルな (単に <code class="docutils literal"><span class="pre">except</span></code> 句を使うだけでは処理できない) ケースでは次のようなコードになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">cleanup_needed</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">perform_operation</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">cleanup_needed</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">cleanup_needed</span><span class="p">:</span>
        <span class="n">cleanup_resources</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">try</span></code> 文を使ったコードでは、セットアップとクリーンアップのコードが任意の長さのコードで分離してしまうので、開発者やレビューアにとって問題になりえます。</p>
<p><a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> を使えば、代わりに <code class="docutils literal"><span class="pre">with</span></code> 文の終わりに実行されるコールバックを登録し、後でそのコールバックをスキップするかどうかを決定できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ExitStack</span>

<span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">cleanup_resources</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">perform_operation</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">pop_all</span><span class="p">()</span>
</pre></div>
</div>
<p>これにより、別のフラグ変数を使う代わりに、必要なクリーンアップ処理を手前に明示しておくことができます。</p>
<p>もしあるアプリケーションがこのパターンを多用するのであれば、小さいヘルパークラスを導入してよりシンプルにすることができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ExitStack</span>

<span class="k">class</span> <span class="nc">Callback</span><span class="p">(</span><span class="n">ExitStack</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Callback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop_all</span><span class="p">()</span>

<span class="k">with</span> <span class="n">Callback</span><span class="p">(</span><span class="n">cleanup_resources</span><span class="p">)</span> <span class="k">as</span> <span class="n">cb</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">perform_operation</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</pre></div>
</div>
<p>もしリソースのクリーンアップが単体の関数にまとまってない場合でも、 <a class="reference internal" href="#contextlib.ExitStack.callback" title="contextlib.ExitStack.callback"><code class="xref py py-meth docutils literal"><span class="pre">ExitStack.callback()</span></code></a> のデコレーター形式を利用してリソース開放処理を宣言することができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ExitStack</span>

<span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
    <span class="nd">@stack</span><span class="o">.</span><span class="n">callback</span>
    <span class="k">def</span> <span class="nf">cleanup_resources</span><span class="p">():</span>
        <span class="o">...</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">perform_operation</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">pop_all</span><span class="p">()</span>
</pre></div>
</div>
<p>Due to the way the decorator protocol works, a callback function
declared this way cannot take any parameters. Instead, any resources to
be released must be accessed as closure variables.</p>
</div>
<div class="section" id="using-a-context-manager-as-a-function-decorator">
<h3>29.6.2.6. コンテキストマネージャーを関数デコレーターとして使う<a class="headerlink" href="#using-a-context-manager-as-a-function-decorator" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#contextlib.ContextDecorator" title="contextlib.ContextDecorator"><code class="xref py py-class docutils literal"><span class="pre">ContextDecorator</span></code></a> はコンテキストマネージャーを通常の <code class="docutils literal"><span class="pre">with</span></code> 文に加えて関数デコレーターとしても利用できるようにします。</p>
<p>例えば、関数やまとまった文を、そこに入った時と出た時の時間をトラックするロガーでラップしたい場合があります。そのために関数デコレーターとコンテキストマネージャーを別々に書く代わりに、 <a class="reference internal" href="#contextlib.ContextDecorator" title="contextlib.ContextDecorator"><code class="xref py py-class docutils literal"><span class="pre">ContextDecorator</span></code></a> を継承すると1つの定義で両方の機能を提供できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ContextDecorator</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">track_entry_and_exit</span><span class="p">(</span><span class="n">ContextDecorator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Entering: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exiting: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>このクラスのインスタンスはコンテキストマネージャーとしても利用でき:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">track_entry_and_exit</span><span class="p">(</span><span class="s1">&#39;widget loader&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Some time consuming activity goes here&#39;</span><span class="p">)</span>
    <span class="n">load_widget</span><span class="p">()</span>
</pre></div>
</div>
<p>また関数デコレーターとしても利用できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nd">@track_entry_and_exit</span><span class="p">(</span><span class="s1">&#39;widget loader&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">activity</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Some time consuming activity goes here&#39;</span><span class="p">)</span>
    <span class="n">load_widget</span><span class="p">()</span>
</pre></div>
</div>
<p>コンテキストマネージャーを関数デコレーターとして使う場合、 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドの戻り値にアクセスする手段がないという制限があることに注意してください。もしその値が必要であれば、明示的な <code class="docutils literal"><span class="pre">with</span></code> 文を使う必要があります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; ステートメント</dt>
<dd>Python の <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の仕様、背景、および例が記載されています。</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="single-use-reusable-and-reentrant-context-managers">
<span id="single-use-reusable-and-reentrant-cms"></span><h2>29.6.3. Single use, reusable and reentrant context managers<a class="headerlink" href="#single-use-reusable-and-reentrant-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Most context managers are written in a way that means they can only be
used effectively in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement once. These single use
context managers must be created afresh each time they’re used -
attempting to use them a second time will trigger an exception or
otherwise not work correctly.</p>
<p>This common limitation means that it is generally advisable to create
context managers directly in the header of the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement
where they are used (as shown in all of the usage examples above).</p>
<p>Files are an example of effectively single use context managers, since
the first <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement will close the file, preventing any
further IO operations using that file object.</p>
<p>Context managers created using <a class="reference internal" href="#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-func docutils literal"><span class="pre">contextmanager()</span></code></a> are also single use
context managers, and will complain about the underlying generator failing
to yield if an attempt is made to use them a second time:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@contextmanager</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">singleuse</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Before&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">yield</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cm</span> <span class="o">=</span> <span class="n">singleuse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">cm</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="go">Before</span>
<span class="go">After</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">cm</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">RuntimeError</span>: <span class="n">generator didn&#39;t yield</span>
</pre></div>
</div>
<div class="section" id="reentrant-context-managers">
<span id="reentrant-cms"></span><h3>29.6.3.1. Reentrant context managers<a class="headerlink" href="#reentrant-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>More sophisticated context managers may be &quot;reentrant&quot;. These context
managers can not only be used in multiple <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statements,
but may also be used <em>inside</em> a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement that is already
using the same context manager.</p>
<p><a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">threading.RLock</span></code></a> is an example of a reentrant context manager, as are
<a class="reference internal" href="#contextlib.suppress" title="contextlib.suppress"><code class="xref py py-func docutils literal"><span class="pre">suppress()</span></code></a> and <a class="reference internal" href="#contextlib.redirect_stdout" title="contextlib.redirect_stdout"><code class="xref py py-func docutils literal"><span class="pre">redirect_stdout()</span></code></a>. Here’s a very simple example of
reentrant use:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">redirect_stdout</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">write_to_stream</span> <span class="o">=</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">write_to_stream</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This is written to the stream rather than stdout&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">write_to_stream</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This is also written to the stream&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This is written directly to stdout&quot;</span><span class="p">)</span>
<span class="go">This is written directly to stdout</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
<span class="go">This is written to the stream rather than stdout</span>
<span class="go">This is also written to the stream</span>
</pre></div>
</div>
<p>Real world examples of reentrancy are more likely to involve multiple
functions calling each other and hence be far more complicated than this
example.</p>
<p>Note also that being reentrant is <em>not</em> the same thing as being thread safe.
<a class="reference internal" href="#contextlib.redirect_stdout" title="contextlib.redirect_stdout"><code class="xref py py-func docutils literal"><span class="pre">redirect_stdout()</span></code></a>, for example, is definitely not thread safe, as it
makes a global modification to the system state by binding <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a>
to a different stream.</p>
</div>
<div class="section" id="reusable-context-managers">
<span id="reusable-cms"></span><h3>29.6.3.2. Reusable context managers<a class="headerlink" href="#reusable-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Distinct from both single use and reentrant context managers are &quot;reusable&quot;
context managers (or, to be completely explicit, &quot;reusable, but not
reentrant&quot; context managers, since reentrant context managers are also
reusable). These context managers support being used multiple times, but
will fail (or otherwise not work correctly) if the specific context manager
instance has already been used in a containing with statement.</p>
<p><a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal"><span class="pre">threading.Lock</span></code></a> is an example of a reusable, but not reentrant,
context manager (for a reentrant lock, it is necessary to use
<a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">threading.RLock</span></code></a> instead).</p>
<p>Another example of a reusable, but not reentrant, context manager is
<a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a>, as it invokes <em>all</em> currently registered callbacks
when leaving any with statement, regardless of where those callbacks
were added:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ExitStack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span> <span class="o">=</span> <span class="n">ExitStack</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">stack</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Callback: from first context&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Leaving first context&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Leaving first context</span>
<span class="go">Callback: from first context</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">stack</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Callback: from second context&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Leaving second context&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Leaving second context</span>
<span class="go">Callback: from second context</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">stack</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Callback: from outer context&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">stack</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Callback: from inner context&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Leaving inner context&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Leaving outer context&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Leaving inner context</span>
<span class="go">Callback: from inner context</span>
<span class="go">Callback: from outer context</span>
<span class="go">Leaving outer context</span>
</pre></div>
</div>
<p>As the output from the example shows, reusing a single stack object across
multiple with statements works correctly, but attempting to nest them
will cause the stack to be cleared at the end of the innermost with
statement, which is unlikely to be desirable behaviour.</p>
<p>Using separate <a class="reference internal" href="#contextlib.ExitStack" title="contextlib.ExitStack"><code class="xref py py-class docutils literal"><span class="pre">ExitStack</span></code></a> instances instead of reusing a single
instance avoids that problem:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">ExitStack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">outer_stack</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">outer_stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Callback: from outer context&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">inner_stack</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">inner_stack</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Callback: from inner context&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Leaving inner context&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Leaving outer context&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Leaving inner context</span>
<span class="go">Callback: from inner context</span>
<span class="go">Leaving outer context</span>
<span class="go">Callback: from outer context</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">29.6. <code class="docutils literal"><span class="pre">contextlib</span></code> — <code class="docutils literal"><span class="pre">with</span></code> 文コンテキスト用ユーティリティ</a><ul>
<li><a class="reference internal" href="#utilities">29.6.1. ユーティリティ</a></li>
<li><a class="reference internal" href="#examples-and-recipes">29.6.2. 例とレシピ</a><ul>
<li><a class="reference internal" href="#supporting-a-variable-number-of-context-managers">29.6.2.1. 可変数個のコンテキストマネージャーをサポートする</a></li>
<li><a class="reference internal" href="#simplifying-support-for-single-optional-context-managers">29.6.2.2. 1つのオプションのコンテキストマネージャーを簡潔にサポートする</a></li>
<li><a class="reference internal" href="#catching-exceptions-from-enter-methods">29.6.2.3. <code class="docutils literal"><span class="pre">__enter__</span></code> メソッドからの例外をキャッチする</a></li>
<li><a class="reference internal" href="#cleaning-up-in-an-enter-implementation">29.6.2.4. <code class="docutils literal"><span class="pre">__enter__</span></code> 実装内のクリーンアップ</a></li>
<li><a class="reference internal" href="#replacing-any-use-of-try-finally-and-flag-variables">29.6.2.5. <code class="docutils literal"><span class="pre">try-finally</span></code> + flag 変数パターンを置き換える</a></li>
<li><a class="reference internal" href="#using-a-context-manager-as-a-function-decorator">29.6.2.6. コンテキストマネージャーを関数デコレーターとして使う</a></li>
</ul>
</li>
<li><a class="reference internal" href="#single-use-reusable-and-reentrant-context-managers">29.6.3. Single use, reusable and reentrant context managers</a><ul>
<li><a class="reference internal" href="#reentrant-context-managers">29.6.3.1. Reentrant context managers</a></li>
<li><a class="reference internal" href="#reusable-context-managers">29.6.3.2. Reusable context managers</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="warnings.html"
                        title="前の章へ">29.5. <code class="docutils literal"><span class="pre">warnings</span></code> — 警告の制御</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="abc.html"
                        title="次の章へ">29.7. <code class="docutils literal"><span class="pre">abc</span></code> — 抽象基底クラス</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/contextlib.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="abc.html" title="29.7. abc — 抽象基底クラス"
             >次へ</a> |</li>
        <li class="right" >
          <a href="warnings.html" title="29.5. warnings — 警告の制御"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" >29. Python ランタイムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 11月 20, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.4 を使って作成されました。
    </div>

  </body>
</html>