
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>8.8. weakref — 弱参照 &#8212; Python 3.6.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="8.9. types — 動的な型生成と組み込み型に対する名前" href="types.html" />
    <link rel="prev" title="8.7. array — 効率のよい数値アレイ" href="array.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/weakref.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/weakref.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="types.html" title="8.9. types — 動的な型生成と組み込み型に対する名前"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="array.html" title="8.7. array — 効率のよい数値アレイ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="datatypes.html" accesskey="U">8. データ型</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-weakref">
<span id="weakref-weak-references"></span><h1>8.8. <a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> — 弱参照<a class="headerlink" href="#module-weakref" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/weakref.py">Lib/weakref.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールは、Pythonプログラマがオブジェクトへの弱参照 (<em class="dfn">weak refarence</em>)を作成できるようにします。</p>
<p>以下では、用語リファレント(<em class="dfn">referent</em>) は弱参照が参照するオブジェクトを意味します。</p>
<p>オブジェクトへの弱参照があることは、そのオブジェクトを生かしておくのには不十分です。リファレントへの参照が弱参照しか残っていない場合、 <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a> はリファレントを自由に破棄し、メモリを別のものに再利用することができます。しかし、オブジェクトへの強参照がなくても、オブジェクトが実際に破棄されるまでは、弱参照はオブジェクトを返す場合があります。</p>
<p>弱参照の主な用途は、巨大なオブジェクトを保持するキャッシュやマッピングを実装することです。ここで、キャッシュやマッピングに保持されているからという理由だけで、巨大なオブジェクトが生き続けることは望ましくありません。</p>
<p>例えば、巨大なバイナリ画像のオブジェクトがたくさんあり、それぞれに名前を関連付けたいとします。 Python の辞書型を使って名前を画像に対応付けたり画像を名前に対応付けたりすると、画像オブジェクトは辞書内のキーや値に使われているため存続しつづけることになります。 <a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールが提供している <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> や <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> クラスはその代用で、対応付けを構築するのに弱参照を使い、キャッシュやマッピングに存在するという理由だけでオブジェクトを存続させないようにします。例えば、もしある画像オブジェクトが <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> の値になっていた場合、最後に残った画像オブジェクトへの参照を弱参照マッピングが保持していれば、ガーベジコレクションはこのオブジェクトを再利用でき、画像オブジェクトに対する弱参照内の対応付けは削除されます。</p>
<p><a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> と <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> はその実装に弱参照を使用しており、キーや値がガーベジコレクションによって回収されたことを弱参照辞書に通知するコールバック関数を設定しています。 <a class="reference internal" href="#weakref.WeakSet" title="weakref.WeakSet"><code class="xref py py-class docutils literal"><span class="pre">WeakSet</span></code></a> は <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> インターフェースを実装していますが、 <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> のように要素への弱参照を持ちます。</p>
<p><a class="reference internal" href="#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal"><span class="pre">finalize</span></code></a> は、オブジェクトのガベージコレクションの実行時にクリーンアップ関数が呼び出されるように登録する、単純な方法を提供します。これは、未加工の弱参照上にコールバック関数を設定するよりも簡単です。なぜなら、オブジェクトのコレクションが完了するまでファイナライザが生き続けることを、モジュールが自動的に保証するからです。</p>
<p>ほとんどのプログラムでは弱参照コンテナまたは <a class="reference internal" href="#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal"><span class="pre">finalize</span></code></a> のどれかを使えば必要なものは揃うはずです。通常は直接自前の弱参照を作成する必要はありません。低レベルな機構は、より進んだ使い方をするために <a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールとして公開されています。</p>
<p>全てのオブジェクトが弱参照で参照できるわけではありません; 弱参照で参照できるのは、クラスインスタンス、(C ではなく) Python で書かれた関数、インスタンスメソッド、set オブジェクト、frozenset オブジェクト、 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file オブジェクト</span></a> 、 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> 型のオブジェクト、socket オブジェクト、array オジェクト、deque オブジェクト、正規表現パターンオブジェクト、code オブジェクトです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>thread.lock, threading.Lock, code オブジェクトのサポートが追加されました。</p>
</div>
<p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> や <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> など、いくつかの組み込み型は弱参照を直接サポートしませんが、以下のようにサブクラス化を行えばサポートを追加できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">(</span><span class="n">red</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">blue</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>   <span class="c1"># this object is weak referenceable</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> と <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> のような他の組み込み型はサブクラス化しても弱参照はサポートしません。(これは実装詳細であり、他の様々な Python 実装では異なる可能性があります。)。</p>
<p>拡張型は、簡単に弱参照をサポートできます。詳細については、 <a class="reference internal" href="../extending/newtypes.html#weakref-support"><span class="std std-ref">弱参照(Weak Reference)のサポート</span></a> を参照してください。</p>
<dl class="class">
<dt id="weakref.ref">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">ref</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>callback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.ref" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> への弱参照を返します。リファレントがまだ生きているならば、元のオブジェクトは参照オブジェクトの呼び出しで取り出せす。リファレントがもはや生きていないならば、参照オブジェクトを呼び出したときに <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します。 <em>callback</em> に <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 以外の値を与えた場合、オブジェクトをまさに後始末処理しようとするときに呼び出します。このとき弱参照オブジェクトは <em>callback</em> の唯一のパラメタとして渡されます。リファレントはもはや利用できません。</p>
<p>同じオブジェクトに対してたくさんの弱参照を作れます。それぞれの弱参照に対して登録されたコールバックは、もっとも新しく登録されたコールバックからもっとも古いものへと呼び出されます。</p>
<p>コールバックが発生させた例外は標準エラー出力に書き込まれますが、伝播されません。それらはオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが発生させる例外と完全に同じ方法で処理されます。</p>
<p><em>object</em> がハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>)ならば、弱参照はハッシュ可能です。それらは <em>object</em> が削除された後でもそれらのハッシュ値を保持します。 <em>object</em> が削除されてから初めて <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> が呼び出された場合に、その呼び出しは <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を発生させます。</p>
<p>弱参照は等価性のテストをサポートしていますが、順序をサポートしていません。参照がまだ生きているならば、 <em>callback</em> に関係なく二つの参照はそれらのリファレントと同じ等価関係を持ちます。リファレントのどちらか一方が削除された場合、参照オブジェクトが同一である場合に限り、その参照は等価です。</p>
<p>これはサブクラス化可能な型というよりファクトリ関数です。</p>
<dl class="attribute">
<dt id="weakref.ref.__callback__">
<code class="descname">__callback__</code><a class="headerlink" href="#weakref.ref.__callback__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この読み出し専用の属性は、現在弱参照に関連付けられているコールバックを返します。コールバックが存在しないか、弱参照のリファレントが生きていない場合、この属性の値は <code class="docutils literal"><span class="pre">None</span></code>  になります。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="#weakref.ref.__callback__" title="weakref.ref.__callback__"><code class="xref py py-attr docutils literal"><span class="pre">__callback__</span></code></a> 属性が追加されました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="weakref.proxy">
<code class="descclassname">weakref.</code><code class="descname">proxy</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>callback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.proxy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>弱参照を使う <em>object</em> へのプロキシを返します。弱参照オブジェクトを明示的な参照外しをしながら利用する代わりに、多くのケースでプロキシを利用することができます。返されるオブジェクトは、 <em>object</em> が呼び出し可能かどうかによって、 <code class="docutils literal"><span class="pre">ProxyType</span></code> または <code class="docutils literal"><span class="pre">CallableProxyType</span></code> のどちらかの型を持ちます。プロキシオブジェクトはリファレントに関係なくハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>)ではありません。これによって、それらの基本的な変更可能という性質による多くの問題を避けています。そして、辞書のキーとしての利用を妨げます。 <em>callback</em> は <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-func docutils literal"><span class="pre">ref()</span></code></a> 関数の同じ名前のパラメータと同じものです。(— 訳注: リファレントが変更不能型であっても、プロキシはリファレントが消えるという状態の変更があるために、変更可能型です。—)</p>
</dd></dl>

<dl class="function">
<dt id="weakref.getweakrefcount">
<code class="descclassname">weakref.</code><code class="descname">getweakrefcount</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.getweakrefcount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> を参照する弱参照とプロキシの数を返します。</p>
</dd></dl>

<dl class="function">
<dt id="weakref.getweakrefs">
<code class="descclassname">weakref.</code><code class="descname">getweakrefs</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.getweakrefs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> を参照するすべての弱参照とプロキシオブジェクトのリストを返します。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakKeyDictionary">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakKeyDictionary</code><span class="sig-paren">(</span><span class="optional">[</span><em>dict</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakKeyDictionary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キーを弱参照するマッピングクラス。キーへの強参照がなくなったときに、辞書のエントリは捨てられます。アプリケーションの他の部分が所有するオブジェクトへ属性を追加することもなく、それらのオブジェクトに追加データを関連づけるために使うことができます。これは属性へのアクセスをオーバーライドするオブジェクトに特に便利です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">警告: <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> は Python 辞書型の上に作られているので、反復処理を行うときにはサイズ変更してはなりません。 <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> の場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用として) 「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更は困難なのです。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> objects have an additional method that
exposes the internal references directly.  The references are not guaranteed to
be &quot;live&quot; at the time they are used, so the result of calling the references
needs to be checked before being used.  This can be used to avoid creating
references that will cause the garbage collector to keep the keys around longer
than needed.</p>
<dl class="method">
<dt id="weakref.WeakKeyDictionary.keyrefs">
<code class="descclassname">WeakKeyDictionary.</code><code class="descname">keyrefs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakKeyDictionary.keyrefs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キーへの弱参照を持つ iterable オブジェクトを返します。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakValueDictionary">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakValueDictionary</code><span class="sig-paren">(</span><span class="optional">[</span><em>dict</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakValueDictionary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値を弱参照するマッピングクラス。値への強参照が存在しなくなったときに、辞書のエントリは捨てられます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">警告: <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> は Python 辞書型の上に作られているので、反復処理を行うときにはサイズ変更してはなりません。 <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> の場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用として) 「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更は困難なのです。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> objects have an additional method that has the
same issues as the <code class="xref py py-meth docutils literal"><span class="pre">keyrefs()</span></code> method of <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a>
objects.</p>
<dl class="method">
<dt id="weakref.WeakValueDictionary.valuerefs">
<code class="descclassname">WeakValueDictionary.</code><code class="descname">valuerefs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakValueDictionary.valuerefs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値への弱参照を持つ iterable オブジェクトを返します。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakSet">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakSet</code><span class="sig-paren">(</span><span class="optional">[</span><em>elements</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakSet" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素への弱参照を持つ集合型。要素への強参照が無くなったときに、その要素は削除されます。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakMethod">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakMethod</code><span class="sig-paren">(</span><em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakMethod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張された <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-class docutils literal"><span class="pre">ref</span></code></a> のサブクラスで、束縛されたメソッドへの弱参照をシミュレートします (つまり、クラスで定義され、インスタンスにあるメソッド)。
束縛されたメソッドは短命なので、標準の弱参照では保持し続けられません。
<a class="reference internal" href="#weakref.WeakMethod" title="weakref.WeakMethod"><code class="xref py py-class docutils literal"><span class="pre">WeakMethod</span></code></a> には、オブジェクトと元々の関数が死ぬまで束縛されたメソッドを再作成する特別なコードがあります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;method called!&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakMethod</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="go">&lt;bound method C.method of &lt;__main__.C object at 0x7fc859830220&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()()</span>
<span class="go">method called!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="weakref.finalize">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">finalize</code><span class="sig-paren">(</span><em>obj</em>, <em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> がガベージコレクションで回収されるときに呼び出される、呼び出し可能なファイナライザオブジェクトを返します。
通常の弱参照とは異なり、ファイナライザは参照しているオブジェクトが回収されるまで必ず生き残り、そのおかげでライフサイクル管理が大いに簡単になります。</p>
<p>ファイナライザは (直接もしくはガベージコレクションのときに) 呼び出されるまで <em>生きている</em> と見なされ、呼び出された後には <em>死んでいます</em> 。
生きているファイナライザを呼び出すと、 <code class="docutils literal"><span class="pre">func(*arg,</span> <span class="pre">**kwargs)</span></code> を評価した結果を返します。一方、死んでいるファイナライザを呼び出すと <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します。</p>
<p>ガベージコレクション中にファイナライザコールバックが発生させた例外は、標準エラー出力に表示されますが、伝播することはできません。これらの例外は、オブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドや弱参照のコールバックが発生させる例外と同じ方法で処理されます。</p>
<p>プログラムが終了するとき、生き残ったそれぞれのファイナライザは、自身の <a class="reference internal" href="atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-attr docutils literal"><span class="pre">atexit</span></code></a> 属性が偽に設定されるまで呼び出され続けます。
ファイナライザは生成された順序の逆順で呼び出されます。</p>
<p>A finalizer will never invoke its callback during the later part of
the <a class="reference internal" href="../glossary.html#term-interpreter-shutdown"><span class="xref std std-term">interpreter shutdown</span></a> when module globals are liable to have
been replaced by <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
<dl class="method">
<dt id="weakref.finalize.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize.__call__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <em>self</em> is alive then mark it as dead and return the result of
calling <code class="docutils literal"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code>.  If <em>self</em> is dead then return
<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="weakref.finalize.detach">
<code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize.detach" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <em>self</em> is alive then mark it as dead and return the tuple
<code class="docutils literal"><span class="pre">(obj,</span> <span class="pre">func,</span> <span class="pre">args,</span> <span class="pre">kwargs)</span></code>.  If <em>self</em> is dead then return
<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="weakref.finalize.peek">
<code class="descname">peek</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize.peek" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <em>self</em> is alive then return the tuple <code class="docutils literal"><span class="pre">(obj,</span> <span class="pre">func,</span> <span class="pre">args,</span>
<span class="pre">kwargs)</span></code>.  If <em>self</em> is dead then return <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="weakref.finalize.alive">
<code class="descname">alive</code><a class="headerlink" href="#weakref.finalize.alive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイナライザが生きている場合には真、そうでない場合には偽のプロパティです。</p>
</dd></dl>

<dl class="attribute">
<dt id="weakref.finalize.atexit">
<code class="descname">atexit</code><a class="headerlink" href="#weakref.finalize.atexit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A writable boolean property which by default is true.  When the
program exits, it calls all remaining live finalizers for which
<a class="reference internal" href="#weakref.finalize.atexit" title="weakref.finalize.atexit"><code class="xref py py-attr docutils literal"><span class="pre">atexit</span></code></a> is true.  They are called in reverse order of
creation.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">It is important to ensure that <em>func</em>, <em>args</em> and <em>kwargs</em> do
not own any references to <em>obj</em>, either directly or indirectly,
since otherwise <em>obj</em> will never be garbage collected.  In
particular, <em>func</em> should not be a bound method of <em>obj</em>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="weakref.ReferenceType">
<code class="descclassname">weakref.</code><code class="descname">ReferenceType</code><a class="headerlink" href="#weakref.ReferenceType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>弱参照オブジェクトのための型オブジェクト。</p>
</dd></dl>

<dl class="data">
<dt id="weakref.ProxyType">
<code class="descclassname">weakref.</code><code class="descname">ProxyType</code><a class="headerlink" href="#weakref.ProxyType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し可能でないオブジェクトのプロキシのための型オブジェクト。</p>
</dd></dl>

<dl class="data">
<dt id="weakref.CallableProxyType">
<code class="descclassname">weakref.</code><code class="descname">CallableProxyType</code><a class="headerlink" href="#weakref.CallableProxyType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し可能なオブジェクトのプロキシのための型オブジェクト。</p>
</dd></dl>

<dl class="data">
<dt id="weakref.ProxyTypes">
<code class="descclassname">weakref.</code><code class="descname">ProxyTypes</code><a class="headerlink" href="#weakref.ProxyTypes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシのためのすべての型オブジェクトを含むシーケンス。これは両方のプロキシ型の名前付けに依存しないで、オブジェクトがプロキシかどうかのテストをより簡単にできます。</p>
</dd></dl>

<dl class="exception">
<dt id="weakref.ReferenceError">
<em class="property">exception </em><code class="descclassname">weakref.</code><code class="descname">ReferenceError</code><a class="headerlink" href="#weakref.ReferenceError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシオブジェクトが使われても、元のオブジェクトがガベージコレクションされてしまっているときに発生する例外。これは標準の <a class="reference internal" href="exceptions.html#ReferenceError" title="ReferenceError"><code class="xref py py-exc docutils literal"><span class="pre">ReferenceError</span></code></a> 例外と同じです。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0205"><strong>PEP 205</strong></a> - 弱参照</dt>
<dd>この機能の提案と理論的根拠。初期の実装と他の言語における類似の機能についての情報へのリンクを含んでいます。</dd>
</dl>
</div>
<div class="section" id="weak-reference-objects">
<span id="weakref-objects"></span><h2>8.8.1. 弱参照オブジェクト<a class="headerlink" href="#weak-reference-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Weak reference objects have no methods and no attributes besides
<a class="reference internal" href="#weakref.ref.__callback__" title="weakref.ref.__callback__"><code class="xref py py-attr docutils literal"><span class="pre">ref.__callback__</span></code></a>. A weak reference object allows the referent to be
obtained, if it still exists, by calling it:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weakref</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Object</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o2</span> <span class="o">=</span> <span class="n">r</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="ow">is</span> <span class="n">o2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>リファレントがもはや存在しないならば、参照オブジェクトの呼び出しは <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">o</span><span class="p">,</span> <span class="n">o2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">())</span>
<span class="go">None</span>
</pre></div>
</div>
<p>弱参照オブジェクトがまだ生きているかどうかのテストは、式 <code class="docutils literal"><span class="pre">ref()</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code> を用いて行われます。通常、参照オブジェクトを使う必要があるアプリケーションコードはこのパターンに従います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># r is a weak reference object</span>
<span class="n">o</span> <span class="o">=</span> <span class="n">r</span><span class="p">()</span>
<span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># referent has been garbage collected</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object has been deallocated; can&#39;t frobnicate.&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object is still live!&quot;</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">do_something_useful</span><span class="p">()</span>
</pre></div>
</div>
<p>&quot;生存性(liveness)&quot;のテストを分割すると、スレッド化されたアプリケーションにおいて競合状態を作り出します。 (訳注:<code class="docutils literal"><span class="pre">if</span> <span class="pre">r()</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None:</span> <span class="pre">r().do_something()</span></code> では、2度目のr()がNoneを返す可能性があります) 弱参照が呼び出される前に、他のスレッドは弱参照が無効になる原因となり得ます。上で示したイディオムは、シングルスレッドのアプリケーションと同じくマルチスレッド化されたアプリケーションにおいても安全です。</p>
<p>サブクラス化を行えば、 <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-class docutils literal"><span class="pre">ref</span></code></a> オブジェクトの特殊なバージョンを作成できます。これは <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> の実装で使われており、マップ内の各エントリによるメモリのオーバヘッドを減らしています。こうした実装は、ある参照に追加情報を関連付けたい場合に便利ですし、リファレントを取り出すための呼び出し時に何らかの追加処理を行いたい場合にも使えます。</p>
<p>以下の例では、 <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-class docutils literal"><span class="pre">ref</span></code></a> のサブクラスを使って、あるオブジェクトに追加情報を保存し、リファレントがアクセスされたときにその値に作用をできるようにするための方法を示しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">weakref</span>

<span class="k">class</span> <span class="nc">ExtendedRef</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">annotations</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ExtendedRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a pair containing the referent and the number of</span>
<span class="sd">        times the reference has been called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ExtendedRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__counter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ob</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<span id="weakref-example"></span><h2>8.8.2. 使用例<a class="headerlink" href="#example" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この簡単な例では、アプリケーションが以前に参照したオブジェクトを取り出すためにオブジェクトIDを利用する方法を示します。オブジェクトに生きたままであることを強制することなく、オブジェクトの IDを他のデータ構造の中で使うことができ、必要に応じてIDからオブジェクトを取り出せます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">weakref</span>

<span class="n">_id2obj_dict</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">remember</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">oid</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">_id2obj_dict</span><span class="p">[</span><span class="n">oid</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">return</span> <span class="n">oid</span>

<span class="k">def</span> <span class="nf">id2obj</span><span class="p">(</span><span class="n">oid</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_id2obj_dict</span><span class="p">[</span><span class="n">oid</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="finalizer-objects">
<span id="finalize-examples"></span><h2>8.8.3. ファイナライザオブジェクト<a class="headerlink" href="#finalizer-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The main benefit of using <a class="reference internal" href="#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal"><span class="pre">finalize</span></code></a> is that it makes it simple
to register a callback without needing to preserve the returned finalizer
object.  For instance</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weakref</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Object</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kenny</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">kenny</span><span class="p">,</span> <span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;You killed Kenny!&quot;</span><span class="p">)</span>  
<span class="go">&lt;finalize object at ...; for &#39;Object&#39; at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">kenny</span>
<span class="go">You killed Kenny!</span>
</pre></div>
</div>
<p>ファイナライザは直接呼び出すこともできます。ただし、ファイナライザはコールバックを最大でも一度しか呼び出しません。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CALLBACK&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">alive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">f</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">CALLBACK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">alive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>                     <span class="c1"># callback not called because finalizer dead</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">obj</span>                 <span class="c1"># callback not called because finalizer dead</span>
</pre></div>
</div>
<p>You can unregister a finalizer using its <a class="reference internal" href="#weakref.finalize.detach" title="weakref.finalize.detach"><code class="xref py py-meth docutils literal"><span class="pre">detach()</span></code></a>
method.  This kills the finalizer and returns the arguments passed to
the constructor when it was created.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>                                           
<span class="go">(&lt;__main__.Object object ...&gt;, &lt;function callback ...&gt;, (1, 2), {&#39;z&#39;: 3})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newobj</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">alive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">newobj</span> <span class="ow">is</span> <span class="n">obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">CALLBACK</span>
</pre></div>
</div>
<p>Unless you set the <a class="reference internal" href="#weakref.finalize.atexit" title="weakref.finalize.atexit"><code class="xref py py-attr docutils literal"><span class="pre">atexit</span></code></a> attribute to
<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>, a finalizer will be called when the program exits if it
is still alive.  For instance</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;obj dead or exiting&quot;</span><span class="p">)</span>  
<span class="go">&lt;finalize object at ...; for &#39;Object&#39; at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exit</span><span class="p">()</span>                                               
<span class="go">obj dead or exiting</span>
</pre></div>
</div>
</div>
<div class="section" id="comparing-finalizers-with-del-methods">
<h2>8.8.4. ファイナライザと <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドとの比較<a class="headerlink" href="#comparing-finalizers-with-del-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>インスタンスが一時ディレクトリを表す、クラスを作成するとします。そのディレクトリは、次のイベントのいずれかが起きた時に、そのディレクトリの内容とともに削除されるべきです。</p>
<ul class="simple">
<li>オブジェクトのガベージコレクションが行われた場合</li>
<li>オブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code> メソッドが呼び出された場合</li>
<li>プログラムが終了した場合</li>
</ul>
<p>ここでは、 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドを使用して次のようにクラスを実装します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TempDir</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</pre></div>
</div>
<p>Starting with Python 3.4, <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> methods no longer prevent
reference cycles from being garbage collected, and module globals are
no longer forced to <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> during <a class="reference internal" href="../glossary.html#term-interpreter-shutdown"><span class="xref std std-term">interpreter shutdown</span></a>.
So this code should work without any issues on CPython.</p>
<p>However, handling of <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> methods is notoriously implementation
specific, since it depends on internal details of the interpreter’s garbage
collector implementation.</p>
<p>A more robust alternative can be to define a finalizer which only references
the specific functions and objects that it needs, rather than having access
to the full state of the object:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TempDir</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalizer</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalizer</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalizer</span><span class="o">.</span><span class="n">alive</span>
</pre></div>
</div>
<p>Defined like this, our finalizer only receives a reference to the details
it needs to clean up the directory appropriately. If the object never gets
garbage collected the finalizer will still be called at exit.</p>
<p>The other advantage of weakref based finalizers is that they can be used to
register finalizers for classes where the definition is controlled by a
third party, such as running code when a module is unloaded:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">weakref</span><span class="o">,</span> <span class="nn">sys</span>
<span class="k">def</span> <span class="nf">unloading_module</span><span class="p">():</span>
    <span class="c1"># implicit reference to the module globals from the function body</span>
<span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">],</span> <span class="n">unloading_module</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If you create a finalizer object in a daemonic thread just as the program
exits then there is the possibility that the finalizer
does not get called at exit.  However, in a daemonic thread
<a class="reference internal" href="atexit.html#atexit.register" title="atexit.register"><code class="xref py py-func docutils literal"><span class="pre">atexit.register()</span></code></a>, <code class="docutils literal"><span class="pre">try:</span> <span class="pre">...</span> <span class="pre">finally:</span> <span class="pre">...</span></code> and <code class="docutils literal"><span class="pre">with:</span> <span class="pre">...</span></code>
do not guarantee that cleanup occurs either.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">8.8. <code class="docutils literal"><span class="pre">weakref</span></code> — 弱参照</a><ul>
<li><a class="reference internal" href="#weak-reference-objects">8.8.1. 弱参照オブジェクト</a></li>
<li><a class="reference internal" href="#example">8.8.2. 使用例</a></li>
<li><a class="reference internal" href="#finalizer-objects">8.8.3. ファイナライザオブジェクト</a></li>
<li><a class="reference internal" href="#comparing-finalizers-with-del-methods">8.8.4. ファイナライザと <code class="docutils literal"><span class="pre">__del__()</span></code> メソッドとの比較</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="array.html"
                        title="前の章へ">8.7. <code class="docutils literal"><span class="pre">array</span></code> — 効率のよい数値アレイ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="types.html"
                        title="次の章へ">8.9. <code class="docutils literal"><span class="pre">types</span></code> — 動的な型生成と組み込み型に対する名前</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/weakref.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="types.html" title="8.9. types — 動的な型生成と組み込み型に対する名前"
             >次へ</a> |</li>
        <li class="right" >
          <a href="array.html" title="8.7. array — 効率のよい数値アレイ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="datatypes.html" >8. データ型</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 1月 29, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>