
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4. 組み込み型 &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="5. 組み込み例外" href="exceptions.html" />
    <link rel="prev" title="3. 組み込み定数" href="constants.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/stdtypes.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/stdtypes.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="5. 組み込み例外"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 組み込み定数"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 標準ライブラリ</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-types">
<span id="bltin-types"></span><h1>4. 組み込み型<a class="headerlink" href="#built-in-types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>以下のセクションでは、インタプリタに組み込まれている標準型について記述します。</p>
<p id="index-0">主要な組み込み型は、数値、シーケンス、マッピング、クラス、インスタンス、および例外です。</p>
<p>コレクションクラスには、ミュータブルなものがあります。コレクションのメンバをインプレースに足し、引き、または並べ替えて、特定の要素を返さないメソッドは、コレクション自身ではなく <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>演算には、複数の型でサポートされているものがあります; 特に、ほぼ全てのオブジェクトは、比較でき、真理値を判定でき、 (<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 関数や、わずかに異なる <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 関数によって) 文字列に変換できます。オブジェクトが <a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数で印字されるとき、文字列に変換する関数が暗黙に使われます。</p>
<div class="section" id="truth-value-testing">
<span id="truth"></span><h2>4.1. 真理値判定<a class="headerlink" href="#truth-value-testing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-1">どのようなオブジェクトでも真理値として判定でき、 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> や <a class="reference internal" href="../reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal"><span class="pre">while</span></code></a> の条件あるいは以下のブール演算の被演算子として使えます。</p>
<p id="index-2">オブジェクトは、デフォルトでは真と判定されます。ただしそのクラスが <a class="reference internal" href="../reference/datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> メソッドを定義していて、それが <code class="docutils literal"><span class="pre">False</span></code> を返す場合、または <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> メソッドを定義していて、それが 0 を返す場合は偽と判定されます。 <a class="footnote-reference" href="#id12" id="id1">[1]</a> 主な組み込みオブジェクトで偽と判定されるものを次に示します:</p>
<blockquote>
<div></div></blockquote>
<ul class="simple" id="index-3">
<li>偽であると定義されている定数: <code class="docutils literal"><span class="pre">None</span></code> と <code class="docutils literal"><span class="pre">False</span></code></li>
<li>数値型におけるゼロ: <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">0.0</span></code>, <code class="docutils literal"><span class="pre">0j</span></code>, <code class="docutils literal"><span class="pre">Decimal(0)</span></code>, <code class="docutils literal"><span class="pre">Fraction(0,</span> <span class="pre">1)</span></code></li>
<li>空のシーケンスまたはコレクション: <code class="docutils literal"><span class="pre">''</span></code>, <code class="docutils literal"><span class="pre">()</span></code>, <code class="docutils literal"><span class="pre">[]</span></code>, <code class="docutils literal"><span class="pre">{}</span></code>, <code class="docutils literal"><span class="pre">set()</span></code>, <code class="docutils literal"><span class="pre">range(0)</span></code></li>
</ul>
<p id="index-4">ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に偽値として <code class="docutils literal"><span class="pre">0</span></code> または <code class="docutils literal"><span class="pre">False</span></code> を返し、真値として <code class="docutils literal"><span class="pre">1</span></code> または <code class="docutils literal"><span class="pre">True</span></code> を返します。 (重要な例外: ブール演算 <code class="docutils literal"><span class="pre">or</span></code> および <code class="docutils literal"><span class="pre">and</span></code> は常に被演算子のうちの一つを返します。)</p>
</div>
<div class="section" id="boolean-operations-and-or-not">
<span id="boolean"></span><h2>4.2. ブール演算 — <a class="reference internal" href="../reference/expressions.html#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a>, <a class="reference internal" href="../reference/expressions.html#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a>, <a class="reference internal" href="../reference/expressions.html#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a><a class="headerlink" href="#boolean-operations-and-or-not" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-5">以下にブール演算を、優先順位が低い順に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="62%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code></td>
<td><em>x</em> が偽なら <em>y</em>, そうでなければ <em>x</em></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code></td>
<td><em>x</em> が偽なら <em>x</em>, そうでなければ <em>y</em></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span></code></td>
<td><em>x</em> が偽なら <code class="docutils literal"><span class="pre">True</span></code>, そうでなければ <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p id="index-6">注釈:</p>
<ol class="arabic simple">
<li>この演算子は短絡評価されます。つまり第一引数が偽のときにのみ、第二引数が評価されます。</li>
<li>この演算子は短絡評価されます。つまり第一引数が真のときにのみ、第二引数が評価されます。</li>
<li><code class="docutils literal"><span class="pre">not</span></code> は非ブール演算子よりも優先度が低いので、 <code class="docutils literal"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> は <code class="docutils literal"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> と解釈され、 <code class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">not</span> <span class="pre">b</span></code> は構文エラーです。</li>
</ol>
</div>
<div class="section" id="comparisons">
<span id="stdcomparisons"></span><h2>4.3. 比較<a class="headerlink" href="#comparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-7">Python には 8 種の比較演算があります。比較演算の優先順位は全て同じです (ブール演算より高い優先順位です)。比較は任意に連鎖できます; 例えば、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> とほぼ等価ですが、この <em>y</em> は一度だけしか評価されません (どちらにしても、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> が偽となれば <em>z</em> は評価されません)。</p>
<p>以下の表に比較演算をまとめます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;</span></code></td>
<td>より小さい</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;=</span></code></td>
<td>以下</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;</span></code></td>
<td>より大きい</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&gt;=</span></code></td>
<td>以上</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">==</span></code></td>
<td>等しい</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">!=</span></code></td>
<td>等しくない</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">is</span></code></td>
<td>同一のオブジェクトである</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></td>
<td>同一のオブジェクトでない</td>
</tr>
</tbody>
</table>
<p id="index-8">異なる型のオブジェクトは、異なる数値型を除き、決して等価になりません。さらに、型には、 (例えば関数オブジェクトのように) その型のどの 2 つのオブジェクトも等しくないという、退化した比較の概念しかサポートしていないものもあります。複素数とその他の組み込み数値型を比較するときや、オブジェクト同士が異なる型で比較できないときや、その他順序づけが定義されていないとき、演算子 <code class="docutils literal"><span class="pre">&lt;</span></code> 、 <code class="docutils literal"><span class="pre">&lt;=</span></code> 、 <code class="docutils literal"><span class="pre">&gt;</span></code> 、 <code class="docutils literal"><span class="pre">&gt;=</span></code> は <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外を送出します。</p>
<p id="index-9">あるクラスの同一でないインスタンスは、通常等価でないとされますが、そのクラスが <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> メソッドを定義している場合は除きます。</p>
<p>クラスのインスタンスは、そのクラスがメソッド <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> 、 <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a> 、 <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a> 、 <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a> のうち十分なものを定義していない限り、同じクラスの別のインスタンスや他の型のオブジェクトとは順序付けできません (一般に、比較演算子の通常の意味を求めるなら、 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> だけで十分です)。</p>
<p><a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> および <a class="reference internal" href="../reference/expressions.html#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a> 演算子の振る舞いはカスタマイズできません。また、これらはいかなる 2 つのオブジェクトにも適用でき、決して例外を送出しません。</p>
<p id="index-10">シーケンス型 (以下を参照) でのみ、構文上同じ優先順位を持つさらに 2 つの演算子 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> および <a class="reference internal" href="../reference/expressions.html#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> がサポートされています。</p>
</div>
<div class="section" id="numeric-types-int-float-complex">
<span id="typesnumeric"></span><h2>4.4. 数値型 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a><a class="headerlink" href="#numeric-types-int-float-complex" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-11">数値型には 3 種類あります: <em class="dfn">整数</em> 、 <em class="dfn">浮動小数点数</em> 、 <em class="dfn">複素数</em> です。さらに、ブール型は整数のサブタイプです。整数には精度の制限がありません。浮動小数点型はたいていは C の <code class="xref c c-type docutils literal"><span class="pre">double</span></code> を使って実装されています; あなたのプログラムが動作するマシンでの浮動小数点型の精度と内部表現は、 <a class="reference internal" href="sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal"><span class="pre">sys.float_info</span></code></a> から利用できます。複素数は実部と虚部を持ち、それぞれ浮動小数点数です。複素数 <em>z</em> から実部および虚部を取り出すには、 <code class="docutils literal"><span class="pre">z.real</span></code> および <code class="docutils literal"><span class="pre">z.imag</span></code> を使ってください。 (標準ライブラリには、その他の数値型、分数を保持する <a class="reference internal" href="fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> や、ユーザ定義の精度の浮動小数点数を保持する <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> があります。)</p>
<p id="index-12">数値は、数値リテラルによって、あるいは組み込み関数や演算子の戻り値として生成されます。 (十六進、八進、二進数を含む) 修飾のない整数リテラルは、整数を与えます。小数点または指数表記を含む数値リテラルは浮動小数点数を与えます。数値リテラルに <code class="docutils literal"><span class="pre">'j'</span></code> または <code class="docutils literal"><span class="pre">'J'</span></code> をつけると虚数 (実部がゼロの複素数) を与え、それに整数や浮動小数点数を加えて実部と虚部を持つ複素数を得られます。</p>
<p id="index-13">Python は型混合の算術演算に完全に対応しています: ある二項算術演算子の被演算子の数値型が互いに異なるとき、より &quot;制限された&quot; 型の被演算子は他方の型に合わせて広げられます。ここで整数は浮動小数点数より制限されており、浮動小数点数は複素数より制限されています。型混合の数値間での比較も同じ規則に従います。 <a class="footnote-reference" href="#id13" id="id2">[2]</a> コンストラクタ <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a> 、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a> 、 <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a> で、特定の型の数を生成できます。</p>
<p>全ての (複素数を除く) 組み込み数値型は以下の演算に対応しています。これらは優先順位が低い順で並んでいます (全ての数値演算は比較演算よりも高い優先順位です):</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="40%" />
<col width="11%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
<th class="head">完全なドキュメント</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の和</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の差</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の積</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の商</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> の商を切り下げたもの</td>
<td>(1)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code></td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> の剰余</td>
<td>(2)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-x</span></code></td>
<td><em>x</em> の符号反転</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">+x</span></code></td>
<td><em>x</em> そのまま</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">abs(x)</span></code></td>
<td><em>x</em> の絶対値または大きさ</td>
<td>&#160;</td>
<td><a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">int(x)</span></code></td>
<td><em>x</em> の整数への変換</td>
<td>(3)(6)</td>
<td><a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">float(x)</span></code></td>
<td><em>x</em> の浮動小数点数への変換</td>
<td>(4)(6)</td>
<td><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">complex(re,</span> <span class="pre">im)</span></code></td>
<td>実部 <em>re</em>, 虚部 <em>im</em> の複素数。 <em>im</em> の既定値はゼロ。</td>
<td>(6)</td>
<td><a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">c.conjugate()</span></code></td>
<td>複素数 <em>c</em> の共役複素数</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span></code></td>
<td><code class="docutils literal"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code> からなるペア</td>
<td>(2)</td>
<td><a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code></td>
<td><em>x</em> の <em>y</em> 乗</td>
<td>(5)</td>
<td><a class="reference internal" href="functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></td>
<td><em>x</em> の <em>y</em> 乗</td>
<td>(5)</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p id="index-14">注釈:</p>
<ol class="arabic">
<li><p class="first">整数の除算とも呼ばれます。結果の型は整数型とは限りませんが、結果の値は整数です。結果は常に負の無限大の方向に丸められます: <code class="docutils literal"><span class="pre">1//2</span></code> は <code class="docutils literal"><span class="pre">0</span></code> 、 <code class="docutils literal"><span class="pre">(-1)//2</span></code> は <code class="docutils literal"><span class="pre">-1</span></code> 、 <code class="docutils literal"><span class="pre">1//(-2)</span></code> は <code class="docutils literal"><span class="pre">-1</span></code> 、そして <code class="docutils literal"><span class="pre">(-1)//(-2)</span></code> は <code class="docutils literal"><span class="pre">0</span></code> です。</p>
</li>
<li><p class="first">複素数型には使えません。適用可能な場合には代わりに <a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> で浮動小数点型に変換してください。</p>
</li>
<li><p id="index-15">浮動小数点数から整数への変換はC言語と同様の方法で丸め、または切り捨てられます; より明確に定義された変換を行う場合は、 <a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor()</span></code></a> と <a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil()</span></code></a> を参照してください。</p>
</li>
<li><p class="first">浮動小数点数は、文字列 &quot;nan&quot; と &quot;inf&quot; を、オプションの接頭辞 &quot;+&quot; または &quot;-&quot; と共に、非数 (Not a Number (NaN)) や正、負の無限大として受け付けます。</p>
</li>
<li><p class="first">Python は、プログラム言語一般でそうであるように、 <code class="docutils literal"><span class="pre">pow(0,</span> <span class="pre">0)</span></code> および <code class="docutils literal"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></code> を <code class="docutils literal"><span class="pre">1</span></code> と定義します。</p>
</li>
<li><p class="first">受け付けられる数値リテラルは数字 <code class="docutils literal"><span class="pre">0</span></code> から <code class="docutils literal"><span class="pre">9</span></code> または等価な Unicode (<code class="docutils literal"><span class="pre">Nd</span></code> プロパティを持つコードポイント) を含みます。</p>
<p><code class="docutils literal"><span class="pre">Nd</span></code> プロパティを持つコードポイントの完全なリストは <a class="reference external" href="http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt">http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt</a> をご覧ください。</p>
</li>
</ol>
<p>全ての <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> 型 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) は以下の演算も含みます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc(x)</span></code></a></td>
<td><em>x</em> を <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> (整数) に切り捨てます</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round(x[,</span>
<span class="pre">n])</span></code></a></td>
<td><em>x</em> を <em>n</em> 桁に丸めます。丸め方は偶数丸めです。 <em>n</em> が省略されれば 0 がデフォルトとなります。</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor(x)</span></code></a></td>
<td><em>x</em> 以下の最大の <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> (整数) を返します</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil(x)</span></code></a></td>
<td><em>x</em> 以上の最小の <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> (整数) を返します</td>
</tr>
</tbody>
</table>
<p>その他の数値演算は、 <a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> や <a class="reference internal" href="cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> モジュールをご覧ください。</p>
<div class="section" id="bitwise-operations-on-integer-types">
<span id="bitstring-ops"></span><h3>4.4.1. 整数型におけるビット単位演算<a class="headerlink" href="#bitwise-operations-on-integer-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-16">ビット単位演算は、整数に対してのみ意味があります。負の数は、その 2 の補数の値として扱われます (演算中にオーバフローが起こらないように十分なビット数があるものと仮定します) 。</p>
<p>二項ビット単位演算の優先順位は全て、数値演算よりも低く、比較よりも高くなっています; 単項演算 <code class="docutils literal"><span class="pre">~</span></code> の優先順位は他の単項数値演算 (<code class="docutils literal"><span class="pre">+</span></code> および <code class="docutils literal"><span class="pre">-</span></code>) と同じです。</p>
<p>以下の表では、ビット単位演算を優先順位が低い順に並べています:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="59%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> のビット単位 <em class="dfn">論理和</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> のビット単位 <em class="dfn">排他的論理和</em></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></code></td>
<td><em>x</em> と <em>y</em> のビット単位 <em class="dfn">論理積</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> の <em>n</em> ビット左シフト</td>
<td>(1)(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> の <em>n</em> ビット右シフト</td>
<td>(1)(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">~x</span></code></td>
<td><em>x</em> のビット反転</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic simple">
<li>負値のシフト数は不正であり、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</li>
<li><em>n</em> ビットの左シフトは、 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> による乗算のオーバーフローチェックをしないものと等価です。</li>
<li><em>n</em> ビットの右シフトは、 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> による除算のオーバーフローチェックをしないものと等価です。</li>
</ol>
</div>
<div class="section" id="additional-methods-on-integer-types">
<h3>4.4.2. 整数型における追加のメソッド<a class="headerlink" href="#additional-methods-on-integer-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数型は <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></code></a> 抽象基底クラス (<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>) を実装します。さらに、追加のメソッドをいくつか提供します:</p>
<dl class="method">
<dt id="int.bit_length">
<code class="descclassname">int.</code><code class="descname">bit_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.bit_length" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数を、符号と先頭の 0 は除いて二進法で表すために必要なビットの数を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;-0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>正確には、 <code class="docutils literal"><span class="pre">x</span></code> が非 0 なら、 <code class="docutils literal"><span class="pre">x.bit_length()</span></code> は <code class="docutils literal"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></code> を満たす唯一の正の整数 <code class="docutils literal"><span class="pre">k</span></code> です。同様に、 <code class="docutils literal"><span class="pre">abs(x)</span></code> が十分小さくて対数を適切に丸められるとき、 <code class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></code> です。 <code class="docutils literal"><span class="pre">x</span></code> が 0 なら、 <code class="docutils literal"><span class="pre">x.bit_length()</span></code> は <code class="docutils literal"><span class="pre">0</span></code> を返します。</p>
<p>次と等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c1"># binary representation:  bin(-37) --&gt; &#39;-0b100101&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-0b&#39;</span><span class="p">)</span> <span class="c1"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c1"># len(&#39;100101&#39;) --&gt; 6</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="int.to_bytes">
<code class="descclassname">int.</code><code class="descname">to_bytes</code><span class="sig-paren">(</span><em>length</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.to_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>整数を表すバイト列を返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">b&#39;\xe8\x03&#39;</span>
</pre></div>
</div>
<p>整数は <em>length</em> バイトで表されます。整数が与えられた数のバイトで表せなければ、 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> が送出されます。</p>
<p><em>byteorder</em> 引数は、整数を表すのに使われるバイトオーダーを決定します。 <em>byteorder</em> が <code class="docutils literal"><span class="pre">&quot;big&quot;</span></code> なら、最上位のバイトがバイト配列の最初に来ます。 <em>byteorder</em> が <code class="docutils literal"><span class="pre">&quot;little&quot;</span></code> なら、最上位のバイトがバイト配列の最後に来ます。ホストシステムにネイティブのバイトオーダーを要求するには、 <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a> をバイトオーダーの値として使ってください。</p>
<p><em>signed</em> 引数は、整数を表すのに 2 の補数を使うかどうかを決定します。 <em>signed</em> が <code class="docutils literal"><span class="pre">False</span></code> で、負の整数が与えられたなら、 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>  が送出されます。 <em>signed</em> のデフォルト値は <code class="docutils literal"><span class="pre">False</span></code> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="int.from_bytes">
<em class="property">classmethod </em><code class="descclassname">int.</code><code class="descname">from_bytes</code><span class="sig-paren">(</span><em>bytes</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.from_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたバイト列の整数表現を返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">-1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">64512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16711680</span>
</pre></div>
</div>
<p>引数 <em>bytes</em> は <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> か、または bytes を生成する iterable でなければなりません。</p>
<p><em>byteorder</em> 引数は、整数を表すのに使われるバイトオーダーを決定します。 <em>byteorder</em> が <code class="docutils literal"><span class="pre">&quot;big&quot;</span></code> なら、最上位のバイトがバイト配列の最初に来ます。 <em>byteorder</em> が <code class="docutils literal"><span class="pre">&quot;little&quot;</span></code> なら、最上位のバイトがバイト配列の最後に来ます。ホストシステムにネイティブのバイトオーダーを要求するには、 <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a> をバイトオーダーの値として使ってください。</p>
<p><em>signed</em> 引数は、整数を表すのに 2 の補数を使うかどうかを決定します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="additional-methods-on-float">
<h3>4.4.3. 浮動小数点数に対する追加のメソッド<a class="headerlink" href="#additional-methods-on-float" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>浮動小数点数型は、 <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> 抽象基底クラス (<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>) を実装しています。浮動小数点型はまた、以下の追加のメソッドを持ちます。</p>
<dl class="method">
<dt id="float.as_integer_ratio">
<code class="descclassname">float.</code><code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.as_integer_ratio" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>比が元の浮動小数点数とちょうど同じで分母が正である、一対の整数を返します。無限大に対しては <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> を、非数 (NaN) に対しては <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="float.is_integer">
<code class="descclassname">float.</code><code class="descname">is_integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.is_integer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数インスタンスが有限の整数値なら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<p>16 進表記の文字列へ、または、 16 進表記からの変換をサポートする二つのメソッドがあります。 Python の浮動小数点数は内部的には2進数で保持されるので、浮動小数点数の <em>10進数</em> へまたは <em>10進数</em> からの変換には若干の丸め誤差があります。それに対し、16 進表記では、浮動小数点数を正確に表現できます。これはデバッグのときや、数学的な用途 (numerical work) に便利でしょう。</p>
<dl class="method">
<dt id="float.hex">
<code class="descclassname">float.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>浮動小数点数の 16 進文字列表現を返します。有限の浮動小数点数に対し、この表現は常に <code class="docutils literal"><span class="pre">0x</span></code> で始まり <code class="docutils literal"><span class="pre">p</span></code> と指数が続きます。</p>
</dd></dl>

<dl class="classmethod">
<dt id="float.fromhex">
<em class="property">classmethod </em><code class="descclassname">float.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#float.fromhex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>16 進文字列表現 <em>s</em> で表される、浮動小数点数を返すクラスメソッドです。文字列 <em>s</em> は、前や後にホワイトスペースを含んでいても構いません。</p>
</dd></dl>

<p><a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> はクラスメソッドですが、 <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> はインスタンスメソッドであることに注意して下さい。</p>
<p>16 進文字列表現は以下の書式となります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;0x&#39;</span><span class="p">]</span> <span class="n">integer</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span> <span class="n">fraction</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="n">exponent</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sign</span></code> は必須ではなく、 <code class="docutils literal"><span class="pre">+</span></code> と <code class="docutils literal"><span class="pre">-</span></code> のどちらかです。 <code class="docutils literal"><span class="pre">integer</span></code> と <code class="docutils literal"><span class="pre">fraction</span></code> は 16 進数の文字列で、 <code class="docutils literal"><span class="pre">exponent</span></code> は 10 進数で符号もつけられます。大文字・小文字は区別されず、最低でも 1 つの 16 進数文字を整数部もしくは小数部に含む必要があります。この制限は C99 規格のセクション 6.4.4.2 で規定されていて、 Java 1.5 以降でも使われています。特に、 <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> の出力は C や Java コード中で、浮動小数点数の 16 進表記として役に立つでしょう。また、 C の <code class="docutils literal"><span class="pre">%a</span></code> 書式や、 Java の <code class="docutils literal"><span class="pre">Double.toHexString</span></code> で書きだされた文字列は <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> で受け付けられます。</p>
<p>なお、指数部は 16 進数ではなく 10 進数で書かれ、係数に掛けられる 2 の累乗を与えます。例えば、16 進文字列 <code class="docutils literal"><span class="pre">0x3.a7p10</span></code> は浮動小数点数 <code class="docutils literal"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></code> すなわち <code class="docutils literal"><span class="pre">3740.0</span></code> を表します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x3.a7p10&#39;</span><span class="p">)</span>
<span class="go">3740.0</span>
</pre></div>
</div>
<p>逆変換を <code class="docutils literal"><span class="pre">3740.0</span></code> に適用すると、同じ数を表す異なる 16 進文字列表現を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">&#39;0x1.d380000000000p+11&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="hashing-of-numeric-types">
<span id="numeric-hash"></span><h3>4.4.4. 数値型のハッシュ化<a class="headerlink" href="#hashing-of-numeric-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>数 <code class="docutils literal"><span class="pre">x</span></code> と <code class="docutils literal"><span class="pre">y</span></code> に対して、型が異なっていたとしても、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> であれば必ず <code class="docutils literal"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> であることが要請されます (詳細は <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a>  メソッドドキュメントを参照してください)。実装の簡単さと 複数の数値型 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 、 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a> 、 <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> を含みます) 間の効率のため、Python の 数値型に対するハッシュ値はある単一の数学的関数に基づいていて、 その関数はすべての有理数に対し定義されているため、 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> と <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> のすべてのインスタンスと、 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> と <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a> のすべての有限なインスタンスに 対して適用されます。本質的には、この関数は定数の素数 <code class="docutils literal"><span class="pre">P</span></code> に対して <code class="docutils literal"><span class="pre">P</span></code> を法とする還元で与えられます。 値 <code class="docutils literal"><span class="pre">P</span></code> は、 <a class="reference internal" href="sys.html#sys.hash_info" title="sys.hash_info"><code class="xref py py-data docutils literal"><span class="pre">sys.hash_info</span></code></a> の <code class="xref py py-attr docutils literal"><span class="pre">modulus</span></code> 属性として Python で利用できます。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 現在使われている素数は、32 bit C long のマシンでは <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> 、 64-bit C long のマシンでは <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**61</span> <span class="pre">-</span> <span class="pre">1</span></code> です。</p>
</div>
<p>詳細な規則はこうです:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> が非負の有理数で、 <code class="docutils literal"><span class="pre">n</span></code> が <code class="docutils literal"><span class="pre">P</span></code> で割り切れないなら、 <code class="docutils literal"><span class="pre">invmod(n,</span> <span class="pre">P)</span></code> を <code class="docutils literal"><span class="pre">n</span></code> を <code class="docutils literal"><span class="pre">P</span></code> で割った剰余の (剰余演算の意味での) 逆数を与えるものとして、 <code class="docutils literal"><span class="pre">hash(x)</span></code> を <code class="docutils literal"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">invmod(n,</span> <span class="pre">P)</span> <span class="pre">%</span> <span class="pre">P</span></code> と定義します。</li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> が非負の有理数で、 <code class="docutils literal"><span class="pre">n</span></code> が <code class="docutils literal"><span class="pre">P</span></code> で割り切れる (が <code class="docutils literal"><span class="pre">m</span></code> は割り切れない) なら、 <code class="docutils literal"><span class="pre">n</span></code> は <code class="docutils literal"><span class="pre">P</span></code> で割った余りの逆数を持たず、上の規則は適用できません。この場合、 <code class="docutils literal"><span class="pre">hash(x)</span></code> を定数 <code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code> と定義します。</li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> が負の有理数なら、 <code class="docutils literal"><span class="pre">hash(x)</span></code> を <code class="docutils literal"><span class="pre">-hash(-x)</span></code> と定義します。その結果のハッシュが <code class="docutils literal"><span class="pre">-1</span></code> なら、 <code class="docutils literal"><span class="pre">-2</span></code> に置き換えます。</li>
<li>特定の値 <code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code> 、 <code class="docutils literal"><span class="pre">-sys.hash_info.inf</span></code> 、 <code class="docutils literal"><span class="pre">sys.hash_info.nan</span></code> は、正の無限大、負の無限大、nan を (それぞれ) 表すのに使われます。(すべてのハッシュ可能な nan は同じハッシュ値を持ちます。)</li>
<li>複素 (<a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a>) 数 <code class="docutils literal"><span class="pre">z</span></code> に対して、実部と虚部のハッシュ値は、 <code class="docutils literal"><span class="pre">hash(z.real)</span> <span class="pre">+</span> <span class="pre">sys.hash_info.imag</span> <span class="pre">*</span> <span class="pre">hash(z.imag)</span></code> の <code class="docutils literal"><span class="pre">2**sys.hash_info.width</span></code> を法とする還元を計算することにより組み合わせられ、よってこれは <code class="docutils literal"><span class="pre">range(-2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1))</span></code> に収まります。再び、結果が <code class="docutils literal"><span class="pre">-1</span></code> なら、 <code class="docutils literal"><span class="pre">-2</span></code> で置き換えられます。</li>
</ul>
<p>上述の規則をわかりやすくするため、有理数 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> や、 <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a> のハッシュを計算する組み込みのハッシュと等価な Python コードの例を挙げます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">hash_fraction</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a rational number m / n.</span>

<span class="sd">    Assumes m and n are integers, with n positive.</span>
<span class="sd">    Equivalent to hash(fractions.Fraction(m, n)).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">modulus</span>
    <span class="c1"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="n">P</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="n">P</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fermat&#39;s Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="c1"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">hash_value</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="k">def</span> <span class="nf">hash_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a float x.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hash_fraction</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">hash_complex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a complex number z.&quot;&quot;&quot;</span>

    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="c1"># do a signed reduction modulo 2**sys.hash_info.width</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterator-types">
<span id="typeiter"></span><h2>4.5. イテレータ型<a class="headerlink" href="#iterator-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-17">Python はコンテナでの反復処理の概念をサポートしています。この概念は 2 つの別々のメソッドを使って実装されています; これらのメソッドを使ってユーザ定義のクラスで反復を行えるようにできます。後に詳しく述べるシーケンスは、必ず反復処理メソッドをサポートしています。</p>
<p>コンテナオブジェクトに反復処理をサポートさせるためには、以下のメソッドを定義しなければなりません:</p>
<dl class="method">
<dt id="container.__iter__">
<code class="descclassname">container.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#container.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータオブジェクトを返します。オブジェクトは後述するイテレータプロトコルをサポートする必要があります。もしコンテナが異なる型の反復処理をサポートするなら、それらの反復処理毎に追加のメソッドを提供しても構いません (複数の形式の反復処理を提供するオブジェクトの例として、幅優先探索と深さ優先探索をサポートする木構造が挙げられます)。このメソッドは Python/C API での Python オブジェクトの型構造体の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> スロットに対応します。</p>
</dd></dl>

<p>イテレータオブジェクト自体は以下の 2 つのメソッドをサポートする必要があります。これらのメソッドは 2 つ合わせて <em class="dfn">iterator protocol</em>: (イテレータプロトコル) を成します:</p>
<dl class="method">
<dt id="iterator.__iter__">
<code class="descclassname">iterator.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータオブジェクト自体を返します。このメソッドはコンテナとイテレータの両方を <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> および <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 文で使えるようにするために必要です。このメソッドは Python/C API において Python オブジェクトを表す型構造体の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> スロットに対応します。</p>
</dd></dl>

<dl class="method">
<dt id="iterator.__next__">
<code class="descclassname">iterator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__next__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテナの次のアイテムを返します。もしそれ以上アイテムが無ければ <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外を送出します。 このメソッドは Python/C APIでのPythonオブジェクトの型構造体の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a> スロットに対応します。</p>
</dd></dl>

<p>Python では、いくつかのイテレータオブジェクトを定義して、一般のシーケンス型、特殊なシーケンス型、辞書型、その他の特殊な形式に渡って反復をサポートしています。特殊型は、イテレータプロトコルの実装以外では重要ではありません。</p>
<p>イテレータの <a class="reference internal" href="#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドが一旦 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を送出したなら、以降の呼び出しでも例外を送出し続けなければなりません。この特性に従わない実装は壊れているとみなされます。</p>
<div class="section" id="generator-types">
<span id="id3"></span><h3>4.5.1. ジェネレータ型<a class="headerlink" href="#generator-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python における <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> (ジェネレータ) は、イテレータプロトコルを実装する便利な方法を提供します。コンテナオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> メソッドがジェネレータとして実装されていれば、そのメソッドは <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> および <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドを提供するイテレータオブジェクト (厳密にはジェネレータオブジェクト) を自動的に返します。ジェネレータに関する詳細な情報は、 <a class="reference internal" href="../reference/expressions.html#yieldexpr"><span class="std std-ref">yield 式のドキュメント</span></a> にあります。</p>
</div>
</div>
<div class="section" id="sequence-types-list-tuple-range">
<span id="typesseq"></span><h2>4.6. シーケンス型 — <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a><a class="headerlink" href="#sequence-types-list-tuple-range" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的なシーケンス型は 3 つあります: リスト、タプル、range オブジェクトです。<a class="reference internal" href="#binaryseq"><span class="std std-ref">バイナリデータ</span></a> や <a class="reference internal" href="#textseq"><span class="std std-ref">テキスト文字列</span></a> を処理するように仕立てられたシーケンス型は、セクションを割いて解説します。</p>
<div class="section" id="common-sequence-operations">
<span id="typesseq-common"></span><h3>4.6.1. 共通のシーケンス演算<a class="headerlink" href="#common-sequence-operations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-18">以下の表にある演算は、ほとんどのミュータブル、イミュータブル両方のシーケンスでサポートされています。カスタムのシーケンス型にこれらの演算を完全に実装するのが簡単になるように、 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC が提供されています。</p>
<p>以下のテーブルで、シーケンス演算を優先順位が低い順に挙げます。表内で、 <em>s</em> と <em>t</em> は同じ型のシーケンス、 <em>n</em>、 <em>i</em>、 <em>j</em> 、 <em>k</em> は整数、<em>x</em> は <em>s</em> に課された型と値の条件を満たす任意のオブジェクトです。</p>
<p><code class="docutils literal"><span class="pre">in</span></code> および <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> 演算の優先順位は比較演算と同じです。<code class="docutils literal"><span class="pre">+</span></code> (結合) および <code class="docutils literal"><span class="pre">*</span></code> (繰り返し)の優先順位は対応する数値演算と同じです。 <a class="footnote-reference" href="#id14" id="id4">[3]</a></p>
<table border="1" class="docutils" id="index-19">
<colgroup>
<col width="38%" />
<col width="47%" />
<col width="15%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> のある要素が <em>x</em> と等しければ <code class="docutils literal"><span class="pre">True</span></code> , そうでなければ <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> のある要素が <em>x</em> と等しければ <code class="docutils literal"><span class="pre">False</span></code>, そうでなければ <code class="docutils literal"><span class="pre">True</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code></td>
<td><em>s</em> と <em>t</em> の結合</td>
<td>(6)(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> または <code class="docutils literal"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></code></td>
<td><em>s</em> 自身を <em>n</em> 回足すのと同じ</td>
<td>(2)(7)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span></code></td>
<td><em>s</em> の 0 から数えて <em>i</em> 番目の要素</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span></code></td>
<td><em>s</em> の <em>i</em> から <em>j</em> までのスライス</td>
<td>(3)(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code></td>
<td><em>s</em> の <em>i</em> から <em>j</em> まで、 <em>k</em> 毎のスライス</td>
<td>(3)(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">len(s)</span></code></td>
<td><em>s</em> の長さ</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">min(s)</span></code></td>
<td><em>s</em> の最小の要素</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">max(s)</span></code></td>
<td><em>s</em> の最大の要素</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.index(x[,</span> <span class="pre">i[,</span> <span class="pre">j]])</span></code></td>
<td><em>s</em> 中で <em>x</em> が最初に出現するインデックス (インデックス <em>i</em> 以降からインデックス <em>j</em> までの範囲)</td>
<td>(8)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.count(x)</span></code></td>
<td><em>s</em> 中に <em>x</em> が出現する回数</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>同じ型のシーケンスは比較もサポートしています。特に、タプルとリストは対応する要素を比較することで辞書式順序で比較されます。つまり、等しいとされるためには、すべての要素が等しく、両シーケンスの型も長さも等しくなければなりません。(完全な詳細は言語リファレンスの <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">比較</span></a> を参照してください。)</p>
<p>注釈:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">in</span></code> および <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> 演算は、一般に単純な包含判定にのみ使われますが、(<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> のような) 特殊なシーケンスでは部分シーケンス判定にも使われます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;gg&quot;</span> <span class="ow">in</span> <span class="s2">&quot;eggs&quot;</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">0</span></code> 未満の値 <em>n</em> は <code class="docutils literal"><span class="pre">0</span></code> として扱われます (これは <em>s</em> と同じ型の空のシーケンスを表します)。シーケンス <em>s</em> の要素はコピーされないので注意してください; コピーではなく要素に対する参照カウントが増えます。これは Python に慣れていないプログラマをよく悩ませます。例えば以下のコードを考えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal"><span class="pre">[[]]</span></code> が空リストを含む 1 要素のリストなので、<code class="docutils literal"><span class="pre">[[]]</span> <span class="pre">*</span> <span class="pre">3</span></code> の 3 要素はこの一つの空リスト (への参照) です。<code class="docutils literal"><span class="pre">lists</span></code> のいずれかの要素を変更すると、その一つのリストが変更されます。別々のリストのリストを作るにはこうします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</pre></div>
</div>
<p>別の説明が FAQ エントリ <a class="reference internal" href="../faq/programming.html#faq-multidimensional-list"><span class="std std-ref">多次元のリストを作るにはどうしますか？</span></a> にあります。</p>
</li>
<li><p class="first"><em>i</em> または <em>j</em> が負の数の場合、インデックスはシーケンスの末端からの相対インデックスになります: <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></code> または <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></code> が代わりに使われます。
ただし <code class="docutils literal"><span class="pre">-0</span></code> はやはり <code class="docutils literal"><span class="pre">0</span></code> であることに注意してください。</p>
</li>
<li><p class="first"><em>s</em> の <em>i</em> から <em>j</em> へのスライスは <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code> となるようなインデックス <em>k</em> を持つ要素からなるシーケンスとして定義されます。 <em>i</em> または <em>j</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> よりも大きい場合、 <code class="docutils literal"><span class="pre">len(s)</span></code> を使います。 <em>i</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> だった場合、 <code class="docutils literal"><span class="pre">0</span></code> を使います。 <em>j</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> だった場合、 <code class="docutils literal"><span class="pre">len(s)</span></code> を使います。 <em>i</em> が <em>j</em> 以上の場合、スライスは空のシーケンスになります。</p>
</li>
<li><p class="first"><em>s</em> の「 <em>i</em> から <em>j</em> まででステップが <em>k</em> のスライス」は、インデックス <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code> （ただし n は <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">(j-i)/k</span></code> を満たす任意の整数）を持つ要素からなるシーケンスとして定義されます。言い換えるとインデックスは <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">i+k</span></code>, <code class="docutils literal"><span class="pre">i+2*k</span></code>, <code class="docutils literal"><span class="pre">i+3*k</span></code> と続き、 <em>j</em> に達したところでストップします (ただし <em>j</em> は含みません)。 <em>k</em> が正の数である場合、 <em>i</em> または <em>j</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> より大きければ <code class="docutils literal"><span class="pre">len(s)</span></code> を代わりに使用します。 <em>k</em> が負の数である場合、 <em>i</em> または <em>j</em> が <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code> より大きければ <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code> を代わりに使用します。 <em>i</em> または <em>j</em> を省略または <code class="docutils literal"><span class="pre">None</span></code> を指定すると、 &quot;端&quot; (どちらの端かは <em>k</em> の符号に依存) の値を代わりに使用します。なお <em>k</em> はゼロにできないので注意してください。また <em>k</em> に <code class="docutils literal"><span class="pre">None</span></code> を指定すると、 <code class="docutils literal"><span class="pre">1</span></code> が指定されたものとして扱われます。</p>
</li>
<li><p class="first">イミュータブルなシーケンスの結合は、常に新しいオブジェクトを返します。これは、結合の繰り返しでシーケンスを構築する実行時間コストがシーケンスの長さの合計の二次式になることを意味します。実行時間コストを線形にするには、代わりに以下のいずれかにしてください:</p>
<ul class="simple">
<li><a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> オブジェクトを結合するには、リストを構築して最後に <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a> を使うか、 <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> インスタンスに書き込んで完成してから値を取得してください</li>
<li><a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトを結合するなら、同様に <a class="reference internal" href="#bytes.join" title="bytes.join"><code class="xref py py-meth docutils literal"><span class="pre">bytes.join()</span></code></a> や <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> を使うか、 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> オブジェクトでインプレースに結合できます。 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> オブジェクトはミュータブルで、効率のいい割り当て超過機構を備えています</li>
<li><a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> オブジェクトを結合するなら、代わりに <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> を拡張してください</li>
<li>その他の型については、関連するクラスのドキュメントを調べてください</li>
</ul>
</li>
<li><p class="first">シーケンス型には、 (<a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> のように) 特殊なパターンに従う項目のシーケンスのみをサポートするものがあり、それらはシーケンスの結合や繰り返しをサポートしません。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">index</span></code> は <em>x</em> が <em>s</em> 中に見つからないとき <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。追加の引数 <em>i</em> と <em>j</em> は、すべての実装がサポートしているわけではありません。追加の引数を渡すのは、おおよそ <code class="docutils literal"><span class="pre">s[i:j].index(x)</span></code> を使うのと等価ですが、データをコピーしなくて済むし、返されるのはスライスの最初ではなくシーケンスの最初からの相対インデクスです。</p>
</li>
</ol>
</div>
<div class="section" id="immutable-sequence-types">
<span id="typesseq-immutable"></span><h3>4.6.2. イミュータブルなシーケンス型<a class="headerlink" href="#immutable-sequence-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-20">イミュータブルなシーケンス型が一般に実装している演算のうち、ミュータブルなシーケンス型がサポートしていないのは、組み込みの <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> だけです。</p>
<p>このサポートにより、<a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> インスタンスのようなイミュータブルなシーケンスは、 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のキーとして使え、 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> や <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> インスタンスに保存できます。</p>
<p>ハッシュ不可能な値を含むイミュータブルなシーケンスをハッシュ化しようとすると、 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> となります。</p>
</div>
<div class="section" id="mutable-sequence-types">
<span id="typesseq-mutable"></span><h3>4.6.3. ミュータブルなシーケンス型<a class="headerlink" href="#mutable-sequence-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-21">以下のテーブルにある演算は、ほとんどのミュータブルなシーケンスでサポートされています。カスタムのシーケンス型にこれらの演算を完全に実装するのが簡単になるように、 <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSequence</span></code></a> ABC が提供されています。</p>
<p>このテーブルで、 <em>s</em> はミュータブルなシーケンス型のインスタンス、 <em>t</em> は任意のイテラブルオブジェクト、 <em>x</em> は <em>s</em> に課された型と値の条件を満たす任意のオブジェクト (例えば、 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> は値の制限 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">255</span></code> に合う整数のみを受け付けます) です。</p>
<table border="1" class="docutils" id="index-22">
<colgroup>
<col width="36%" />
<col width="39%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></code></td>
<td><em>s</em> の要素 <em>i</em> を <em>x</em> と入れ替えます</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><em>s</em> の <em>i</em> から <em>j</em> 番目までのスライスをイテラブル <em>t</em> の内容に入れ替えます</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j]</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">[]</span></code> と同じです</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code> の要素を <em>t</em> の要素と入れ替えます</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></code></td>
<td>リストから <code class="docutils literal"><span class="pre">s[i:j:k]</span></code> の要素を削除します</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.append(x)</span></code></td>
<td><em>x</em> をシーケンスの最後に加えます (<code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> と同じ)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.clear()</span></code></td>
<td><code class="docutils literal"><span class="pre">s</span></code> から全ての要素を取り除きます (<code class="docutils literal"><span class="pre">del</span> <span class="pre">s[:]</span></code> と同じ)</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.copy()</span></code></td>
<td><code class="docutils literal"><span class="pre">s</span></code> の浅いコピーを作成します (<code class="docutils literal"><span class="pre">s[:]</span></code> と同じ)</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.extend(t)</span></code> または <code class="docutils literal"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code></td>
<td><em>s</em> を <em>t</em> の内容で拡張します (ほとんど <code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">t</span></code> と同じ)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*=</span> <span class="pre">n</span></code></td>
<td><em>s</em> をその内容を <em>n</em> 回繰り返したもので更新</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></code></td>
<td><em>s</em> の <em>i</em> で与えられたインデックスに <em>x</em> を挿入します。 (<code class="docutils literal"><span class="pre">s[i:i]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> と同じ)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.pop([i])</span></code></td>
<td><em>s</em> から <em>i</em> 番目の要素を取り出し、また取り除きます</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.remove(x)</span></code></td>
<td><em>s</em> から <code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">==</span> <span class="pre">x</span></code> となる最初の要素を取り除きます</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.reverse()</span></code></td>
<td><em>s</em> をインプレースに逆転させます</td>
<td>(4)</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic">
<li><p class="first"><em>t</em> は置き換えるスライスと同じ長さでなければいけません。</p>
</li>
<li><p class="first">オプションの引数 <em>i</em> は標準で <code class="docutils literal"><span class="pre">-1</span></code> なので、標準では最後の要素をリストから除去して返します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">remove</span></code> は <em>s</em> に <em>x</em> が見つからなければ <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code> メソッドは、大きなシーケンスを反転するときの容量の節約のため、シーケンスをインプレースに変化させます。副作用としてこの演算が行われることをユーザに気づかせるために、これは反転したシーケンスを返しません。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code> は、スライシング操作をサポートしないミュータブルなコンテナ (<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> や <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> など) のインタフェースとの一貫性のために含まれています</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code> メソッド。</p>
</div>
</li>
<li><p class="first">値 <em>n</em> は整数であるか、<a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> を実装したオブジェクトです。 <em>n</em> の値がゼロまたは負数の場合、シーケンスをクリアします。<a class="reference internal" href="#typesseq-common"><span class="std std-ref">共通のシーケンス演算</span></a> で <code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> について説明したとおり、シーケンスの要素はコピーされないので注意してください; コピーではなく要素に対する参照カウントが増えます。</p>
</li>
</ol>
</div>
<div class="section" id="lists">
<span id="typesseq-list"></span><h3>4.6.4. リスト型 (list)<a class="headerlink" href="#lists" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-23">リストはミュータブルなシーケンスで、一般的に同種の項目の集まりを格納するために使われます (厳密な類似の度合いはアプリケーションによって異なる場合があります)。</p>
<dl class="class">
<dt id="list">
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#list" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リストの構成にはいくつかの方法があります:</p>
<ul class="simple">
<li>角括弧の対を使い、空のリストを表す: <code class="docutils literal"><span class="pre">[]</span></code></li>
<li>角括弧を使い、項目をカンマで区切る: <code class="docutils literal"><span class="pre">[a]</span></code>、<code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code></li>
<li>リスト内包表記を使う: <code class="docutils literal"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">iterable]</span></code></li>
<li>型コンストラクタを使う: <code class="docutils literal"><span class="pre">list()</span></code> または <code class="docutils literal"><span class="pre">list(iterable)</span></code></li>
</ul>
<p>コンストラクタは、 <em>iterable</em> の項目と同じ項目で同じ順のリストを構築します。 <em>iterable</em> は、シーケンス、イテレートをサポートするコンテナ、またはイテレータオブジェクトです。 <em>iterable</em> が既にリストなら、 <code class="docutils literal"><span class="pre">iterable[:]</span></code> と同様にコピーが作られて返されます。例えば、 <code class="docutils literal"><span class="pre">list('abc')</span></code> は <code class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> を、 <code class="docutils literal"><span class="pre">list(</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span> <span class="pre">)</span></code> は <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> を返します。引数が与えられなければ、このコンストラクタは新しい空のリスト <code class="docutils literal"><span class="pre">[]</span></code> を作成します。</p>
<p>リストを作る方法は、他にも組み込み関数 <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> などいろいろあります。</p>
<p>リストは <a class="reference internal" href="#typesseq-common"><span class="std std-ref">共通の</span></a> および <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">ミュータブルの</span></a> シーケンス演算をすべて実装します。リストは、更に以下のメソッドも提供します:</p>
<dl class="method">
<dt id="list.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>*</em>, <em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#list.sort" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、項目間の <code class="docutils literal"><span class="pre">&lt;</span></code> 比較のみを用いてリストをインプレースにソートします。例外は抑制されません。比較演算がどこかで失敗したら、ソート演算自体が失敗します (そしてリストは部分的に変更された状態で残されるでしょう)。</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a> には２つの引数をキーワード引数 (<a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">keyword-only arguments</span></a>) としてのみ渡せます :</p>
<p><em>key</em> は一引数をとる関数を指定し、リストのそれぞれの要素から比較キーを取り出すのに使います (例えば、 <code class="docutils literal"><span class="pre">key=str.lower</span></code>)。それぞれの項目に対応するキーは一度計算され、ソート処理全体に使われます。デフォルトの値 <code class="docutils literal"><span class="pre">None</span></code> は、別のキー値を計算せず、リストの値が直接ソートされることを意味します。</p>
<p>2.x 形式の <em>cmp</em> 関数を <em>key</em> 関数に変換するために、<a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></code></a> ユーティリティが利用できます。</p>
<p><em>reverse</em> は真偽値です。 <code class="docutils literal"><span class="pre">True</span></code> がセットされた場合、リストの要素は個々の比較が反転したものとして並び替えられます。</p>
<p>このメソッドは、大きなシーケンスをソートするときの容量の節約のため、シーケンスをインプレースに変化させます。副作用としてこの演算が行われることをユーザに気づかせるために、これはソートしたシーケンスを返しません (新しいリストインスタンスを明示的に要求するには <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> を使ってください)。</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a> メソッドは安定していることが保証されています。ソートは、等しい要素の相対順序が変更されないことが保証されていれば、安定しています。これは複数パスのソートを行なう (例えば部署でソートして、それから給与の等級でソートする) のに役立ちます。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> リストがソートされている間、または変更しようとする試みの影響中、あるいは検査中でさえ、リストは未定義です。Python の C 実装では、それらが続いている間、リストは空として出力され、リストがソート中に変更されていることを検知できたら <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tuples">
<span id="typesseq-tuple"></span><h3>4.6.5. タプル型 (tuple)<a class="headerlink" href="#tuples" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-24">タプルはイミュータブルなシーケンスで、一般的に異種のデータの集まり (組み込みの <a class="reference internal" href="functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> で作られた 2-タプルなど) を格納するために使われます。タプルはまた、同種のデータのイミュータブルなシーケンスが必要な場合 (<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> インスタンスや <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> インスタンスに保存できるようにするためなど) にも使われます。</p>
<dl class="class">
<dt id="tuple">
<em class="property">class </em><code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#tuple" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タプルの構成にはいくつかの方法があります:</p>
<ul class="simple">
<li>丸括弧の対を使い、空のタプルを表す: <code class="docutils literal"><span class="pre">()</span></code></li>
<li>カンマを使い、単要素のタプルを表す: <code class="docutils literal"><span class="pre">a,</span></code> または <code class="docutils literal"><span class="pre">(a,)</span></code></li>
<li>項目をカンマで区切る: <code class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> または <code class="docutils literal"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></li>
<li>組み込みの <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-func docutils literal"><span class="pre">tuple()</span></code></a> を使う: <code class="docutils literal"><span class="pre">tuple()</span></code> または <code class="docutils literal"><span class="pre">tuple(iterable)</span></code></li>
</ul>
<p>コンストラクタは、 <em>iterable</em> の項目と同じ項目で同じ順のタプルを構築します。 <em>iterable</em> は、シーケンス、イテレートをサポートするコンテナ、またはイテレータオブジェクトです。 <em>iterable</em> が既にタプルなら、そのまま返されます。例えば、 <code class="docutils literal"><span class="pre">tuple('abc')</span></code> は <code class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> を、 <code class="docutils literal"><span class="pre">tuple(</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">)</span></code> は <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> を返します。引数が与えられなければ、このコンストラクタは新しい空のタプル <code class="docutils literal"><span class="pre">()</span></code> を作成します。</p>
<p>なお、タプルを作るのはカンマであり、丸括弧ではありません。丸括弧は省略可能ですが、空のタプルの場合や構文上の曖昧さを避けるのに必要な時は例外です。例えば、 <code class="docutils literal"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> は三引数の関数呼び出しですが、<code class="docutils literal"><span class="pre">f((a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> は 3-タプルを唯一の引数とする関数の呼び出しです。</p>
<p>タプルは <a class="reference internal" href="#typesseq-common"><span class="std std-ref">共通の</span></a> シーケンス演算をすべて実装します。</p>
</dd></dl>

<p>異種のデータの集まりで、インデックスによってアクセスするよりも名前によってアクセスしたほうが明確になるものには、単純なタプルオブジェクトよりも <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal"><span class="pre">collections.namedtuple()</span></code></a> が向いているかもしれません。</p>
</div>
<div class="section" id="ranges">
<span id="typesseq-range"></span><h3>4.6.6. range<a class="headerlink" href="#ranges" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-25"><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 型は、数のイミュータブルなシーケンスを表し、一般に <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループにおいて特定の回数のループに使われます。</p>
<dl class="class">
<dt id="range">
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#range" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>range コンストラクタの引数は整数 (組み込みの <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> または <code class="docutils literal"><span class="pre">__index__</span></code> 特殊メソッドを実装するオブジェクト) でなければなりません。<em>step</em> 引数が省略された場合のデフォルト値は <code class="docutils literal"><span class="pre">1</span></code> です。<em>start</em> 引数が省略された場合のデフォルト値は  <code class="docutils literal"><span class="pre">0</span></code> です。 <em>step</em> が 0 の場合、<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<p><em>step</em> が正の場合、range <code class="docutils literal"><span class="pre">r</span></code> の内容は式 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> で決定されます。ここで、 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> かつ <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&lt;</span> <span class="pre">stop</span></code> です。</p>
<p><em>step</em> が負の場合も、range <code class="docutils literal"><span class="pre">r</span></code> の内容は式 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> で決定されます。ただし、制約条件は <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> かつ <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&gt;</span> <span class="pre">stop</span></code> です。</p>
<p><code class="docutils literal"><span class="pre">r[0]</span></code> が値の制約を満たさない場合、range オブジェクトは空になります。range は負のインデックスをサポートしますが、これらは正のインデックスにより決定されるシーケンスの末尾からのインデックス指定として解釈されます。</p>
<p>range は <a class="reference internal" href="sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal"><span class="pre">sys.maxsize</span></code></a> より大きい絶対値を含むことができますが、いくつかの機能 (<a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> など) は <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> を送出することがあります。</p>
<p>range の例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>range は <a class="reference internal" href="#typesseq-common"><span class="std std-ref">共通の</span></a> シーケンス演算を、結合と繰り返し以外すべて実装します (range オブジェクトは厳格なパターンに従うシーケンスのみを表せ、繰り返しと結合はたいていそのパターンを破るという事実によります)。</p>
<dl class="attribute">
<dt id="range.start">
<code class="descname">start</code><a class="headerlink" href="#range.start" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>start</em> の値 (この引数が与えられていない場合は <code class="docutils literal"><span class="pre">0</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="range.stop">
<code class="descname">stop</code><a class="headerlink" href="#range.stop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>stop</em> の値</p>
</dd></dl>

<dl class="attribute">
<dt id="range.step">
<code class="descname">step</code><a class="headerlink" href="#range.step" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>引数 <em>step</em> の値 (この引数が与えられていない場合は <code class="docutils literal"><span class="pre">1</span></code>)</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 型が通常の <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> や <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> にまさる点は、<a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> オブジェクトがサイズや表す範囲にかかわらず常に一定の (小さな) 量のメモリを使うことです (<code class="docutils literal"><span class="pre">start</span></code>、<code class="docutils literal"><span class="pre">stop</span></code>、<code class="docutils literal"><span class="pre">step</span></code> の値のみを保存し、後は必要に応じて個々の項目や部分 range を計算するためです)。</p>
<p>range オブジェクトは <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC を実装し、包含判定、要素インデックス検索、スライシングのような機能を提供し、負のインデックスをサポートします (<a class="reference internal" href="#typesseq"><span class="std std-ref">シーケンス型 — list, tuple, range</span></a> を参照):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">range(0, 20, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">11</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">range(0, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">18</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">==</span></code> および <code class="docutils literal"><span class="pre">!=</span></code> による range オブジェクトの等価性の判定は、これらをシーケンスとして比較します。つまり、二つの range オブジェクトは同じ値のシーケンスを表すなら等しいとみなされます。(なお、二つの等しいとされる range オブジェクトが異なる  <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a> および <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a> 属性を持つことがあります。例えば <code class="docutils literal"><span class="pre">range(0)</span> <span class="pre">==</span> <span class="pre">range(2,</span> <span class="pre">1,</span> <span class="pre">3)</span></code> や <code class="docutils literal"><span class="pre">range(0,</span> <span class="pre">3,</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">range(0,</span> <span class="pre">4,</span> <span class="pre">2)</span></code>。)</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>シーケンス ABC を実装。スライスと負のインデックスのサポート。<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> オブジェクトの帰属判定を、すべてのアイテムをイテレートする代わりに、定数時間で行います。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>(オブジェクトの同一性に基づいて比較する代わりに) range オブジェクトをそれらが定義する値のシーケンスに基づいて比較するように '==' と '!=' を定義しました。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span>属性 <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a> および <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a>。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<ul class="last simple">
<li>遅延評価される浮動小数点版の range の作り方は <a class="reference external" href="http://code.activestate.com/recipes/579000/">linspace レシピ</a> で示されています。</li>
</ul>
</div>
</div>
</div>
<div class="section" id="text-sequence-type-str">
<span id="textseq"></span><span id="index-26"></span><h2>4.7. テキストシーケンス型 — <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a><a class="headerlink" href="#text-sequence-type-str" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のテキストデータは <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> オブジェクト、すなわち <em class="dfn">文字列</em> として扱われます。文字列は Unicode コードポイントのイミュータブルな <a class="reference internal" href="#typesseq"><span class="std std-ref">シーケンス</span></a> です。文字列リテラルには様々な記述方法があります:</p>
<ul class="simple">
<li>シングルクォート: <code class="docutils literal"><span class="pre">'&quot;ダブル&quot;</span> <span class="pre">クォートを埋め込むことができます'</span></code></li>
<li>ダブルクォート: <code class="docutils literal"><span class="pre">&quot;'シングル'</span> <span class="pre">クォートを埋め込むことができます&quot;</span></code>。</li>
<li>三重引用符: <code class="docutils literal"><span class="pre">'''三つのシングルクォート'''</span></code>, <code class="docutils literal"><span class="pre">&quot;&quot;&quot;三つのダブルクォート&quot;&quot;&quot;</span></code></li>
</ul>
<p>三重引用符文字列は、複数行に分けることができます。関連付けられる空白はすべて文字列リテラルに含まれます。</p>
<p>単式の一部であり間に空白のみを含む文字列リテラルは、一つの文字列リテラルに暗黙に変換されます。つまり、<code class="docutils literal"><span class="pre">(&quot;spam</span> <span class="pre">&quot;</span> <span class="pre">&quot;eggs&quot;)</span> <span class="pre">==</span> <span class="pre">&quot;spam</span> <span class="pre">eggs&quot;</span></code> です。</p>
<p>エスケープシーケンスを含む文字列や、ほとんどのエスケープシーケンス処理を無効にする <code class="docutils literal"><span class="pre">r</span></code> (&quot;raw&quot;) 接頭辞などの、文字列リテラルの様々な形式は、<a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">文字列およびバイト列リテラル</span></a> を参照してください。</p>
<p>文字列は他のオブジェクトに <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> コンストラクタを使うことでも生成できます。</p>
<p>&quot;character&quot; 型が特別に用意されているわけではないので、文字列のインデックス指定を行うと長さ 1 の文字列を作成します。つまり、空でない文字列 <em>s</em> に対し、<code class="docutils literal"><span class="pre">s[0]</span> <span class="pre">==</span> <span class="pre">s[0:1]</span></code> です。</p>
<p id="index-27">ミュータブルな文字列型もありませんが、ミュータブルな断片から効率よく文字列を構成するのに <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a> や <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> が使えます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>Python 2 シリーズとの後方互換性のため、文字列リテラルの <code class="docutils literal"><span class="pre">u</span></code> 接頭辞が改めて許可されました。それは文字列リテラルとしての意味には影響がなく、 <code class="docutils literal"><span class="pre">r</span></code> 接頭辞と結合することはできません。</p>
</div>
<span class="target" id="index-28"></span><dl class="class">
<dt id="str">
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span><a class="headerlink" href="#str" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p><em>object</em> の <a class="reference internal" href="#textseq"><span class="std std-ref">文字列</span></a> 版を返します。 <em>object</em> が与えられなかった場合、空文字列が返されます。それ以外の場合 <code class="docutils literal"><span class="pre">str()</span></code> の動作は、 <em>encoding</em> や <em>errors</em> が与えられたかどうかによって次のように変わります。</p>
<p><em>encoding</em> も <em>errors</em> も与えられない場合、 <code class="docutils literal"><span class="pre">str(object)</span></code> は <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">object.__str__()</span></code></a> の結果を返します。これは &quot;略式の&quot; つまり読み易い <em>object</em> の文字列表現です。文字列オブジェクトに対してはその文字列自体を返します。 <em>object</em> が <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code></a> メソッドを持たない場合、<a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> は代わりに <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-meth docutils literal"><span class="pre">repr(object)</span></code></a> の結果を返します。</p>
<p id="index-29"><em>encoding</em> か <em>errors</em> の少なくとも一方が与えられた場合、 <em>object</em> は <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> (たとえば <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> や <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) でなくてはなりません。<em>object</em> が <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> (もしくは <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) オブジェクトである場合は、 <code class="docutils literal"><span class="pre">str(bytes,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> は <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode(encoding,</span> <span class="pre">errors)</span></code></a> と等価です。そうでない場合は、 <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a> が呼ばれる前に buffer オブジェクトの下層にある bytes オブジェクトが取得されます。 buffer オブジェクトについて詳しい情報は、 <a class="reference internal" href="#binaryseq"><span class="std std-ref">バイナリシーケンス型 — bytes, bytearray, memoryview</span></a> や <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">バッファプロトコル (buffer Protocol)</span></a> を参照してください。</p>
<p><em>encoding</em> 引数や <em>errors</em> 引数無しに <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトを <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> に渡すと、略式の文字列表現を返す 1 つ目の場合に該当します。(Python のコマンドラインオプション <a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal"><span class="pre">-b</span></code></a> も参照してください) 例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Zoot!&#39;</span><span class="p">)</span>
<span class="go">&quot;b&#39;Zoot!&#39;&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">str</span></code> クラスとそのメソッドについて詳しくは、 <a class="reference internal" href="#textseq"><span class="std std-ref">テキストシーケンス型 — str</span></a> や <a class="reference internal" href="#string-methods"><span class="std std-ref">文字列メソッド</span></a> の節を参照してください。フォーマットされた文字列を出力するには、 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">フォーマット済み文字列リテラル</span></a> と <a class="reference internal" href="string.html#string-formatting"><span class="std std-ref">カスタムの文字列書式化</span></a> の節を参照してください。加えて、 <a class="reference internal" href="text.html#stringservices"><span class="std std-ref">テキスト処理サービス</span></a> の節も参照してください。</p>
</dd></dl>

<div class="section" id="string-methods">
<span id="index-30"></span><span id="id5"></span><h3>4.7.1. 文字列メソッド<a class="headerlink" href="#string-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-31">文字列は <a class="reference internal" href="#typesseq-common"><span class="std std-ref">共通の</span></a> シーケンス演算全てに加え、以下に述べるメソッドを実装します。</p>
<p>文字列は、二形式の文字列書式化をサポートします。一方は柔軟さが高くカスタマイズできます (<a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a>、 <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">書式指定文字列の文法</span></a> 、および <a class="reference internal" href="string.html#string-formatting"><span class="std std-ref">カスタムの文字列書式化</span></a> を参照してください)。他方は C 言語の <code class="docutils literal"><span class="pre">printf</span></code> 形式の書式化に基づいてより狭い範囲と型を扱うもので、正しく扱うのは少し難しいですが、扱える場合ではたいていこちらのほうが高速です (<a class="reference internal" href="#old-string-formatting"><span class="std std-ref">printf 形式の文字列書式化</span></a>)。</p>
<p>標準ライブラリの <a class="reference internal" href="text.html#textservices"><span class="std std-ref">テキスト処理サービス</span></a> 節は、その他テキストに関する様々なユーティリティ (<a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールによる正規表現サポートなど) を提供するいくつかのモジュールをカバーしています。</p>
<dl class="method">
<dt id="str.capitalize">
<code class="descclassname">str.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.capitalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最初の文字を大文字にし、残りを小文字にした文字列のコピーを返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.casefold">
<code class="descclassname">str.</code><code class="descname">casefold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.casefold" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の casefold されたコピーを返します。casefold された文字列は、大文字小文字に関係ないマッチに使えます。</p>
<p>casefold は、小文字化と似ていますが、より積極的です。これは文字列の大文字小文字の区別をすべて取り去ることを意図しているためです。例えば、ドイツ語の小文字 <code class="docutils literal"><span class="pre">'ß'</span></code> は <code class="docutils literal"><span class="pre">&quot;ss&quot;</span></code> と同じです。これは既に小文字なので、<a class="reference internal" href="#str.lower" title="str.lower"><code class="xref py py-meth docutils literal"><span class="pre">lower()</span></code></a> は <code class="docutils literal"><span class="pre">'ß'</span></code> に何もしませんが、<a class="reference internal" href="#str.casefold" title="str.casefold"><code class="xref py py-meth docutils literal"><span class="pre">casefold()</span></code></a> はこれを <code class="docutils literal"><span class="pre">&quot;ss&quot;</span></code> に変換します。</p>
<p>casefold のアルゴリズムは Unicode Standard のセクション 3.13 に記述されています。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.center">
<code class="descclassname">str.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.center" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>width</em> の長さをもつ中央寄せされた文字列を返します。パディングには <em>fillchar</em> で指定された値 (デフォルトでは ASCII スペース) が使われます。 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下なら元の文字列が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="str.count">
<code class="descclassname">str.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>[<em>start</em>, <em>end</em>] の範囲に、部分文字列 <em>sub</em> が重複せず出現する回数を返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同じように解釈されます。</p>
</dd></dl>

<dl class="method">
<dt id="str.encode">
<code class="descclassname">str.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#str.encode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列のエンコードされたバージョンをバイト列オブジェクトとして返します。標準のエンコーディングは <code class="docutils literal"><span class="pre">'utf-8'</span></code> です。標準とは異なるエラー処理を行うために <em>errors</em> を与えることができます。標準のエラー処理は <code class="docutils literal"><span class="pre">'strict'</span></code> で、エンコードに関するエラーは <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> を送出します。他に利用できる値は <code class="docutils literal"><span class="pre">'ignore'</span></code>, <code class="docutils literal"><span class="pre">'replace'</span></code>, <code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>, <code class="docutils literal"><span class="pre">'backslashreplace'</span></code> および関数 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> によって登録された名前です。これについてはセクション <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">エラーハンドラ</span></a> を参照してください。利用可能なエンコーディングの一覧は、セクション <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">標準エンコーディング</span></a> を参照してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.1 で変更: </span>キーワード引数のサポートが追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.endswith">
<code class="descclassname">str.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.endswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が指定された <em>suffix</em> で終わるなら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。 <em>suffix</em> は見つけたい複数の接尾語のタプルでも構いません。オプションの <em>start</em> があれば、その位置から判定を始めます。オプションの <em>end</em> があれば、その位置で比較を止めます。</p>
</dd></dl>

<dl class="method">
<dt id="str.expandtabs">
<code class="descclassname">str.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#str.expandtabs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列内の全てのタブ文字が 1 つ以上のスペースで置換された、文字列のコピーを返します。スペースの数は現在の桁 (column) 位置と <em>tabsize</em> に依存します。タブ位置は <em>tabsize</em> 文字毎に存在します (デフォルト値である 8 の場合、タブ位置は 0, 8, 16 などになります)。文字列を展開するため、まず現桁位置がゼロにセットされ、文字列が 1 文字ずつ調べられます。文字がタブ文字 (<code class="docutils literal"><span class="pre">\t</span></code>) であれば、現桁位置が次のタブ位置と一致するまで、1 つ以上のスペースが結果の文字列に挿入されます。(タブ文字自体はコピーされません。) 文字が改行文字 (<code class="docutils literal"><span class="pre">\n</span></code> もしくは <code class="docutils literal"><span class="pre">\r</span></code>) の場合、文字がコピーされ、現桁位置は 0 にリセットされます。その他の文字は変更されずにコピーされ、現桁位置は、その文字の表示のされ方 (訳注: 全角、半角など) に関係なく、1 ずつ増加します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.find">
<code class="descclassname">str.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.find" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列のスライス <code class="docutils literal"><span class="pre">s[start:end]</span></code> に部分文字列 <em>sub</em> が含まれる場合、その最小のインデックスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。 <em>sub</em> が見つからなかった場合 <code class="docutils literal"><span class="pre">-1</span></code> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> メソッドは、 <em>sub</em> の位置を知りたいときにのみ使うべきです。 <em>sub</em> が部分文字列であるかどうかのみを調べるには、 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 演算子を使ってください:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format">
<code class="descclassname">str.</code><code class="descname">format</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の書式化操作を行います。このメソッドを呼び出す文字列は通常の文字、または、 <code class="docutils literal"><span class="pre">{}</span></code> で区切られた置換フィールドを含みます。それぞれの置換フィールドは位置引数のインデックスナンバー、または、キーワード引数の名前を含みます。返り値は、それぞれの置換フィールドが対応する引数の文字列値で置換された文字列のコピーです。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;The sum of 1 + 2 is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;The sum of 1 + 2 is 3&#39;</span>
</pre></div>
</div>
<p>書式指定のオプションについては、書式指定文字列を規定する <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">書式指定文字列の文法</span></a> を参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">数値 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> とサブクラス) を <code class="docutils literal"><span class="pre">n</span></code> の整数表現型 (例: <code class="docutils literal"><span class="pre">'{:n}'.format(1234)</span></code>) でフォーマットするとき、<code class="docutils literal"><span class="pre">LC_CTYPE</span></code> ロケールと <code class="docutils literal"><span class="pre">LC_NUMERIC</span></code> ロケールの一方または両方が 1 バイトより長い非 ASCII 文字であると同時に異なる値である場合、この関数は <code class="xref c c-func docutils literal"><span class="pre">localeconv()</span></code> の <code class="docutils literal"><span class="pre">decimal_point</span></code> と <code class="docutils literal"><span class="pre">thousands_sep</span></code> フィールドを読み取るため一時的に <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> ロケールに <code class="docutils literal"><span class="pre">LC_NUMERIC</span></code> のロケール値を設定します。この一時的な変更は他のスレッドの動作に影響します。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6.5 で変更: </span>数値を <code class="docutils literal"><span class="pre">n</span></code> の整数表現型でフォーマットするとき、この関数は一時的に <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> ロケールに <code class="docutils literal"><span class="pre">LC_NUMERIC</span></code> のロケール値を設定する場合があります。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format_map">
<code class="descclassname">str.</code><code class="descname">format_map</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format_map" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">str.format(**mapping)</span></code> と似ていますが、 <code class="docutils literal"><span class="pre">mapping</span></code> は <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>  にコピーされず、直接使われます。これは例えば <code class="docutils literal"><span class="pre">mapping</span></code> が dict のサブクラスであるときに便利です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Default</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">key</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> was born in </span><span class="si">{country}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">Default</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Guido&#39;</span><span class="p">))</span>
<span class="go">&#39;Guido was born in country&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.index">
<code class="descclassname">str.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.index" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> と同様ですが、部分文字列が見つからなかったとき <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalnum">
<code class="descclassname">str.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalnum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が英数字で、かつ 1 文字以上あるなら真を、そうでなければ偽を返します。文字 <code class="docutils literal"><span class="pre">c</span></code> は以下のいずれかが <code class="docutils literal"><span class="pre">True</span></code> を返せば英数字です: <code class="docutils literal"><span class="pre">c.isalpha()</span></code> 、 <code class="docutils literal"><span class="pre">c.isdecimal()</span></code> 、 <code class="docutils literal"><span class="pre">c.isdigit()</span></code> 、 <code class="docutils literal"><span class="pre">c.isnumeric()</span></code> 。</p>
</dd></dl>

<dl class="method">
<dt id="str.isalpha">
<code class="descclassname">str.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalpha" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が英字で、かつ 1 文字以上あるなら真を、そうでなければ偽を返します。英字は、Unicode 文字データベースで &quot;Letter&quot; として定義されているもので、すなわち、一般カテゴリプロパティ &quot;Lm&quot;、 &quot;Lt&quot;、 &quot;Lu&quot;、 &quot;Ll&quot;、 &quot;Lo&quot; のいずれかをもつものです。なお、これは Unicode 標準で定義されている &quot;Alphabetic&quot; プロパティとは異なるものです。</p>
</dd></dl>

<dl class="method">
<dt id="str.isdecimal">
<code class="descclassname">str.</code><code class="descname">isdecimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdecimal" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が十進数字で、かつ 1 文字以上あるなら真を、そうでなければ偽を返します。十進数字とは十進数を書くのに使われる文字のことで、たとえば U+0660 (ARABIC-INDIC DIGIT ZERO) なども含みます。正式には、Unicode の一般カテゴリ &quot;Nd&quot; に含まれる文字を指します。</p>
</dd></dl>

<dl class="method">
<dt id="str.isdigit">
<code class="descclassname">str.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdigit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が数字で、かつ 1 文字以上あるなら真を、そうでなければ偽を返します。ここでの数字とは、十進数字に加えて、互換上付き数字のような特殊操作を必要とする数字を含みます。また 10 を基数とした表現ができないカローシュティー数字のような体系の文字も含みます。正式には、数字とは、プロパティ値 Numeric_Type=Digit または Numeric_Type=Decimal を持つ文字です。</p>
</dd></dl>

<dl class="method">
<dt id="str.isidentifier">
<code class="descclassname">str.</code><code class="descname">isidentifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isidentifier" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が、 <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">識別子 (identifier) およびキーワード (keyword)</span></a> 節の言語定義における有効な識別子であれば真を返します。</p>
<p><a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal"><span class="pre">def</span></code></a> や <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> のような予約済みの識別子か判定するには、<a class="reference internal" href="keyword.html#keyword.iskeyword" title="keyword.iskeyword"><code class="xref py py-func docutils literal"><span class="pre">keyword.iskeyword()</span></code></a> を使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="str.islower">
<code class="descclassname">str.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.islower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の大小文字の区別のある文字 <a class="footnote-reference" href="#id15" id="id6">[4]</a> 全てが小文字で、かつ大小文字の区別のある文字が 1 文字以上あるなら真を、そうでなければ偽を返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.isnumeric">
<code class="descclassname">str.</code><code class="descname">isnumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isnumeric" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の全ての文字が数を表す文字で、かつ 1 文字以上あるなら真を、そうでなければ偽を返します。数を表す文字は、数字と、Unicode の数値プロパティを持つ全ての文字を含みます。たとえば  U+2155 (VULGAR FRACTION ONE FIFTH)。正式には、数を表す文字は、プロパティ値 Numeric_Type=Digit、 Numeric_Type=Decimal または Numeric_Type=Numeric を持つものです。</p>
</dd></dl>

<dl class="method">
<dt id="str.isprintable">
<code class="descclassname">str.</code><code class="descname">isprintable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isprintable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中のすべての文字が印字可能であるか、文字列が空であれば真を、そうでなければ偽を返します。非印字可能文字は、 Unicode 文字データベースで &quot;Other&quot; または &quot;Separator&quot; と定義されている文字の、印字可能と見なされる ASCII space (0x20) 以外のものです。(なお、この文脈での印字可能文字は、文字列に <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> が呼び出されるときにエスケープすべきでない文字のことです。これは <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> や <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a> に書き込まれる文字列の操作とは関係ありません。)</p>
</dd></dl>

<dl class="method">
<dt id="str.isspace">
<code class="descclassname">str.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isspace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が空白文字のみで構成され、かつ 1 文字以上ある場合には真を、そうでなければ偽を返します。空白文字は、Unicode 文字データベースで &quot;Other&quot; または &quot;Separator&quot; と定義されていて、双方向プロパティが &quot;WS&quot;、 &quot;B&quot;、 &quot;S&quot; のいずれかである文字です。</p>
</dd></dl>

<dl class="method">
<dt id="str.istitle">
<code class="descclassname">str.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.istitle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、例えば大文字は大小文字の区別のない文字の後にのみ続き、小文字は大小文字の区別のある文字の後ろにのみ続く場合には真を返します。そうでない場合は偽を返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.isupper">
<code class="descclassname">str.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isupper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の大小文字の区別のある文字 <a class="footnote-reference" href="#id15" id="id7">[4]</a> 全てが大文字で、かつ大小文字の区別のある文字が 1 文字以上あるなら真を、そうでなければ偽を返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.join">
<code class="descclassname">str.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#str.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> 中の文字列を結合した文字列を返します。 <em>iterable</em> に <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトのような非文字列の値が存在するなら、 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。要素間のセパレータは、このメソッドを提供する文字列です。</p>
</dd></dl>

<dl class="method">
<dt id="str.ljust">
<code class="descclassname">str.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.ljust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さ <em>width</em> の左揃えした文字列を返します。パディングは指定された <em>fillchar</em> (デフォルトでは ASCII スペース) を使って行われます。 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下ならば、元の文字列が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="str.lower">
<code class="descclassname">str.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全ての大小文字の区別のある文字 <a class="footnote-reference" href="#id15" id="id8">[4]</a> が小文字に変換された、文字列のコピーを返します。</p>
<p>使われる小文字化のアルゴリズムは Unicode Standard のセクション 3.13 に記述されています。</p>
</dd></dl>

<dl class="method">
<dt id="str.lstrip">
<code class="descclassname">str.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の先頭の文字を除去したコピーを返します。引数 <em>chars</em> は除去される文字の集合を指定する文字列です。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接頭辞ではなく、その値に含まれる文字の組み合わせ全てがはぎ取られます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example.com&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="str.maketrans">
<em class="property">static </em><code class="descclassname">str.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>x</em><span class="optional">[</span>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.maketrans" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この静的メソッドは <a class="reference internal" href="#str.translate" title="str.translate"><code class="xref py py-meth docutils literal"><span class="pre">str.translate()</span></code></a> に使える変換テーブルを返します。</p>
<p>引数を 1 つだけ与える場合、それは Unicode 序数 (整数) または文字  (長さ 1 の文字列) を、Unicode 序数、(任意長の) 文字列、または <code class="docutils literal"><span class="pre">None</span></code> に対応づける辞書でなければなりません。このとき、文字で指定したキーは序数に変換されます。</p>
<p>引数を 2 つ指定する場合、それらは同じ長さの文字列である必要があり、結果の辞書では、x のそれぞれの文字が y の同じ位置の文字に対応付けられます。第 3 引数を指定する場合、文字列を指定する必要があり、それに含まれる文字が <code class="docutils literal"><span class="pre">None</span></code> に対応付けられます。</p>
</dd></dl>

<dl class="method">
<dt id="str.partition">
<code class="descclassname">str.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.partition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> の最初の出現位置で区切り、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。もし区切れなければ、タプルには元の文字列そのものとその後ろに二つの空文字列が入ります。</p>
</dd></dl>

<dl class="method">
<dt id="str.replace">
<code class="descclassname">str.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.replace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列をコピーし、現れる部分文字列 <em>old</em> 全てを <em>new</em> に置換して返します。オプション引数 <em>count</em> が与えられている場合、先頭から <em>count</em> 個の <em>old</em> だけを置換します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rfind">
<code class="descclassname">str.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rfind" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列中の領域 <code class="docutils literal"><span class="pre">s[start:end]</span></code> に <em>sub</em> が含まれる場合、その最大のインデックスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。 <em>sub</em> が見つからなかった場合 <code class="docutils literal"><span class="pre">-1</span></code>  を返します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rindex">
<code class="descclassname">str.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rindex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#str.rfind" title="str.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a> と同様ですが、 <em>sub</em> が見つからなかった場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="str.rjust">
<code class="descclassname">str.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rjust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>width</em> の長さをもつ右寄せした文字列を返します。パディングには <em>fillchar</em> で指定された文字(デフォルトでは ASCII スペース)が使われます。 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下の場合、元の文字列が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="str.rpartition">
<code class="descclassname">str.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rpartition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> の最後の出現位置で区切り、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。もし区切れなければ、タプルには二つの空文字列とその後ろに元の文字列そのものが入ります。</p>
</dd></dl>

<dl class="method">
<dt id="str.rsplit">
<code class="descclassname">str.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rsplit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>sep</em> を区切り文字とした、文字列中の単語のリストを返します。 <em>maxsplit</em> が与えられた場合、文字列の <em>右端</em> から最大 <em>maxsplit</em> 回分割を行います。<em>sep</em> が指定されていない、あるいは <code class="docutils literal"><span class="pre">None</span></code> のとき、全ての空白文字が区切り文字となります。右から分割していくことを除けば、 <a class="reference internal" href="#str.rsplit" title="str.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a> は後ほど詳しく述べる <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> と同様に振る舞います。</p>
</dd></dl>

<dl class="method">
<dt id="str.rstrip">
<code class="descclassname">str.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の末尾部分を除去したコピーを返します。引数 <em>chars</em> は除去される文字集合を指定する文字列です。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接尾語ではなく、そこに含まれる文字の組み合わせ全てがはぎ取られます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">&#39;mississ&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.split">
<code class="descclassname">str.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.split" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を <em>sep</em> をデリミタ文字列として区切った単語のリストを返します。<em>maxsplit</em> が与えられていれば、最大で <em>maxsplit</em> 回分割されます (つまり、リストは最大 <code class="docutils literal"><span class="pre">maxsplit+1</span></code> 要素になります)。 <em>maxsplit</em> が与えられないか <code class="docutils literal"><span class="pre">-1</span></code> なら、分割の回数に制限はありません (可能なだけ分割されます)。</p>
<p><em>sep</em> が与えられた場合、連続した区切り文字はまとめられず、空の文字列を区切っていると判断されます(例えば <code class="docutils literal"><span class="pre">'1,,2'.split(',')</span></code> は <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'',</span> <span class="pre">'2']</span></code> を返します)。引数 <em>sep</em> は複数の文字にもできます (例えば <code class="docutils literal"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></code> は <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></code> を返します)。区切り文字を指定して空の文字列を分割すると、 <code class="docutils literal"><span class="pre">['']</span></code> を返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p><em>sep</em> が指定されていないか <code class="docutils literal"><span class="pre">None</span></code> の場合、異なる分割アルゴリズムが適用されます。連続する空白文字はひとつのデリミタとみなされます。また、文字列の先頭や末尾に空白があっても、結果の最初や最後に空文字列は含まれません。よって、空文字列や空白だけの文字列を <code class="docutils literal"><span class="pre">None</span></code> デリミタで分割すると <code class="docutils literal"><span class="pre">[]</span></code> が返されます。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-32"></span><dl class="method">
<dt id="str.splitlines">
<code class="descclassname">str.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>keepends</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.splitlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を改行部分で分解し、各行からなるリストを返します。 <em>keepends</em> に真が与えらない限り、返されるリストに改行は含まれません。</p>
<p>このメソッドは以下の行境界で分解します。特に、以下の境界は <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> のスーパーセットです。</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">表現</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\n</span></code></td>
<td>改行</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\r</span></code></td>
<td>復帰</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\r\n</span></code></td>
<td>改行 + 復帰</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\v</span></code> or <code class="docutils literal"><span class="pre">\x0b</span></code></td>
<td>垂直タブ</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\f</span></code> or <code class="docutils literal"><span class="pre">\x0c</span></code></td>
<td>改ページ</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1c</span></code></td>
<td>ファイル区切り</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x1d</span></code></td>
<td>グループ区切り</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1e</span></code></td>
<td>レコード区切り</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x85</span></code></td>
<td>改行 (C1 制御コード)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\u2028</span></code></td>
<td>行区切り</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\u2029</span></code></td>
<td>段落区切り</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><code class="docutils literal"><span class="pre">\v</span></code> と <code class="docutils literal"><span class="pre">\f</span></code> が行境界のリストに追加されました。</p>
</div>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;ab c&#39;, &#39;&#39;, &#39;de fg&#39;, &#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;ab c\n&#39;, &#39;\n&#39;, &#39;de fg\r&#39;, &#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p><a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> とは違って、デリミタ文字列 <em>sep</em> が与えられたとき、このメソッドは空文字列に空リストを返し、終末の改行は結果に行を追加しません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;One line&#39;]</span>
</pre></div>
</div>
<p>比較のために <code class="docutils literal"><span class="pre">split('\n')</span></code> は以下のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Two lines</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Two lines&#39;, &#39;&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.startswith">
<code class="descclassname">str.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.startswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列が指定された <em>prefix</em> で始まるなら <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。 <em>prefix</em> は見つけたい複数の接頭語のタプルでも構いません。オプションの <em>start</em> があれば、その位置から判定を始めます。オプションの <em>end</em> があれば、その位置で比較を止めます。</p>
</dd></dl>

<dl class="method">
<dt id="str.strip">
<code class="descclassname">str.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.strip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列の先頭および末尾部分を除去したコピーを返します。引数 <em>chars</em> は除去される文字集合を指定する文字列です。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、空白文字が除去されます。 <em>chars</em> 文字列は接頭語でも接尾語でもなく、そこに含まれる文字の組み合わせ全てがはぎ取られます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example&#39;</span>
</pre></div>
</div>
<p>文字列の最も外側の先頭および末尾から、引数 <em>chars</em> 値がはぎ取られます。文字列の先頭から <em>chars</em> の文字集合に含まれない文字に達するまで、文字が削除されます。文字列の末尾に対しても同様の操作が行われます。例えば、次のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span> <span class="o">=</span> <span class="s1">&#39;#....... Section 3.2.1 Issue #32 .......&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.#! &#39;</span><span class="p">)</span>
<span class="go">&#39;Section 3.2.1 Issue #32&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.swapcase">
<code class="descclassname">str.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.swapcase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>大文字が小文字に、小文字が大文字に変換された、文字列のコピーを返します。なお、 <code class="docutils literal"><span class="pre">s.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">s</span></code> が真であるとは限りません。</p>
</dd></dl>

<dl class="method">
<dt id="str.title">
<code class="descclassname">str.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.title" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>文字列を、単語ごとに大文字から始まり、残りの文字のうち大小文字の区別があるものは全て小文字にする、タイトルケースにして返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>このアルゴリズムは、連続した文字の集まりという、言語から独立した単純な単語の定義を使います。この定義は多くの状況ではうまく機能しますが、短縮形や所有格のアポストロフィが単語の境界になってしまい、望みの結果を得られない場合があります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>正規表現を使うことでアポストロフィに対応できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.translate">
<code class="descclassname">str.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#str.translate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた変換テーブルに基づいて文字列を構成する各文字をマッピングし、マッピング後の文字列のコピーを返します。変換テーブルは、<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> によるインデックス指定を実装するオブジェクトである必要があります。一般的には、 <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> または <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> です。Unicode 序数 (整数) でインデックス指定する場合、変換テーブルのオブジェクトは次のいずれも行うことができます。Unicode 序数または文字列を返して文字を 1 文字以上の別の文字にマッピングすること、<code class="docutils literal"><span class="pre">None</span></code> を返して返り値の文字列から指定した文字を削除すること、例外 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出して文字をその文字自身にマッピングすること。</p>
<p>文字から文字への異なる形式のマッピングから変換マップを作成するために、 <a class="reference internal" href="#str.maketrans" title="str.maketrans"><code class="xref py py-meth docutils literal"><span class="pre">str.maketrans()</span></code></a> が使えます。</p>
<p>文字のマッピングを好みに合わせてより柔軟に変更する方法については、<a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュールも参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="str.upper">
<code class="descclassname">str.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.upper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a copy of the string with all the cased characters <a class="footnote-reference" href="#id15" id="id9">[4]</a> converted to
uppercase.  Note that <code class="docutils literal"><span class="pre">str.upper().isupper()</span></code> might be <code class="docutils literal"><span class="pre">False</span></code> if <code class="docutils literal"><span class="pre">s</span></code>
contains uncased characters or if the Unicode category of the resulting
character(s) is not &quot;Lu&quot; (Letter, uppercase), but e.g. &quot;Lt&quot; (Letter,
titlecase).</p>
<p>使われる大文字化のアルゴリズムは Unicode Standard のセクション 3.13 に記述されています。</p>
</dd></dl>

<dl class="method">
<dt id="str.zfill">
<code class="descclassname">str.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#str.zfill" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さが <em>width</em> になるよう ASCII <code class="docutils literal"><span class="pre">'0'</span></code> で左詰めした文字列のコピーを返します。先頭が符号接頭辞 (<code class="docutils literal"><span class="pre">'+'</span></code>/<code class="docutils literal"><span class="pre">'-'</span></code>) だった場合、 <code class="docutils literal"><span class="pre">'0'</span></code> は符号の前ではなく <em>後</em> に挿入されます。<em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下の場合元の文字列を返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;-0042&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-string-formatting">
<span id="old-string-formatting"></span><h3>4.7.2. <code class="docutils literal"><span class="pre">printf</span></code> 形式の文字列書式化<a class="headerlink" href="#printf-style-string-formatting" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="admonition note" id="index-33">
<p class="first admonition-title">注釈</p>
<p class="last">ここで述べる書式化演算には様々な癖があり、よく間違いの元になっています (タプルや辞書を正しく表示できないなど)。新しい <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">フォーマット文字列リテラル</span></a> や <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> インタフェースの方が間違いにくく、より強力で、柔軟で、さらに拡張可能です。</p>
</div>
<p>文字列オブジェクトには固有の操作: <code class="docutils literal"><span class="pre">%</span></code> 演算子 (モジュロ) があります。この演算子は文字列 <em>書式化</em> または <em>補間</em> 演算子とも呼ばれます。<code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> (<em>format</em> は文字列) とすると、<em>format</em> 中の <code class="docutils literal"><span class="pre">%</span></code> 変換指定は <em>values</em> 中のゼロ個またはそれ以上の要素で置換されます。この動作は C 言語における <code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code> に似ています。</p>
<p><em>format</em> が単一の引数しか要求しない場合、 <em>values</em> はタプルでない単一のオブジェクトでもかまいません。 <a class="footnote-reference" href="#id16" id="id10">[5]</a> それ以外の場合、 <em>values</em> はフォーマット文字列中で指定された項目と正確に同じ数の要素からなるタプルか、単一のマップオブジェクトでなければなりません。</p>
<p>一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は以下からなりますが、示した順に出現しなければなりません:</p>
<ol class="arabic simple">
<li>指定子の開始を示す文字 <code class="docutils literal"><span class="pre">'%'</span></code> 。</li>
<li>マップキー (オプション)。丸括弧で囲った文字列からなります (例えば <code class="docutils literal"><span class="pre">(somename)</span></code>) 。</li>
<li>変換フラグ (オプション)。一部の変換型の結果に影響します。</li>
<li>最小のフィールド幅 (オプション)。 <code class="docutils literal"><span class="pre">'*'</span></code> (アスタリスク) を指定した場合、実際の文字列幅が <em>values</em> タプルの次の要素から読み出されます。タプルには最小フィールド幅やオプションの精度指定の後に変換したいオブジェクトがくるようにします。</li>
<li>精度 (オプション)。 <code class="docutils literal"><span class="pre">'.'</span></code> (ドット) とその後に続く精度で与えられます。 <code class="docutils literal"><span class="pre">'*'</span></code> (アスタリスク) を指定した場合、精度の桁数は <em>values</em> タプルの次の要素から読み出されます。タプルには精度指定の後に変換したい値がくるようにします。</li>
<li>精度長変換子 (オプション)。</li>
<li>変換型。</li>
</ol>
<p><code class="docutils literal"><span class="pre">%</span></code> 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合), 文字列中のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字 <code class="docutils literal"><span class="pre">'%'</span></code> の直後にくるようにしたものが含まれていなければ <em>なりません</em> 。マップキーはフォーマット化したい値をマップから選び出します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">Python has 002 quote types.</span>
</pre></div>
</div>
<p>この場合、 <code class="docutils literal"><span class="pre">*</span></code> 指定子をフォーマットに含めてはいけません (<code class="docutils literal"><span class="pre">*</span></code> 指定子は順番付けされたパラメタのリストが必要だからです)。</p>
<p>変換フラグ文字を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Flag</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'#'</span></code></td>
<td>値の変換に (下で定義されている) &quot;別の形式&quot; を使います。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'0'</span></code></td>
<td>数値型に対してゼロによるパディングを行います。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'-'</span></code></td>
<td>変換された値を左寄せにします (<code class="docutils literal"><span class="pre">'0'</span></code> と同時に与えた場合、 <code class="docutils literal"><span class="pre">'0'</span></code> を上書きします) 。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます (そうでない場合は空文字になります) 。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td>変換の先頭に符号文字 (<code class="docutils literal"><span class="pre">'+'</span></code> または <code class="docutils literal"><span class="pre">'-'</span></code>) を付けます(&quot;スペース&quot; フラグを上書きします) 。</td>
</tr>
</tbody>
</table>
<p>精度長変換子(<code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">l</span></code>,または <code class="docutils literal"><span class="pre">L</span></code>) を使うことができますが、 Python では必要ないため無視されます。 – つまり、例えば <code class="docutils literal"><span class="pre">%ld</span></code> は <code class="docutils literal"><span class="pre">%d</span></code> と等価です。</p>
<p>変換型を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">変換</th>
<th class="head">意味</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'d'</span></code></td>
<td>符号付き 10 進整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'i'</span></code></td>
<td>符号付き 10 進整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'o'</span></code></td>
<td>符号付き 8 進数。</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'u'</span></code></td>
<td>旧式の型 – <code class="docutils literal"><span class="pre">'d'</span></code> と同じです。</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td>符号付き 16 進数 (小文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'X'</span></code></td>
<td>符号付き 16 進数 (大文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'e'</span></code></td>
<td>指数表記の浮動小数点数 (小文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'E'</span></code></td>
<td>指数表記の浮動小数点数 (大文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'f'</span></code></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'F'</span></code></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'g'</span></code></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には小文字指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'G'</span></code></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には大文字指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'c'</span></code></td>
<td>文字一文字 (整数または一文字からなる文字列を受理します)。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td>文字列 (Python オブジェクトを <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> で変換します)。</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'s'</span></code></td>
<td>文字列 (Python オブジェクトを <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> で変換します)。</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'a'</span></code></td>
<td>文字列 (Python オブジェクトを <a class="reference internal" href="functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal"><span class="pre">ascii()</span></code></a> で変換します)。</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'%'</span></code></td>
<td>引数を変換せず、返される文字列中では文字 <code class="docutils literal"><span class="pre">'%'</span></code> になります。</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic">
<li><p class="first">別の形式を指定（訳注: 変換フラグ <code class="docutils literal"><span class="pre">#</span></code> を使用）すると 8 進数を表す接頭辞 (<code class="docutils literal"><span class="pre">'0o'</span></code>) が最初の数字の前に挿入されます。</p>
</li>
<li><p class="first">別の形式を指定（訳注: 変換フラグ <code class="docutils literal"><span class="pre">#</span></code> を使用）すると 16 進数を表す接頭辞 <code class="docutils literal"><span class="pre">'0x'</span></code> または <code class="docutils literal"><span class="pre">'0X'</span></code> (使用するフォーマット文字が <code class="docutils literal"><span class="pre">'x'</span></code> か <code class="docutils literal"><span class="pre">'X'</span></code> に依存します) が最初の数字の前に挿入されます。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ、それはその後ろに数字が続かない場合にも適用されます。</p>
<p>指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ他の形式とは違って末尾の 0 は取り除かれません。</p>
<p>指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first">精度が <code class="docutils literal"><span class="pre">N</span></code> なら、出力は <code class="docutils literal"><span class="pre">N</span></code> 文字に切り詰められます。</p>
</li>
<li><p class="first"><span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> を参照してください。</p>
</li>
</ol>
<p>Python 文字列には明示的な長さ情報があるので、 <code class="docutils literal"><span class="pre">%s</span></code> 変換において <code class="docutils literal"><span class="pre">'\0'</span></code> を文字列の末端と仮定したりはしません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.1 で変更: </span>絶対値が 1e50 を超える数値の <code class="docutils literal"><span class="pre">%f</span></code> 変換が <code class="docutils literal"><span class="pre">%g</span></code> 変換に置き換えられなくなりました。</p>
</div>
</div>
</div>
<div class="section" id="binary-sequence-types-bytes-bytearray-memoryview">
<span id="binaryseq"></span><span id="index-35"></span><h2>4.8. バイナリシーケンス型 — <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a><a class="headerlink" href="#binary-sequence-types-bytes-bytearray-memoryview" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-36">バイナリデータを操作するためのコア組み込み型は <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> および <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> です。これらは、別のバイナリオブジェクトのメモリにコピーを作成すること無くアクセスするための <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">バッファプロトコル</span></a> を利用する <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> でサポートされています。</p>
<p><a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> モジュールは、32 ビット整数や IEEE754 倍精度浮動小数点値のような基本データ型の、効率的な保存をサポートしています。</p>
<div class="section" id="bytes-objects">
<span id="typebytes"></span><h3>4.8.1. バイトオブジェクト<a class="headerlink" href="#bytes-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-37">bytes はバイトの不変なシーケンスです。多くのメジャーなプロトコルがASCIIテキストエンコーディングをベースにしているので、 bytes オブジェクトは ASCII 互換のデータに対してのみ動作する幾つかのメソッドを提供していて、文字列オブジェクトと他の多くの点で近いです。</p>
<dl class="class">
<dt id="bytes">
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>まず、 bytes リテラルの構文は文字列リテラルとほぼ同じで、 <code class="docutils literal"><span class="pre">b</span></code> というプリフィックスを付けます:</p>
<ul class="simple">
<li>シングルクォート: <code class="docutils literal"><span class="pre">b'still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">&quot;double&quot;</span> <span class="pre">quotes'</span></code></li>
<li>ダブルクォート: <code class="docutils literal"><span class="pre">b&quot;still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">'single'</span> <span class="pre">quotes&quot;</span></code>.</li>
<li>3重クォート: <code class="docutils literal"><span class="pre">b'''3</span> <span class="pre">single</span> <span class="pre">quotes'''</span></code>, <code class="docutils literal"><span class="pre">b&quot;&quot;&quot;3</span> <span class="pre">double</span> <span class="pre">quotes&quot;&quot;&quot;</span></code></li>
</ul>
<p>bytes リテラルでは (ソースコードのエンコーディングに関係なく) ASCII文字のみが許可されています。 127より大きい値を bytes リテラルに記述する場合は適切なエスケープシーケンスを書く必要があります。</p>
<p>文字列リテラルと同じく、 bytes リテラルでも <code class="docutils literal"><span class="pre">r</span></code> プリフィックスを用いてエスケープシーケンスの処理を無効にすることができます。 bytes リテラルの様々な形式やサポートされているエスケープシーケンスについては <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">文字列およびバイト列リテラル</span></a> を参照してください。</p>
<p>bytesリテラルと repr 出力は ASCII テキストをベースにしたものですが、 bytes オブジェクトは、各値が <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> の範囲に収まるような整数  (この制限に違反しようとすると <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が発生します) の不変なシーケンスとして振る舞います。多くのバイナリフォーマットがASCIIテキストを元にした要素を持っていたり何らかのテキスト操作アルゴリズムによって操作されるものの、任意のバイナリデータが一般にテキストになっているわけではないことを強調するためにこのように設計されました (何も考えずにテキスト操作アルゴリズムをASCII非互換なバイナリデータフォーマットに対して行うとデータを破壊することがあります)。</p>
<p>リテラル以外に、幾つかの方法で bytes オブジェクトを作ることができます:</p>
<ul class="simple">
<li>指定された長さの、0で埋められた bytes オブジェクト: <code class="docutils literal"><span class="pre">bytes(10)</span></code></li>
<li>整数の iterable から: <code class="docutils literal"><span class="pre">bytes(range(20))</span></code></li>
<li>既存のバイナリデータからバッファプロトコルでコピーする: <code class="docutils literal"><span class="pre">bytes(obj)</span></code></li>
</ul>
<p><a class="reference internal" href="functions.html#func-bytes"><span class="std std-ref">bytes</span></a> ビルトイン関数も参照してください。</p>
<p>16 進数で 2 桁の数は正確に 1 バイトに相当するため、16 進整はバイナリデータを表現する形式として広く使われています。 従って、 bytes 型にはその形式でデータを読み取るための追加のクラスメソッドがあります。</p>
<dl class="classmethod">
<dt id="bytes.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.fromhex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> のクラスメソッドは、与えられた文字列オブジェクトをデコードして bytes オブジェクトを返します。それぞれのバイトを 16 進数 2 桁で表現した文字列を指定しなければなりません。ASCII 空白文字は無視されます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">b&#39;.\xf0\xf1\xf2&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>bytes オブジェクトをその 16 進表記に変換するための、反対向きの変換関数があります。</p>
<dl class="method">
<dt id="bytes.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インスタンス内の 1 バイトにつき 2 つの 16 進数を含む、文字列オブジェクトを返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>bytes オブジェクトは (タプルに似た) 整数のシーケンスなので、 bytes オブジェクト <em>b</em> について、 <code class="docutils literal"><span class="pre">b[0]</span></code> は整数になり、 <code class="docutils literal"><span class="pre">b[0:1]</span></code> は長さ 1 の bytes オブジェクトになります。 (この動作は、文字列に対するインデックス指定もスライスも長さ 1 の文字列を返すのと対照的です。)</p>
<p>bytes オブジェクトの repr 出力はリテラル形式 (<code class="docutils literal"><span class="pre">b'...'</span></code>) になります。 <code class="docutils literal"><span class="pre">bytes([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> などの形式よりも便利な事が多いからです。 bytes オブジェクトはいつでも <code class="docutils literal"><span class="pre">list(b)</span></code> で整数のリストに変換できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Python 2.x ユーザーへ: Python 2.x では多くの場面で 8bit 文字列 (2.x が提供しているビルトインのバイナリデータ型) と Unicode 文字列の間の暗黙の変換が許可されていました。これは Python がもともと 8bit 文字列しか持っていなくて、あとから Unicode テキストが追加されたので、後方互換性を維持するためのワークアラウンドでした。 Python 3.x ではこれらの暗黙の変換はなくなりました。 8-bit バイナリデータと Unicode テキストは明確に違うもので、 bytes オブジェクトと文字列オブジェクトを比較すると常に等しくなりません。</p>
</div>
</div>
<div class="section" id="bytearray-objects">
<span id="typebytearray"></span><h3>4.8.2. bytearray オブジェクト<a class="headerlink" href="#bytearray-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-38"><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> オブジェクトは <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトの可変なバージョンです。</p>
<dl class="class">
<dt id="bytearray">
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>bytearray に専用のリテラル構文はないので、コンストラクタを使って作成します:</p>
<ul class="simple">
<li>空のインスタンスを作る: <code class="docutils literal"><span class="pre">bytearray()</span></code></li>
<li>指定された長さの0で埋められたインスタンスを作る: <code class="docutils literal"><span class="pre">bytearray(10)</span></code></li>
<li>整数の iterable から: <code class="docutils literal"><span class="pre">bytearray(range(20))</span></code></li>
<li>既存のバイナリデータからバッファプロトコルを通してコピーする: <code class="docutils literal"><span class="pre">bytearray(b'Hi!')</span></code></li>
</ul>
<p>bytearray オブジェクトは可変なので、 <a class="reference internal" href="#bytes-methods"><span class="std std-ref">bytes と bytearray の操作</span></a> で解説されている bytes オブジェクトと共通の操作に加えて、 <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">mutable</span></a> シーケンス操作もサポートしています。</p>
<p><a class="reference internal" href="functions.html#func-bytearray"><span class="std std-ref">bytearray</span></a> ビルトイン関数も参照してください。</p>
<p>16 進数で 2 桁の数は正確に 1 バイトに相当するため、16 進整はバイナリデータを表現する形式として広く使われています。 従って、 bytearray 型にはその形式でデータを読み取るための追加のクラスメソッドがあります。</p>
<dl class="classmethod">
<dt id="bytearray.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.fromhex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> のクラスメソッドは、与えられた文字列オブジェクトをデコードして bytearray オブジェクトを返します。それぞれのバイトを 16 進数 2 桁で表現した文字列を指定しなければなりません。ASCII 空白文字は無視されます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">bytearray(b&#39;.\xf0\xf1\xf2&#39;)</span>
</pre></div>
</div>
</dd></dl>

<p>bytearray オブジェクトをその 16 進表記に変換するための、反対向きの変換関数があります。</p>
<dl class="method">
<dt id="bytearray.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インスタンス内の 1 バイトにつき 2 つの 16 進数を含む、文字列オブジェクトを返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>bytearray オブジェクトは整数のシーケンス (リストのようなもの) なので、 bytearray オブジェクト <em>b</em> について、 <code class="docutils literal"><span class="pre">b[0]</span></code> は整数になり、 <code class="docutils literal"><span class="pre">b[0:1]</span></code> は長さ 1 の bytearray オブジェクトになります。(これは、文字列においてインデックス指定もスライスも長さ 1 の文字列を返すのと対照的です。)</p>
<p>bytearray オブジェクトの表記はバイトのリテラル形式 (<code class="docutils literal"><span class="pre">bytearray(b'...')</span></code>) を使用します。これは <code class="docutils literal"><span class="pre">bytearray([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> などの形式よりも便利な事が多いためです。
bytearray オブジェクトはいつでも <code class="docutils literal"><span class="pre">list(b)</span></code> で整数のリストに変換できます。</p>
</div>
<div class="section" id="bytes-and-bytearray-operations">
<span id="bytes-methods"></span><h3>4.8.3. bytes と bytearray の操作<a class="headerlink" href="#bytes-and-bytearray-operations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-39">bytes と bytearray は両方共 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">一般のシーケンス操作</span></a> をサポートしています。また、両方とも <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> をサポートしている任意のオブジェクトを対象に操作することもできます。この柔軟性により bytes と bytearray を自由に混ぜてもエラーを起こすことなく扱うことができます。ただし、操作の結果のオブジェクトはその操作の順序に依存することになります。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>文字列のメソッドが引数として bytes を受け付けないのと同様、bytes オブジェクトと bytearray オブジェクトのメソッドは引数として文字列を受け付けません。例えば、以下のように書かなければなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>および:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>いくつかの bytes と bytearray の操作は ASCII と互換性のあるバイナリフォーマットが使われていると仮定していますので、フォーマットの不明なバイナリデータに対して使うことは避けるべきです。こうした制約については以下で説明します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">これらの ASCII ベースの演算を使って ASCII ベースではないバイナリデータを操作すると、データを破壊する恐れがあります。</p>
</div>
<p>以下の bytes および bytearray オブジェクトのメソッドは、任意のバイナリデータに対して使用できます。</p>
<dl class="method">
<dt id="bytes.count">
<code class="descclassname">bytes.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.count" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.count">
<code class="descclassname">bytearray.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.count" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>[<em>start</em>, <em>end</em>] の範囲に、部分シーケンス <em>sub</em> が重複せず出現する回数を返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同じように解釈されます。</p>
<p>検索対象の部分シーケンスは、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> または  0 から 255 の範囲の整数にできます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>部分シーケンスとして 0 から 255 の範囲の整数も受け取れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.decode">
<code class="descclassname">bytes.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.decode" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.decode">
<code class="descclassname">bytearray.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.decode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたバイト列からデコードされた文字列を返します。デフォルトのエンコーディングは <code class="docutils literal"><span class="pre">'utf-8'</span></code> です。 <em>errors</em> を与えて異なるエラー処理法を設定できます。 <em>errors</em> のデフォルトは <code class="docutils literal"><span class="pre">'strict'</span></code> で、エンコーディングエラーが <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> を送出します。設定できる他の値は、 <code class="docutils literal"><span class="pre">'ignore'</span></code> 、 <code class="docutils literal"><span class="pre">'replace'</span></code> 、その他の <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> を通して登録された名前で、節 <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">エラーハンドラ</span></a> を参照してください。可能なエンコーディングのリストは、 <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">標準エンコーディング</span></a> を参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">引数 <em>encoding</em> を <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> に渡すと <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を直接デコードすることができます。つまり、一時的な bytes や bytearray オブジェクトを作成する必要はありません。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.1 で変更: </span>キーワード引数のサポートが追加されました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.endswith">
<code class="descclassname">bytes.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.endswith" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.endswith">
<code class="descclassname">bytearray.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.endswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バイナリデータが指定された <em>suffix</em> で終わる場合は <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。 <em>suffix</em> は見つけたい複数の接尾語のタプルでも構いません。オプションの <em>start</em> が指定されている場合、その位置から判定を開始します。オプションの <em>end</em> が指定されている場合、その位置で比較を終了します。</p>
<p>検索対象の接尾語 (複数も可) は、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> にできます。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.find">
<code class="descclassname">bytes.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.find" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.find">
<code class="descclassname">bytearray.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.find" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>スライス <code class="docutils literal"><span class="pre">s[start:end]</span></code> に部分シーケンス <em>sub</em> が含まれる場合、データ中のその <em>sub</em> の最小のインデックスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。 <em>sub</em> が見つからなかった場合、 <code class="docutils literal"><span class="pre">-1</span></code> を返します。</p>
<p>検索対象の部分シーケンスは、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> または  0 から 255 の範囲の整数にできます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p><a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> メソッドは、 <em>sub</em> の位置を知りたいときにのみ使うべきです。 <em>sub</em> が部分文字列 (訳注: おそらく原文の誤り、正しくは部分シーケンス) であるかどうかのみを調べるには、 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 演算子を使ってください:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="sa">b</span><span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>部分シーケンスとして 0 から 255 の範囲の整数も受け取れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.index">
<code class="descclassname">bytes.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.index" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.index">
<code class="descclassname">bytearray.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.index" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> と同様ですが、部分シーケンスが見つからなかった場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<p>検索対象の部分シーケンスは、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> または  0 から 255 の範囲の整数にできます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>部分シーケンスとして 0 から 255 の範囲の整数も受け取れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.join">
<code class="descclassname">bytes.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.join" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.join">
<code class="descclassname">bytearray.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.join" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> 中のバイナリデータを結合した bytes または bytearray オブジェクトを返します。 <em>iterable</em> に <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> オブジェクトなど <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> ではない値が含まれている場合、 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。なお要素間のセパレータは、このメソッドを提供する bytes または bytearray オブジェクトとなります。</p>
</dd></dl>

<dl class="staticmethod">
<dt id="bytes.maketrans">
<em class="property">static </em><code class="descclassname">bytes.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.maketrans" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.maketrans">
<em class="property">static </em><code class="descclassname">bytearray.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.maketrans" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この静的メソッドは、 <a class="reference internal" href="#bytes.translate" title="bytes.translate"><code class="xref py py-func docutils literal"><span class="pre">bytes.translate()</span></code></a> に渡すのに適した変換テーブルを返します。このテーブルは、 <em>from</em> 中の各バイトを <em>to</em> の同じ位置にあるバイトにマッピングします。 <em>from</em> と <em>to</em> は両方とも同じ長さの <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a> でなければなりません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.partition">
<code class="descclassname">bytes.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.partition" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.partition">
<code class="descclassname">bytearray.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.partition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>区切り <em>sep</em> が最初に出現する位置でシーケンスを分割し、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、その区切りオブジェクトまたはその bytearray 型のコピー、そして区切りの後ろの部分です。もし区切れなければ、タプルには元のシーケンスのコピーと、その後ろに二つの空の bytes または bytearray オブジェクトが入ります。</p>
<p>検索する区切りとしては、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を指定できます。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.replace">
<code class="descclassname">bytes.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.replace" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.replace">
<code class="descclassname">bytearray.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.replace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>部分シーケンス <em>old</em> を全て <em>new</em> に置換したシーケンスを返します。オプション引数 <em>count</em> が与えられている場合、先頭から <em>count</em> 個の <em>old</em> だけを置換します。</p>
<p>検索する部分シーケンスおよび置換後の部分シーケンスとしては、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を指定できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rfind">
<code class="descclassname">bytes.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rfind" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.rfind">
<code class="descclassname">bytearray.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rfind" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンス中の領域 <code class="docutils literal"><span class="pre">s[start:end]</span></code> に <em>sub</em> が含まれる場合、その最大のインデックスを返します。オプション引数 <em>start</em> および <em>end</em> はスライス表記と同様に解釈されます。 <em>sub</em> が見つからなかった場合 <code class="docutils literal"><span class="pre">-1</span></code>  を返します。</p>
<p>検索対象の部分シーケンスは、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> または  0 から 255 の範囲の整数にできます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>部分シーケンスとして 0 から 255 の範囲の整数も受け取れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rindex">
<code class="descclassname">bytes.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rindex" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.rindex">
<code class="descclassname">bytearray.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rindex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#bytes.rfind" title="bytes.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a> と同様ですが、部分シーケンス <em>sub</em> が見つからなかった場合 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<p>検索対象の部分シーケンスは、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> または  0 から 255 の範囲の整数にできます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>部分シーケンスとして 0 から 255 の範囲の整数も受け取れるようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rpartition">
<code class="descclassname">bytes.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rpartition" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.rpartition">
<code class="descclassname">bytearray.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rpartition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>区切り <em>sep</em> が最後に出現する位置でシーケンスを分割し、 3 要素のタプルを返します。タプルの内容は、区切りの前の部分、その区切りオブジェクトまたはその bytearray 型のコピー、そして区切りの後ろの部分です。もし区切れなければ、タプルには元のシーケンスのコピーと、その後ろに二つの空の bytes または bytearray オブジェクトが入ります。</p>
<p>検索する区切りとしては、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を指定できます。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.startswith">
<code class="descclassname">bytes.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.startswith" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.startswith">
<code class="descclassname">bytearray.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.startswith" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バイナリデータが指定された <em>prefix</em> で始まる場合は <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> を返します。 <em>prefix</em> は見つけたい複数の接頭語のタプルでも構いません。オプションの <em>start</em> が指定されている場合、その位置から判定を開始します。オプションの <em>end</em> が指定されている場合、その位置で比較を終了します。</p>
<p>検索対象の接頭語 (複数も可) は、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> にできます。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.translate">
<code class="descclassname">bytes.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.translate" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.translate">
<code class="descclassname">bytearray.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.translate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプション引数 <em>delete</em> に現れるすべてのバイトを除去し、残ったバイトを与えられた変換テーブルに従ってマップした、バイト列やバイト配列オブジェクトのコピーを返します。変換テーブルは長さ 256 のバイト列オブジェクトでなければなりません。</p>
<p>変換テーブルの作成に、 <a class="reference internal" href="#bytes.maketrans" title="bytes.maketrans"><code class="xref py py-func docutils literal"><span class="pre">bytes.maketrans()</span></code></a> メソッドを使うこともできます。</p>
<p>文字を削除するだけの変換には、 <em>table</em> 引数を <code class="docutils literal"><span class="pre">None</span></code> に設定してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;read this short text&#39;</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;aeiou&#39;</span><span class="p">)</span>
<span class="go">b&#39;rd ths shrt txt&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><em>delete</em> はキーワード引数として指定可能になりました。</p>
</div>
</dd></dl>

<p>以下の bytes および bytearray オブジェクトのメソッドは、 ASCII と互換性のあるバイナリフォーマットが使われていると仮定していますが、適切な引数を指定すれば任意のバイナリデータに使用できます。なお、このセクションで紹介する bytearray のメソッドはすべてインプレースで動作 <em>せず</em> 、新しいオブジェクトを生成します。</p>
<dl class="method">
<dt id="bytes.center">
<code class="descclassname">bytes.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.center" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.center">
<code class="descclassname">bytearray.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.center" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さ <em>width</em> の中央寄せされたシーケンスのコピーを返します。パディングには <em>fillbyte</em> で指定された値 (デフォルトでは ASCII スペース) が使われます。 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトの場合、 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下なら元のシーケンスが返されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.ljust">
<code class="descclassname">bytes.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.ljust" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.ljust">
<code class="descclassname">bytearray.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.ljust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さ <em>width</em> の左寄せされたシーケンスのコピーを返します。パディングには <em>fillbyte</em> で指定された値 (デフォルトでは ASCII スペース) が使われます。 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトの場合、 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下なら元のシーケンスが返されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.lstrip">
<code class="descclassname">bytes.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lstrip" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.lstrip">
<code class="descclassname">bytearray.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>先頭から特定のバイト値を除去したコピーを返します。引数 <em>chars</em> は除去されるバイト値の集合を指定するバイナリシーケンスです － この名前は、このメソッドが通常は ASCII 文字列に対して使われることに由来しています。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、 ASCII の空白文字（訳注: 半角スペース）が除去されます。なお <em>chars</em> 引数と一致する接頭辞が除去されるのではなく、それに含まれるバイトの組み合わせ全てが除去されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">b&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example.com&#39;</span>
</pre></div>
</div>
<p>除去対象のバイト値を含むバイナリシーケンスには、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を指定できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rjust">
<code class="descclassname">bytes.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rjust" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.rjust">
<code class="descclassname">bytearray.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rjust" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さ <em>width</em> の右寄せされたシーケンスのコピーを返します。パディングには <em>fillbyte</em> で指定された値 (デフォルトでは ASCII スペース) が使われます。 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトの場合、 <em>width</em> が <code class="docutils literal"><span class="pre">len(s)</span></code> 以下なら元のシーケンスが返されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rsplit">
<code class="descclassname">bytes.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rsplit" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.rsplit">
<code class="descclassname">bytearray.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rsplit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>sep</em> を区切りとして、同じ型の部分シーケンスに分割します。 <em>maxsplit</em> が与えられた場合、シーケンスの <em>右端</em> から最大 <em>maxsplit</em> 回だけ分割を行います。 <em>sep</em> が指定されていないか <code class="docutils literal"><span class="pre">None</span></code> のとき、 ASCII 空白文字の組み合わせで作られる部分シーケンスすべてが区切りとなります。右から分割していくことを除けば、 <a class="reference internal" href="#bytearray.rsplit" title="bytearray.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a> は後ほど詳しく述べる <a class="reference internal" href="#bytearray.split" title="bytearray.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> と同様に振る舞います。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.rstrip">
<code class="descclassname">bytes.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rstrip" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.rstrip">
<code class="descclassname">bytearray.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rstrip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>末尾から特定のバイト値を除去したコピーを返します。引数 <em>chars</em> は除去されるバイト値の集合を指定するバイナリシーケンスです － この名前は、このメソッドが通常は ASCII 文字列に対して使われることに由来しています。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、 ASCII の空白文字（訳注: 半角スペース）が除去されます。なお <em>chars</em> 引数と一致する接尾辞が除去されるのではなく、それに含まれるバイトの組み合わせ全てが除去されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">b&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">b&#39;mississ&#39;</span>
</pre></div>
</div>
<p>除去対象のバイト値を含むバイナリシーケンスには、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を指定できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.split">
<code class="descclassname">bytes.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.split" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.split">
<code class="descclassname">bytearray.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.split" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>sep</em> を区切りとして、同じ型の部分シーケンスに分割します。 <em>maxsplit</em> が与えられ、かつ負の数でない場合、シーケンスの <em>左端</em> から最大 <em>maxsplit</em> 回だけ分割を行います (したがって結果のリストの要素数は最大で <code class="docutils literal"><span class="pre">maxsplit+1</span></code> になります)。 <em>maxsplit</em> が指定されていないか <code class="docutils literal"><span class="pre">-1</span></code> のとき、分割の回数に制限はありません (可能なだけ分割されます)。</p>
<p><em>sep</em> が与えられた場合、連続した区切り用バイト値はまとめられず、空の部分シーケンスを区切っていると判断されます(例えば <code class="docutils literal"><span class="pre">b'1,,2'.split(b',')</span></code> は <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'',</span> <span class="pre">b'2']</span></code> を返します)。引数 <em>sep</em> は複数バイトのシーケンスにもできます (例えば <code class="docutils literal"><span class="pre">b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</span></code> は <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'2',</span> <span class="pre">b'3']</span></code> を返します)。空のシーケンスを分割すると、分割するオブジェクトの型によって <code class="docutils literal"><span class="pre">[b'']</span></code> または <code class="docutils literal"><span class="pre">[bytearray(b'')]</span></code> が返ります。引数 <em>sep</em> には、あらゆる <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を指定できます。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;&#39;, b&#39;3&#39;, b&#39;&#39;]</span>
</pre></div>
</div>
<p><em>sep</em> が指定されていないか <code class="docutils literal"><span class="pre">None</span></code> の場合、異なる分割アルゴリズムが適用されます。連続する ASCII 空白文字はひとつの区切りとみなされ、またシーケンスの先頭や末尾に空白があっても、結果の最初や最後に空のシーケンスは含まれません。したがって区切りを指定せずに空のシーケンスや ASCII 空白文字だけのシーケンスを分割すると、 <code class="docutils literal"><span class="pre">[]</span></code> が返されます。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.strip">
<code class="descclassname">bytes.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.strip" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.strip">
<code class="descclassname">bytearray.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.strip" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>先頭および末尾から特定のバイト値を除去したコピーを返します。引数 <em>chars</em> は除去されるバイト値の集合を指定するバイナリシーケンスです － この名前は、このメソッドが通常は ASCII 文字列に対して使われることに由来しています。 <em>chars</em> が省略されるか <code class="docutils literal"><span class="pre">None</span></code> の場合、 ASCII の空白文字（訳注: 半角スペース）が除去されます。なお <em>chars</em> 引数と一致する接頭辞および接尾辞が除去されるのではなく、それに含まれるバイトの組み合わせ全てが除去されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">b&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example&#39;</span>
</pre></div>
</div>
<p>除去対象のバイト値を含むバイナリシーケンスには、任意の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を指定できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<p>以下の bytes および bytearray オブジェクトのメソッドは、 ASCII と互換性のあるバイナリフォーマットが使われていると仮定しており、任意のバイナリデータに対して使用すべきではありません。なお、このセクションで紹介する bytearray のメソッドはすべてインプレースで動作 <em>せず</em> 、新しいオブジェクトを生成します。</p>
<dl class="method">
<dt id="bytes.capitalize">
<code class="descclassname">bytes.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.capitalize" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.capitalize">
<code class="descclassname">bytearray.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.capitalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>各バイトを ASCII 文字と解釈して、最初のバイトを大文字にし、残りを小文字にしたシーケンスのコピーを返します。 ASCII 文字と解釈できないバイト値は、変更されません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.expandtabs">
<code class="descclassname">bytes.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.expandtabs" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.expandtabs">
<code class="descclassname">bytearray.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.expandtabs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>桁 (column) 位置と指定されたタブ幅 (tab size) に応じて、全ての ASCII タブ文字を 1 つ以上の ASCII スペース文字に置換したシーケンスのコピーを返します。ここで <em>tabsize</em> バイトごとの桁位置をタブ位置とします (デフォルト値である 8 の場合、タブ位置は 0 桁目、 8 桁目、 16 桁目、と続いていきます)。シーケンスを展開するにあたって、まず現桁位置をゼロに設定し、シーケンスを 1 バイトずつ調べていきます。もしバイト値が ASCII タブ文字 (<code class="docutils literal"><span class="pre">b'\t'</span></code>) であれば、現桁位置が次のタブ位置と一致するまで 1 つ以上の ASCII スペース文字を結果のシーケンスに挿入していきます（ASCII タブ文字自体はコピーしません）。もしバイト値が ASCII 改行文字 (<code class="docutils literal"><span class="pre">b'\n'</span></code> もしくは <code class="docutils literal"><span class="pre">b'\r'</span></code>) であれば、そのままコピーした上で現桁位置を 0 にリセットします。その他のバイト値については変更せずにコピーし、そのバイト値の表示のされ方（訳注: 全角、半角など）に関わらず現桁位置を 1 つ増加させます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">b&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">b&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalnum">
<code class="descclassname">bytes.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalnum" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.isalnum">
<code class="descclassname">bytearray.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalnum" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスが空でなく、かつ全てのバイト値が ASCII 文字のアルファベットまたは数字である場合は true を、そうでなければ false を返します。ここでの ASCII 文字のアルファベットとはシーケンス <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。 ASCII 文字の数字とは <code class="docutils literal"><span class="pre">b'0123456789'</span></code> に含まれるバイト値です。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABC abc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalpha">
<code class="descclassname">bytes.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalpha" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.isalpha">
<code class="descclassname">bytearray.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalpha" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスが空でなく、かつ全てのバイト値が ASCII 文字のアルファベットである場合は true を、そうでなければ false を返します。ここでの ASCII 文字のアルファベットとはシーケンス <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isdigit">
<code class="descclassname">bytes.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isdigit" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.isdigit">
<code class="descclassname">bytearray.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isdigit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスが空でなく、かつ全てのバイト値が ASCII 文字の数字である場合は true を、そうでなければ false を返します。ここでの ASCII 文字の数字とは <code class="docutils literal"><span class="pre">b'0123456789'</span></code> に含まれるバイト値です。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1.23&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.islower">
<code class="descclassname">bytes.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.islower" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.islower">
<code class="descclassname">bytearray.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.islower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンス中に小文字アルファベットの ASCII 文字が一つ以上あり、かつ大文字アルファベットの ASCII 文字が一つも無い場合に true を返します。そうでなければ false を返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>ここでの小文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> に含まれるバイト値です。また大文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.isspace">
<code class="descclassname">bytes.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isspace" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.isspace">
<code class="descclassname">bytearray.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isspace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスが空でなく、かつ全てのバイト値が ASCII 空白文字である場合は true を、そうでなければ false を返します。ここでの ASCII 空白文字とはシーケンス <code class="docutils literal"><span class="pre">b'</span> <span class="pre">\t\n\r\x0b\f'</span></code> に含まれるバイト値です (半角スペース、タブ、ラインフィード、キャリッジリターン、垂直タブ、フォームフィード) 。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.istitle">
<code class="descclassname">bytes.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.istitle" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.istitle">
<code class="descclassname">bytearray.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.istitle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスが空でなく、かつ ASCII のタイトルケース文字列になっている場合は true を、そうでなければ false を返します。「タイトルケース文字列」の定義については <a class="reference internal" href="#bytes.title" title="bytes.title"><code class="xref py py-meth docutils literal"><span class="pre">bytes.title()</span></code></a> を参照してください。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isupper">
<code class="descclassname">bytes.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isupper" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.isupper">
<code class="descclassname">bytearray.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isupper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンス中に大文字アルファベットの ASCII 文字が一つ以上あり、かつ小文字アルファベットの ASCII 文字が一つも無い場合に true を返します。そうでなければ false を返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;HELLO WORLD&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>ここでの小文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> に含まれるバイト値です。また大文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。</p>
</dd></dl>

<dl class="method">
<dt id="bytes.lower">
<code class="descclassname">bytes.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lower" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.lower">
<code class="descclassname">bytearray.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lower" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスに含まれる大文字アルファベットの ASCII 文字を全て小文字アルファベットに変換したシーケンスのコピーを返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">b&#39;hello world&#39;</span>
</pre></div>
</div>
<p>ここでの小文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> に含まれるバイト値です。また大文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<span class="target" id="index-40"></span><dl class="method">
<dt id="bytes.splitlines">
<code class="descclassname">bytes.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.splitlines" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.splitlines">
<code class="descclassname">bytearray.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.splitlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バイナリシーケンスを ASCII の改行コードで分割し、各行をリストにして返します。このメソッドは <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> アプローチで行を分割します。 <em>keepends</em> 引数に真を与えた場合を除き、改行コードは結果のリストに含まれません。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[b&#39;ab c&#39;, b&#39;&#39;, b&#39;de fg&#39;, b&#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[b&#39;ab c\n&#39;, b&#39;\n&#39;, b&#39;de fg\r&#39;, b&#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p><a class="reference internal" href="#bytes.split" title="bytes.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> とは違って、空シーケンスに対して区切り <em>sep</em> を与えて呼び出すと空のリストを返します。またシーケンス末尾に改行コードがある場合、（訳註: その後ろに空行があるとは判断せず）余分な行を生成することはありません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="sa">b</span><span class="s2">&quot;Two lines</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">([b&#39;&#39;], [b&#39;Two lines&#39;, b&#39;&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">([], [b&#39;One line&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.swapcase">
<code class="descclassname">bytes.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.swapcase" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.swapcase">
<code class="descclassname">bytearray.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.swapcase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスに含まれる小文字アルファベットの ASCII 文字を全て大文字アルファベットに変換し、さらに大文字アルファベットを同様に小文字アルファベットに変換したシーケンスのコピーを返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">b&#39;hELLO wORLD&#39;</span>
</pre></div>
</div>
<p>ここでの小文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> に含まれるバイト値です。また大文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。</p>
<p><a class="reference internal" href="#str.swapcase" title="str.swapcase"><code class="xref py py-func docutils literal"><span class="pre">str.swapcase()</span></code></a> とは違い、バイナリバージョンのこちらでは <code class="docutils literal"><span class="pre">bin.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">bin</span></code> が常に成り立ちます。一般的に Unicode 文字の大文字小文字変換は対称的ではありませんが、 ASCII 文字の場合は対称的です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.title">
<code class="descclassname">bytes.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.title" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.title">
<code class="descclassname">bytearray.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.title" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タイトルケース化したバイナリシーケンスを返します。具体的には、各単語が大文字アルファベットの ASCII 文字で始まり、かつ残りの文字が小文字アルファベットになっているシーケンスが返ります。大文字小文字の区別が無いバイト値については変更されずそのままになります。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>ここでの小文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> に含まれるバイト値です。また大文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。その他のバイト値については、大文字小文字の区別はありません。</p>
<p>このアルゴリズムは、連続した文字の集まりという、言語から独立した単純な単語の定義を使います。この定義は多くの状況ではうまく機能しますが、短縮形や所有格のアポストロフィが単語の境界になってしまい、望みの結果を得られない場合があります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>正規表現を使うことでアポストロフィに対応できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">rb</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">b&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.upper">
<code class="descclassname">bytes.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.upper" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.upper">
<code class="descclassname">bytearray.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.upper" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンスに含まれる小文字アルファベットの ASCII 文字を全て大文字アルファベットに変換したシーケンスのコピーを返します。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">b&#39;HELLO WORLD&#39;</span>
</pre></div>
</div>
<p>ここでの小文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> に含まれるバイト値です。また大文字の ASCII 文字とは <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> に含まれるバイト値です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.zfill">
<code class="descclassname">bytes.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.zfill" title="この定義へのパーマリンク">¶</a></dt>
<dt id="bytearray.zfill">
<code class="descclassname">bytearray.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.zfill" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>長さが <em>width</em> になるよう ASCII <code class="docutils literal"><span class="pre">b'0'</span></code> で左詰めしたシーケンスのコピーを返します。先頭が符号接頭辞 (<code class="docutils literal"><span class="pre">b'+'</span></code>/<code class="docutils literal"><span class="pre">b'-'</span></code>) だった場合、 <code class="docutils literal"><span class="pre">b'0'</span></code> は符号の前ではなく <em>後</em> に挿入されます。 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> オブジェクトの場合、 <em>width</em> が <code class="docutils literal"><span class="pre">len(seq)</span></code> 以下であれば元のシーケンスが返ります。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;-0042&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-bytes-formatting">
<span id="bytes-formatting"></span><h3>4.8.4. <code class="docutils literal"><span class="pre">printf</span></code> 形式での bytes の書式化<a class="headerlink" href="#printf-style-bytes-formatting" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="admonition note" id="index-41">
<p class="first admonition-title">注釈</p>
<p class="last">ここで述べる書式化演算には様々な癖があり、よく間違いの元になっています (タプルや辞書を正しく表示できないなど)。もし表示する値がタプルや辞書かもしれない場合、それをタプルに包むようにしてください。</p>
</div>
<p>bytes オブジェクト (<code class="docutils literal"><span class="pre">bytes</span></code>/<code class="docutils literal"><span class="pre">bytearray</span></code>) には固有の操作: <code class="docutils literal"><span class="pre">%</span></code> 演算子 (モジュロ) があります。この演算子は bytes の <em>書式化</em> または <em>補間</em> 演算子とも呼ばれます。<code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> (<em>format</em> は bytes オブジェクト) とすると、<em>format</em> 中の <code class="docutils literal"><span class="pre">%</span></code> 変換指定は <em>values</em> 中のゼロ個またはそれ以上の要素で置換されます。この動作は C 言語における <code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code> に似ています。</p>
<p><em>format</em> が単一の引数しか要求しない場合、 <em>values</em> はタプルではない単一のオブジェクトで問題ありません。 <a class="footnote-reference" href="#id16" id="id11">[5]</a> それ以外の場合、 <em>values</em> は書式シーケンス（訳註: 先の例での <em>format</em> ）中で指定された項目と正確に同じ数の要素を含むタプルか、単一のマッピング型のオブジェクト (たとえば辞書) でなければなりません。</p>
<p>一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は以下からなりますが、示した順に出現しなければなりません:</p>
<ol class="arabic simple">
<li>指定子の開始を示す文字 <code class="docutils literal"><span class="pre">'%'</span></code> 。</li>
<li>マップキー (オプション)。丸括弧で囲った文字列からなります (例えば <code class="docutils literal"><span class="pre">(somename)</span></code>) 。</li>
<li>変換フラグ (オプション)。一部の変換型の結果に影響します。</li>
<li>最小のフィールド幅 (オプション)。 <code class="docutils literal"><span class="pre">'*'</span></code> (アスタリスク) を指定した場合、実際の文字列幅が <em>values</em> タプルの次の要素から読み出されます。タプルには最小フィールド幅やオプションの精度指定の後に変換したいオブジェクトがくるようにします。</li>
<li>精度 (オプション)。 <code class="docutils literal"><span class="pre">'.'</span></code> (ドット) とその後に続く精度で与えられます。 <code class="docutils literal"><span class="pre">'*'</span></code> (アスタリスク) を指定した場合、精度の桁数は <em>values</em> タプルの次の要素から読み出されます。タプルには精度指定の後に変換したい値がくるようにします。</li>
<li>精度長変換子 (オプション)。</li>
<li>変換型。</li>
</ol>
<p><code class="docutils literal"><span class="pre">%</span></code> 演算子の右側の引数が辞書の場合 (またはその他のマッピング型の場合) 、 bytes オブジェクト中のフォーマットには、辞書のキーを丸括弧で囲って文字 <code class="docutils literal"><span class="pre">'%'</span></code> の直後に書いたものが含まれていなければ <em>なりません</em> 。マップキーは書式化したい値をマッピングから選び出します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="sa">b</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="sa">b</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">b&#39;Python has 002 quote types.&#39;</span>
</pre></div>
</div>
<p>この場合、 <code class="docutils literal"><span class="pre">*</span></code> 指定子をフォーマットに含めてはいけません (<code class="docutils literal"><span class="pre">*</span></code> 指定子は順番付けされたパラメタのリストが必要だからです)。</p>
<p>変換フラグ文字を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Flag</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'#'</span></code></td>
<td>値の変換に (下で定義されている) &quot;別の形式&quot; を使います。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'0'</span></code></td>
<td>数値型に対してゼロによるパディングを行います。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'-'</span></code></td>
<td>変換された値を左寄せにします (<code class="docutils literal"><span class="pre">'0'</span></code> と同時に与えた場合、 <code class="docutils literal"><span class="pre">'0'</span></code> を上書きします) 。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(スペース) 符号付きの変換で正の数の場合、前に一つスペースを空けます (そうでない場合は空文字になります) 。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td>変換の先頭に符号文字 (<code class="docutils literal"><span class="pre">'+'</span></code> または <code class="docutils literal"><span class="pre">'-'</span></code>) を付けます(&quot;スペース&quot; フラグを上書きします) 。</td>
</tr>
</tbody>
</table>
<p>精度長変換子(<code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">l</span></code>,または <code class="docutils literal"><span class="pre">L</span></code>) を使うことができますが、 Python では必要ないため無視されます。 – つまり、例えば <code class="docutils literal"><span class="pre">%ld</span></code> は <code class="docutils literal"><span class="pre">%d</span></code> と等価です。</p>
<p>変換型を以下に示します:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">変換</th>
<th class="head">意味</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'d'</span></code></td>
<td>符号付き 10 進整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'i'</span></code></td>
<td>符号付き 10 進整数。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'o'</span></code></td>
<td>符号付き 8 進数。</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'u'</span></code></td>
<td>旧式の型 – <code class="docutils literal"><span class="pre">'d'</span></code> と同じです。</td>
<td>(8)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td>符号付き 16 進数 (小文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'X'</span></code></td>
<td>符号付き 16 進数 (大文字)。</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'e'</span></code></td>
<td>指数表記の浮動小数点数 (小文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'E'</span></code></td>
<td>指数表記の浮動小数点数 (大文字)。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'f'</span></code></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'F'</span></code></td>
<td>10 進浮動小数点数。</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'g'</span></code></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には小文字指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'G'</span></code></td>
<td>浮動小数点数。指数部が -4 以上または精度以下の場合には大文字指数表記、それ以外の場合には10進表記。</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'c'</span></code></td>
<td>1 バイト (整数または要素 1 つの <code class="docutils literal"><span class="pre">bytes</span></code>/<code class="docutils literal"><span class="pre">bytearray</span></code> オブジェクトを受理します)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'b'</span></code></td>
<td>バイナリシーケンス (<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> をサポートするか、 <a class="reference internal" href="../reference/datamodel.html#object.__bytes__" title="object.__bytes__"><code class="xref py py-meth docutils literal"><span class="pre">__bytes__()</span></code></a> メソッドがあるオブジェクト)</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'s'</span></code></td>
<td><code class="docutils literal"><span class="pre">'s'</span></code> は <code class="docutils literal"><span class="pre">'b'</span></code> の別名です。Python 2/3 の両方を対象としたコードでのみ使用すべきです。</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'a'</span></code></td>
<td>バイナリシーケンス (Python オブジェクトを <code class="docutils literal"><span class="pre">repr(obj).encode('ascii','backslashreplace)</span></code> で変換します)。</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td><code class="docutils literal"><span class="pre">'r'</span></code> は <code class="docutils literal"><span class="pre">'a'</span></code> の別名です。Python 2/3 の両方を対象としたコードでのみ使用すべきです。</td>
<td>(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'%'</span></code></td>
<td>引数を変換せず、返される文字列中では文字 <code class="docutils literal"><span class="pre">'%'</span></code> になります。</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic">
<li><p class="first">別の形式を指定（訳注: 変換フラグ <code class="docutils literal"><span class="pre">#</span></code> を使用）すると 8 進数を表す接頭辞 (<code class="docutils literal"><span class="pre">'0o'</span></code>) が最初の数字の前に挿入されます。</p>
</li>
<li><p class="first">別の形式を指定（訳注: 変換フラグ <code class="docutils literal"><span class="pre">#</span></code> を使用）すると 16 進数を表す接頭辞 <code class="docutils literal"><span class="pre">'0x'</span></code> または <code class="docutils literal"><span class="pre">'0X'</span></code> (使用するフォーマット文字が <code class="docutils literal"><span class="pre">'x'</span></code> か <code class="docutils literal"><span class="pre">'X'</span></code> に依存します) が最初の数字の前に挿入されます。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ、それはその後ろに数字が続かない場合にも適用されます。</p>
<p>指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first">この形式にした場合、変換結果には常に小数点が含まれ他の形式とは違って末尾の 0 は取り除かれません。</p>
<p>指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。</p>
</li>
<li><p class="first">精度が <code class="docutils literal"><span class="pre">N</span></code> なら、出力は <code class="docutils literal"><span class="pre">N</span></code> 文字に切り詰められます。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">b'%s'</span></code> は非推奨ですが、3.x 系では削除されません。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">b'%r'</span></code> は非推奨ですが、3.x 系では削除されません。</p>
</li>
<li><p class="first"><span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> を参照してください。</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">bytearray のこのメソッドはインプレースでは動作 <em>しません</em> – 一切変化が無い場合でも、常に新しいオブジェクトを生成します。</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0461"><strong>PEP 461</strong></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</div>
<div class="section" id="memory-views">
<span id="typememoryview"></span><h3>4.8.5. メモリビュー<a class="headerlink" href="#memory-views" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> オブジェクトは、Python コードが <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">バッファプロトコル</span></a> をサポートするオブジェクトの内部データへ、コピーすることなくアクセスすることを可能にします。</p>
<dl class="class">
<dt id="memoryview">
<em class="property">class </em><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> を参照する <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> を作成します。 <em>obj</em> はバッファプロトコルをサポートしていなければなりません。バッファプロトコルをサポートする組み込みオブジェクトには、 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 、 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> などがあります。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> は元となるオブジェクト <em>obj</em> が扱うメモリーの最小単位を <em>要素</em> として扱います。多くの単純なオブジェクト、例えば <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> や <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> では、要素は単バイトになりますが、他の <a class="reference internal" href="array.html#array.array" title="array.array"><code class="xref py py-class docutils literal"><span class="pre">array.array</span></code></a> 等の型では、要素はより大きくなりえます。</p>
<p>メモリビューの長さ <code class="docutils literal"><span class="pre">len(view)</span></code> は、 <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-class docutils literal"><span class="pre">tolist</span></code></a> で得られるリストの長さとなります。<code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code> なら、長さは 1 です。<code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code> なら、長さはビューの要素数と等しいです。より高次元では、長さはビューのネストされたリスト表現の長さと等しいです。要素一つあたりのバイト数は <a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal"><span class="pre">itemsize</span></code></a> 属性から取得できます。</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> はスライスおよびインデックス指定で内容を取得できます。一次元のスライスは部分ビューになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x7f3ddc9f4350&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">b&#39;bce&#39;</span>
</pre></div>
</div>
<p>もしメモリビューの <a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal"><span class="pre">format</span></code></a> が <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールによって定義されているネイティブのフォーマット指定子であれば、整数または整数のタプルでのインデックス指定により適切な型の <em>要素1つ</em> を得ることができます。一次元のメモリビューでは、整数または整数 1 つのタプルでインデックス指定できます。多次元のメモリビューでは、その次元数を <em>ndim</em> としたとき、ちょうど <em>ndim</em> 個の整数からなるタプルでインデックス指定できます。ゼロ次元のメモリビューでは、空のタプルでインデックス指定できます。</p>
<p><a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal"><span class="pre">format</span></code></a> が単バイト単位ではない例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">11111111</span><span class="p">,</span> <span class="mi">22222222</span><span class="p">,</span> <span class="o">-</span><span class="mi">33333333</span><span class="p">,</span> <span class="mi">44444444</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-11111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">44444444</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-11111111, -33333333]</span>
</pre></div>
</div>
<p>メモリビューの参照しているオブジェクトが書き込み可能であれば、一次元スライスでの代入が可能です。ただしサイズの変更はできません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;zbcefg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z123fg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview assignment: lvalue and rvalue have different structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z1spam&#39;)</span>
</pre></div>
</div>
<p>'B', 'b', 'c' いずれかのフォーマットのハッシュ可能な (読み出し専用の) 型の1次元メモリビューもまた、ハッシュ可能です。ハッシュは <code class="docutils literal"><span class="pre">hash(m)</span> <span class="pre">==</span> <span class="pre">hash(m.tobytes())</span></code> として定義されています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ce&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>1 次元のメモリビューがスライス可能になりました。 'B', 'b', 'c' いずれかのフォーマットの 1 次元のメモリビューがハッシュ可能になりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>memoryview は自動的に <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> へ登録されるようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>メモリビューは整数のタプルでインデックス指定できるようになりました。</p>
</div>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> にはいくつかのメソッドがあります:</p>
<dl class="method">
<dt id="memoryview.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>exporter</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.__eq__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>memoryview と <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> エクスポーターは、 shape が同じで、 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> のフォーマットで解釈したときの値が同じ場合に同値になります。</p>
<p><a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a> がサポートしている <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> フォーマットの一部では、 <code class="docutils literal"><span class="pre">v.tolist()</span> <span class="pre">==</span> <span class="pre">w.tolist()</span></code> が成り立つときに <code class="docutils literal"><span class="pre">v</span></code> == <code class="docutils literal"><span class="pre">w</span></code> になります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">==</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>どちらかの書式文字列が <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールにサポートされていなければ、 (書式文字列とバッファの内容が同一でも) オブジェクトは常に等しくないものとして比較されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">BigEndianStructure</span><span class="p">,</span> <span class="n">c_long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BEPoint</span><span class="p">(</span><span class="n">BigEndianStructure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">BEPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">point</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>浮動小数点数の場合と同様 memoryview オブジェクトに対する <code class="docutils literal"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">w</span></code> は <code class="docutils literal"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">w</span></code> を意味しないことに注意してください。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>以前のバージョンは、要素フォーマットと論理的な配列構造を無視して生のメモリを比較していました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tobytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファ中のデータをバイト文字列として返します。これはメモリビューに対して <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> コンストラクタを呼び出すのと同等です。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">b&#39;abc&#39;</span>
</pre></div>
</div>
<p>連続でない配列については、結果はすべての要素がバイトに変換されたものを含むフラットなリスト表現に等しくなります。 <a class="reference internal" href="#memoryview.tobytes" title="memoryview.tobytes"><code class="xref py py-meth docutils literal"><span class="pre">tobytes()</span></code></a> は、 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュール文法にないものを含むすべての書式文字列をサポートします。</p>
</dd></dl>

<dl class="method">
<dt id="memoryview.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.hex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファ中の各バイトを 2 つの 16 進数で表した文字列を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;616263&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tolist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファ中のデータを要素のリストとして返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a> が <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュール文法に含まれるすべての単一文字の native フォーマットと多次元の表現をサポートするようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.release" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>memoryview オブジェクトによって晒されている、元になるバッファを解放します。多くのオブジェクトはビューに支配されているときに特殊なふるまいをします (例えば、 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> は大きさの変更を一時的に禁止します)。ですから、release() を呼び出すことは、これらの制約をできるだけ早く取り除く (そしてぶら下がったリソースをすべて解放する) のに便利です。</p>
<p>このメソッドが呼ばれた後、このビュー上のそれ以上の演算は <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></a> を送出します (複数回呼ばれえる <a class="reference internal" href="#memoryview.release" title="memoryview.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> 自身は除きます):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<p>コンテキストマネージャプロトコルは、 <code class="docutils literal"><span class="pre">with</span></code> 文を使って同様の効果を得るのに使えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.cast">
<code class="descname">cast</code><span class="sig-paren">(</span><em>format</em><span class="optional">[</span>, <em>shape</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.cast" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>memoryview を新しいフォーマットか shape にキャストします。 <em>shape</em> はデフォルトで <code class="docutils literal"><span class="pre">[byte_length//new_itemsize]</span></code> で、 1次元配列になります。戻り値は memoryview ですが、バッファー自体はコピーされません。サポートされている変換は 1次元配列 -&gt; C言語型の連続配列 と C言語型の連続配列 -&gt; 1次元配列 です（参考: <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>）。</p>
<p>キャスト後のフォーマットは <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 文法の単一要素ネイティブフォーマットに制限されます。フォーマットのうちの一つはバイトフォーマット ('B', 'b', 'c') でなければなりません。結果のバイト長はオリジナルの長さと同じでなければなりません。</p>
<p>1D/long から 1D/unsigned byte へのキャスト:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;l&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
</pre></div>
</div>
<p>1D/unsigned byte から 1D/char へのキャスト:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;zyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview: invalid value for format &quot;B&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;ayz&#39;)</span>
</pre></div>
</div>
<p>1D/byte から 3D/int へ、そして 1D/signed char へのキャスト:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;i&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
</pre></div>
</div>
<p>1D/unsigned char から 2D/unsigned long へのキャスト:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [3, 4, 5]]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>単バイトのビューへキャストする場合、キャスト元のフォーマットについて制約は無くなりました。</p>
</div>
</dd></dl>

<p>読み出し専用の属性もいくつか使えます:</p>
<dl class="attribute">
<dt id="memoryview.obj">
<code class="descname">obj</code><a class="headerlink" href="#memoryview.obj" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>memoryview が参照しているオブジェクト:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#memoryview.nbytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">nbytes</span> <span class="pre">==</span> <span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len(m.tobytes())</span></code>. その配列が連続表現において利用するスペースです。これは len(m) と一致するとは限りません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">12</span>
</pre></div>
</div>
<p>多次元配列:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">96</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.readonly">
<code class="descname">readonly</code><a class="headerlink" href="#memoryview.readonly" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリが読み出し専用かどうかを示す真偽値です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.format">
<code class="descname">format</code><a class="headerlink" href="#memoryview.format" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ビューの中の各要素に対する (<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールスタイルの) フォーマットを含む文字列。 memoryview は、任意のフォーマット文字列を使ってエクスポーターから作成することができます。しかし、いくつかのメソッド(例えば <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a>) はネイティブの単一要素フォーマットに制限されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>フォーマット <code class="docutils literal"><span class="pre">'B'</span></code> は struct モジュール構文で扱われるようになりました。これは <code class="docutils literal"><span class="pre">memoryview(b'abc')[0]</span> <span class="pre">==</span> <span class="pre">b'abc'[0]</span> <span class="pre">==</span> <span class="pre">97</span></code> ということを意味します。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#memoryview.itemsize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>memoryview の各要素のバイト単位の大きさ:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">32000</span><span class="p">,</span> <span class="mi">32001</span><span class="p">,</span> <span class="mi">32002</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">32000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#memoryview.ndim" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリが表す多次元配列が何次元かを示す整数です。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.shape">
<code class="descname">shape</code><a class="headerlink" href="#memoryview.shape" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリが表している N 次元配列の形状を表す、長さ <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> の整数のタプルです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ndim = 0 の場合は <code class="docutils literal"><span class="pre">None</span></code> ではなく空のタプルとなるよう変更されました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.strides">
<code class="descname">strides</code><a class="headerlink" href="#memoryview.strides" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>配列のそれぞれの次元に対して、それぞれの要素にアクセスするのに必要なバイト数を表す、長さ <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> の整数のタプルです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ndim = 0 の場合は <code class="docutils literal"><span class="pre">None</span></code> ではなく空のタプルとなるよう変更されました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.suboffsets">
<code class="descname">suboffsets</code><a class="headerlink" href="#memoryview.suboffsets" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>PILスタイルの配列の内部で利用している値。この値はただの情報として公開されています。</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.c_contiguous">
<code class="descname">c_contiguous</code><a class="headerlink" href="#memoryview.c_contiguous" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリーが C 形式の順序で連続しているかどうかを示す真偽値（参考: <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> ）。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.f_contiguous">
<code class="descname">f_contiguous</code><a class="headerlink" href="#memoryview.f_contiguous" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリーがFortran形式の順序で連続しているかどうかを示す真偽値（参考: <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> ）。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.contiguous">
<code class="descname">contiguous</code><a class="headerlink" href="#memoryview.contiguous" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリーが連続しているかどうかを示す真偽値（参考: <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> ）。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="set-types-set-frozenset">
<span id="types-set"></span><h2>4.9. set（集合）型 — <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a><a class="headerlink" href="#set-types-set-frozenset" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-45"><em class="dfn">set</em> オブジェクトは、固有の <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> オブジェクトの順序なしコレクションです。通常の用途には、帰属テスト、シーケンスからの重複除去、積集合、和集合、差集合、対称差 (排他的論理和) のような数学的演算の計算が含まれます。(他のコンテナについては組み込みの <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> クラスや <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールを参照してください。)</p>
<p>集合は、他のコレクションと同様、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">len(set)</span></code>, <code class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code> をサポートします。コレクションには順序がないので、集合は挿入の順序や要素の位置を記録しません。従って、集合はインデクシング、スライシング、その他のシーケンス的な振舞いをサポートしません。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> および <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> という、2つの組み込みの集合型があります。 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> はミュータブルで、<code class="xref py py-meth docutils literal"><span class="pre">add()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code> のようなメソッドを使って内容を変更できます。ミュータブルなため、ハッシュ値を持たず、また辞書のキーや他の集合の要素として用いることができません。一方、<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 型はイミュータブルで、<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">ハッシュ可能</span></a> です。作成後に内容を改変できないため、辞書のキーや他の集合の要素として用いることができます。</p>
<p>空でない <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> (<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> ではない) は、<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> コンストラクタに加え、要素を波括弧中にカンマで区切って列挙することでも生成できます。例: <code class="docutils literal"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></code>。</p>
<p>どちらのクラスのコンストラクタも同様に働きます:</p>
<dl class="class">
<dt id="set">
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set" title="この定義へのパーマリンク">¶</a></dt>
<dt id="frozenset">
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>iterable</em> から要素を取り込んだ、新しい <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> もしくは <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> オブジェクトを返します。 集合の要素は <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">ハッシュ可能</span></a> なものでなくてはなりません。集合の集合を表現するためには、内側の集合は <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> オブジェクトでなくてはなりません。<em>iterable</em> が指定されない場合、新しい空の集合が返されます。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> および <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のインスタンスは以下の操作を提供します:</p>
<dl class="describe">
<dt>
<code class="descname">len(s)</code></dt>
<dd><p>集合 <em>s</em> の要素数 (<em>s</em> の濃度) を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in s</code></dt>
<dd><p><em>x</em> が <em>s</em> のメンバーに含まれるか判定します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x not in s</code></dt>
<dd><p><em>x</em> が <em>s</em> のメンバーに含まれていないことを判定します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.isdisjoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>集合が <em>other</em> と共通の要素を持たないとき、<code class="docutils literal"><span class="pre">True</span></code> を返します。集合はそれらの積集合が空集合となるときのみ、互いに素 (disjoint) となります。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issubset" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &lt;= other</code></dt>
<dd><p>set の全ての要素が <em>other</em> に含まれるか判定します。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &lt; other</code></dt>
<dd><p>set が <em>other</em> の真部分集合であるかを判定します。つまり、 <code class="docutils literal"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code> と等価です。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issuperset" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &gt;= other</code></dt>
<dd><p><em>other</em> の全ての要素が set に含まれるか判定します。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &gt; other</code></dt>
<dd><p>set が <em>other</em> の真上位集合であるかを判定します。つまり、 <code class="docutils literal"><span class="pre">set</span> <span class="pre">&gt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code> と等価です。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.union" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set | other | ...</code></dt>
<dd><p>set と全ての other の要素からなる新しい集合を返します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &amp; other &amp; ...</code></dt>
<dd><p>set と全ての other に共通する要素を持つ、新しい集合を返します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set - other - ...</code></dt>
<dd><p>set に含まれて、かつ、全ての other に含まれない要素を持つ、新しい集合を返します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set ^ other</code></dt>
<dd><p>set と <em>other</em> のいずれか一方だけに含まれる要素を持つ新しい集合を返します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>s</em> の浅いコピーを新しい集合として返します。</p>
</dd></dl>

<p>なお、演算子でない版の <a class="reference internal" href="#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code></a>, <a class="reference internal" href="#frozenset.difference" title="frozenset.difference"><code class="xref py py-meth docutils literal"><span class="pre">difference()</span></code></a>, <a class="reference internal" href="#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#frozenset.issubset" title="frozenset.issubset"><code class="xref py py-meth docutils literal"><span class="pre">issubset()</span></code></a>, <a class="reference internal" href="#frozenset.issuperset" title="frozenset.issuperset"><code class="xref py py-meth docutils literal"><span class="pre">issuperset()</span></code></a> メソッドは、任意のイテラブルを引数として受け付けます。対して、演算子を使う版では、引数は集合でなくてはなりません。これは、<code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code> のような誤りがちな構文を予防し、より読みやすい <code class="docutils literal"><span class="pre">set('abc').intersection('cbs')</span></code> を支持します。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> と <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のどちらも、集合同士の比較をサポートします。二つの集合は、それぞれの集合の要素全てが他方にも含まれている (互いに他方の部分集合である) とき、かつそのときに限り等しいです。一方の集合が他方の集合の真部分集合である (部分集合であるが等しくない) とき、かつそのときに限り一方の集合は他方の集合より小さいです。一方の集合が他方の集合の真上位集合である (上位集合であるが等しくない) とき、かつそのときに限り一方の集合は他方の集合より大きいです。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> のインスタンスは、 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のインスタンスと、要素に基づいて比較されます。例えば、 <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code> や <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code> は <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p>部分集合と等価性の比較は全順序付けを行う関数へと一般化することはできません。例えば、互いに素である二つの非空集合は、等しくなく、他方の部分集合でもありませんから、以下の <em>すべて</em> に <code class="docutils literal"><span class="pre">False</span></code> を返します: <code class="docutils literal"><span class="pre">a&lt;b</span></code>, <code class="docutils literal"><span class="pre">a==b</span></code>, そして <code class="docutils literal"><span class="pre">a&gt;b</span></code>.</p>
<p>集合は半順序（部分集合関係）しか定義しないので、集合のリストにおける <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> メソッドの出力は未定義です。</p>
<p>集合の要素は、辞書のキーのように、ハッシュ可能 (<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) でなければなりません。</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> インスタンスと <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> インスタンスを取り混ぜての二項演算は、第一被演算子の型を返します。例えば: <code class="docutils literal"><span class="pre">frozenset('ab')</span> <span class="pre">|</span> <span class="pre">set('bc')</span></code> は <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> インスタンスを返します。</p>
<p>以下の表に挙げる演算は <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> に適用されますが、<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> のイミュータブルなインスタンスには適用されません:</p>
<dl class="method">
<dt id="frozenset.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set |= other | ...</code></dt>
<dd><p>全ての other の要素を追加し、 set を更新します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set &amp;= other &amp; ...</code></dt>
<dd><p>元の set と全ての other に共通する要素だけを残して set を更新します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set -= other | ...</code></dt>
<dd><p><em>other</em> に含まれる要素を取り除き、 set を更新します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference_update" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<code class="descname">set ^= other</code></dt>
<dd><p>どちらかにのみ含まれて、共通には持たない要素のみで set を更新します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> を set に追加します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.remove" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> を set から取り除きます。<em>elem</em> が set に含まれていなければ <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.discard" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素 <em>elem</em> が set に含まれていれば、取り除きます。</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>s</em> から任意の要素を取り除き、それを返します。集合が空の場合、 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>set の全ての要素を取り除きます。</p>
</dd></dl>

<p>なお、演算子でない版の <a class="reference internal" href="#frozenset.update" title="frozenset.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a>, <a class="reference internal" href="#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal"><span class="pre">intersection_update()</span></code></a>, <a class="reference internal" href="#frozenset.difference_update" title="frozenset.difference_update"><code class="xref py py-meth docutils literal"><span class="pre">difference_update()</span></code></a>, および <a class="reference internal" href="#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference_update()</span></code></a> メソッドは、任意のイテラブルを引数として受け付けます。</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#frozenset.remove" title="frozenset.remove"><code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code></a>, <a class="reference internal" href="#frozenset.discard" title="frozenset.discard"><code class="xref py py-meth docutils literal"><span class="pre">discard()</span></code></a> メソッドの引数 <em>elem</em> は集合かもしれないことに注意してください。
その集合と等価な <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> の検索をサポートするために、 <em>elem</em> から一時的な frozenset を作成します。</p>
</dd></dl>

</div>
<div class="section" id="mapping-types-dict">
<span id="typesmapping"></span><h2>4.10. マッピング型 — <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a><a class="headerlink" href="#mapping-types-dict" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-46">マッピング (<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>) オブジェクトは、ハッシュ可能 (<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) な値を任意のオブジェクトに対応付けます。マッピングはミュータブルなオブジェクトです。現在、標準マッピング型は辞書 (<em class="dfn">dictionary</em>) だけです。 (他のコンテナについては組み込みの <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, および <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> クラスと、 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールを参照してください。)</p>
<p>辞書のキーは <em>ほぼ</em> 任意の値です。ハッシュ可能 (<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) でない値、つまり、リストや辞書その他のミュータブルな型 (オブジェクトの同一性ではなく値で比較されるもの) はキーとして使用できません。キーとして使われる数値型は通常の数値比較のルールに従います: もしふたつの数値が (例えば <code class="docutils literal"><span class="pre">1</span></code> と <code class="docutils literal"><span class="pre">1.0</span></code> のように) 等しければ、同じ辞書の項目として互換的に使用できます。 (ただし、コンピュータは浮動小数点数を近似値として保管するので、辞書型のキーとして使用するのはたいてい賢くありません。)</p>
<p>辞書は <code class="docutils literal"><span class="pre">key:</span> <span class="pre">value</span></code> 対のカンマ区切りのリストを波括弧でくくることで作成できます。例えば: <code class="docutils literal"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></code> あるいは <code class="docutils literal"><span class="pre">{4098:</span> <span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></code> 。あるいは、 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> コンストラクタでも作成できます。</p>
<dl class="class">
<dt id="dict">
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#dict" title="この定義へのパーマリンク">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>オプションの位置引数と空の可能性もあるキーワード引数の集合により初期化された新しい辞書を返します。</p>
<p>位置引数が何も与えられなかった場合、空の辞書が作成されます。位置引数が与えられ、それがマッピングオブジェクトだった場合、そのマッピングオブジェクトと同じキーと値のペアを持つ辞書が作成されます。それ以外の場合、位置引数は <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> オブジェクトでなければなりません。iterable のそれぞれの要素自身は、ちょうど 2 個のオブジェクトを持つイテラブルでなければなりません。それぞれの要素の最初のオブジェクトは新しい辞書のキーになり、2 番目のオブジェクトはそれに対応する値になります。同一のキーが 2 回以上現れた場合は、そのキーの最後の値が新しい辞書での対応する値になります。</p>
<p>キーワード引数が与えられた場合、キーワード引数とその値が位置引数から作られた辞書に追加されます。既に存在しているキーが追加された場合、キーワード引数の値は位置引数の値を置き換えます。</p>
<p>例を出すと、次の例は全て <code class="docutils literal"><span class="pre">{&quot;one&quot;:</span> <span class="pre">1,</span> <span class="pre">&quot;two&quot;:</span> <span class="pre">2,</span> <span class="pre">&quot;three&quot;:</span> <span class="pre">3}</span></code> に等しい辞書を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<p>最初の例のようにキーワード引数を与える方法では、キーは有効な Python の識別子でなければなりません。それ以外の方法では、辞書のキーとして有効などんなキーでも使えます。</p>
<p>以下は辞書型がサポートする操作です (それゆえ、カスタムのマップ型もこれらの操作をサポートするべきです):</p>
<dl class="describe">
<dt>
<code class="descname">len(d)</code></dt>
<dd><p>辞書 <em>d</em> の項目数を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key]</code></dt>
<dd><p><em>d</em> のキー <em>key</em> の項目を返します。マップに <em>key</em> が存在しなければ、 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
<p id="index-47">辞書のサブクラスが <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> メソッドを定義していて、 <em>key</em> が存在しない場合、 <code class="docutils literal"><span class="pre">d[key]</span></code> 演算はこのメソッドをキー <em>key</em> を引数として呼び出します。 <code class="docutils literal"><span class="pre">d[key]</span></code> 演算は、 <code class="docutils literal"><span class="pre">__missing__(key)</span></code> の呼び出しによって返された値をそのまま返すか、送出されたものをそのまま送出します。他の演算やメソッドは <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> を呼び出しません。 <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> が定義されていない場合、 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> が送出されます。 <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> はメソッドでなければならず、インスタンス変数であってはなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>ここでお見せした例は <a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal"><span class="pre">collections.Counter</span></code></a> 実装の一部です。これとは違った <code class="docutils literal"><span class="pre">__missing__</span></code> が <a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal"><span class="pre">collections.defaultdict</span></code></a> で使われています。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key] = value</code></dt>
<dd><p><code class="docutils literal"><span class="pre">d[key]</span></code> に <em>value</em> を設定します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">del d[key]</code></dt>
<dd><p><em>d</em> から <code class="docutils literal"><span class="pre">d[key]</span></code> を削除します。マップに <em>key</em> が存在しなければ、 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key in d</code></dt>
<dd><p><em>d</em> がキー <em>key</em> を持っていれば <code class="docutils literal"><span class="pre">True</span></code> を、そうでなければ、 <code class="docutils literal"><span class="pre">False</span></code> を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key not in d</code></dt>
<dd><p><code class="docutils literal"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code> と等価です。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(d)</code></dt>
<dd><p>辞書のキーに渡るイテレータを返します。これは <code class="docutils literal"><span class="pre">iter(d.keys())</span></code> へのショートカットです。</p>
</dd></dl>

<dl class="method">
<dt id="dict.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の全ての項目を消去します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の浅いコピーを返します。</p>
</dd></dl>

<dl class="classmethod">
<dt id="dict.fromkeys">
<em class="property">classmethod </em><code class="descname">fromkeys</code><span class="sig-paren">(</span><em>seq</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.fromkeys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>seq</em> からキーを取り、値を <em>value</em> に設定した、新しい辞書を作成します。</p>
<p><a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><code class="xref py py-meth docutils literal"><span class="pre">fromkeys()</span></code></a> は新しい辞書を返すクラスメソッドです。 <em>value</em> のデフォルト値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="dict.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.get" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>key</em> が辞書にあれば <em>key</em> に対する値を、そうでなければ <em>default</em> を返します。 <em>default</em> が与えられなかった場合、デフォルトでは <code class="docutils literal"><span class="pre">None</span></code> となります。そのため、このメソッドは <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出することはありません。</p>
</dd></dl>

<dl class="method">
<dt id="dict.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.items" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の項目 (<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 対) の新しいビューを返します。<a class="reference internal" href="#dict-views"><span class="std std-ref">ビューオブジェクトのドキュメント</span></a> を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="dict.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.keys" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書のキーの新しいビューを返します。<a class="reference internal" href="#dict-views"><span class="std std-ref">ビューオブジェクトのドキュメント</span></a> を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="dict.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.pop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>key</em> が辞書に存在すればその値を辞書から消去して返し、そうでなければ <em>default</em> を返します。 <em>default</em> が与えらず、かつ <em>key</em> が辞書に存在しなければ <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.popitem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>任意の <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 対を辞書から消去して返します。</p>
<p>集合のアルゴリズムで使われるのと同じように、 <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a> は辞書に繰り返し適用して消去するのに便利です。辞書が空であれば、 <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a> の呼び出しは <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="dict.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.setdefault" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>もし、 <em>key</em> が辞書に存在すれば、その値を返します。そうでなければ、値を <em>default</em> として <em>key</em> を挿入し、 <em>default</em> を返します。 <em>default</em> のデフォルトは <code class="docutils literal"><span class="pre">None</span></code> です。</p>
</dd></dl>

<dl class="method">
<dt id="dict.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>other</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.update" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の内容を <em>other</em> のキーと値で更新します。既存のキーは上書きされます。返り値は <code class="docutils literal"><span class="pre">None</span></code> です。</p>
<p><a class="reference internal" href="#dict.update" title="dict.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a> は、他の辞書オブジェクトでもキー/値の対のイテラブル (タプル、もしくは、長さが2のイテラブル) でも、どちらでも受け付けます。キーワード引数が指定されれば、そのキー/値の対で辞書を更新します: <code class="docutils literal"><span class="pre">d.update(red=1,</span> <span class="pre">blue=2)</span></code>。</p>
</dd></dl>

<dl class="method">
<dt id="dict.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.values" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>辞書の値の新しいビューを返します。<a class="reference internal" href="#dict-views"><span class="std std-ref">ビューオブジェクトのドキュメント</span></a> を参照してください。</p>
</dd></dl>

<p>複数の辞書は、同じ <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> の対を持つ場合に、そしてその場合にのみ等しくなります。順序比較 ('&lt;', '&lt;=', '&gt;=', '&gt;') は <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> の読み出し専用ビューを作るために <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal"><span class="pre">types.MappingProxyType</span></code></a> を使うことができます。</p>
</div>
<div class="section" id="dictionary-view-objects">
<span id="dict-views"></span><h3>4.10.1. 辞書ビューオブジェクト<a class="headerlink" href="#dictionary-view-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="#dict.values" title="dict.values"><code class="xref py py-meth docutils literal"><span class="pre">dict.values()</span></code></a>, <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> によって返されるオブジェクトは、 <em>ビューオブジェクト</em> です。これらは、辞書の項目の動的なビューを提供し、辞書が変更された時、ビューはその変更を反映します。</p>
<p>辞書ビューは、イテレートすることで対応するデータを yield できます。また、帰属判定をサポートします:</p>
<dl class="describe">
<dt>
<code class="descname">len(dictview)</code></dt>
<dd><p>辞書の項目数を返します。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(dictview)</code></dt>
<dd><p>辞書のキー、値、または (<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> のタプルとして表される) 項目に渡るイテレータを返します。</p>
<p>キーと値のリストはある任意の順序でイテレートされますが、ランダムではなく、 Python の実装によって変わり、辞書への挿入や削除の履歴に依存します。キー、値、要素のビューを通して、辞書の変更を挟まずにイテレートされたら、その要素の順序は完全に一致します。これにより、 <code class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></code> の対を <a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> で作成できます: <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code> 。同じリストを作成する他の方法は、 <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></code> です。</p>
<p>辞書の項目の追加や削除中にビューをイテレートすると、 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を送出したり、すべての項目に渡ってイテレートできなかったりします。</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in dictview</code></dt>
<dd><p><em>x</em> が元の辞書のキー、値、または項目 (項目の場合、 <em>x</em> は <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> タプルです) にあるとき <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<p>キーのビューは、項目が一意的でハッシュ可能であるという点で、集合に似ています。すべての値がハッシュ可能なら、 <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 対も一意的でハッシュ可能なので、要素のビューも集合に似ています。(値のビューは、要素が一般に一意的でないことから、集合に似ているとは考えられません。) 集合に似ているビューに対して、抽象基底クラス <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Set</span></code></a> で定義されている全ての演算 (例えば、 <code class="docutils literal"><span class="pre">==</span></code>、<code class="docutils literal"><span class="pre">&lt;</span></code>、<code class="docutils literal"><span class="pre">^</span></code>) が利用できます。</p>
<p>辞書ビューの使用法の例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys and values are iterated over in the same order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;eggs&#39;, &#39;bacon&#39;, &#39;sausage&#39;, &#39;spam&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;sausage&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;spam&#39;, &#39;bacon&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">,</span> <span class="s1">&#39;salad&#39;</span><span class="p">}</span>
<span class="go">{&#39;bacon&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">^</span> <span class="p">{</span><span class="s1">&#39;sausage&#39;</span><span class="p">,</span> <span class="s1">&#39;juice&#39;</span><span class="p">}</span>
<span class="go">{&#39;juice&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="context-manager-types">
<span id="typecontextmanager"></span><h2>4.11. コンテキストマネージャ型<a class="headerlink" href="#context-manager-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-48">Python の <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文は、コンテキストマネージャによって定義される実行時コンテキストの概念をサポートします。これは、文の本体が実行される前に進入し文の終わりで脱出する実行時コンテキストを、ユーザ定義クラスが定義できるようにする一対のメソッドで実装されます:</p>
<dl class="method">
<dt id="contextmanager.__enter__">
<code class="descclassname">contextmanager.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__enter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時コンテキストに入り、このオブジェクトまたは他の実行時コンテキストに関連したオブジェクトを返します。このメソッドが返す値はこのコンテキストマネージャによって <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節の識別子に束縛されます。</p>
<p>自分自身を返すコンテキストマネージャの例としてファイルオブジェクト (<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>) があります。ファイルオブジェクトは __enter__() から自分自身を返し、 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> が <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文のコンテキスト式として使われるようにします。</p>
<p>関連オブジェクトを返すコンテキストマネージャの例としては <a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">decimal.localcontext()</span></code></a> が返すものがあります。このマネージャはアクティブな10進数コンテキストをオリジナルのコンテキストのコピーにセットしてそのコピーを返します。こうすることで, <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の本体の内部で、外側のコードに影響を与えずに、 10進数コンテキストを変更できます。</p>
</dd></dl>

<dl class="method">
<dt id="contextmanager.__exit__">
<code class="descclassname">contextmanager.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__exit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>実行時コンテキストから抜け、(発生していた場合) 例外を抑制するかどうかを示すブール値フラグを返します。 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の本体の実行中に例外が発生した場合、引数にはその例外の型と値とトレースバック情報を渡します。そうでない場合、引数は全て <code class="docutils literal"><span class="pre">None</span></code> となります。</p>
<p>このメソッドから真値が返されると <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文は例外の発生を抑え、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の直後の文に実行を続けます。そうでなければ、このメソッドの実行を終えると例外の伝播が続きます。このメソッドの実行中に起きた例外は <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の本体の実行中に起こった例外を置き換えてしまいます。</p>
<p>渡された例外を明示的に再送出すべきではありません。その代わりに、このメソッドが偽の値を返すことでメソッドの正常終了と送出された例外を抑制しないことを伝えるべきです。このようにすればコンテキストマネージャは <a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッド自体が失敗したのかどうかを簡単に見分けることができます。</p>
</dd></dl>

<p>Python は、易しいスレッド同期、ファイルなどのオブジェクトの即時クローズ、アクティブな小数算術コンテキストの単純な操作をサポートするために、いくつかのコンテキストマネージャを用意しています。各型はコンテキスト管理プロトコルを実装しているという以上の特別の取り扱いを受けるわけではありません。例については <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールを参照してください。</p>
<p>Python のジェネレータ (<a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>) と <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a> デコレータ (<a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>) はこのプロトコルの簡便な実装方法を提供します。ジェネレータ関数を <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a> デコレータでデコレートすると、デコレートされないジェネレータ関数が作成するイテレータの代わりに、必要な <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> および <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドを実装したコンテキストマネージャを返すようになります。</p>
<p>これらのメソッドのために Python/C API の中の Python オブジェクトの型構造体に特別なスロットが作られたわけではないことに注意してください。これらのメソッドを定義したい拡張型はこれらを通常の Python からアクセスできるメソッドとして提供しなければなりません。実行時コンテキストを準備するオーバーヘッドに比べたら、一回のクラス辞書の探索のオーバーヘッドは無視できます。</p>
</div>
<div class="section" id="other-built-in-types">
<span id="typesother"></span><h2>4.12. その他の組み込み型<a class="headerlink" href="#other-built-in-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>インタプリタは、その他いくつかの種類のオブジェクトをサポートしています。これらのほとんどは 1 つまたは 2 つの演算だけをサポートしています。</p>
<div class="section" id="modules">
<span id="typesmodules"></span><h3>4.12.1. モジュール (module)<a class="headerlink" href="#modules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールに対する唯一の特殊な演算は属性アクセス: <code class="docutils literal"><span class="pre">m.name</span></code> です。ここで <em>m</em> はモジュールで、 <em>name</em> は <em>m</em> のシンボルテーブル上に定義された名前にアクセスします。モジュール属性に代入することもできます。 (なお、<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文は、厳密にいえば、モジュールオブジェクトに対する演算ではありません; <code class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></code> は <em>foo</em> と名づけられたモジュールオブジェクトの存在を必要とはせず、<em>foo</em> と名づけられたモジュールの (外部の) <em>定義</em> を必要とします。)</p>
<p>全てのモジュールにある特殊属性が <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> です。これはモジュールのシンボルテーブルを含む辞書です。この辞書を書き換えると実際にモジュールのシンボルテーブルを変更することができますが、<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性を直接代入することはできません (<code class="docutils literal"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></code> と書いて <code class="docutils literal"><span class="pre">m.a</span></code> を <code class="docutils literal"><span class="pre">1</span></code> に定義することはできますが、<code class="docutils literal"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></code> と書くことはできません)。 <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> を直接書き換えることは推奨されません。</p>
<p>インタプリタ内に組み込まれたモジュールは、 <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'sys'</span> <span class="pre">(built-in)&gt;</span></code> のように書かれます。ファイルから読み出された場合、 <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span> <span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></code> と書かれます。</p>
</div>
<div class="section" id="classes-and-class-instances">
<span id="typesobjects"></span><h3>4.12.2. クラスおよびクラスインスタンス<a class="headerlink" href="#classes-and-class-instances" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらについては <a class="reference internal" href="../reference/datamodel.html#objects"><span class="std std-ref">オブジェクト、値、および型</span></a> および <a class="reference internal" href="../reference/compound_stmts.html#class"><span class="std std-ref">クラス定義</span></a> を参照してください。</p>
</div>
<div class="section" id="functions">
<span id="typesfunctions"></span><h3>4.12.3. 関数<a class="headerlink" href="#functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>関数オブジェクトは関数定義によって生成されます。関数オブジェクトに対する唯一の操作は、それを呼び出すことです: <code class="docutils literal"><span class="pre">func(argument-list)</span></code> 。</p>
<p>関数オブジェクトには実際には二種類あります: 組み込み関数とユーザ定義関数です。どちらも同じ操作 (関数の呼び出し) をサポートしますが、実装は異なるので、オブジェクトの型も異なります。</p>
<p>詳細は、 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。</p>
</div>
<div class="section" id="methods">
<span id="typesmethods"></span><h3>4.12.4. メソッド<a class="headerlink" href="#methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-49">メソッドは属性表記を使って呼び出される関数です。メソッドには二種類あります: (リストの <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> のような) 組み込みメソッドと、クラスインスタンスのメソッドです。組み込みメソッドは、それをサポートする型と一緒に記述されています。</p>
<p>インスタンスを通してメソッド (クラスの名前空間内で定義された関数) にアクセスすると、特殊なオブジェクトが得られます。それは束縛メソッド (<em class="dfn">bound method</em>) オブジェクトで、インスタンスメソッド (<em class="dfn">instance method</em>) とも呼ばれます。呼び出された時、引数リストに <code class="docutils literal"><span class="pre">self</span></code> 引数が追加されます。束縛メソッドには 2 つの特殊読み出し専用属性があります。 <code class="docutils literal"><span class="pre">m.__self__</span></code> はそのメソッドが操作するオブジェクトで、 <code class="docutils literal"><span class="pre">m.__func__</span></code> はそのメソッドを実装している関数です。 <code class="docutils literal"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> の呼び出しは、 <code class="docutils literal"><span class="pre">m.__func__(m.__self__,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> の呼び出しと完全に等価です。</p>
<p>関数オブジェクトと同様に、メソッドオブジェクトは任意の属性の取得をサポートしています。しかし、メソッド属性は実際には下層の関数オブジェクト (<code class="docutils literal"><span class="pre">meth.__func__</span></code>) に記憶されているので、バインドされるメソッドにメソッド属性を設定することは許されていません。メソッドに属性を設定しようとすると <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。メソッドの属性を設定するためには、次のようにその下層の関数オブジェクトに明示的に設定する必要があります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>  <span class="c1"># can&#39;t set on the method</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;method&#39; object has no attribute &#39;whoami&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span>
<span class="go">&#39;my name is method&#39;</span>
</pre></div>
</div>
<p>詳細は、 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> を参照してください。</p>
</div>
<div class="section" id="code-objects">
<span id="bltin-code-objects"></span><span id="index-50"></span><h3>4.12.5. コードオブジェクト<a class="headerlink" href="#code-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-51">コードオブジェクトは、関数本体のような &quot;擬似コンパイルされた&quot; Python の実行可能コードを表すために実装系によって使われます。コードオブジェクトはグローバルな実行環境への参照を持たない点で関数オブジェクトとは異なります。コードオブジェクトは組み込み関数 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> によって返され、また関数オブジェクトの <code class="xref py py-attr docutils literal"><span class="pre">__code__</span></code> 属性として取り出せます。 <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a> モジュールも参照してください。</p>
<p id="index-52">コードオブジェクトは、組み込み関数 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> や <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> に (ソース文字列の代わりに) 渡すことで、実行や評価できます。</p>
<p>詳細は、 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> を参照してください。</p>
</div>
<div class="section" id="type-objects">
<span id="bltin-type-objects"></span><h3>4.12.6. 型オブジェクト<a class="headerlink" href="#type-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-53">型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は組み込み関数 <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> でアクセスされます。型オブジェクトには特有の操作はありません。標準モジュール <a class="reference internal" href="types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal"><span class="pre">types</span></code></a> には全ての組み込み型名が定義されています。</p>
<p>型はこのように書き表されます: <code class="docutils literal"><span class="pre">&lt;class</span> <span class="pre">'int'&gt;</span></code> 。</p>
</div>
<div class="section" id="the-null-object">
<span id="bltin-null-object"></span><h3>4.12.7. ヌルオブジェクト<a class="headerlink" href="#the-null-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは明示的に値を返さない関数によって返されます。このオブジェクトには特有の操作はありません。ヌルオブジェクトは一つだけで、 <code class="docutils literal"><span class="pre">None</span></code> (組み込み名) と名づけられています。 <code class="docutils literal"><span class="pre">type(None)()</span></code> は同じシングルトンを作成します。</p>
<p><code class="docutils literal"><span class="pre">None</span></code> と書き表されます。</p>
</div>
<div class="section" id="the-ellipsis-object">
<span id="bltin-ellipsis-object"></span><h3>4.12.8. Ellipsis オブジェクト<a class="headerlink" href="#the-ellipsis-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは一般にスライシングによって使われます (<a class="reference internal" href="../reference/expressions.html#slicings"><span class="std std-ref">スライス表記 (slicing)</span></a> を参照してください)。特殊な演算は何もサポートしていません。Ellipsis オブジェクトは一つだけで、その名前は <a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a> (組み込み名) です。<code class="docutils literal"><span class="pre">type(Ellipsis)()</span></code> は単一の <a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a> を作成します。</p>
<p><code class="docutils literal"><span class="pre">Ellipsis</span></code> または <code class="docutils literal"><span class="pre">...</span></code> と書き表されます。</p>
</div>
<div class="section" id="the-notimplemented-object">
<span id="bltin-notimplemented-object"></span><h3>4.12.9. NotImplemented オブジェクト<a class="headerlink" href="#the-notimplemented-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このオブジェクトは、対応していない型に対して比較演算や二項演算が求められたとき、それらの演算から返されます。詳細は <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">比較</span></a> を参照してください。 <code class="docutils literal"><span class="pre">NotImplemented</span></code> オブジェクトは一つだけです。 <code class="docutils literal"><span class="pre">type(NotImplemented)()</span></code> はこの単一のインスタンスを作成します。</p>
<p><code class="docutils literal"><span class="pre">NotImplemented</span></code> と書き表されます。</p>
</div>
<div class="section" id="boolean-values">
<span id="bltin-boolean-values"></span><h3>4.12.10. ブール値<a class="headerlink" href="#boolean-values" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ブール値は二つの定数オブジェクト <code class="docutils literal"><span class="pre">False</span></code> および <code class="docutils literal"><span class="pre">True</span></code> です。これらは真理値を表すのに使われます (ただし他の値も偽や真とみなされます)。 数値処理のコンテキスト (例えば算術演算子の引数として使われた場合) では、これらはそれぞれ 0 および 1 と同様に振舞います。任意の値に対して、真理値と解釈できる場合、組み込み関数 <a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a> は値をブール値に変換するのに使われます (上述の <a class="reference internal" href="#truth"><span class="std std-ref">真理値判定</span></a> の節を参照してください)。</p>
<p id="index-54">それぞれ <code class="docutils literal"><span class="pre">False</span></code> および <code class="docutils literal"><span class="pre">True</span></code> と書き表されます。</p>
</div>
<div class="section" id="internal-objects">
<span id="typesinternal"></span><h3>4.12.11. 内部オブジェクト<a class="headerlink" href="#internal-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この情報は <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> を参照してください。スタックフレームオブジェクト、トレースバックオブジェクト、スライスオブジェクトについて記述されています。</p>
</div>
</div>
<div class="section" id="special-attributes">
<span id="specialattrs"></span><h2>4.13. 特殊属性<a class="headerlink" href="#special-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>実装は、いくつかのオブジェクト型に対して、適切な場合には特殊な読み出し専用の属性を追加します。そのうちいくつかは <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> 組込み関数で報告されません。</p>
<dl class="attribute">
<dt id="object.__dict__">
<code class="descclassname">object.</code><code class="descname">__dict__</code><a class="headerlink" href="#object.__dict__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの (書き込み可能な) 属性を保存するために使われる辞書またはその他のマッピングオブジェクトです。</p>
</dd></dl>

<dl class="attribute">
<dt id="instance.__class__">
<code class="descclassname">instance.</code><code class="descname">__class__</code><a class="headerlink" href="#instance.__class__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスインスタンスが属しているクラスです。</p>
</dd></dl>

<dl class="attribute">
<dt id="class.__bases__">
<code class="descclassname">class.</code><code class="descname">__bases__</code><a class="headerlink" href="#class.__bases__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスオブジェクトの基底クラスのタプルです。</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__name__">
<code class="descclassname">definition.</code><code class="descname">__name__</code><a class="headerlink" href="#definition.__name__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス、関数、メソッド、デスクリプタ、ジェネレータインスタンスの名前です。</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__qualname__">
<code class="descclassname">definition.</code><code class="descname">__qualname__</code><a class="headerlink" href="#definition.__qualname__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス、関数、メソッド、デスクリプタ、ジェネレータインスタンスの <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">修飾名</span></a> です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="class.__mro__">
<code class="descclassname">class.</code><code class="descname">__mro__</code><a class="headerlink" href="#class.__mro__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性はメソッドの解決時に基底クラスを探索するときに考慮されるクラスのタプルです。</p>
</dd></dl>

<dl class="method">
<dt id="class.mro">
<code class="descclassname">class.</code><code class="descname">mro</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.mro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、メタクラスによって、そのインスタンスのメソッド解決の順序をカスタマイズするために、上書きされるかも知れません。このメソッドはクラスのインスタンス化時に呼ばれ、その結果は <a class="reference internal" href="#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal"><span class="pre">__mro__</span></code></a> に格納されます。</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasses__">
<code class="descclassname">class.</code><code class="descname">__subclasses__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasses__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>それぞれのクラスは、それ自身の直接のサブクラスへの弱参照を保持します。このメソッドはそれらの参照のうち、生存しているもののリストを返します。例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class &#39;bool&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>これらの特殊なメソッドのさらなる情報については、 Python リファレンスマニュアル (<a class="reference internal" href="../reference/datamodel.html#customization"><span class="std std-ref">基本的なカスタマイズ</span></a>) を参照してください。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>この結果として、リスト <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></code> は <code class="docutils literal"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code> と等しいと見なされます。タプルの場合も同様です。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>パーザが演算対象の型を識別できるようにするために、このような優先順位でなければならないのです。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>, <a class="fn-backref" href="#id9">4</a>)</em> 大小文字の区別のある文字とは、一般カテゴリプロパティが &quot;Lu&quot; (Letter, uppercase (大文字))、 &quot;Ll&quot; (Letter, lowercase (小文字))、 &quot;Lt&quot; (Letter、titlecase (先頭が大文字)) のいずれかであるものです。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> 従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯一の要素とする単一のタプルを <em>values</em> に与えなくてはなりません。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. 組み込み型</a><ul>
<li><a class="reference internal" href="#truth-value-testing">4.1. 真理値判定</a></li>
<li><a class="reference internal" href="#boolean-operations-and-or-not">4.2. ブール演算 — <code class="docutils literal"><span class="pre">and</span></code>, <code class="docutils literal"><span class="pre">or</span></code>, <code class="docutils literal"><span class="pre">not</span></code></a></li>
<li><a class="reference internal" href="#comparisons">4.3. 比較</a></li>
<li><a class="reference internal" href="#numeric-types-int-float-complex">4.4. 数値型 <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">complex</span></code></a><ul>
<li><a class="reference internal" href="#bitwise-operations-on-integer-types">4.4.1. 整数型におけるビット単位演算</a></li>
<li><a class="reference internal" href="#additional-methods-on-integer-types">4.4.2. 整数型における追加のメソッド</a></li>
<li><a class="reference internal" href="#additional-methods-on-float">4.4.3. 浮動小数点数に対する追加のメソッド</a></li>
<li><a class="reference internal" href="#hashing-of-numeric-types">4.4.4. 数値型のハッシュ化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-types">4.5. イテレータ型</a><ul>
<li><a class="reference internal" href="#generator-types">4.5.1. ジェネレータ型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-types-list-tuple-range">4.6. シーケンス型 — <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">range</span></code></a><ul>
<li><a class="reference internal" href="#common-sequence-operations">4.6.1. 共通のシーケンス演算</a></li>
<li><a class="reference internal" href="#immutable-sequence-types">4.6.2. イミュータブルなシーケンス型</a></li>
<li><a class="reference internal" href="#mutable-sequence-types">4.6.3. ミュータブルなシーケンス型</a></li>
<li><a class="reference internal" href="#lists">4.6.4. リスト型 (list)</a></li>
<li><a class="reference internal" href="#tuples">4.6.5. タプル型 (tuple)</a></li>
<li><a class="reference internal" href="#ranges">4.6.6. range</a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-sequence-type-str">4.7. テキストシーケンス型 — <code class="docutils literal"><span class="pre">str</span></code></a><ul>
<li><a class="reference internal" href="#string-methods">4.7.1. 文字列メソッド</a></li>
<li><a class="reference internal" href="#printf-style-string-formatting">4.7.2. <code class="docutils literal"><span class="pre">printf</span></code> 形式の文字列書式化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-sequence-types-bytes-bytearray-memoryview">4.8. バイナリシーケンス型 — <code class="docutils literal"><span class="pre">bytes</span></code>, <code class="docutils literal"><span class="pre">bytearray</span></code>, <code class="docutils literal"><span class="pre">memoryview</span></code></a><ul>
<li><a class="reference internal" href="#bytes-objects">4.8.1. バイトオブジェクト</a></li>
<li><a class="reference internal" href="#bytearray-objects">4.8.2. bytearray オブジェクト</a></li>
<li><a class="reference internal" href="#bytes-and-bytearray-operations">4.8.3. bytes と bytearray の操作</a></li>
<li><a class="reference internal" href="#printf-style-bytes-formatting">4.8.4. <code class="docutils literal"><span class="pre">printf</span></code> 形式での bytes の書式化</a></li>
<li><a class="reference internal" href="#memory-views">4.8.5. メモリビュー</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types-set-frozenset">4.9. set（集合）型 — <code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code></a></li>
<li><a class="reference internal" href="#mapping-types-dict">4.10. マッピング型 — <code class="docutils literal"><span class="pre">dict</span></code></a><ul>
<li><a class="reference internal" href="#dictionary-view-objects">4.10.1. 辞書ビューオブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-manager-types">4.11. コンテキストマネージャ型</a></li>
<li><a class="reference internal" href="#other-built-in-types">4.12. その他の組み込み型</a><ul>
<li><a class="reference internal" href="#modules">4.12.1. モジュール (module)</a></li>
<li><a class="reference internal" href="#classes-and-class-instances">4.12.2. クラスおよびクラスインスタンス</a></li>
<li><a class="reference internal" href="#functions">4.12.3. 関数</a></li>
<li><a class="reference internal" href="#methods">4.12.4. メソッド</a></li>
<li><a class="reference internal" href="#code-objects">4.12.5. コードオブジェクト</a></li>
<li><a class="reference internal" href="#type-objects">4.12.6. 型オブジェクト</a></li>
<li><a class="reference internal" href="#the-null-object">4.12.7. ヌルオブジェクト</a></li>
<li><a class="reference internal" href="#the-ellipsis-object">4.12.8. Ellipsis オブジェクト</a></li>
<li><a class="reference internal" href="#the-notimplemented-object">4.12.9. NotImplemented オブジェクト</a></li>
<li><a class="reference internal" href="#boolean-values">4.12.10. ブール値</a></li>
<li><a class="reference internal" href="#internal-objects">4.12.11. 内部オブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-attributes">4.13. 特殊属性</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="constants.html"
                        title="前の章へ">3. 組み込み定数</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="exceptions.html"
                        title="次の章へ">5. 組み込み例外</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/stdtypes.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="5. 組み込み例外"
             >次へ</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 組み込み定数"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 6月 26, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>