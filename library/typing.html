
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>26.1. typing — 型ヒントのサポート &#8212; Python 3.6.4 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="26.2. pydoc — ドキュメント生成とオンラインヘルプシステム" href="pydoc.html" />
    <link rel="prev" title="26. 開発ツール" href="development.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/typing.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/typing.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="26.2. pydoc — ドキュメント生成とオンラインヘルプシステム"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="development.html" title="26. 開発ツール"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.4</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">26. 開発ツール</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-typing">
<span id="typing-support-for-type-hints"></span><h1>26.1. <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see PEP 484)."><code class="xref py py-mod docutils literal"><span class="pre">typing</span></code></a> — 型ヒントのサポート<a class="headerlink" href="#module-typing" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">typing モジュールは <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">暫定的に</span></a> 標準ライブラリに追加されました。マイナーリリースの間でもコアデベロッパーが必要だと判断した場合は、新機能の追加や API の変更がなされることがあります。</p>
</div>
<hr class="docutils" />
<p>このモジュールは <span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> と <span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> によって規定された型ヒントをサポートします。最も基本的なサポートとして <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a>、 <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal"><span class="pre">Union</span></code></a>、 <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal"><span class="pre">Tuple</span></code></a>、 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal"><span class="pre">Callable</span></code></a>、 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal"><span class="pre">TypeVar</span></code></a> および <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a> 型を含みます。完全な仕様は <span class="target" id="index-24"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> を参照してください。型ヒントの簡単な導入は <span class="target" id="index-25"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a> を参照してください。</p>
<p>以下の関数は文字列を受け取って文字列を返す関数で、次のようにアノテーションがつけられます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello &#39;</span> <span class="o">+</span> <span class="n">name</span>
</pre></div>
</div>
<p>関数 <code class="docutils literal"><span class="pre">greeting</span></code> で、実引数 <code class="docutils literal"><span class="pre">name</span></code> の型は <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> であり、返り値の型は <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> であることが期待されます。サブタイプも実引数として許容されます。</p>
<div class="section" id="type-aliases">
<h2>26.1.1. 型エイリアス<a class="headerlink" href="#type-aliases" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>型エイリアスは型をエイリアスに代入することで定義されます。この例では <code class="docutils literal"><span class="pre">Vector</span></code> と <code class="docutils literal"><span class="pre">List[float]</span></code> は交換可能な同義語として扱われます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span>
<span class="n">Vector</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># typechecks; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>型エイリアスは複雑な型シグネチャを単純化するのに有用です。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>型ヒントとしての <code class="docutils literal"><span class="pre">None</span></code> は特別なケースであり、 <code class="docutils literal"><span class="pre">type(None)</span></code> によって置き換えられます。</p>
</div>
<div class="section" id="newtype">
<span id="distinct"></span><h2>26.1.2. NewType<a class="headerlink" href="#newtype" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>異なる型を作るためには <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal"><span class="pre">NewType()</span></code></a> ヘルパー関数を使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>静的型検査器は新しい型を元々の型のサブクラスのように扱います。このことは論理的な誤りを見つけることを支援するのに有用です。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># typechecks</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># does not typecheck; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">UserId</span></code> 型の変数についても全ての <code class="docutils literal"><span class="pre">int</span></code> についての演算を行うことが出来ます、しかしその結果は常に <code class="docutils literal"><span class="pre">int</span></code> 型になります。これは <code class="docutils literal"><span class="pre">int</span></code> が期待されるところに <code class="docutils literal"><span class="pre">UserId</span></code> を渡すことを許します、しかし誤った方法で <code class="docutils literal"><span class="pre">UserId</span></code> を作ってしまうことを防ぎます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>これらのチェックは静的型検査器のみによって強制されるということに注意してください。実行時に <code class="docutils literal"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> という文は渡された仮引数をただちに返す <code class="docutils literal"><span class="pre">Derived</span></code> 関数を作ります。つまり <code class="docutils literal"><span class="pre">Derived(some_value)</span></code> という式は新しいクラスを作ることはなく、通常の関数呼び出し以上のオーバーヘッドがないということを意味します。</p>
<p>より正確に言うと、式 <code class="docutils literal"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> は実行時に常に真を返します。</p>
<p>This also means that it is not possible to create a subtype of <code class="docutils literal"><span class="pre">Derived</span></code>
since it is an identity function at runtime, not an actual type:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not typecheck</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>However, it is possible to create a <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal"><span class="pre">NewType()</span></code></a> based on a 'derived' <code class="docutils literal"><span class="pre">NewType</span></code>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>and typechecking for <code class="docutils literal"><span class="pre">ProUserId</span></code> will work as expected.</p>
<p>詳細は <span class="target" id="index-26"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> を参照。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>型エイリアスの使用は二つの型が互いに <em>等価</em> だと宣言している、ということを思い出してください。 <code class="docutils literal"><span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> とすると、静的型検査器は <code class="docutils literal"><span class="pre">Alias</span></code> をすべての場合において <code class="docutils literal"><span class="pre">Original</span></code> と <em>完全に等価</em> なものとして扱います。これは複雑な型シグネチャを単純化したい時に有用です。</p>
<p class="last">これに対し、 <code class="docutils literal"><span class="pre">NewType</span></code> はある型をもう一方の型の <em>サブタイプ</em> として宣言します。 <code class="docutils literal"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> とすると静的型検査器は <code class="docutils literal"><span class="pre">Derived</span></code> を <code class="docutils literal"><span class="pre">Original</span></code> の <em>サブクラス</em> として扱います。つまり <code class="docutils literal"><span class="pre">Original</span></code> 型の値は <code class="docutils literal"><span class="pre">Derived</span></code> 型の値が期待される場所で使うことが出来ないということです。これは論理的な誤りを最小の実行時のコストで防ぎたい時に有用です。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.2 で追加.</span></p>
</div>
</div>
<div class="section" id="callable">
<h2>26.1.3. 呼び出し可能オブジェクト<a class="headerlink" href="#callable" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>特定のシグネチャのコールバック関数であることが期待されるフレームワークでは <code class="docutils literal"><span class="pre">Callable[[Arg1Type,</span> <span class="pre">Arg2Type],</span> <span class="pre">ReturnType]</span></code> のように使って型ヒントを与えられます。</p>
<p>例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>
</pre></div>
</div>
<p>型ヒントの実引数の型を ellipsis で置き換えることで呼び出しシグニチャを指定せずに callable の戻り値の型を宣言することができます: <code class="docutils literal"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>。</p>
</div>
<div class="section" id="generics">
<h2>26.1.4. ジェネリクス<a class="headerlink" href="#generics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>コンテナ内のオブジェクトについての型情報は一般的な方法では静的に推論出来ないため、抽象基底クラスが拡張され、コンテナの要素に対して期待される型を示すために添字表記をサポートするようになりました。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>ジェネリクスは <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal"><span class="pre">TypeVar</span></code></a> と呼ばれる typing で利用できる新しいファクトリを使ってパラメータ化することができます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># Generic function</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="user-defined-generic-types">
<h2>26.1.5. ユーザー定義のジェネリック型<a class="headerlink" href="#user-defined-generic-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユーザー定義のクラスはジェネリッククラスとして定義できます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Generic[T]</span></code> を基底クラスとすることで <code class="docutils literal"><span class="pre">LoggedVar</span></code> クラスは一つの型引数 <code class="docutils literal"><span class="pre">T</span></code> をとることを定義します。これはまたこのクラスの中で <code class="docutils literal"><span class="pre">T</span></code> を型として有効にします。</p>
<p>基底クラス <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a> は <code class="docutils literal"><span class="pre">LoggedVar[t]</span></code> が型として有効になるように <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> を定義したメタクラスを利用します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>ジェネリック型は任意の数の型変数をとることが出来ます、また型変数に制約をつけることが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StrangePair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a> の引数のそれぞれの型変数は別のものでなければなりません。このため次は無効です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a> を用いて多重継承することが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sized</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>ジェネリッククラスを継承するとき、いくつかの型変数を固定することが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>この場合では <code class="docutils literal"><span class="pre">MyDict</span></code> は一つの仮引数 <code class="docutils literal"><span class="pre">T</span></code> をとります。</p>
<p>型引数を指定せずにジェネリッククラスを使う場合、それぞれの型引数に <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> を与えられたものとして扱います。
次の例では、<code class="docutils literal"><span class="pre">MyIterable</span></code> はジェネリックではありませんが <code class="docutils literal"><span class="pre">Iterable[Any]</span></code> を暗黙的に継承しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
</pre></div>
</div>
<p>ユーザ定義のジェネリック型エイリアスもサポートされています。例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>

<span class="c1"># Return type here is same as Union[Iterable[str], int]</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[Tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal"><span class="pre">Generic</span></code></a> に用いられているメタクラスは <a class="reference internal" href="abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal"><span class="pre">abc.ABCMeta</span></code></a> のサブクラスです。
ジェネリッククラスは抽象メソッドや抽象プロパティを含めることで抽象基底クラスになれ、ジェネリッククラスはメタクラスの衝突を起こすことなく基底クラスに抽象基底クラスをとれます。
ジェネリックメタクラスはサポートされません。
パラメータ化を行うジェネリクスの結果はキャッシュされていて、 typing モジュールのほとんどの型はハッシュ化でき、等価比較できます。</p>
</div>
<div class="section" id="the-any-type">
<h2>26.1.6. <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> 型<a class="headerlink" href="#the-any-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> は特別な種類の型です。静的型検査器はすべての型を <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> と互換として扱い、 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> をすべての型と互換として扱います。</p>
<p>つまり、 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> 型の値に対し任意の演算やメソッド呼び出しができ、任意の変数に代入できるということです。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span>

<span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># type: Any</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>       <span class="c1"># OK</span>

<span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>      <span class="c1"># type: str</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>       <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> 型の値をより詳細な型に代入する時に型検査が行われないことに注意してください。例えば、静的型検査器は <code class="docutils literal"><span class="pre">a</span></code> を <code class="docutils literal"><span class="pre">s</span></code> に代入する時、<code class="docutils literal"><span class="pre">s</span></code> が <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 型として宣言されていて実行時に <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> の値を受け取るとしても、エラーを報告しません。</p>
<p>さらに、返り値や引数の型のないすべての関数は暗黙的に <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> を使用します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>この挙動により、動的型付けと静的型付けが混在したコードを書かなければならない時に <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> を <em>非常口</em> として使用することができます。</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> の挙動と <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> の挙動を対比しましょう。 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> と同様に、すべての型は <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> のサブタイプです。しかしながら、 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> と異なり、逆は成り立ちません: <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> はすべての他の型のサブタイプでは <em>ありません</em>。</p>
<p>これは、ある値の型が <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> のとき、型検査器はこれについてのほとんどすべての操作を拒否し、これをより特殊化された変数に代入する (または返り値として利用する) ことは型エラーになることを意味します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Typechecks, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Typechecks, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> は、ある値が型安全な方法で任意の型として使えることを示すために使用します。 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> はある値が動的に型付けられることを示すために使用します。</p>
</div>
<div class="section" id="classes-functions-and-decorators">
<h2>26.1.7. クラス、関数、およびデコレータ<a class="headerlink" href="#classes-functions-and-decorators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールでは以下のクラス、関数とデコレータを定義します:</p>
<dl class="class">
<dt id="typing.TypeVar">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">TypeVar</code><a class="headerlink" href="#typing.TypeVar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>型変数です。</p>
<p>使い方:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be str or bytes</span>
</pre></div>
</div>
<p>型変数は主として静的型検査器のために存在します。型変数はジェネリック型やジェネリック関数の定義の引数として役に立ちます。ジェネリック型についての詳細は Generic クラスを参照してください。ジェネリック関数は以下のように動作します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the longest of two strings.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>後者の例のシグネチャは本質的に <code class="docutils literal"><span class="pre">(str,</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></code> と <code class="docutils literal"><span class="pre">(bytes,</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">bytes</span></code> のオーバーロードです。もし引数が <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> のサブクラスのインスタンスの場合、返り値は普通の <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> であることに注意して下さい。</p>
<p>実行時に、<code class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> は <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出するでしょう。一般的に、<a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> は型に対して使用するべきではありません。</p>
<p>型変数は <code class="docutils literal"><span class="pre">covariant=True</span></code> または <code class="docutils literal"><span class="pre">contravariant=True</span></code> を渡すことによって共変または反変であることを示せます。詳細は <span class="target" id="index-27"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> を参照して下さい。デフォルトの型変数は不変です。あるいは、型変数は <code class="docutils literal"><span class="pre">bound=&lt;type&gt;</span></code> を使うことで上界を指定することが出来ます。これは、型変数に (明示的または非明示的に) 代入された実際の型が境界の型のサブクラスでなければならないということを意味します、<span class="target" id="index-28"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> も参照。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Generic">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generic</code><a class="headerlink" href="#typing.Generic" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネリック型のための抽象基底クラスです。</p>
<p>ジェネリック型は典型的にはこのクラスを1つ以上の型変数によってインスタンス化したものを継承することによって宣言されます。例えば、ジェネリックマップ型は次のように定義することが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p>このクラスは次のように使用することが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Type">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Type</code><span class="sig-paren">(</span><em>Generic[CT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">C</span></code> と注釈が付けされた変数は <code class="docutils literal"><span class="pre">C</span></code> 型の値を受理します。一方で <code class="docutils literal"><span class="pre">Type[C]</span></code> と注釈が付けられた変数は、そのクラス自身を受理します – 具体的には、それは <code class="docutils literal"><span class="pre">C</span></code> の <em>クラスオブジェクト</em> を受理します。例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type &#39;int&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type &#39;Type[int]&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type &#39;Type[int]&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Type[C]</span></code> は共変であることに注意してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">BasicUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># Accepts User, BasicUser, ProUser, TeamUser, ...</span>
<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Type[C]</span></code> が共変だということは、 <code class="docutils literal"><span class="pre">C</span></code> の全てのサブクラスは、 <code class="docutils literal"><span class="pre">C</span></code> と同じシグネチャのコンストラクタとクラスメソッドを実装すべきだということになります。
型チェッカーはこの規則への違反に印を付けるべきですが、サブクラスでのコンストラクタ呼び出しで、指定された基底クラスのコンストラクタ呼び出しに適合するものは許可すべきです。
この特別な場合を型チェッカーがどう扱うべきかについては、 <span class="target" id="index-29"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> の将来のバージョンで変更されるかもしれません。</p>
<p><a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal"><span class="pre">Type</span></code></a> で許されているパラメータは、クラスかクラスのユニオン型か <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> です。
例えば次のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">BaseUser</span><span class="p">,</span> <span class="n">ProUser</span><span class="p">]]):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Type[Any]</span></code> は <code class="docutils literal"><span class="pre">Type</span></code> と等価で、同様に <code class="docutils literal"><span class="pre">Type</span></code> は <code class="docutils literal"><span class="pre">type</span></code> と等価です。<code class="docutils literal"><span class="pre">type</span></code> は Python のメタクラス階層のルートです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Iterable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Iterable</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Iterator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterator</code><span class="sig-paren">(</span><em>Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Iterator</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Reversible">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Reversible</code><span class="sig-paren">(</span><em>Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Reversible</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsInt">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsInt</code><a class="headerlink" href="#typing.SupportsInt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>抽象メソッド <code class="docutils literal"><span class="pre">__int__</span></code> を備えた ABC です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsFloat">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsFloat</code><a class="headerlink" href="#typing.SupportsFloat" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>抽象メソッド <code class="docutils literal"><span class="pre">__float__</span></code> を備えた ABC です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsComplex">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsComplex</code><a class="headerlink" href="#typing.SupportsComplex" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>抽象メソッド <code class="docutils literal"><span class="pre">__complex__</span></code> を備えた ABC です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsBytes">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsBytes</code><a class="headerlink" href="#typing.SupportsBytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>抽象メソッド <code class="docutils literal"><span class="pre">__bytes__</span></code> を備えた ABC です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsAbs">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsAbs</code><a class="headerlink" href="#typing.SupportsAbs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返り値の型と共変な抽象メソッド <code class="docutils literal"><span class="pre">__abs__</span></code> を備えた ABC です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsRound">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsRound</code><a class="headerlink" href="#typing.SupportsRound" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返り値の型と共変な抽象メソッド <code class="docutils literal"><span class="pre">__round__</span></code> を備えた ABC です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Container">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Container</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Container</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Hashable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Hashable</code><a class="headerlink" href="#typing.Hashable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Hashable</span></code></a> へのエイリアス</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sized">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Sized</code><a class="headerlink" href="#typing.Sized" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sized</span></code></a> へのエイリアス</p>
</dd></dl>

<dl class="class">
<dt id="typing.Collection">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Collection</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Collection</span></code></a> のジェネリック版です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AbstractSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AbstractSet</code><span class="sig-paren">(</span><em>Sized, Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Set</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSet</code><span class="sig-paren">(</span><em>AbstractSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSet</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Mapping">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Mapping</code><span class="sig-paren">(</span><em>Sized, Collection[KT], Generic[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Mapping</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableMapping">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableMapping</code><span class="sig-paren">(</span><em>Mapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableMapping</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sequence">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Sequence</code><span class="sig-paren">(</span><em>Reversible[T_co], Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSequence">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSequence</code><span class="sig-paren">(</span><em>Sequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSequence</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ByteString">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ByteString</code><span class="sig-paren">(</span><em>Sequence[int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.ByteString</span></code></a> のジェネリック版です。</p>
<p>この型は <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> と <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 、 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> を表します。</p>
<p>この型の省略形として、 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> を上に挙げた任意の型の引数にアノテーションをつけることに使えます。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Deque">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Deque</code><span class="sig-paren">(</span><em>deque, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal"><span class="pre">collections.deque</span></code></a> のジェネリック版です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.List">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">List</code><span class="sig-paren">(</span><em>list, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> のジェネリック版です。返り値の型のアノテーションをつけることに便利です。引数にアノテーションをつけるためには、<a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal"><span class="pre">Mapping</span></code></a> や <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal"><span class="pre">Sequence</span></code></a> 、 <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal"><span class="pre">AbstractSet</span></code></a> のような抽象コレクション型を使うことが好ましいです。</p>
<p>この型は以下のように使うことが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Set">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Set</code><span class="sig-paren">(</span><em>set, MutableSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">builtins.set</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.FrozenSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">FrozenSet</code><span class="sig-paren">(</span><em>frozenset, AbstractSet[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">builtins.frozenset</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.MappingView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MappingView</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MappingView</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.KeysView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">KeysView</code><span class="sig-paren">(</span><em>MappingView[KT_co], AbstractSet[KT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.KeysView</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ItemsView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ItemsView</code><span class="sig-paren">(</span><em>MappingView, Generic[KT_co, VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.ItemsView</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ValuesView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ValuesView</code><span class="sig-paren">(</span><em>MappingView[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.ValuesView</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Awaitable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Awaitable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Awaitable</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Coroutine">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Coroutine</code><span class="sig-paren">(</span><em>Awaitable[V_co], Generic[T_co T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Coroutine</span></code></a> のジェネリック版です。
変性と型変数の順序は <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal"><span class="pre">Generator</span></code></a> のものと対応しています。例えば次のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Coroutine</span>
<span class="n">c</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># type: Coroutine[List[str], str, int]</span>
<span class="o">...</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span> <span class="c1"># type: List[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span> <span class="c1"># type: int</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncIterable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.AsyncIterable</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncIterator</code><span class="sig-paren">(</span><em>AsyncIterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.AsyncIterator</span></code></a> のジェネリック版です。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ContextManager">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ContextManager</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.AbstractContextManager</span></code></a> のジェネリック版です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Dict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Dict</code><span class="sig-paren">(</span><em>dict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のジェネリック版です。この型の使い方は以下の通りです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.DefaultDict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">DefaultDict</code><span class="sig-paren">(</span><em>collections.defaultdict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal"><span class="pre">collections.defaultdict</span></code></a> のジェネリック版です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Counter">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Counter</code><span class="sig-paren">(</span><em>collections.Counter, Dict[T, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal"><span class="pre">collections.Counter</span></code></a> のジェネリック版です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ChainMap">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ChainMap</code><span class="sig-paren">(</span><em>collections.ChainMap, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal"><span class="pre">collections.ChainMap</span></code></a> のジェネリック版です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6.1 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Generator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generator</code><span class="sig-paren">(</span><em>Iterator[T_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータはジェネリック型 <code class="docutils literal"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code> によってアノテーションを付けられます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>typing モジュールの多くの他のジェネリクスと違い <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal"><span class="pre">Generator</span></code></a> の <code class="docutils literal"><span class="pre">SendType</span></code> は共変や不変ではなく、反変として扱われることに注意してください。</p>
<p>もしジェネレータが値を返すだけの場合は、 <code class="docutils literal"><span class="pre">SendType</span></code> と <code class="docutils literal"><span class="pre">ReturnType</span></code> に <code class="docutils literal"><span class="pre">None</span></code> を設定してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>代わりに、ジェネレータを <code class="docutils literal"><span class="pre">Iterable[YieldType]</span></code> や <code class="docutils literal"><span class="pre">Iterator[YieldType]</span></code> という返り値の型でアノテーションをつけることもできます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncGenerator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncGenerator</code><span class="sig-paren">(</span><em>AsyncIterator[T_co], Generic[T_co, T_contra]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>非同期ジェネレータはジェネリック型 <code class="docutils literal"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code> によってアノテーションを付けられます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>通常のジェネレータと違って非同期ジェネレータは値を返せないので、<code class="docutils literal"><span class="pre">ReturnType</span></code> 型引数はありません。<a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal"><span class="pre">Generator</span></code></a> と同様に、<code class="docutils literal"><span class="pre">SendType</span></code> は反変的に振る舞います。</p>
<p>ジェネレータが値を yield するだけなら、<code class="docutils literal"><span class="pre">SendType</span></code> を <code class="docutils literal"><span class="pre">None</span></code> にします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>あるいは、ジェネレータが <code class="docutils literal"><span class="pre">AsyncIterable[YieldType]</span></code> と <code class="docutils literal"><span class="pre">AsyncIterator[YieldType]</span></code> のいずれかの戻り値型を持つとアノテートします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Text">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Text</code><a class="headerlink" href="#typing.Text" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">Text</span></code> は <code class="docutils literal"><span class="pre">str</span></code> のエイリアスです。これは Python 2 のコードの前方互換性を提供するために設けられています: Python 2 では <code class="docutils literal"><span class="pre">Text</span></code> は <code class="docutils literal"><span class="pre">unicode</span></code> のエイリアスです。</p>
<p><code class="docutils literal"><span class="pre">Text</span></code> は Python 2 と Python 3 の両方と互換性のある方法で値が unicode 文字列を含んでいなければならない場合に使用してください。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.io">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">io</code><a class="headerlink" href="#typing.io" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>I/O ストリーム型のためのラッパー名前空間です。</p>
<p>This defines the generic type <code class="docutils literal"><span class="pre">IO[AnyStr]</span></code> and subclasses <code class="docutils literal"><span class="pre">TextIO</span></code>
and <code class="docutils literal"><span class="pre">BinaryIO</span></code>, deriving from <code class="docutils literal"><span class="pre">IO[str]</span></code> and <code class="docutils literal"><span class="pre">IO[bytes]</span></code>,
respectively. These represent the types of I/O streams such as returned by
<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>.</p>
<p>これらの型は <code class="docutils literal"><span class="pre">typing.IO</span></code>, <code class="docutils literal"><span class="pre">typing.TextIO</span></code>, <code class="docutils literal"><span class="pre">typing.BinaryIO</span></code> のように直接アクセスすることもできます。</p>
</dd></dl>

<dl class="class">
<dt id="typing.re">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">re</code><a class="headerlink" href="#typing.re" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>正規表現のマッチング型のための名前空間です。</p>
<p>これは <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal"><span class="pre">re.compile()</span></code></a> と <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal"><span class="pre">re.match()</span></code></a> の返り値の型に対応する型エイリアス <code class="docutils literal"><span class="pre">Pattern</span></code> と <code class="docutils literal"><span class="pre">Match</span></code> を定義します。これらの型 (と対応する関数) は <code class="docutils literal"><span class="pre">AnyStr</span></code> についてジェネリックで、<code class="docutils literal"><span class="pre">Pattern[str]</span></code> や <code class="docutils literal"><span class="pre">Pattern[bytes]</span></code> 、 <code class="docutils literal"><span class="pre">Match[str]</span></code> 、 <code class="docutils literal"><span class="pre">Match[bytes]</span></code> のように書くことで具体的にすることが出来ます。</p>
<p>これらの型は <code class="docutils literal"><span class="pre">typing.Pattern</span></code>, <code class="docutils literal"><span class="pre">typing.Match</span></code> のように直接アクセスすることもできます。</p>
</dd></dl>

<dl class="class">
<dt id="typing.NamedTuple">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">NamedTuple</code><a class="headerlink" href="#typing.NamedTuple" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>namedtuple の型付き版です。</p>
<p>使い方:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>これは次と等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>フィールドにデフォルト値を与えるにはクラス本体で代入してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>デフォルト値のあるフィールドはデフォルト値のないフィールドの後でなければなりません。</p>
<p>結果としてできるクラスは二つの追加の属性を持ちます。一つは <code class="docutils literal"><span class="pre">_field_types</span></code> で、フィールド名を型に結びつける辞書です。
もう一つは <code class="docutils literal"><span class="pre">_field_defaults</span></code> で、フィールド名をデフォルト値に結びつける辞書です。
(フィールド名は namedtuple API の一つである <code class="docutils literal"><span class="pre">_fields</span></code> 属性にあります。)</p>
<p><code class="docutils literal"><span class="pre">NamedTuple</span></code> のサブクラスは docstring やメソッドも持てます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{self.name}</span><span class="s1">, id=</span><span class="si">{self.id}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>後方互換な使用法:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><span class="target" id="index-30"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 変数アノテーションのシンタックスが追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6.1 で変更: </span>デフォルト値、メソッド、ドキュメンテーション文字列への対応が追加されました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.NewType">
<code class="descclassname">typing.</code><code class="descname">NewType</code><span class="sig-paren">(</span><em>typ</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>異なる型であることを型チェッカーに教えるためのヘルパー関数です。
<a class="reference internal" href="#distinct"><span class="std std-ref">NewType</span></a> を参照してください。
実行時には、その引数を返す関数を返します。
使い方は次のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.cast">
<code class="descclassname">typing.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>typ</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値をある型にキャストします。</p>
<p>これは値を変更せずに返します。型検査器にこれは返り値の型が指定された型を持っていることを知らせますが、故意に実行時に何も検査しません。(これを出来る限り速く行いたかったのです。)</p>
</dd></dl>

<dl class="function">
<dt id="typing.get_type_hints">
<code class="descclassname">typing.</code><code class="descname">get_type_hints</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数、メソッド、モジュールまたはクラスのオブジェクトの型ヒントを含む辞書を返します。</p>
<p>この辞書はたいてい <code class="docutils literal"><span class="pre">obj.__annotations__</span></code> と同じものです。
それに加えて、文字列リテラルにエンコードされた順方向参照は <code class="docutils literal"><span class="pre">globals</span></code> 名前空間および <code class="docutils literal"><span class="pre">locals</span></code> 名前空間で評価されます。
必要であれば、 <code class="docutils literal"><span class="pre">None</span></code> と等価なデフォルト値が設定されている場合に、関数とメソッドのアノテーションに <code class="docutils literal"><span class="pre">Optional[t]</span></code> が追加されます。
クラス <code class="docutils literal"><span class="pre">C</span></code> については、 <code class="docutils literal"><span class="pre">C.__mro__</span></code> の逆順に沿って全ての <code class="docutils literal"><span class="pre">__annotations__</span></code> を合併して構築された辞書を返します。</p>
</dd></dl>

<dl class="function">
<dt id="typing.overload">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">overload</code><a class="headerlink" href="#typing.overload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">&#64;overload</span></code> デコレータを使うと、引数の型の複数の組み合わせをサポートする関数やメソッドを書けるようになります。
<code class="docutils literal"><span class="pre">&#64;overload</span></code> 付きの定義を並べた後ろに、(同じ関数やメソッドの) <code class="docutils literal"><span class="pre">&#64;overload</span></code> 無しの定義が来なければなりません。
<code class="docutils literal"><span class="pre">&#64;overload</span></code> 付きの定義は型チェッカーのためでしかありません。
というのも、 <code class="docutils literal"><span class="pre">&#64;overload</span></code> 付きの定義は <code class="docutils literal"><span class="pre">&#64;overload</span></code> 無しの定義で上書きされるからです。
後者は実行時に使われますが、型チェッカーからは無視されるべきなのです。
実行時には、 <code class="docutils literal"><span class="pre">&#64;overload</span></code> 付きの関数を直接呼び出すと <code class="docutils literal"><span class="pre">NotImplementedError</span></code> を送出します。
次のコードはオーバーロードを使うことでユニオン型や型変数を使うよりもより正確な型が表現できる例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">actual</span> <span class="n">implementation</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>詳細と他の型付け意味論との比較は <span class="target" id="index-31"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">no_type_check</code><a class="headerlink" href="#typing.no_type_check" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アノテーションが型ヒントでないことを示すデコレータです。</p>
<p>This works as class or function <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>.  With a class, it
applies recursively to all methods defined in that class (but not
to methods defined in its superclasses or subclasses).</p>
<p>これは関数を適切に変更します。</p>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check_decorator">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">no_type_check_decorator</code><a class="headerlink" href="#typing.no_type_check_decorator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>別のデコレータに <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal"><span class="pre">no_type_check()</span></code></a> の効果を与えるデコレータです。</p>
<p>これは何かの関数をラップするデコレータを <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal"><span class="pre">no_type_check()</span></code></a> でラップします。</p>
</dd></dl>

<dl class="data">
<dt id="typing.Any">
<code class="descclassname">typing.</code><code class="descname">Any</code><a class="headerlink" href="#typing.Any" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>制約のない型であることを示す特別な型。</p>
<ul class="simple">
<li>任意の型は <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> と互換です。</li>
<li><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal"><span class="pre">Any</span></code></a> は任意の型と互換です。</li>
</ul>
</dd></dl>

<dl class="data">
<dt id="typing.Union">
<code class="descclassname">typing.</code><code class="descname">Union</code><a class="headerlink" href="#typing.Union" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ユニオン型; <code class="docutils literal"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> は X または Y を表します。</p>
<p>ユニオン型を定義します、例えば <code class="docutils literal"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> のように使います。詳細:</p>
<ul>
<li><p class="first">引数は型でなければならず、少なくとも一つ必要です。</p>
</li>
<li><p class="first">ユニオン型のユニオン型は平滑化されます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">引数が一つのユニオン型は消えます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p class="first">冗長な実引数は飛ばされます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">ユニオン型を比較するとき引数の順序は無視されます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">When a class and its subclass are present, the latter is skipped, e.g.:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span> <span class="o">==</span> <span class="nb">object</span>
</pre></div>
</div>
</li>
<li><p class="first">ユニオン型のサブクラスを作成したり、インスタンスを作成することは出来ません。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Union[X][Y]</span></code> と書くことは出来ません。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Optional[X]</span></code> を <code class="docutils literal"><span class="pre">Union[X,</span> <span class="pre">None]</span></code> の略記として利用することが出来ます。</p>
</li>
</ul>
</dd></dl>

<dl class="data">
<dt id="typing.Optional">
<code class="descclassname">typing.</code><code class="descname">Optional</code><a class="headerlink" href="#typing.Optional" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オプショナル型。</p>
<p><code class="docutils literal"><span class="pre">Optional[X]</span></code> は <code class="docutils literal"><span class="pre">Union[X,</span> <span class="pre">None]</span></code> と同値です。</p>
<p>これがデフォルト値のある引数であるオプショナル引数と同じ概念ではないと言うことに注意してください。デフォルト値のあるオプショナル引数ではその型アノテーションで <code class="docutils literal"><span class="pre">Optional</span></code> を使う必要はありません (ただしデフォルトでは <code class="docutils literal"><span class="pre">None</span></code> と推論されます)。必須の引数は明示的な値として <code class="docutils literal"><span class="pre">None</span></code> が許されるのであれば <code class="docutils literal"><span class="pre">Optional</span></code> 型も持つことが出来ます。</p>
</dd></dl>

<dl class="data">
<dt id="typing.Tuple">
<code class="descclassname">typing.</code><code class="descname">Tuple</code><a class="headerlink" href="#typing.Tuple" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>タプル型; <code class="docutils literal"><span class="pre">Tuple[X,</span> <span class="pre">Y]</span></code> は、最初の要素の型が X で、2つ目の要素の型が Y であるような、2つの要素を持つタプルの型です。</p>
<p>例: <code class="docutils literal"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code>  は型変数 T1 と T2 に対応する2つの要素を持つタプルです。<code class="docutils literal"><span class="pre">Tuple[int,</span> <span class="pre">float,</span> <span class="pre">str]</span></code> は int と float、 string のタプルです。</p>
<p>同じ型の任意の長さのタプルを指定するには ellipsis リテラルを用います。例:  <code class="docutils literal"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code>。ただの <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal"><span class="pre">Tuple</span></code></a> は <code class="docutils literal"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code> と等価で、さらに <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> と等価です。.</p>
</dd></dl>

<dl class="data">
<dt id="typing.Callable">
<code class="descclassname">typing.</code><code class="descname">Callable</code><a class="headerlink" href="#typing.Callable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し可能型; <code class="docutils literal"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> は (int) -&gt; str の関数です。</p>
<p>添字表記は常に2つの値とともに使われなければなりません: 実引数のリストと返り値の型です。
実引数のリストは型のリストか ellipsis でなければなりません; 返り値の型は単一の型でなければなりません。</p>
<p>オプショナル引数やキーワード引数を表すための文法はありません; そのような関数型はコールバックの型として滅多に使われません。
<code class="docutils literal"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code> (リテラルの Ellipsis) は任意の個数の引数をとり <code class="docutils literal"><span class="pre">ReturnType</span></code> を返す型ヒントを与えるために使えます。
普通の <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal"><span class="pre">Callable</span></code></a> は <code class="docutils literal"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code> と同等で、 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Callable</span></code></a> でも同様です。</p>
</dd></dl>

<dl class="data">
<dt id="typing.ClassVar">
<code class="descclassname">typing.</code><code class="descname">ClassVar</code><a class="headerlink" href="#typing.ClassVar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラス変数であることを示す特別な型構築子です。</p>
<p><span class="target" id="index-32"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> で導入された通り、 ClassVar でラップされた変数アノテーションによって、ある属性はクラス変数として使うつもりであり、そのクラスのインスタンスから設定すべきではないということを示せます。使い方は次のようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal"><span class="pre">ClassVar</span></code></a> は型のみを受け入れ、それ以外は受け付けられません。</p>
<p>ClassVar はクラスそのものではなく、<a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> や <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> で使うべきではありません。
<a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal"><span class="pre">ClassVar</span></code></a> は Python の実行時の挙動を変えませんが、サードパーティの型検査器で使えます。
例えば、型チェッカーは次のコードをエラーとするかもしれません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.AnyStr">
<code class="descclassname">typing.</code><code class="descname">AnyStr</code><a class="headerlink" href="#typing.AnyStr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">AnyStr</span></code> は <code class="docutils literal"><span class="pre">AnyStr</span> <span class="pre">=</span> <span class="pre">TypeVar('AnyStr',</span> <span class="pre">str,</span> <span class="pre">bytes)</span></code> として定義される型変数です。</p>
<p>他の種類の文字列を混ぜることなく、任意の種類の文字列を許す関数によって使われることを意図しています。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;unicode&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Error, cannot mix unicode and bytes</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.TYPE_CHECKING">
<code class="descclassname">typing.</code><code class="descname">TYPE_CHECKING</code><a class="headerlink" href="#typing.TYPE_CHECKING" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サードパーティーの静的型検査器が <code class="docutils literal"><span class="pre">True</span></code> と仮定する特別な定数です。 実行時には <code class="docutils literal"><span class="pre">False</span></code> になります。使用例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that the first type annotation must be enclosed in quotes, making it a
&quot;forward reference&quot;, to hide the <code class="docutils literal"><span class="pre">expensive_mod</span></code> reference from the
interpreter runtime.  Type annotations for local variables are not
evaluated, so the second annotation does not need to be enclosed in quotes.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5.2 で追加.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">26.1. <code class="docutils literal"><span class="pre">typing</span></code> — 型ヒントのサポート</a><ul>
<li><a class="reference internal" href="#type-aliases">26.1.1. 型エイリアス</a></li>
<li><a class="reference internal" href="#newtype">26.1.2. NewType</a></li>
<li><a class="reference internal" href="#callable">26.1.3. 呼び出し可能オブジェクト</a></li>
<li><a class="reference internal" href="#generics">26.1.4. ジェネリクス</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">26.1.5. ユーザー定義のジェネリック型</a></li>
<li><a class="reference internal" href="#the-any-type">26.1.6. <code class="docutils literal"><span class="pre">Any</span></code> 型</a></li>
<li><a class="reference internal" href="#classes-functions-and-decorators">26.1.7. クラス、関数、およびデコレータ</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="development.html"
                        title="前の章へ">26. 開発ツール</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="pydoc.html"
                        title="次の章へ">26.2. <code class="docutils literal"><span class="pre">pydoc</span></code> — ドキュメント生成とオンラインヘルプシステム</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/typing.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="26.2. pydoc — ドキュメント生成とオンラインヘルプシステム"
             >次へ</a> |</li>
        <li class="right" >
          <a href="development.html" title="26. 開発ツール"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.4</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >26. 開発ツール</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 3月 29, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>