
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>16.16. ctypes — Pythonのための外部関数ライブラリ &#8212; Python 3.6.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="17. 並行実行" href="concurrency.html" />
    <link rel="prev" title="16.15. errno — 標準の errno システムシンボル" href="errno.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/ctypes.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/ctypes.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="17. 並行実行"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="errno.html" title="16.15. errno — 標準の errno システムシンボル"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">16. 汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1>16.16. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> — Pythonのための外部関数ライブラリ<a class="headerlink" href="#module-ctypes" title="このヘッドラインへのパーマリンク">¶</a></h1>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は Python のための外部関数ライブラリです。このライブラリは C と互換性のあるデータ型を提供し、動的リンク/共有ライブラリ内の関数呼び出しを可能にします。動的リンク/共有ライブラリを純粋な Python でラップするために使うことができます。</p>
<div class="section" id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2>16.16.1. ctypesチュートリアル<a class="headerlink" href="#ctypes-tutorial" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>注意: このチュートリアルのコードサンプルは動作確認のために <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> を使います。コードサンプルの中には Linux、 Windows、あるいは Mac OS X 上で異なる動作をするものがあるため、サンプルのコメントに doctest 命令を入れてあります。</p>
<p>注意: いくつかのコードサンプルで ctypes の <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a> 型を参照しています。 <code class="docutils literal"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code> であるようなプラットフォームでは、この型は <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal"><span class="pre">c_long</span></code></a> のエイリアスです。そのため、 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a> 型を想定しているときに <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal"><span class="pre">c_long</span></code></a> が表示されたとしても、混乱しないようにしてください — 実際には同じ型なのです。</p>
<div class="section" id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3>16.16.1.1. 動的リンクライブラリをロードする<a class="headerlink" href="#loading-dynamic-link-libraries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>動的リンクライブラリをロードするために、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は <em>cdll</em> をエクスポートします。 Windows では <em>windll</em> と <em>oledll</em> オブジェクトをエクスポートします。</p>
<p>これらのオブジェクトの属性としてライブラリにアクセスすることでライブラリをロードします。 <em>cdll</em> は、標準 <code class="docutils literal"><span class="pre">cdecl</span></code> 呼び出し規約を用いて関数をエクスポートしているライブラリをロードします。それに対して、 <em>windll</em> ライブラリは <code class="docutils literal"><span class="pre">stdcall</span></code> 呼び出し規約を用いる関数を呼び出します。 <em>oledll</em> も <code class="docutils literal"><span class="pre">stdcall</span></code> 呼び出し規約を使いますが、関数が Windows <code class="xref c c-type docutils literal"><span class="pre">HRESULT</span></code> エラーコードを返すことを想定しています。このエラーコードは関数呼び出しが失敗したとき、 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal"><span class="pre">OSError</span></code></a> 例外を自動的に送出させるために使われます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>Windows エラーは以前は <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal"><span class="pre">WindowsError</span></code></a> を送出していましたが、これは現在では <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> の別名になっています。</p>
</div>
<p>Windows用の例ですが、 <code class="docutils literal"><span class="pre">msvcrt</span></code> はほとんどの標準 C 関数が含まれている MS 標準 C ライブラリであり、 cdecl 呼び出し規約を使うことに注意してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>  
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>      
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>      
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows では通常の <code class="docutils literal"><span class="pre">.dll</span></code> ファイル拡張子を自動的に追加します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">cdll.msvcrt</span></code> 経由で標準 C ライブラリにアクセスすると、Python が使用しているライブラリとは互換性のない可能性のある、古いバージョンのライブラリが使用されます。可能な場合には、ネイティブ Python の機能を使用するか、<code class="docutils literal"><span class="pre">msvcrt</span></code> モジュールをインポートして使用してください。</p>
</div>
<p>Linux ではライブラリをロードするために拡張子を <em>含む</em> ファイル名を指定する必要があるので、ロードしたライブラリに対する属性アクセスはできません。 dll ローダーの <code class="xref py py-meth docutils literal"><span class="pre">LoadLibrary()</span></code> メソッドを使うか、コンストラクタを呼び出して CDLL のインスタンスを作ることでライブラリをロードするかのどちらかを行わなければなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>       
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>                           
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3>16.16.1.2. ロードしたdllから関数にアクセスする<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>dll オブジェクトの属性として関数にアクセスします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>     
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">kernel32</span></code> や <code class="docutils literal"><span class="pre">user32</span></code> のような win32 システム dll は、多くの場合関数の UNICODE バージョンに加えて ANSI バージョンもエクスポートすることに注意してください。 UNICODE バージョンは後ろに <code class="docutils literal"><span class="pre">W</span></code> が付いた名前でエクスポートされ、 ANSI バージョンは <code class="docutils literal"><span class="pre">A</span></code> が付いた名前でエクスポートされます。与えられたモジュールの <em>モジュールハンドル</em> を返す win32 <code class="docutils literal"><span class="pre">GetModuleHandle</span></code> 関数は次のような C プロトタイプを持ちます。 UNICODE バージョンが定義されているかどうかにより <code class="docutils literal"><span class="pre">GetModuleHandle</span></code> としてどちらか一つを公開するためにマクロが使われます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p><em>windll</em> は魔法を使ってどちらか一つを選ぶようなことはしません。<code class="docutils literal"><span class="pre">GetModuleHandleA</span></code> もしくは <code class="docutils literal"><span class="pre">GetModuleHandleW</span></code> を明示的に指定して必要とするバージョンにアクセスし、バイト列か文字列を使ってそれぞれ呼び出さなければなりません。</p>
<p>時には、 dll が関数を <code class="docutils literal"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code> のような Python 識別子として有効でない名前でエクスポートすることがあります。このような場合に関数を取り出すには、 <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> を使わなければなりません。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows では、名前ではなく序数によって関数をエクスポートする dll もあります。こうした関数には序数を使って dll オブジェクトにインデックス指定することでアクセスします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions">
<span id="ctypes-calling-functions"></span><h3>16.16.1.3. 関数を呼び出す<a class="headerlink" href="#calling-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらの関数は他の Python 呼び出し可能オブジェクトと同じように呼び出すことができます。この例では <code class="docutils literal"><span class="pre">time()</span></code> 関数 (Unixエポックからのシステム時間を秒単位で返す) と、 <code class="docutils literal"><span class="pre">GetModuleHandleA()</span></code> 関数 (win32モジュールハンドルを返す) を使います。</p>
<p>この例は両方の関数を NULL ポインタとともに呼び出します (<code class="docutils literal"><span class="pre">None</span></code> を NULL ポインタとして使う必要があります):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  
<span class="go">1150640792</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>  
<span class="go">0x1d000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">不正な数の引数が渡されたことを検知した場合、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は関数を呼び出した後に <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出することがあります。
この動作には依存するべきではありません。
この動作は 3.6.2 で非推奨であり、 3.7 で削除予定です。</p>
</div>
<p><code class="docutils literal"><span class="pre">cdecl</span></code> 呼び出し規約を使って <code class="docutils literal"><span class="pre">stdcall</span></code> 関数を呼び出したときには、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。逆の場合も同様です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>正しい呼び出し規約を知るためには、呼び出したい関数についての C ヘッダファイルもしくはドキュメントを見なければなりません。</p>
<p>Windows では、関数が無効な引数とともに呼び出された場合の一般保護例外によるクラッシュを防ぐために、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は win32 構造化例外処理を使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>しかしそれでも他に <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> で Python がクラッシュする状況はあるので、どちらにせよ気を配るべきです。クラッシュのデバッグには、 <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal"><span class="pre">faulthandler</span></code></a> モジュールが役に立つ場合があります (例えば、誤った C ライブラリ呼び出しによって引き起こされたセグメンテーション違反) 。</p>
<p><code class="docutils literal"><span class="pre">None</span></code> 、整数、バイト列オブジェクトおよび (Unicode) 文字列だけが、こうした関数呼び出しにおいてパラメータとして直接使えるネイティブの Python オブジェクトです。 <code class="docutils literal"><span class="pre">None</span></code> は C の <code class="docutils literal"><span class="pre">NULL</span></code> ポインタとして渡され、バイト文字列とユニコード文字列はそのデータを含むメモリブロックへのポインタ (<code class="xref c c-type docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> または <code class="xref c c-type docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></code>) として渡されます。 Python 整数はプラットホームのデフォルトの C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 型として渡され、その値は C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 型に合うようにマスクされます。</p>
<p>他のパラメータ型をもつ関数呼び出しに移る前に、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> データ型についてさらに学ぶ必要があります。</p>
</div>
<div class="section" id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3>16.16.1.4. 基本データ型<a class="headerlink" href="#fundamental-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> ではいくつもの C 互換のプリミティブなデータ型を定義しています:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="46%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ctypes の型</th>
<th class="head">C の型</th>
<th class="head">Python の型</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal"><span class="pre">c_bool</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">_Bool</span></code></td>
<td>bool (1)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal"><span class="pre">c_char</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">char</span></code></td>
<td>1文字のバイト列オブジェクト</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal"><span class="pre">c_wchar</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">wchar_t</span></code></td>
<td>1文字の文字列</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal"><span class="pre">c_byte</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">char</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal"><span class="pre">c_ubyte</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal"><span class="pre">c_short</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">short</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal"><span class="pre">c_ushort</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">int</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal"><span class="pre">c_uint</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal"><span class="pre">c_long</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal"><span class="pre">c_ulong</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal"><span class="pre">c_longlong</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">__int64</span></code> または <code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal"><span class="pre">c_ulonglong</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">__int64</span></code> または <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal"><span class="pre">c_size_t</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">size_t</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal"><span class="pre">c_ssize_t</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">ssize_t</span></code> または <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal"><span class="pre">c_float</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">float</span></code></td>
<td>浮動小数点数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal"><span class="pre">c_double</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">double</span></code></td>
<td>浮動小数点数</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal"><span class="pre">c_longdouble</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">double</span></code></td>
<td>浮動小数点数</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal"><span class="pre">c_char_p</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> (NUL 終端)</td>
<td>バイト列オブジェクトまたは <code class="docutils literal"><span class="pre">None</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal"><span class="pre">c_wchar_p</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></code> (NUL 終端)</td>
<td>文字列または <code class="docutils literal"><span class="pre">None</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal"><span class="pre">c_void_p</span></code></a></td>
<td><code class="xref c c-type docutils literal"><span class="pre">void</span> <span class="pre">*</span></code></td>
<td>整数または <code class="docutils literal"><span class="pre">None</span></code></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li>コンストラクタは任意のオブジェクトをその真偽値として受け取ります。</li>
</ol>
<p>これら全ての型はその型を呼び出すことによって作成でき、オプションとして型と値が合っている初期化子を指定することができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>これらの型は変更可能であり、値を後で変更することもできます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>新しい値をポインタ型 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal"><span class="pre">c_char_p</span></code></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal"><span class="pre">c_wchar_p</span></code></a> および <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal"><span class="pre">c_void_p</span></code></a> のインスタンスへ代入すると、変わるのは指している <em>メモリ位置</em> であって、メモリブロックの <em>内容ではありません</em> (これは当然で、なぜなら、 Python バイト列オブジェクトは変更不可能だからです):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># the memory location has changed</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># first object is unchanged</span>
<span class="go">Hello, World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>しかし、変更可能なメモリを指すポインタであることを想定している関数へそれらを渡さないように注意すべきです。もし変更可能なメモリブロックが必要なら、 ctypes には <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal"><span class="pre">create_string_buffer()</span></code></a> 関数があり、いろいろな方法で作成することできます。現在のメモリブロックの内容は <code class="docutils literal"><span class="pre">raw</span></code> プロパティを使ってアクセス (あるいは変更) することができます。もし現在のメモリブロックに NUL 終端文字列としてアクセスしたいなら、 <code class="docutils literal"><span class="pre">value</span></code> プロパティを使ってください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># create a 3 byte buffer, initialized to NUL bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># create a buffer containing a NUL terminated string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># create a 10 byte buffer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal"><span class="pre">create_string_buffer()</span></code></a> 関数は初期の ctypes リリースにあった <code class="xref py py-func docutils literal"><span class="pre">c_string()</span></code> 関数だけでなく、 (エイリアスとしてはまだ利用できる) <code class="xref py py-func docutils literal"><span class="pre">c_buffer()</span></code> 関数をも置き換えるものです。 C の型 <code class="xref c c-type docutils literal"><span class="pre">wchar_t</span></code> の Unicode 文字を含む変更可能なメモリブロックを作成するには、 <a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal"><span class="pre">create_unicode_buffer()</span></code></a> 関数を使ってください。</p>
</div>
<div class="section" id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3>16.16.1.5. 続・関数を呼び出す<a class="headerlink" href="#calling-functions-continued" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>printf は <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> では <em>なく</em> 、本物の標準出力チャンネルへプリントすることに注意してください。したがって、これらの例はコンソールプロンプトでのみ動作し、 <em>IDLE</em> や <em>PythonWin</em> では動作しません。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>前に述べたように、必要な C のデータ型へ変換できるようにするためには、整数、文字列およびバイト列オブジェクトを除くすべての Python 型を対応する <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> 型でラップしなければなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3>16.16.1.6. 自作のデータ型とともに関数を呼び出す<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>自作のクラスのインスタンスを関数引数として使えるように、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> 引数変換をカスタマイズすることもできます。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は <code class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></code> 属性を探し出し、関数引数として使います。もちろん、整数、文字列もしくはバイト列オブジェクトの中の一つでなければなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></code> インスタンス変数にインスタンスのデータを保持したくない場合は、必要に応じて利用できる属性を作る <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal"><span class="pre">property</span></code></a> を定義しても構いません。</p>
</div>
<div class="section" id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3>16.16.1.7. 要求される引数の型を指定する (関数プロトタイプ)<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> 属性を設定することによって、 DLL からエクスポートされている関数に要求される引数の型を指定することができます。</p>
<p><code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> は C データ型のシーケンスでなければなりません (この場合 <code class="docutils literal"><span class="pre">printf</span></code> 関数はおそらく良い例ではありません。なぜなら、引数の数が可変であり、フォーマット文字列に依存した異なる型のパラメータを取るからです。一方では、この機能の実験にはとても便利です)。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>(C の関数のプロトタイプのように) 書式を指定すると互換性のない引数型になるのを防ぎ、引数を有効な型へ変換しようとします。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: wrong type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>関数呼び出しへ渡す自作のクラスを定義した場合には、 <code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> シーケンスの中で使えるようにするために、そのクラスに <code class="xref py py-meth docutils literal"><span class="pre">from_param()</span></code> クラスメソッドを実装しなければなりません。 <code class="xref py py-meth docutils literal"><span class="pre">from_param()</span></code> クラスメソッドは関数呼び出しへ渡された Python オブジェクトを受け取り、型チェックもしくはこのオブジェクトが受け入れ可能であると確かめるために必要なことはすべて行ってから、オブジェクト自身、 <code class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></code> 属性、あるいは、この場合に C 関数引数として渡したい何かの値を返さなければなりません。繰り返しになりますが、その返される結果は整数、文字列、バイト列、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> インスタンス、あるいは <code class="xref py py-attr docutils literal"><span class="pre">_as_parameter_</span></code> 属性をもつオブジェクトであるべきです。</p>
</div>
<div class="section" id="return-types">
<span id="ctypes-return-types"></span><h3>16.16.1.8. 戻り値の型<a class="headerlink" href="#return-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトでは、関数は C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> を返すと仮定されます。他の戻り値の型を指定するには、関数オブジェクトの <code class="xref py py-attr docutils literal"><span class="pre">restype</span></code> 属性に設定します。</p>
<p>さらに高度な例として、 <code class="docutils literal"><span class="pre">strchr</span></code> 関数を使います。この関数は文字列ポインタと char を受け取り、文字列へのポインタを返します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>  
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>上の <code class="docutils literal"><span class="pre">ord(&quot;x&quot;)</span></code> 呼び出しを避けたいなら、 <code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> 属性を設定することができます。二番目の引数が一文字の Python バイト列オブジェクトから C の char へ変換されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: one character string expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>外部関数が整数を返す場合は、 <code class="xref py py-attr docutils literal"><span class="pre">restype</span></code> 属性として呼び出し可能な Python オブジェクト (例えば、関数またはクラス) を使うこともできます。呼び出し可能オブジェクトは C 関数が返す <em>整数</em> とともに呼び出され、この呼び出しの結果は関数呼び出しの結果として使われるでしょう。これはエラーの戻り値をチェックして自動的に例外を送出させるために役に立ちます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">WinError</span></code> はエラーコードの文字列表現を得るために Windows の <code class="docutils literal"><span class="pre">FormatMessage()</span></code> api を呼び出し、例外を <em>返す</em> 関数です。 <code class="docutils literal"><span class="pre">WinError</span></code> はオプションでエラーコードパラメータを取ります。このパラメータが使われない場合は、エラーコードを取り出すために <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal"><span class="pre">GetLastError()</span></code></a> を呼び出します。</p>
<p><code class="xref py py-attr docutils literal"><span class="pre">errcheck</span></code> 属性によってもっと強力なエラーチェック機構を利用できることに注意してください。詳細はリファレンスマニュアルを参照してください。</p>
</div>
<div class="section" id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3>16.16.1.9. ポインタを渡す(または、パラメータの参照渡し)<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>時には、 C api 関数がパラメータのデータ型として <em>ポインタ</em> を想定していることがあります。おそらくパラメータと同一の場所に書き込むためか、もしくはそのデータが大きすぎて値渡しできない場合です。これは <em>パラメータの参照渡し</em> としても知られています。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal"><span class="pre">byref()</span></code></a> 関数をエクスポートしており、パラメータを参照渡しするために使用します。 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal"><span class="pre">pointer()</span></code></a> 関数を使っても同じ効果が得られます。しかし、 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal"><span class="pre">pointer()</span></code></a> は本当のポインタオブジェクトを構築するためより多くの処理を行うことから、 Python 側でポインタオブジェクト自体を必要としないならば <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal"><span class="pre">byref()</span></code></a> を使う方がより高速です。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3>16.16.1.10. 構造体と共用体<a class="headerlink" href="#structures-and-unions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>構造体と共用体は <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> モジュールに定義されている <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal"><span class="pre">Structure</span></code></a> および <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal"><span class="pre">Union</span></code></a> ベースクラスからの派生クラスでなければなりません。それぞれのサブクラスは <code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code> 属性を定義する必要があります。 <code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code> は <em>フィールド名</em> と <em>フィールド型</em> を持つ <em>2要素タプル</em> のリストでなければなりません。</p>
<p>フィールド型は <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a> か他の <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> 型 (構造体、共用体、配列、ポインタ) から派生した <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> 型である必要があります。</p>
<p>以下は、 <em>x</em> と <em>y</em> という名前の二つの整数からなる簡単な POINT 構造体の例です。コンストラクタで構造体を初期化する方法も説明しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">too many initializers</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>しかし、もっと複雑な構造体を構築することもできます。ある構造体は、他の構造体をフィールド型として使うことで、他の構造体を含むことができます。</p>
<p><em>upperleft</em> と <em>lowerright</em> という名前の二つの POINT を持つ RECT 構造体です。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>入れ子になった構造体はいくつかの方法を用いてコンストラクタで初期化することができます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>フィールド <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> (記述子)は <em>クラス</em> から取り出せます。デバッグするときに役に立つ情報を得ることができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=4, size=4&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> では、ビットフィールドのある共用体や構造体の関数への値渡しはサポートしていません。これは 32-bit の x86 環境では動くかもしれませんが、このライブラリでは一般の場合に動作することは保証していません。</p>
</div>
</div>
<div class="section" id="structure-union-alignment-and-byte-order">
<h3>16.16.1.11. 構造体/共用体アライメントとバイトオーダー<a class="headerlink" href="#structure-union-alignment-and-byte-order" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトでは、構造体 (Structure) と共用体(Union) のフィールドは C コンパイラが行うのと同じ方法でアライメントされています。サブクラスを定義するときに <code class="xref py py-attr docutils literal"><span class="pre">_pack_</span></code> クラス属性を指定することでこの動作を変えることは可能です。このクラス属性には正の整数を設定する必要があり、フィールドの最大アライメントを指定します。これは MSVC で <code class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack(n)</span></code> が行っていること同じです。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は Structure と Union に対してネイティブのバイトオーダーを使います。ネイティブではないバイトオーダーの構造体を作成するには、 <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal"><span class="pre">LittleEndianStructure</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">BigEndianUnion</span></code> および <code class="xref py py-class docutils literal"><span class="pre">LittleEndianUnion</span></code> ベースクラスの中の一つを使います。これらのクラスにポインタフィールドを持たせることはできません。</p>
</div>
<div class="section" id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3>16.16.1.12. 構造体と共用体におけるビットフィールド<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ビットフィールドを含む構造体と共用体を作ることができます。ビットフィールドは整数フィールドに対してのみ作ることができ、ビット幅は <code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code> タプルの第三要素で指定します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="arrays">
<span id="ctypes-arrays"></span><h3>16.16.1.13. 配列<a class="headerlink" href="#arrays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>配列 (Array) はシーケンスであり、決まった数の同じ型のインスタンスを持ちます。</p>
<p>推奨されている配列の作成方法はデータ型に正の整数を掛けることです。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p>ややわざとらしいデータ型の例になりますが、他のものに混ざって 4 個の POINT がある構造体です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>インスタンスはクラスを呼び出す通常の方法で作成します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>上記のコードは <code class="docutils literal"><span class="pre">0</span> <span class="pre">0</span></code> という行が並んだものを表示します。配列の要素がゼロで初期化されているためです。</p>
<p>正しい型の初期化子を指定することもできます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="pointers">
<span id="ctypes-pointers"></span><h3>16.16.1.14. ポインタ<a class="headerlink" href="#pointers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ポインタのインスタンスは <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> 型に対して <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal"><span class="pre">pointer()</span></code></a> 関数を呼び出して作成します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>次のように、ポインタインスタンスは、ポインタが指すオブジェクト (上の例では <code class="docutils literal"><span class="pre">i</span></code>) を返す <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal"><span class="pre">contents</span></code></a> 属性を持ちます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は OOR (original object return 、元のオブジェクトを返すこと) ではないことに注意してください。属性を取り出す度に、新しい同等のオブジェクトを作成しているのです。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>別の <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a> インスタンスがポインタの contents 属性に代入されると、これが記憶されているメモリ位置を指すポインタに変化します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ポインタインスタンスは整数でインデックス指定することもできます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>整数インデックスへ代入するとポインタが指す値が変更されます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>0 ではないインデックスを使うこともできますが、 C の場合と同じように自分が何をしているかを理解している必要があります。任意のメモリ位置にアクセスもしくは変更できるのです。一般的にこの機能を使うのは、 C 関数からポインタを受け取り、そのポインタが単一の要素ではなく実際に配列を指していると <em>分かっている</em> 場合だけです。</p>
<p>舞台裏では、 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal"><span class="pre">pointer()</span></code></a> 関数は単にポインタインスタンスを作成するという以上のことを行っています。はじめにポインタ <em>型</em> を作成する必要があります。これは任意の <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> 型を受け取る <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal"><span class="pre">POINTER()</span></code></a> 関数を使って行われ、新しい型を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ポインタ型を引数なしで呼び出すと <code class="docutils literal"><span class="pre">NULL</span></code> ポインタを作成します。 <code class="docutils literal"><span class="pre">NULL</span></code> ポインタは <code class="docutils literal"><span class="pre">False</span></code> ブール値を持っています。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> はポインタの指す値を取り出すときに <code class="docutils literal"><span class="pre">NULL</span></code> かどうかを調べます(しかし、 <code class="docutils literal"><span class="pre">NULL</span></code> でない不正なポインタの指す値の取り出す行為は Python をクラッシュさせるでしょう)。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="type-conversions">
<span id="ctypes-type-conversions"></span><h3>16.16.1.15. 型変換<a class="headerlink" href="#type-conversions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>たいていの場合、 ctypes は厳密な型チェックを行います。これが意味するのは、関数の <code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> リスト内に、もしくは、構造体定義におけるメンバーフィールドの型として <code class="docutils literal"><span class="pre">POINTER(c_int)</span></code> がある場合、厳密に同じ型のインスタンスだけを受け取るということです。このルールには ctypes が他のオブジェクトを受け取る場合に例外がいくつかあります。例えば、ポインタ型の代わりに互換性のある配列インスタンスを渡すことができます。このように、 <code class="docutils literal"><span class="pre">POINTER(c_int)</span></code> に対して、 ctypes は c_int の配列を受け取ります。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>それに加えて、 <code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> で関数の引数が明示的に (<code class="docutils literal"><span class="pre">POINTER(c_int)</span></code> などの) ポインタ型であると宣言されていた場合、ポインタ型が指し示している型のオブジェクト (この場合では <code class="docutils literal"><span class="pre">c_int</span></code>) を関数に渡すことができます。この場合 ctypes は、必要となる <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal"><span class="pre">byref()</span></code></a> での変換を自動的に適用します。</p>
<p>POINTER型フィールドを <code class="docutils literal"><span class="pre">NULL</span></code> に設定するために、 <code class="docutils literal"><span class="pre">None</span></code> を代入してもかまいません。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>時には、非互換な型のインスタンスであることもあります。 C では、ある型を他の型へキャストすることができます。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は同じやり方で使える <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal"><span class="pre">cast()</span></code></a> 関数を提供しています。上で定義した <code class="docutils literal"><span class="pre">Bar</span></code> 構造体は <code class="docutils literal"><span class="pre">POINTER(c_int)</span></code> ポインタまたは <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a> 配列を <code class="docutils literal"><span class="pre">values</span></code> フィールドに対して受け取り、他の型のインスタンスは受け取りません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>このような場合には、 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal"><span class="pre">cast()</span></code></a> 関数が便利です。</p>
<p><a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal"><span class="pre">cast()</span></code></a> 関数は ctypes インスタンスを異なる ctypes データ型を指すポインタへキャストするために使えます。 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal"><span class="pre">cast()</span></code></a> は二つのパラメータ、ある種のポインタかそのポインタへ変換できる ctypes オブジェクトと、 ctypes ポインタ型を取ります。そして、第二引数のインスタンスを返します。このインスタンスは第一引数と同じメモリブロックを参照しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>したがって、 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal"><span class="pre">cast()</span></code></a> を <code class="docutils literal"><span class="pre">Bar</span></code> 構造体の <code class="docutils literal"><span class="pre">values</span></code> フィールドへ代入するために使うことができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3>16.16.1.16. 不完全型<a class="headerlink" href="#incomplete-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>不完全型</em> はメンバーがまだ指定されていない構造体、共用体もしくは配列です。 C では、前方宣言により指定され、後で定義されます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>ctypes コードへの直接的な変換ではこうなるでしょう。しかし、動作しません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>なぜなら、新しい <code class="docutils literal"><span class="pre">class</span> <span class="pre">cell</span></code> はクラス文自体の中では利用できないからです。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> では、 <code class="docutils literal"><span class="pre">cell</span></code> クラスを定義して、 <code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code> 属性をクラス文の後で設定することができます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>試してみましょう。 <code class="docutils literal"><span class="pre">cell</span></code> のインスタンスを二つ作り、互いに参照し合うようにします。最後に、つながったポインタを何度かたどります。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="callback-functions">
<span id="ctypes-callback-functions"></span><h3>16.16.1.17. コールバック関数<a class="headerlink" href="#callback-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は C の呼び出し可能な関数ポインタを Python 呼び出し可能オブジェクトから作成できるようにします。これらは <em>コールバック関数</em> と呼ばれることがあります。</p>
<p>最初に、コールバック関数のためのクラスを作る必要があります。そのクラスには呼び出し規約、戻り値の型およびこの関数が受け取る引数の数と型についての情報があります。</p>
<p><a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal"><span class="pre">CFUNCTYPE()</span></code></a> ファクトリ関数は通常の <code class="docutils literal"><span class="pre">cdecl</span></code> 呼び出し規約を用いてコールバック関数のための型を作成します。 Windows では、 <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal"><span class="pre">WINFUNCTYPE()</span></code></a> ファクトリ関数が <code class="docutils literal"><span class="pre">stdcall</span></code> 呼び出し規約を用いてコールバック関数の型を作成します。</p>
<p>これらのファクトリ関数はともに最初の引数に戻り値の型、残りの引数としてコールバック関数が想定する引数の型を渡して呼び出されます。</p>
<p>標準 C ライブラリの <code class="xref c c-func docutils literal"><span class="pre">qsort()</span></code> 関数を使う例を示します。これはコールバック関数の助けをかりて要素をソートするために使われます。 <code class="xref c c-func docutils literal"><span class="pre">qsort()</span></code> は整数の配列をソートするために使われます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">qsort()</span></code> はソートするデータを指すポインタ、データ配列の要素の数、要素の一つの大きさ、およびコールバック関数である比較関数へのポインタを引数に渡して呼び出さなければなりません。そして、コールバック関数は要素を指す二つのポインタを渡されて呼び出され、一番目が二番目より小さいなら負の数を、等しいならゼロを、それ以外なら正の数を返さなければなりません。</p>
<p>コールバック関数は整数へのポインタを受け取り、整数を返す必要があります。まず、コールバック関数のための <code class="docutils literal"><span class="pre">type</span></code> を作成します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>まず初めに、これが受け取った変数を表示するだけのシンプルなコールバックです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>結果は以下の通りです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>  
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>ここで 2 つの要素を実際に比較し、役に立つ結果を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> 
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>簡単に確認できるように、配列を次のようにソートしました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>C コードから <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal"><span class="pre">CFUNCTYPE()</span></code></a> オブジェクトが使用される限り、そのオブジェクトへの参照を確実に保持してください。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は参照を保持しないため、あなたが参照を保持しないと、オブジェクトはガベージコレクションの対象となり、コールバックが行われたときにプログラムをクラッシュさせる場合があります。</p>
<p class="last">同様に、コールバック関数が Python の管理外 (例えば、コールバックを呼び出す外部のコード) で作られたスレッドで呼び出された場合、 ctypes は全ての呼び出しごとに新しいダミーの Python スレッドを作成することに注意してください。 この動作はほとんどの目的に対して正しいものですが、同じ C スレッドからの呼び出しだったとしても、 <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal"><span class="pre">threading.local</span></code></a> で格納された値は異なるコールバックをまたいで生存は <em>しません</em> 。</p>
</div>
</div>
<div class="section" id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3>16.16.1.18. dllからエクスポートされた値へアクセスする<a class="headerlink" href="#accessing-values-exported-from-dlls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>共有ライブラリの一部は関数だけでなく変数もエクスポートしています。 Python ライブラリにある例としては <code class="xref c c-data docutils literal"><span class="pre">Py_OptimizeFlag</span></code> 、起動時の <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal"><span class="pre">-O</span></code></a> または <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal"><span class="pre">-OO</span></code></a> フラグに依存して、 0 , 1 または 2 が設定される整数があります。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は型の <code class="xref py py-meth docutils literal"><span class="pre">in_dll()</span></code> クラスメソッドを使ってこのように値にアクセスできます。 <em>pythonapi</em> はPython C api へアクセスできるようにするための予め定義されたシンボルです。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opt_flag</span> <span class="o">=</span> <span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_OptimizeFlag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">opt_flag</span><span class="p">)</span>
<span class="go">c_long(0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>インタープリタが <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal"><span class="pre">-O</span></code></a> を指定されて動き始めた場合、サンプルは <code class="docutils literal"><span class="pre">c_long(1)</span></code> を表示するでしょうし、 <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal"><span class="pre">-OO</span></code></a> が指定されたならば <code class="docutils literal"><span class="pre">c_long(2)</span></code> を表示するでしょう。</p>
<p>ポインタの使い方を説明する拡張例では、 Python がエクスポートする <a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal"><span class="pre">PyImport_FrozenModules</span></code></a> ポインタにアクセスします。</p>
<p>この値のドキュメントから引用すると:</p>
<blockquote>
<div>このポインタは <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">_frozen</span></code> のレコードからなり、終端の要素のメンバが <em>NULL</em> かゼロになっているような配列を指すよう初期化されます。フリーズされたモジュールをインポートするとき、このテーブルを検索します。サードパーティ製のコードからこのポインタに仕掛けを講じて、動的に生成されたフリーズ化モジュールの集合を提供するようにできます。</div></blockquote>
<p>これで、このポインタを操作することが役に立つことを証明できるでしょう。例の大きさを制限するために、このテーブルを <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> を使って読む方法だけを示します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>私たちは <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">_frozen</span></code> データ型を定義済みなので、このテーブルを指すポインタを得ることができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;PyImport_FrozenModules&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">table</span></code> が <code class="docutils literal"><span class="pre">struct_frozen</span></code> レコードの配列への <code class="docutils literal"><span class="pre">pointer</span></code> なので、その配列に対して反復処理を行えます。しかし、ループが確実に終了するようにする必要があります。なぜなら、ポインタに大きさの情報がないからです。遅かれ早かれ、アクセス違反か何かでクラッシュすることになるでしょう。 NULL エントリに達したときはループを抜ける方が良いです。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">__hello__ 161</span>
<span class="go">__phello__ -161</span>
<span class="go">__phello__.spam 161</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>標準 Python はフローズンモジュールとフローズンパッケージ (負のサイズのメンバーで表されています) を持っているという事実はあまり知られておらず、テストにだけ使われています。例えば、 <code class="docutils literal"><span class="pre">import</span> <span class="pre">__hello__</span></code> を試してみてください。</p>
</div>
<div class="section" id="surprises">
<span id="ctypes-surprises"></span><h3>16.16.1.19. びっくり仰天<a class="headerlink" href="#surprises" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>There are some edges in <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> where you might expect something other
than what actually happens.</p>
<p>次に示す例について考えてみてください。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now swap the two points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>うーん、最後の文に <code class="docutils literal"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code> と表示されることを期待していたはずです。何が起きたのでしょうか? 上の行の <code class="docutils literal"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> の各段階はこのようになります。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">temp0</span></code> と <code class="docutils literal"><span class="pre">temp1</span></code> は前記の <code class="docutils literal"><span class="pre">rc</span></code> オブジェクトの内部バッファでまだ使われているオブジェクトです。したがって、 <code class="docutils literal"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code> を実行すると <code class="docutils literal"><span class="pre">temp0</span></code> のバッファ内容が <code class="docutils literal"><span class="pre">rc</span></code> のバッファへコピーされます。さらに、これは <code class="docutils literal"><span class="pre">temp1</span></code> の内容を変更します。そのため、最後の代入 <code class="docutils literal"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code> は、期待する結果にはならないのです。</p>
<p>Structure 、 Union および Array のサブオブジェクトを取り出しても、そのサブオブジェクトが <em>コピー</em> されるわけではなく、ルートオブジェクトの内部バッファにアクセスするラッパーオブジェクトを取り出すことを覚えておいてください。</p>
<p>期待とは違う振る舞いをする別の例はこれです。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>なぜ <code class="docutils literal"><span class="pre">False</span></code> と表示されるのでしょうか? ctypes インスタンスはメモリと、メモリの内容にアクセスするいくつかの <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> (記述子)を含むオブジェクトです。メモリブロックに Python オブジェクトを保存してもオブジェクト自身が保存される訳ではなく、オブジェクトの <code class="docutils literal"><span class="pre">contents</span></code> が保存されます。その contents に再アクセスすると新しい Python オブジェクトがその度に作られます。</p>
</div>
<div class="section" id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3>16.16.1.20. 可変サイズのデータ型<a class="headerlink" href="#variable-sized-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は可変サイズの配列と構造体をサポートしています。</p>
<p><a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal"><span class="pre">resize()</span></code></a> 関数は既存の ctypes オブジェクトのメモリバッファのサイズを変更したい場合に使えます。この関数は第一引数にオブジェクト、第二引数に要求されたサイズをバイト単位で指定します。メモリブロックはオブジェクト型で指定される通常のメモリブロックより小さくすることはできません。これをやろうとすると、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>これはこれで上手くいっていますが、この配列の追加した要素へどうやってアクセスするのでしょうか? この型は要素の数が 4 個であるとまだ認識しているので、他の要素にアクセスするとエラーになります。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> で可変サイズのデータ型を使うもう一つの方法は、必要なサイズが分かった後に Python の動的性質を使って一つ一つデータ型を(再)定義することです。</p>
</div>
</div>
<div class="section" id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2>16.16.2. ctypesリファレンス<a class="headerlink" href="#ctypes-reference" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3>16.16.2.1. 共有ライブラリを見つける<a class="headerlink" href="#finding-shared-libraries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンパイルされる言語でプログラミングしている場合、共有ライブラリはプログラムをコンパイル/リンクしているときと、そのプログラムが動作しているときにアクセスされます。</p>
<p>ctypes ライブラリローダーはプログラムが動作しているときのように振る舞い、ランタイムローダーを直接呼び出すのに対し、 <code class="xref py py-func docutils literal"><span class="pre">find_library()</span></code> 関数の目的はコンパイラまたはランタイムローダーが行うのと似た方法でライブラリを探し出すことです。 (複数のバージョンの共有ライブラリがあるプラットホームでは、一番最近に見つかったものがロードされます)。</p>
<p><code class="xref py py-mod docutils literal"><span class="pre">ctypes.util</span></code> モジュールはロードするライブラリを決めるのに役立つ関数を提供します。</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.util.</code><code class="descname">find_library</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>ライブラリを見つけてパス名を返そうと試みます。 <em>name</em> は <code class="docutils literal"><span class="pre">lib</span></code> のような接頭辞、 <code class="docutils literal"><span class="pre">.so</span></code>, <code class="docutils literal"><span class="pre">.dylib</span></code> のような接尾辞、あるいは、バージョン番号が何も付いていないライブラリの名前です (これは posix リンカのオプション <code class="xref std std-option docutils literal"><span class="pre">-l</span></code> に使われている形式です)。
ライブラリが見つからないときは <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<p>厳密な機能はシステムに依存します。</p>
<p>Linux では、 <code class="xref py py-func docutils literal"><span class="pre">find_library()</span></code> はライブラリファイルを見つけるために外部プログラム (<code class="docutils literal"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal"><span class="pre">gcc</span></code>, <code class="docutils literal"><span class="pre">objdump</span></code> と <code class="docutils literal"><span class="pre">ld</span></code>) を実行しようとします。ライブラリファイルのファイル名を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Linux では、ライブラリを検索する際に、他の方法でライブラリが見つけられない場合は、 <code class="docutils literal"><span class="pre">LD_LIBRARY_PATH</span></code> 環境変数の値が使われます</p>
</div>
<p>ここに例があります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="k">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>OS X では、 <code class="xref py py-func docutils literal"><span class="pre">find_library()</span></code> はライブラリの位置を探すために、予め定義された複数の命名方法とパスを試し、成功すればフルパスを返します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="k">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows では、 <code class="xref py py-func docutils literal"><span class="pre">find_library()</span></code> はシステムの探索パスに沿って探し、フルパスを返します。しかし、予め定義された命名方法がないため、 <code class="docutils literal"><span class="pre">find_library(&quot;c&quot;)</span></code> のような呼び出しは失敗し、 <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> で共有ライブラリをラップする場合、 <code class="xref py py-func docutils literal"><span class="pre">find_library()</span></code> を使って実行時にライブラリの場所を特定するのではなく、共有ライブラリの名前を開発時に決めておいて、ラッパーモジュールにハードコードする方が良い <em>かもしれません</em> 。</p>
</div>
<div class="section" id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3>16.16.2.2. 共有ライブラリをロードする<a class="headerlink" href="#loading-shared-libraries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>共有ライブラリを Python プロセスへロードする方法はいくつかあります。一つの方法は下記のクラスの一つをインスタンス化することです:</p>
<dl class="class">
<dt id="ctypes.CDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">CDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は標準 C 呼び出し規約を使用し、 <code class="xref c c-type docutils literal"><span class="pre">int</span></code> を返すと仮定されます。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.OleDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">OleDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は <code class="docutils literal"><span class="pre">stdcall</span></code> 呼び出し規約を使用し、 windows 固有の <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal"><span class="pre">HRESULT</span></code></a> コードを返すと仮定されます。 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal"><span class="pre">HRESULT</span></code></a> 値には関数呼び出しが失敗したのか成功したのかを特定する情報とともに、補足のエラーコードが含まれます。戻り値が失敗を知らせたならば、 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal"><span class="pre">OSError</span></code></a> が自動的に送出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>以前は <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal"><span class="pre">WindowsError</span></code></a> を送出していました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.WinDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">WinDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: このクラスのインスタンスはロードされた共有ライブラリをあらわします。これらのライブラリの関数は <code class="docutils literal"><span class="pre">stdcall</span></code> 呼び出し規約を使用し、デフォルトでは <code class="xref c c-type docutils literal"><span class="pre">int</span></code> を返すと仮定されます。</p>
<p>Windows CE では標準呼び出し規約だけが使われます。便宜上、このプラットフォームでは、 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal"><span class="pre">WinDLL</span></code></a> と <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal"><span class="pre">OleDLL</span></code></a> が標準呼び出し規約を使用します。</p>
</dd></dl>

<p>これらのライブラリがエクスポートするどの関数でも呼び出す前に Python GIL (<a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>) は解放され、後でまた獲得されます。</p>
<dl class="class">
<dt id="ctypes.PyDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">PyDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python GIL が関数呼び出しの間解放 <em>されず</em> 、関数実行の後に Python エラーフラグがチェックされるということを除けば、このクラスのインスタンスは <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal"><span class="pre">CDLL</span></code></a> インスタンスのように振る舞います。エラーフラグがセットされた場合、 Python 例外が送出されます。</p>
<p>要するに、これは Python C api 関数を直接呼び出すのに便利だというだけです。</p>
</dd></dl>

<p>これらすべてのクラスは少なくとも一つの引数、すなわちロードする共有ライブラリのパスを渡して呼び出すことでインスタンス化されます。すでにロード済みの共有ライブラリへのハンドルがあるなら、 <code class="docutils literal"><span class="pre">handle</span></code> 名前付き引数として渡すことができます。土台となっているプラットフォームの <code class="docutils literal"><span class="pre">dlopen</span></code> または <code class="docutils literal"><span class="pre">LoadLibrary</span></code> 関数がプロセスへライブラリをロードするために使われ、そのライブラリに対するハンドルを得ます。</p>
<p><em>mode</em> パラメータを使うと、ライブラリがどうやってロードされたかを特定できます。
詳細は <em class="manpage">dlopen(3)</em> マニュアルページを参考にしてください。
Windows では <em>mode</em> は無視されます。
POSIX システムでは RTLD_NOW が常に追加され、設定変更はできません。</p>
<p><em>use_errno</em> 変数が真に設定されたとき、システムの <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal"><span class="pre">errno</span></code></a> エラーナンバーに安全にアクセスする ctypes の仕組みが有効化されます。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> はシステムの <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal"><span class="pre">errno</span></code></a> 変数のスレッド限定のコピーを管理します。もし、 <code class="docutils literal"><span class="pre">use_errno=True</span></code> の状態で作られた外部関数を呼び出したなら、関数呼び出し前の <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal"><span class="pre">errno</span></code></a> 変数は ctypes のプライベートコピーと置き換えられ、同じことが関数呼び出しの直後にも発生します。</p>
<p><a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal"><span class="pre">ctypes.get_errno()</span></code></a> 関数は ctypes のプライベートコピーの値を返します。そして、 <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal"><span class="pre">ctypes.set_errno()</span></code></a> 関数は ctypes のプライベートコピーを置き換え、以前の値を返します。</p>
<p><em>use_last_error</em> パラメータは、真に設定されたとき、 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal"><span class="pre">GetLastError()</span></code></a> と <code class="xref py py-func docutils literal"><span class="pre">SetLastError()</span></code> Windows API によって管理される Windows エラーコードに対するのと同じ仕組みが有効化されます。 <a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal"><span class="pre">ctypes.get_last_error()</span></code></a> と <a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal"><span class="pre">ctypes.set_last_error()</span></code></a> は Windows エラーコードの ctypes プライベートコピーを変更したり要求したりするのに使われます。</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">RTLD_GLOBAL</code></dt>
<dd><p><em>mode</em> パラメータとして使うフラグ。このフラグが利用できないプラットフォームでは、整数のゼロと定義されています。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">RTLD_LOCAL</code></dt>
<dd><p><em>mode</em> パラメータとして使うフラグ。これが利用できないプラットフォームでは、 <em>RTLD_GLOBAL</em> と同様です。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">DEFAULT_MODE</code></dt>
<dd><p>共有ライブラリをロードするために使われるデフォルトモード。 OSX 10.3 では <em>RTLD_GLOBAL</em> であり、そうでなければ <em>RTLD_LOCAL</em> と同じです。</p>
</dd></dl>

<p>これらのクラスのインスタンスには公開メソッドはありません。共有ライブラリからエクスポートされた関数は、属性として、もしくは添字でアクセスできます。属性を通した関数へのアクセスは結果がキャッシュされ、従って繰り返しアクセスされると毎回同じオブジェクトを返すことに注意してください。それとは反対に、添字を通したアクセスは毎回新しいオブジェクトを返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>次に述べる公開属性が利用できます。それらの名前はエクスポートされた関数名に衝突しないように下線で始まります。:</p>
<dl class="attribute">
<dt id="ctypes.PyDLL._handle">
<code class="descclassname">PyDLL.</code><code class="descname">_handle</code><a class="headerlink" href="#ctypes.PyDLL._handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ライブラリへのアクセスに用いられるシステムハンドル。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.PyDLL._name">
<code class="descclassname">PyDLL.</code><code class="descname">_name</code><a class="headerlink" href="#ctypes.PyDLL._name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタに渡されたライブラリの名前。</p>
</dd></dl>

<p>共有ライブラリは (<a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal"><span class="pre">LibraryLoader</span></code></a> クラスのインスタンスである) 前もって作られたオブジェクトの一つを使うことによってロードすることもできます。それらの <code class="xref py py-meth docutils literal"><span class="pre">LoadLibrary()</span></code> メソッドを呼び出すか、ローダーインスタンスの属性としてライブラリを取り出すかのどちらかによりロードします。</p>
<dl class="class">
<dt id="ctypes.LibraryLoader">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">LibraryLoader</code><span class="sig-paren">(</span><em>dlltype</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有ライブラリをロードするクラス。 <em>dlltype</em> は <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal"><span class="pre">CDLL</span></code></a> 、 <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal"><span class="pre">PyDLL</span></code></a> 、 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal"><span class="pre">WinDLL</span></code></a> もしくは <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal"><span class="pre">OleDLL</span></code></a> 型の一つであるべきです。</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> は次のような特別なはたらきをします。ライブラリローダーインスタンスの属性として共有ライブラリにアクセスするとそれがロードされるということを可能にします。結果はキャッシュされます。そのため、繰り返し属性アクセスを行うといつも同じライブラリが返されます。</p>
<dl class="method">
<dt id="ctypes.LibraryLoader.LoadLibrary">
<code class="descname">LoadLibrary</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>共有ライブラリをプロセスへロードし、それを返します。このメソッドはライブラリの新しいインスタンスを常に返します。</p>
</dd></dl>

</dd></dl>

<p>これらの前もって作られたライブラリローダーを利用することができます。:</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">cdll</code></dt>
<dd><p><a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal"><span class="pre">CDLL</span></code></a> インスタンスを作ります。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">windll</code></dt>
<dd><p>Windows 用: <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal"><span class="pre">WinDLL</span></code></a> インスタンスを作ります。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">oledll</code></dt>
<dd><p>Windows 用: <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal"><span class="pre">OleDLL</span></code></a> インスタンスを作ります。</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">pydll</code></dt>
<dd><p><a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal"><span class="pre">PyDLL</span></code></a> インスタンスを作ります。</p>
</dd></dl>

<p>C Python api に直接アクセスするために、すぐに使用できる Python 共有ライブラリオブジェクトが次のように用意されています。</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">pythonapi</code></dt>
<dd><p>属性として Python C api 関数を公開する <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal"><span class="pre">PyDLL</span></code></a> のインスタンス。これらすべての関数は C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> を返すと仮定されますが、もちろん常に正しいとは限りません。そのため、これらの関数を使うためには正しい <code class="xref py py-attr docutils literal"><span class="pre">restype</span></code> 属性を代入しなければなりません。</p>
</dd></dl>

</div>
<div class="section" id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3>16.16.2.3. 外部関数<a class="headerlink" href="#foreign-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前節で説明した通り、外部関数はロードされた共有ライブラリの属性としてアクセスできます。デフォルトではこの方法で作成された関数オブジェクトはどんな数の引数でも受け取り、引数としてどんな ctypes データのインスタンスをも受け取り、そして、ライブラリローダーが指定したデフォルトの結果の値の型を返します。関数オブジェクトはプライベートクラスのインスタンスです。:</p>
<dl class="class">
<dt id="ctypes._FuncPtr">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_FuncPtr</code><a class="headerlink" href="#ctypes._FuncPtr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の呼び出し可能外部関数のためのベースクラス。</p>
<p>外部関数のインスタンスも C 互換データ型です。それらは C の関数ポインタを表しています。</p>
<p>この振る舞いは外部関数オブジェクトの特別な属性に代入することによって、カスタマイズすることができます。</p>
<dl class="attribute">
<dt id="ctypes._FuncPtr.restype">
<code class="descname">restype</code><a class="headerlink" href="#ctypes._FuncPtr.restype" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>外部関数の結果の型を指定するために ctypes 型を代入する。何も返さない関数を表す <code class="xref c c-type docutils literal"><span class="pre">void</span></code> に対しては <code class="docutils literal"><span class="pre">None</span></code> を使います。</p>
<p>ctypes 型ではない呼び出し可能な Python オブジェクトを代入することは可能です。このような場合、関数が C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> を返すと仮定され、呼び出し可能オブジェクトはこの整数を引数に呼び出されます。さらに処理を行ったり、エラーチェックをしたりできるようにするためです。これの使用は推奨されません。より柔軟な後処理やエラーチェックのためには <a class="reference internal" href="#ctypes._FuncPtr.restype" title="ctypes._FuncPtr.restype"><code class="xref py py-attr docutils literal"><span class="pre">restype</span></code></a> として ctypes 型を使い、 <a class="reference internal" href="#ctypes._FuncPtr.errcheck" title="ctypes._FuncPtr.errcheck"><code class="xref py py-attr docutils literal"><span class="pre">errcheck</span></code></a> 属性へ呼び出し可能オブジェクトを代入してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.argtypes">
<code class="descname">argtypes</code><a class="headerlink" href="#ctypes._FuncPtr.argtypes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数が受け取る引数の型を指定するために ctypes 型のタプルを代入します。<code class="docutils literal"><span class="pre">stdcall</span></code> 呼び出し規約を使う関数はこのタプルの長さと同じ数の引数で呼び出されます。C 呼び出し規約を使う関数は、追加の不特定の引数も取ります。</p>
<p>外部関数が呼ばれたとき、それぞれの実引数は <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code></a> タプルの要素の <code class="xref py py-meth docutils literal"><span class="pre">from_param()</span></code> クラスメソッドへ渡されます。このメソッドは実引数を外部関数が受け取るオブジェクトに合わせて変えられるようにします。例えば、 <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code></a> タプルの <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal"><span class="pre">c_char_p</span></code></a> 要素は、 ctypes 変換規則にしたがって引数として渡された文字列をバイト列オブジェクトへ変換するでしょう。</p>
<p>新: ctypes 型でない要素を argtypes に入れることができますが、個々の要素は引数として使える値 (整数、文字列、 ctypes インスタンス) を返す <code class="xref py py-meth docutils literal"><span class="pre">from_param()</span></code> メソッドを持っていなければなりません。これにより関数パラメータとしてカスタムオブジェクトを適合するように変更できるアダプタが定義可能となります。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.errcheck">
<code class="descname">errcheck</code><a class="headerlink" href="#ctypes._FuncPtr.errcheck" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python 関数または他の呼び出し可能オブジェクトをこの属性に代入します。呼び出し可能オブジェクトは三つ以上の引数とともに呼び出されます。</p>
<dl class="function">
<dt>
<code class="descname">callable</code><span class="sig-paren">(</span><em>result</em>, <em>func</em>, <em>arguments</em><span class="sig-paren">)</span></dt>
<dd><p><em>result</em> は外部関数が返すもので、 <code class="xref py py-attr docutils literal"><span class="pre">restype</span></code> 属性で指定されます。</p>
<p><em>func</em> は外部関数オブジェクト自身で、これにより複数の関数の処理結果をチェックまたは後処理するために、同じ呼び出し可能オブジェクトを再利用できるようになります。</p>
<p><em>arguments</em> は関数呼び出しに最初に渡されたパラメータが入ったタプルです。これにより使われた引数に基づいた特別な振る舞いをさせることができるようになります。</p>
</dd></dl>

<p>この関数が返すオブジェクトは外部関数呼び出しから返された値でしょう。しかし、戻り値をチェックして、外部関数呼び出しが失敗しているなら例外を送出させることもできます。</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ctypes.ArgumentError">
<em class="property">exception </em><code class="descclassname">ctypes.</code><code class="descname">ArgumentError</code><a class="headerlink" href="#ctypes.ArgumentError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この例外は外部関数呼び出しが渡された引数を変換できなかったときに送出されます。</p>
</dd></dl>

</div>
<div class="section" id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3>16.16.2.4. 関数プロトタイプ<a class="headerlink" href="#function-prototypes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>外部関数は関数プロトタイプをインスタンス化することによって作成されます。関数プロトタイプは C の関数プロトタイプと似ています。実装を定義せずに、関数 (戻り値、引数の型、呼び出し規約) を記述します。ファクトリ関数は関数に要求する戻り値の型と引数の型とともに呼び出されます。</p>
<dl class="function">
<dt id="ctypes.CFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">CFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返された関数プロトタイプは標準 C 呼び出し規約をつかう関数を作成します。関数は呼び出されている間 GIL を解放します。 <em>use_errno</em> が真に設定されれば、呼び出しの前後で System 変数 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal"><span class="pre">errno</span></code></a> の ctypesプライベートコピーは本当の <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal"><span class="pre">errno</span></code></a> の値と交換されます。 <em>use_last_error</em> も Windows エラーコードに対するのと同様です。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WINFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">WINFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows のみ: 返された関数プロトタイプは <code class="docutils literal"><span class="pre">stdcall</span></code> 呼び出し規約を使う関数を作成します。ただし、 <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal"><span class="pre">WINFUNCTYPE()</span></code></a> が <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal"><span class="pre">CFUNCTYPE()</span></code></a> と同じである Windows CE を除きます。関数は呼び出されている間 GIL を解放します。 <em>use_errno</em> と <em>use_last_error</em> は前述と同じ意味を持ちます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.PYFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">PYFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返された関数プロトタイプは Python 呼び出し規約を使う関数を作成します。関数は呼び出されている間 GIL を解放 <em>しません</em>。</p>
</dd></dl>

<p>ファクトリ関数によって作られた関数プロトタイプは呼び出しのパラメータの型と数に依存した別の方法でインスタンス化することができます。 :</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span></dt>
<dd><p>指定されたアドレス(整数でなくてはなりません)の外部関数を返します。</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span></dt>
<dd><p>Python の <em>callable</em> から C の呼び出し可能関数(コールバック関数) を作成します。</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>func_spec</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>共有ライブラリがエクスポートしている外部関数を返します。 <em>func_spec</em> は 2 要素タプル <code class="docutils literal"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code> でなければなりません。第一要素はエクスポートされた関数の名前である文字列、またはエクスポートされた関数の序数である小さい整数です。第二要素は共有ライブラリインスタンスです。</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>vtbl_index</em>, <em>name</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">[</span>, <em>iid</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>COM メソッドを呼び出す外部関数を返します。 <em>vtbl_index</em> は仮想関数テーブルのインデックスで、非負の小さい整数です。 <em>name</em> は COM メソッドの名前です。 <em>iid</em> はオプションのインターフェイス識別子へのポインタで、拡張されたエラー情報の提供のために使われます。</p>
<p>COM メソッドは特殊な呼び出し規約を用います。このメソッドは <code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> タプルに指定されたパラメータに加えて、第一引数として COM インターフェイスへのポインタを必要とします。</p>
</dd></dl>

<p>オプションの <em>paramflags</em> パラメータは上述した機能より多機能な外部関数ラッパーを作成します。</p>
<p><em>paramflags</em> は <code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> と同じ長さのタプルでなければなりません。</p>
<p>このタプルの個々の要素はパラメータについてのより詳細な情報を持ち、 1 、 2 もしくは 3 要素を含むタプルでなければなりません。</p>
<p>第一要素はパラメータについてのフラグの組み合わせを含んだ整数です。</p>
<blockquote>
<div><dl class="docutils">
<dt>1</dt>
<dd>入力パラメータを関数に指定します。</dd>
<dt>2</dt>
<dd>出力パラメータ。外部関数が値を書き込みます。</dd>
<dt>4</dt>
<dd>デフォルトで整数ゼロになる入力パラメータ。</dd>
</dl>
</div></blockquote>
<p>オプションの第二要素はパラメータ名の文字列です。これが指定された場合は、外部関数を名前付きパラメータで呼び出すことができます。</p>
<p>オプションの第三要素はこのパラメータのデフォルト値です。</p>
</div></blockquote>
<p>この例では、デフォルトパラメータと名前付き引数をサポートするために Windows の <code class="docutils literal"><span class="pre">MessageBoxW</span></code> 関数をラップする方法を示します。
windows のヘッダファイルの C の宣言は次の通りです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> を使ってラップします。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="k">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p>これで外部関数の <code class="docutils literal"><span class="pre">MessageBox</span></code> を次のような方法で呼び出すことができるようになりました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>二番目の例は出力パラメータについて説明します。 win32 の <code class="docutils literal"><span class="pre">GetWindowRect</span></code> 関数は、指定されたウィンドウの大きさを呼び出し側が与える <code class="docutils literal"><span class="pre">RECT</span></code> 構造体へコピーすることで取り出します。 C の宣言はこうです。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> を使ってラップします。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="k">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>出力パラメータを持つ関数は、単一のパラメータがある場合にはその出力パラメータ値を、複数のパラメータがある場合には出力パラメータ値が入ったタプルを、それぞれ自動的に返します。そのため、GetWindowRect 関数は呼び出されると RECT インスタンスを返します。</p>
<p>さらに出力処理やエラーチェックを行うために、出力パラメータを <code class="xref py py-attr docutils literal"><span class="pre">errcheck</span></code> プロトコルと組み合わせることができます。 win32 <code class="docutils literal"><span class="pre">GetWindowRect</span></code> api 関数は成功したか失敗したかを知らせるために <code class="docutils literal"><span class="pre">BOOL</span></code> を返します。そのため、この関数はエラーチェックを行って、 api 呼び出しが失敗した場合に例外を送出させることができます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal"><span class="pre">errcheck</span></code> 関数が受け取った引数タプルを変更なしに返した場合、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は出力パラメータに対する通常の処理を続けます。 <code class="docutils literal"><span class="pre">RECT</span></code> インスタンスの代わりに window 座標のタプルを返すには、関数のフィールドを取り出し、代わりにそれらを返すことができます。この場合、通常処理は行われなくなります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="utility-functions">
<span id="ctypes-utility-functions"></span><h3>16.16.2.5. ユーティリティー関数<a class="headerlink" href="#utility-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="ctypes.addressof">
<code class="descclassname">ctypes.</code><code class="descname">addressof</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリバッファのアドレスを示す整数を返します。 <em>obj</em> は ctypes 型のインスタンスでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.alignment">
<code class="descclassname">ctypes.</code><code class="descname">alignment</code><span class="sig-paren">(</span><em>obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ctypes 型のアライメントの必要条件を返します。 <em>obj_or_type</em> は ctypes 型またはインスタンスでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.byref">
<code class="descclassname">ctypes.</code><code class="descname">byref</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> (ctypes 型のインスタンスでなければならない) への軽量ポインタを返します。 <em>offset</em> はデフォルトでは 0 で、内部ポインターへ加算される整数です。</p>
<p><code class="docutils literal"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code> は、 C コードとしては、以下のようにみなされます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>返されるオブジェクトは外部関数呼び出しのパラメータとしてのみ使用できます。<code class="docutils literal"><span class="pre">pointer(obj)</span></code> と似たふるまいをしますが、作成が非常に速く行えます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.cast">
<code class="descclassname">ctypes.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>obj</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は C のキャスト演算子に似ています。<em>obj</em> と同じメモリブロックを指している <em>type</em> の新しいインスタンスを返します。<em>type</em> はポインタ型でなければならず、<em>obj</em> はポインタとして解釈できるオブジェクトでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_string_buffer">
<code class="descclassname">ctypes.</code><code class="descname">create_string_buffer</code><span class="sig-paren">(</span><em>init_or_size</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は変更可能な文字バッファを作成します。返されるオブジェクトは <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal"><span class="pre">c_char</span></code></a> の ctypes 配列です。</p>
<p><em>init_or_size</em> は配列のサイズを指定する整数もしくは配列要素を初期化するために使われるバイト列オブジェクトである必要があります。</p>
<p>バイト列オブジェクトが第一引数として指定されていた場合、配列の最後の要素が NUL 終端文字となるように、バイト列オブジェクトの長さより 1 つ長いバッファを作成します。バイト列の長さを使うべきではない場合は、第二引数として整数を渡して、配列の長さを指定することができます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_unicode_buffer">
<code class="descclassname">ctypes.</code><code class="descname">create_unicode_buffer</code><span class="sig-paren">(</span><em>init_or_size</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は変更可能な Unicode 文字バッファを作成します。返されるオブジェクトは <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal"><span class="pre">c_wchar</span></code></a> の ctypes 配列です。</p>
<p><em>init_or_size</em> は配列のサイズを指定する整数もしくは配列要素を初期化するために使われる文字列である必要があります。</p>
<p>第一引数として文字列が指定された場合は、バッファが文字列の長さより一要素分大きく作られます。配列の最後の要素が NUL 終端文字であるためです。文字列の長さを使うべきでない場合は、配列のサイズを指定するために整数を第二引数として渡すことができます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllCanUnloadNow">
<code class="descclassname">ctypes.</code><code class="descname">DllCanUnloadNow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: この関数は ctypes をつかってインプロセス COM サーバーを実装できるようにするためのフックです。_ctypes 拡張 dll がエクスポートしている DllCanUnloadNow 関数から呼び出されます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllGetClassObject">
<code class="descclassname">ctypes.</code><code class="descname">DllGetClassObject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: この関数は ctypes をつかってインプロセス COM サーバーを実装できるようにするためのフックです。<code class="docutils literal"><span class="pre">_ctypes</span></code> 拡張 dll がエクスポートしている DllGetClassObject 関数から呼び出されます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_library">
<code class="descclassname">ctypes.util.</code><code class="descname">find_library</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ライブラリを検索し、パス名を返します。 <em>name</em> は <code class="docutils literal"><span class="pre">lib</span></code> のような接頭辞、 <code class="docutils literal"><span class="pre">.so</span></code> や <code class="docutils literal"><span class="pre">.dylib</span></code> のような接尾辞、そして、バージョンナンバーを除くライブラリ名です (これは posix のリンカーオプション <code class="xref std std-option docutils literal"><span class="pre">-l</span></code> で使われる書式です) 。もしライブラリが見つからなければ、 <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>厳密な機能はシステムに依存します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_msvcrt">
<code class="descclassname">ctypes.util.</code><code class="descname">find_msvcrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: Python と拡張モジュールで使われる VC ランタイムライブラリのファイル名を返します。もしライブラリ名が同定できなければ、 <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>もし、例えば拡張モジュールにより割り付けられたメモリを <code class="docutils literal"><span class="pre">free(void</span> <span class="pre">*)</span></code> で解放する必要があるなら、メモリ割り付けを行ったのと同じライブラリの関数を使うことが重要です。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.FormatError">
<code class="descclassname">ctypes.</code><code class="descname">FormatError</code><span class="sig-paren">(</span><span class="optional">[</span><em>code</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: エラーコード <em>code</em> の説明文を返します。エラーコードが指定されない場合は、 Windows api 関数 GetLastError を呼び出して、もっとも新しいエラーコードが使われます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.GetLastError">
<code class="descclassname">ctypes.</code><code class="descname">GetLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: 呼び出し側のスレッド内で Windows によって設定された最新のエラーコードを返します。この関数は Windows の <cite>GetLastError()</cite> 関数を直接実行します。 ctypes のプライベートなエラーコードのコピーを返したりはしません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_errno">
<code class="descclassname">ctypes.</code><code class="descname">get_errno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>システムの <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal"><span class="pre">errno</span></code></a> 変数の、スレッドローカルなプライベートコピーを返します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_last_error">
<code class="descclassname">ctypes.</code><code class="descname">get_last_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: システムの <code class="xref py py-data docutils literal"><span class="pre">LastError</span></code> 変数の、スレッドローカルなプライベートコピーを返します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memmove">
<code class="descclassname">ctypes.</code><code class="descname">memmove</code><span class="sig-paren">(</span><em>dst</em>, <em>src</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準 C の memmove ライブラリ関数と同じものです。: <em>count</em> バイトを <em>src</em> から <em>dst</em> へコピーします。 <em>dst</em> と <em>src</em> はポインタへ変換可能な整数または ctypes インスタンスでなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memset">
<code class="descclassname">ctypes.</code><code class="descname">memset</code><span class="sig-paren">(</span><em>dst</em>, <em>c</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準 C の memset ライブラリ関数と同じものです。: アドレス <em>dst</em> のメモリブロックを値 <em>c</em> を <em>count</em> バイト分書き込みます。 <em>dst</em> はアドレスを指定する整数または ctypes インスタンスである必要があります。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.POINTER">
<code class="descclassname">ctypes.</code><code class="descname">POINTER</code><span class="sig-paren">(</span><em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このファクトリ関数は新しい ctypes ポインタ型を作成して返します。ポインタ型はキャッシュされ、内部で再利用されます。したがって、この関数を繰り返し呼び出してもコストは小さいです。<em>type</em> は ctypes 型でなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.pointer">
<code class="descclassname">ctypes.</code><code class="descname">pointer</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <em>obj</em> を指す新しいポインタインスタンスを作成します。戻り値は <code class="docutils literal"><span class="pre">POINTER(type(obj))</span></code> 型のオブジェクトです。</p>
<p>注意: 外部関数呼び出しへオブジェクトへのポインタを渡したいだけなら、はるかに高速な <code class="docutils literal"><span class="pre">byref(obj)</span></code> を使うべきです。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.resize">
<code class="descclassname">ctypes.</code><code class="descname">resize</code><span class="sig-paren">(</span><em>obj</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は <em>obj</em> の内部メモリバッファのサイズを変更します。 <em>obj</em> は ctypes 型のインスタンスでなければなりません。バッファを <code class="docutils literal"><span class="pre">sizeof(type(obj))</span></code> で与えられるオブジェクト型の本来のサイズより小さくすることはできませんが、バッファを拡大することはできます。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_errno">
<code class="descclassname">ctypes.</code><code class="descname">set_errno</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>システム変数 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal"><span class="pre">errno</span></code></a> の、呼び出し元スレッドでの ctypes のプライベートコピーの現在値を <em>value</em> に設定し、前の値を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_last_error">
<code class="descclassname">ctypes.</code><code class="descname">set_last_error</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: システム変数 <code class="xref py py-data docutils literal"><span class="pre">LastError</span></code> の、呼び出し元スレッドでの ctypes のプライベートコピーの現在値を <em>value</em> に設定し、前の値を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.sizeof">
<code class="descclassname">ctypes.</code><code class="descname">sizeof</code><span class="sig-paren">(</span><em>obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ctypes の型やインスタンスのメモリバッファのサイズをバイト数で返します。C の <code class="docutils literal"><span class="pre">sizeof</span></code> 演算子と同様の動きをします。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.string_at">
<code class="descclassname">ctypes.</code><code class="descname">string_at</code><span class="sig-paren">(</span><em>address</em>, <em>size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数はメモリアドレス <em>address</em> から始まる C 文字列を返します。size が指定された場合はサイズとして使われます。指定されなければ、文字列がゼロ終端されていると仮定します。</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WinError">
<code class="descclassname">ctypes.</code><code class="descname">WinError</code><span class="sig-paren">(</span><em>code=None</em>, <em>descr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows 用: この関数はおそらく ctypes の中で最悪の名前でしょう。これは OSError のインスタンスを作成します。 <em>code</em> が指定されていなかった場合、エラーコードを判別するために <code class="docutils literal"><span class="pre">GetLastError</span></code> が呼び出されます。 <em>descr</em> が指定されていなかった場合、エラーの説明文を得るために <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><code class="xref py py-func docutils literal"><span class="pre">FormatError()</span></code></a> が呼び出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>以前は <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal"><span class="pre">WindowsError</span></code></a> インスタンスが作成されていました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ctypes.wstring_at">
<code class="descclassname">ctypes.</code><code class="descname">wstring_at</code><span class="sig-paren">(</span><em>address</em>, <em>size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この関数は文字列としてメモリアドレス <em>address</em> から始まるワイドキャラクタ文字列を返します。<em>size</em> が指定されたならば、文字列の文字数として使われます。指定されなければ、文字列がゼロ終端されていると仮定します。</p>
</dd></dl>

</div>
<div class="section" id="data-types">
<span id="ctypes-data-types"></span><h3>16.16.2.6. データ型<a class="headerlink" href="#data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="ctypes._CData">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_CData</code><a class="headerlink" href="#ctypes._CData" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この非公開クラスはすべての ctypes データ型の共通のベースクラスです。他のことはさておき、すべての ctypes 型インスタンスは C 互換データを保持するメモリブロックを内部に持ちます。このメモリブロックのアドレスは <a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal"><span class="pre">addressof()</span></code></a> ヘルパー関数が返します。別のインスタンス変数が <a class="reference internal" href="#ctypes._CData._objects" title="ctypes._CData._objects"><code class="xref py py-attr docutils literal"><span class="pre">_objects</span></code></a> として公開されます。これはメモリブロックがポインタを含む場合に存続し続ける必要のある他の Python オブジェクトを含んでいます。</p>
<p>ctypes データ型の共通メソッド、すべてのクラスメソッドが存在します (正確には、 <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">メタクラス</span></a> のメソッドです):</p>
<dl class="method">
<dt id="ctypes._CData.from_buffer">
<code class="descname">from_buffer</code><span class="sig-paren">(</span><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>source</em> オブジェクトのバッファを共有する ctypes のインスタンスを返します。 <em>source</em> オブジェクトは書き込み可能バッファインターフェースをサポートしている必要があります。オプションの <em>offset</em> 引数では <em>source</em> バッファのオフセットをバイト単位で指定します。デフォルトではゼロです。もし <em>source</em> バッファが十分に大きくなければ、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_buffer_copy">
<code class="descname">from_buffer_copy</code><span class="sig-paren">(</span><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>source</em> オブジェクトの読み出し可能バッファをコピーすることで、ctypes のインスタンスを生成します。オプションの <em>offset</em> 引数では <em>source</em> バッファのオフセットをバイト単位で指定します。デフォルトではゼロです。もし <em>source</em> バッファが十分に大きくなければ、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_address">
<code class="descname">from_address</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>address</em> で指定されたメモリを使って ctypes 型のインスタンスを返します。 <em>address</em> は整数でなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_param">
<code class="descname">from_param</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <em>obj</em> を ctypes 型に適合させます。外部関数の <code class="xref py py-attr docutils literal"><span class="pre">argtypes</span></code> タプルに、その型があるとき、外部関数呼び出しで実際に使われるオブジェクトと共に呼び出されます。</p>
<p>すべての ctypes のデータ型は、それが型のインスタンスであれば、 <em>obj</em> を返すこのクラスメソッドのデフォルトの実装を持ちます。いくつかの型は、別のオブジェクトも受け付けます。</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.in_dll">
<code class="descname">in_dll</code><span class="sig-paren">(</span><em>library</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、共有ライブラリによってエクスポートされた ctypes 型のインスタンスを返します。 <em>name</em> はエクスポートされたデータの名前で、 <em>library</em> はロードされた共有ライブラリです。</p>
</dd></dl>

<p>ctypes データ型共通のインスタンス変数:</p>
<dl class="attribute">
<dt id="ctypes._CData._b_base_">
<code class="descname">_b_base_</code><a class="headerlink" href="#ctypes._CData._b_base_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ctypes 型データのインスタンスは、それ自身のメモリブロックを持たず、基底オブジェクトのメモリブロックの一部を共有することがあります。 <a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal"><span class="pre">_b_base_</span></code></a> 読み出し専用属性は、メモリブロックを保持する ctypes の基底オブジェクトです。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._b_needsfree_">
<code class="descname">_b_needsfree_</code><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この読み出し専用の変数は、 ctypes データインスタンスが、それ自身に割り当てられたメモリブロックを持つとき true になります。それ以外の場合は false になります。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._objects">
<code class="descname">_objects</code><a class="headerlink" href="#ctypes._CData._objects" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメンバは <code class="docutils literal"><span class="pre">None</span></code> 、または、メモリブロックの内容が正しく保つために、生存させておかなくてはならない Python オブジェクトを持つディクショナリです。このオブジェクトはデバッグでのみ使われます。決してディクショナリの内容を変更しないで下さい。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3>16.16.2.7. 基本データ型<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="ctypes._SimpleCData">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_SimpleCData</code><a class="headerlink" href="#ctypes._SimpleCData" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この非公開クラスは、全ての基本的な ctypes データ型の基底クラスです。これは基本的な ctypes データ型に共通の属性を持っているので、ここで触れておきます。 <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal"><span class="pre">_SimpleCData</span></code></a> は <a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal"><span class="pre">_CData</span></code></a> の子クラスなので、そのメソッドと属性を継承しています。ポインタでないかポインタを含まない ctypes データ型は、現在は pickle 化できます。</p>
<p>インスタンスは一つだけ属性を持ちます:</p>
<dl class="attribute">
<dt id="ctypes._SimpleCData.value">
<code class="descname">value</code><a class="headerlink" href="#ctypes._SimpleCData.value" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性は、インスタンスの実際の値を持ちます。整数型とポインタ型に対しては整数型、文字型に対しては一文字のバイト列オブジェクト、文字へのポインタに対しては Python のバイト列オブジェクトもしくは文字列となります。</p>
<p><code class="docutils literal"><span class="pre">value</span></code> 属性が ctypes インスタンスより参照されたとき、大抵の場合はそれぞれに対し新しいオブジェクトを返します。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> はオリジナルのオブジェクトを返す実装にはなって <em>おらず</em> 新しいオブジェクトを構築します。同じことが他の ctypes オブジェクトインスタンスに対しても言えます。</p>
</dd></dl>

</dd></dl>

<p>基本データ型は、外部関数呼び出しの結果として返されたときや、例えば構造体のフィールドメンバーや配列要素を取り出すときに、ネイティブの Python 型へ透過的に変換されます。言い換えると、外部関数が <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal"><span class="pre">c_char_p</span></code></a> の <code class="xref py py-attr docutils literal"><span class="pre">restype</span></code> を持つ場合は、 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal"><span class="pre">c_char_p</span></code></a> インスタンスでは <em>なく</em> 常に Python バイト列オブジェクトを受け取ることでしょう。</p>
<p>基本データ型のサブクラスはこの振る舞いを継承 <em>しません</em> 。したがって、外部関数の <code class="xref py py-attr docutils literal"><span class="pre">restype</span></code> が <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal"><span class="pre">c_void_p</span></code></a> のサブクラスならば、関数呼び出しからこのサブクラスのインスタンスを受け取ります。もちろん、 <code class="docutils literal"><span class="pre">value</span></code> 属性にアクセスしてポインタの値を得ることができます。</p>
<p>これらが基本 ctypes データ型です:</p>
<dl class="class">
<dt id="ctypes.c_byte">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_byte</code><a class="headerlink" href="#ctypes.c_byte" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">char</span></code> データ型を表し、小整数として値を解釈します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_char</code><a class="headerlink" href="#ctypes.c_char" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">char</span></code> データ型を表し、単一の文字として値を解釈します。コンストラクタはオプションの文字列初期化子を受け取り、その文字列の長さちょうど一文字である必要があります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_char_p</code><a class="headerlink" href="#ctypes.c_char_p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> データ型を表し、ゼロ終端文字列へのポインタでなければなりません。バイナリデータを指す可能性のある一般的なポインタに対しては <code class="docutils literal"><span class="pre">POINTER(c_char)</span></code> を使わなければなりません。コンストラクタは整数のアドレスもしくはバイト列オブジェクトを受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_double">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_double</code><a class="headerlink" href="#ctypes.c_double" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">double</span></code> データ型を表します。コンストラクタはオプションの浮動小数点数初期化子を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longdouble">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_longdouble</code><a class="headerlink" href="#ctypes.c_longdouble" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">double</span></code> データ型を表します。コンストラクタはオプションで浮動小数点数初期化子を受け取ります。 <code class="docutils literal"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span> <span class="pre">sizeof(double)</span></code> であるプラットフォームでは <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal"><span class="pre">c_double</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_float">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_float</code><a class="headerlink" href="#ctypes.c_float" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">float</span></code> データ型を表します。コンストラクタはオプションの浮動小数点数初期化子を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int</code><a class="headerlink" href="#ctypes.c_int" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。 <code class="docutils literal"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> であるプラットフォームでは、 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal"><span class="pre">c_long</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int8">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int8</code><a class="headerlink" href="#ctypes.c_int8" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 8-bit <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal"><span class="pre">c_byte</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int16">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int16</code><a class="headerlink" href="#ctypes.c_int16" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 16-bit <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal"><span class="pre">c_short</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int32">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int32</code><a class="headerlink" href="#ctypes.c_int32" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 32-bit <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int64">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int64</code><a class="headerlink" href="#ctypes.c_int64" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 64-bit <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal"><span class="pre">c_longlong</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_long">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_long</code><a class="headerlink" href="#ctypes.c_long" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">long</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longlong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_longlong</code><a class="headerlink" href="#ctypes.c_longlong" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_short">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_short</code><a class="headerlink" href="#ctypes.c_short" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">signed</span> <span class="pre">short</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_size_t">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_size_t</code><a class="headerlink" href="#ctypes.c_size_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">size_t</span></code> データ型を表します。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ssize_t">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ssize_t</code><a class="headerlink" href="#ctypes.c_ssize_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">ssize_t</span></code> データ型を表します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ubyte">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ubyte</code><a class="headerlink" href="#ctypes.c_ubyte" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></code> データ型を表し、小さな整数として値を解釈します。コンストラクタはオプションの整数初期化子を受け取ります; オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint</code><a class="headerlink" href="#ctypes.c_uint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の  <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります; オーバーフローのチェックは行われません。これは、 <code class="docutils literal"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> であるプラットフォームでは <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal"><span class="pre">c_ulong</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint8">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint8</code><a class="headerlink" href="#ctypes.c_uint8" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 8-bit <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal"><span class="pre">c_ubyte</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint16">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint16</code><a class="headerlink" href="#ctypes.c_uint16" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 16-bit <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal"><span class="pre">c_ushort</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint32">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint32</code><a class="headerlink" href="#ctypes.c_uint32" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 32-bit <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal"><span class="pre">c_uint</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint64">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint64</code><a class="headerlink" href="#ctypes.c_uint64" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C 64-bit <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> データ型を表します。たいていは、 <a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal"><span class="pre">c_ulonglong</span></code></a> の別名です。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ulong</code><a class="headerlink" href="#ctypes.c_ulong" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulonglong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ulonglong</code><a class="headerlink" href="#ctypes.c_ulonglong" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ushort">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ushort</code><a class="headerlink" href="#ctypes.c_ushort" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></code> データ型を表します。コンストラクタはオプションの整数初期化子を受け取ります。オーバーフローのチェックは行われません。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_void_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_void_p</code><a class="headerlink" href="#ctypes.c_void_p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">void</span> <span class="pre">*</span></code> データ型を表します。値は整数として表されます。コンストラクタはオプションの整数初期化子を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_wchar</code><a class="headerlink" href="#ctypes.c_wchar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">wchar_t</span></code> データ型を表し、値は Unicode 文字列の単一の文字として解釈されます。コンストラクタはオプションの文字列初期化子を受け取り、その文字列の長さはちょうど一文字である必要があります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_wchar_p</code><a class="headerlink" href="#ctypes.c_wchar_p" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <code class="xref c c-type docutils literal"><span class="pre">wchar_t</span> <span class="pre">*</span></code> データ型を表し、ゼロ終端ワイド文字列へのポインタでなければなりません。コンストラクタは整数のアドレスもしくは文字列を受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_bool">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_bool</code><a class="headerlink" href="#ctypes.c_bool" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C の <code class="xref c c-type docutils literal"><span class="pre">bool</span></code> データ型 (より正確には、 C99 以降の  <code class="xref c c-type docutils literal"><span class="pre">_Bool</span></code>) を表します。 <code class="docutils literal"><span class="pre">True</span></code> または <code class="docutils literal"><span class="pre">False</span></code> の値を持ち、コンストラクタは真偽値と解釈できるオブジェクトを受け取ります。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.HRESULT">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">HRESULT</code><a class="headerlink" href="#ctypes.HRESULT" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows用: <code class="xref c c-type docutils literal"><span class="pre">HRESULT</span></code> 値を表し、関数またはメソッド呼び出しに対する成功またはエラーの情報を含んでいます。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.py_object">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">py_object</code><a class="headerlink" href="#ctypes.py_object" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>C <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> データ型を表します。引数なしでこれを呼び出すと <code class="docutils literal"><span class="pre">NULL</span></code> <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> ポインタを作成します。</p>
</dd></dl>

<p><code class="xref py py-mod docutils literal"><span class="pre">ctypes.wintypes</span></code> モジュールは他の Windows 固有のデータ型を提供します。例えば、 <code class="xref c c-type docutils literal"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal"><span class="pre">WPARAM</span></code>, <code class="xref c c-type docutils literal"><span class="pre">DWORD</span></code> です。 <code class="xref c c-type docutils literal"><span class="pre">MSG</span></code> や <code class="xref c c-type docutils literal"><span class="pre">RECT</span></code> のような有用な構造体も定義されています。</p>
</div>
<div class="section" id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3>16.16.2.8. 構造化データ型<a class="headerlink" href="#structured-data-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="ctypes.Union">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Union</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ネイティブのバイトオーダーでの共用体のための抽象ベースクラス。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.BigEndianStructure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">BigEndianStructure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>ビックエンディアン</em> バイトオーダーでの構造体のための抽象ベースクラス。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.LittleEndianStructure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">LittleEndianStructure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>リトルエンディアン</em> バイトオーダーでの構造体のための抽象ベースクラス。</p>
</dd></dl>

<p>ネイティブではないバイトオーダーを持つ構造体にポインタ型フィールドあるいはポインタ型フィールドを含む他のどんなデータ型をも入れることはできません。</p>
<dl class="class">
<dt id="ctypes.Structure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Structure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>ネイティブ</em> のバイトオーダーでの構造体のための抽象ベースクラス。</p>
<p>具象構造体型と具象共用体型はこれらの型の一つをサブクラス化することで作らなければなりません。少なくとも、 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> クラス変数を定義する必要があります。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は、属性に直接アクセスしてフィールドを読み書きできるようにする記述子 (<a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>) を作成するでしょう。これらは、</p>
<dl class="attribute">
<dt id="ctypes.Structure._fields_">
<code class="descname">_fields_</code><a class="headerlink" href="#ctypes.Structure._fields_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>構造体のフィールドを定義するシーケンス。要素は2要素タプルか3要素タプルでなければなりません。第一要素はフィールドの名前です。第二要素はフィールドの型を指定します。それはどんな ctypes データ型でも構いません。</p>
<p><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal"><span class="pre">c_int</span></code></a> のような整数型のために、オプションの第三要素を与えることができます。フィールドのビット幅を定義する正の小整数である必要があります。</p>
<p>一つの構造体と共用体の中で、フィールド名はただ一つである必要があります。これはチェックされません。名前が繰り返しでてきたときにアクセスできるのは一つのフィールドだけです。</p>
<p>Structure サブクラスを定義するクラス文の <em>後で</em> 、 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> クラス変数を定義することができます。これにより、次のように自身を直接または間接的に参照するデータ型を作成できるようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p>しかし、 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> クラス変数はその型が最初に使われる (インスタンスが作成される、それに対して <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal"><span class="pre">sizeof()</span></code></a> が呼び出されるなど) より前に定義されていなければなりません。その後 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> クラス変数へ代入すると AttributeError が送出されます。</p>
<p>構造体型のサブクラスを定義することができ、もしあるならサブクラス内で定義された <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> に加えて、ベースクラスのフィールドも継承します。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._pack_">
<code class="descname">_pack_</code><a class="headerlink" href="#ctypes.Structure._pack_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インスタンスの構造体フィールドのアライメントを上書きできるようにするオブションの小整数。 <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal"><span class="pre">_pack_</span></code></a> は <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> が代入されたときすでに定義されていなければなりません。そうでなければ、何の効果もありません。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._anonymous_">
<code class="descname">_anonymous_</code><a class="headerlink" href="#ctypes.Structure._anonymous_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>無名 (匿名) フィールドの名前が並べあげられたオプションのシーケンス。 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> が代入されたとき、 <a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal"><span class="pre">_anonymous_</span></code></a> がすでに定義されていなければなりません。そうでなければ、何ら影響はありません。</p>
<p>この変数に並べあげられたフィールドは構造体型もしくは共用体型フィールドである必要があります。構造体フィールドまたは共用体フィールドを作る必要なく、入れ子になったフィールドに直接アクセスできるようにするために、 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は構造体型の中に記述子を作成します。</p>
<p>型の例です (Windows):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">TYPEDESC</span></code> 構造体はCOMデータ型を表現しており、 <code class="docutils literal"><span class="pre">vt</span></code> フィールドは共用体フィールドのどれが有効であるかを指定します。 <code class="docutils literal"><span class="pre">u</span></code> フィールドは匿名フィールドとして定義されているため、 TYPEDESC インスタンスから取り除かれてそのメンバーへ直接アクセスできます。 <code class="docutils literal"><span class="pre">td.lptdesc</span></code> と <code class="docutils literal"><span class="pre">td.u.lptdesc</span></code> は同等ですが、前者がより高速です。なぜなら一時的な共用体インスタンスを作る必要がないためです。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>構造体のサブ-サブクラスを定義することができ、ベースクラスのフィールドを継承します。サブクラス定義に別の <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> 変数がある場合は、この中で指定されたフィールドはベースクラスのフィールドへ追加されます。</p>
<p>構造体と共用体のコンストラクタは位置引数とキーワード引数の両方を受け取ります。位置引数は <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> の中に現れたのと同じ順番でメンバーフィールドを初期化するために使われます。コンストラクタのキーワード引数は属性代入として解釈され、そのため、同じ名前をもつ <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> を初期化するか、 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal"><span class="pre">_fields_</span></code></a> に存在しない名前に対しては新しい属性を作ります。</p>
</dd></dl>

</div>
<div class="section" id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3>16.16.2.9. 配列とポインタ<a class="headerlink" href="#arrays-and-pointers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="class">
<dt id="ctypes.Array">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Array</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>配列のための抽象基底クラスです。</p>
<p>具象配列型を作成するための推奨される方法は、任意の <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> データ型に正の整数を乗算することです。代わりに、この型のサブクラスを作成し、 <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal"><span class="pre">_length_</span></code></a> と <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal"><span class="pre">_type_</span></code></a> のクラス変数を定義することもできます。配列の要素は、標準の添え字とスライスによるアクセスを使用して読み書きを行うことができます。スライスの読み込みでは、結果のオブジェクト自体は <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal"><span class="pre">Array</span></code></a> ではありません。</p>
<dl class="attribute">
<dt id="ctypes.Array._length_">
<code class="descname">_length_</code><a class="headerlink" href="#ctypes.Array._length_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>配列の要素数を指定する正の整数。範囲外の添え字を指定すると、 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> が送出されます。<a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> がこの整数を返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Array._type_">
<code class="descname">_type_</code><a class="headerlink" href="#ctypes.Array._type_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>配列内の各要素の型を指定します。</p>
</dd></dl>

<p>配列のサブクラスのコンストラクタは、位置引数を受け付けて、配列を順番に初期化するために使用します。</p>
</dd></dl>

<dl class="class">
<dt id="ctypes._Pointer">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_Pointer</code><a class="headerlink" href="#ctypes._Pointer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ポインタのためのプライベートな抽象基底クラスです。</p>
<p>具象ポインタ型は、ポイント先の型を持つ <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal"><span class="pre">POINTER()</span></code></a> を呼び出すことで、作成できます。これは、 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal"><span class="pre">pointer()</span></code></a> により自動的に行われます。</p>
<p>ポインタが配列を指す場合、その配列の要素は、標準の添え字とスライスによるアクセスを使用して読み書きが行えます。ポインタオブジェクトには、サイズがないため、 <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> 関数は <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。負の添え字は、(C と同様に) ポインタの <em>前</em> のメモリから読み込み、範囲外の添え字はおそらく (幸運な場合でも) アクセス違反によりクラッシュを起こします。</p>
<dl class="attribute">
<dt id="ctypes._Pointer._type_">
<code class="descname">_type_</code><a class="headerlink" href="#ctypes._Pointer._type_" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ポイント先の型を指定します。</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._Pointer.contents">
<code class="descname">contents</code><a class="headerlink" href="#ctypes._Pointer.contents" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ポインタが指すオブジェクトを返します。この属性に割り当てると、ポインタが割り当てられたオブジェクトを指すようになります。</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">16.16. <code class="docutils literal"><span class="pre">ctypes</span></code> — Pythonのための外部関数ライブラリ</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">16.16.1. ctypesチュートリアル</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">16.16.1.1. 動的リンクライブラリをロードする</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">16.16.1.2. ロードしたdllから関数にアクセスする</a></li>
<li><a class="reference internal" href="#calling-functions">16.16.1.3. 関数を呼び出す</a></li>
<li><a class="reference internal" href="#fundamental-data-types">16.16.1.4. 基本データ型</a></li>
<li><a class="reference internal" href="#calling-functions-continued">16.16.1.5. 続・関数を呼び出す</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">16.16.1.6. 自作のデータ型とともに関数を呼び出す</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">16.16.1.7. 要求される引数の型を指定する (関数プロトタイプ)</a></li>
<li><a class="reference internal" href="#return-types">16.16.1.8. 戻り値の型</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">16.16.1.9. ポインタを渡す(または、パラメータの参照渡し)</a></li>
<li><a class="reference internal" href="#structures-and-unions">16.16.1.10. 構造体と共用体</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">16.16.1.11. 構造体/共用体アライメントとバイトオーダー</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">16.16.1.12. 構造体と共用体におけるビットフィールド</a></li>
<li><a class="reference internal" href="#arrays">16.16.1.13. 配列</a></li>
<li><a class="reference internal" href="#pointers">16.16.1.14. ポインタ</a></li>
<li><a class="reference internal" href="#type-conversions">16.16.1.15. 型変換</a></li>
<li><a class="reference internal" href="#incomplete-types">16.16.1.16. 不完全型</a></li>
<li><a class="reference internal" href="#callback-functions">16.16.1.17. コールバック関数</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">16.16.1.18. dllからエクスポートされた値へアクセスする</a></li>
<li><a class="reference internal" href="#surprises">16.16.1.19. びっくり仰天</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">16.16.1.20. 可変サイズのデータ型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">16.16.2. ctypesリファレンス</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">16.16.2.1. 共有ライブラリを見つける</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">16.16.2.2. 共有ライブラリをロードする</a></li>
<li><a class="reference internal" href="#foreign-functions">16.16.2.3. 外部関数</a></li>
<li><a class="reference internal" href="#function-prototypes">16.16.2.4. 関数プロトタイプ</a></li>
<li><a class="reference internal" href="#utility-functions">16.16.2.5. ユーティリティー関数</a></li>
<li><a class="reference internal" href="#data-types">16.16.2.6. データ型</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">16.16.2.7. 基本データ型</a></li>
<li><a class="reference internal" href="#structured-data-types">16.16.2.8. 構造化データ型</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">16.16.2.9. 配列とポインタ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="errno.html"
                        title="前の章へ">16.15. <code class="docutils literal"><span class="pre">errno</span></code> — 標準の errno システムシンボル</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="concurrency.html"
                        title="次の章へ">17. 並行実行</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/ctypes.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="17. 並行実行"
             >次へ</a> |</li>
        <li class="right" >
          <a href="errno.html" title="16.15. errno — 標準の errno システムシンボル"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >16. 汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2月 10, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>