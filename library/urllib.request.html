
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>21.6. urllib.request — URL を開くための拡張可能なライブラリ &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="21.8. urllib.parse — URL を解析して構成要素にする" href="urllib.parse.html" />
    <link rel="prev" title="21.5. urllib — URL を扱うモジュール群" href="urllib.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/urllib.request.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/urllib.request.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="21.8. urllib.parse — URL を解析して構成要素にする"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="21.5. urllib — URL を扱うモジュール群"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">21. インターネットプロトコルとサポート</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-urllib.request">
<span id="urllib-request-extensible-library-for-opening-urls"></span><h1>21.6. <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal"><span class="pre">urllib.request</span></code></a> — URL を開くための拡張可能なライブラリ<a class="headerlink" href="#module-urllib.request" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/urllib/request.py">Lib/urllib/request.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal"><span class="pre">urllib.request</span></code></a> モジュールは基本的な認証、暗号化認証、リダイレクション、Cookie、その他の介在する複雑なアクセス環境において (大抵は HTTP で) URL を開くための関数とクラスを定義します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">より高水準の HTTP クライアントインターフェイスとしては <a class="reference external" href="http://docs.python-requests.org/">Requests パッケージ</a> がお奨めです。</p>
</div>
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal"><span class="pre">urllib.request</span></code></a> モジュールでは以下の関数を定義しています:</p>
<dl class="function">
<dt id="urllib.request.urlopen">
<code class="descclassname">urllib.request.</code><code class="descname">urlopen</code><span class="sig-paren">(</span><em>url</em>, <em>data=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>*</em>, <em>cafile=None</em>, <em>capath=None</em>, <em>cadefault=False</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL <em>url</em> を開きます。 <em>url</em> は文字列でも <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> オブジェクトでもかまいません。</p>
<p><em>data</em> must be an object specifying additional data to be sent to the
server, or <code class="docutils literal"><span class="pre">None</span></code> if no such data is needed.  See <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a>
for details.</p>
<p>urllib.request モジュールは HTTP/1.1 を使用し、その HTTP リクエストに <code class="docutils literal"><span class="pre">Connection:close</span></code> ヘッダーを含みます。</p>
<p>任意引数 <em>timeout</em> には接続開始などのブロックする操作におけるタイムアウト時間を秒数で指定します (指定されなかった場合、グローバルのデフォルトタイムアウト時間が利用されます)。この引数は、 HTTP, HTTPS, FTP 接続でのみ有効です。</p>
<p><em>context</em> を指定する場合は、様々な SSL オプションを記述する <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a> インスタンスでなければなりません。
詳細は <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal"><span class="pre">HTTPSConnection</span></code></a> を参照してください。</p>
<p>任意引数 <em>cafile</em> および <em>capath</em> には HTTPS リクエストのための CA 証明書のセットを指定します。<em>cafile</em> には CA 証明書のリストを含む 1 個のファイルを指定し、<em>capath</em> にはハッシュ化された証明書ファイルが格納されたディレクトリを指定しなければなりません。より詳しい情報は <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a> を参照してください。</p>
<p><em>cadefault</em> 引数は無視されます。</p>
<p>この関数は常に <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">コンテクストマネージャ</span></a> として機能するオブジェクトを返します。このオブジェクトには以下のメソッドがあります。</p>
<ul class="simple">
<li><code class="xref py py-meth docutils literal"><span class="pre">geturl()</span></code> — 取得されたリソースの URL を返します。 主に、リダイレクトが発生したかどうかを確認するために利用します</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">info()</span></code> — 取得されたページのヘッダーなどのメタ情報を、 <a class="reference internal" href="email.parser.html#email.message_from_string" title="email.message_from_string"><code class="xref py py-func docutils literal"><span class="pre">email.message_from_string()</span></code></a> インスタンスとして返します。 (<a class="reference external" href="https://www.cs.tut.fi/~jkorpela/http.html">Quick Reference to HTTP Headers</a> を参照してください)</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">getcode()</span></code> – レスポンスの HTTP ステータスコードです。</li>
</ul>
<p>HTTP および HTTPS URL の場合、この関数は、わずかに修正された <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal"><span class="pre">http.client.HTTPResponse</span></code></a> オブジェクトを返します。上記の3つの新しいメソッドに加えて、 msg 属性が <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal"><span class="pre">HTTPResponse</span></code></a> のドキュメンテーションで指定されているレスポンスヘッダーの代わりに <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal"><span class="pre">reason</span></code></a> 属性 — サーバーから返された reason フレーズ — と同じ情報を含んでいます。</p>
<p>FTP 、ファイルおよびデータ URL 、レガシーな <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal"><span class="pre">URLopener</span></code></a> や <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal"><span class="pre">FancyURLopener</span></code></a> によって明示的に扱われるリクエストの場合、この関数は <code class="xref py py-class docutils literal"><span class="pre">urllib.response.addinfourl</span></code> オブジェクトを返します。</p>
<p>プロトコルエラー発生時は <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal"><span class="pre">URLError</span></code></a> を送出します。</p>
<p>どのハンドラもリクエストを処理しなかった場合には <code class="docutils literal"><span class="pre">None</span></code> を返すことがあるので注意してください (デフォルトでインストールされる グローバルハンドラの <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> は、 <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal"><span class="pre">UnknownHandler</span></code></a> を使って上記の問題が起きないようにしています)。</p>
<p>さらに、プロキシ設定が検出された場合(例えば <span class="target" id="index-23"></span><code class="xref std std-envvar docutils literal"><span class="pre">http_proxy</span></code> のような <code class="docutils literal"><span class="pre">*_proxy</span></code> 環境変数がセットされているなど)には <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyHandler</span></code></a> がデフォルトでインストールされ、これがプロキシを通してリクエストを処理するようにしています。</p>
<p>Python 2.6 以前のレガシーな <code class="docutils literal"><span class="pre">urllib.urlopen</span></code> 関数は廃止されました。<a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urllib.request.urlopen()</span></code></a> が過去の <code class="docutils literal"><span class="pre">urllib2.urlopen</span></code> に相当します。<code class="docutils literal"><span class="pre">urllib.urlopen</span></code> において辞書型オブジェクトで渡していたプロキシの扱いは、<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyHandler</span></code></a> オブジェクトを使用して取得できます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>cafile</em> および <em>capath</em> が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>HTTPS バーチャルホストがサポートされました (<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal"><span class="pre">ssl.HAS_SNI</span></code></a> が真の場合のみ)。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span><em>data</em> にイテラブルなオブジェクトを指定できるようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><em>cadefault</em> が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4.3 で変更: </span><em>context</em> が追加されました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.6 で撤廃: </span><em>cafile</em>, <em>capath</em> and <em>cadefault</em> are deprecated in favor of <em>context</em>.
Please use <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a> instead, or let
<a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal"><span class="pre">ssl.create_default_context()</span></code></a> select the system’s trusted CA
certificates for you.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.request.install_opener">
<code class="descclassname">urllib.request.</code><code class="descname">install_opener</code><span class="sig-paren">(</span><em>opener</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.install_opener" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定された <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> のインスタンスを、デフォルトで利用されるグローバルの opener としてインストールします。 opener のインストールは、 urlopen にその opener を使って欲しいとき以外必要ありません。普段は単に <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> の代わりに <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal"><span class="pre">OpenerDirector.open()</span></code></a> を利用してください。この関数は引数が本当に <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> のインスタンスであるかどうかはチェックしません。適切なインタフェースを持った任意のクラスを利用することができます。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.build_opener">
<code class="descclassname">urllib.request.</code><code class="descname">build_opener</code><span class="sig-paren">(</span><span class="optional">[</span><em>handler</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.build_opener" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた順番に URL ハンドラを連鎖させる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a>  のインスタンスを返します。 <em>handler</em> は <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> または <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> のサブクラスのインスタンスのどちらかです (どちらの場合も、コンストラクトは引数無しで呼び出せるようになっていなければなりません) 。クラス  <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyHandler</span></code></a> (proxy 設定が検出された場合), <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal"><span class="pre">UnknownHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPDefaultErrorHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPRedirectHandler" title="urllib.request.HTTPRedirectHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPRedirectHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal"><span class="pre">FTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FileHandler" title="urllib.request.FileHandler"><code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPErrorProcessor" title="urllib.request.HTTPErrorProcessor"><code class="xref py py-class docutils literal"><span class="pre">HTTPErrorProcessor</span></code></a> については、そのクラスのインスタンスか、そのサブクラスのインスタンスが <em>handler</em>  に含まれていない限り、 <em>handler</em> よりも先に連鎖します。</p>
<p>Python が SSL をサポートするように設定してインストールされている場合 (すなわち、 <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a> モジュールを import できる場合) <a class="reference internal" href="#urllib.request.HTTPSHandler" title="urllib.request.HTTPSHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPSHandler</span></code></a> も追加されます。</p>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> サブクラスでも <code class="xref py py-attr docutils literal"><span class="pre">handler_order</span></code> メンバー変数を変更して、ハンドラーリスト内での場所を変更できます。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.pathname2url">
<code class="descclassname">urllib.request.</code><code class="descname">pathname2url</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.pathname2url" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローカルシステムにおける記法で表されたパス名 <em>path</em> をURL におけるパス部分の形式に変換します。これは完全な URL を生成するわけではありません。戻り値は <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal"><span class="pre">quote()</span></code></a> 関数によってクオートされています。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.url2pathname">
<code class="descclassname">urllib.request.</code><code class="descname">url2pathname</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.url2pathname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL の、パーセントエンコードされたパス部分 <em>path</em> をローカルシステムの記法に変換します。これは完全な URL を受け付けません。<em>path</em> のデコードには <a class="reference internal" href="urllib.parse.html#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal"><span class="pre">unquote()</span></code></a> 関数を使用します。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.getproxies">
<code class="descclassname">urllib.request.</code><code class="descname">getproxies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.getproxies" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このヘルパー関数はスキーマからプロキシサーバーのURLへのマッピングを行う辞書を返します。この関数はまず、どのOSでも最初に <code class="docutils literal"><span class="pre">&lt;scheme&gt;_proxy</span></code> という名前の環境変数を大文字小文字を区別せずにスキャンします。そこで見つからなかった場合、 Max OS X の場合は Mac OSX システム環境設定を、 Windows の場合はシステムレジストリを参照します。もし小文字と大文字の環境変数が両方存在する (そして値が一致しない) なら、小文字の環境変数が優先されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">もし環境変数 <code class="docutils literal"><span class="pre">REQUEST_METHOD</span></code> が設定されていたら (これは通常スクリプトが CGI 環境で動いていることを示しています)、環境変数 <code class="docutils literal"><span class="pre">HTTP_PROXY</span></code> (大文字の <code class="docutils literal"><span class="pre">_PROXY</span></code>) は無視されます。その理由は、クライアントが &quot;Proxy:&quot; HTTP ヘッダーを使ってこの環境変数を注入できるからです。もし CGI 環境で HTTP プロキシを使う必要があれば、 <code class="docutils literal"><span class="pre">ProxyHandler</span></code> を明示的に使用するか、環境変数名を小文字にしてください (あるいは、少なくともサフィックスを <code class="docutils literal"><span class="pre">_proxy</span></code> にしてください) 。</p>
</div>
</dd></dl>

<p>以下のクラスが提供されています:</p>
<dl class="class">
<dt id="urllib.request.Request">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">Request</code><span class="sig-paren">(</span><em>url</em>, <em>data=None</em>, <em>headers={}</em>, <em>origin_req_host=None</em>, <em>unverifiable=False</em>, <em>method=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスは URL リクエストを抽象化したものです。</p>
<p><em>url</em> は有効な URL を指す文字列でなくてはなりません。</p>
<p><em>data</em> must be an object specifying additional data to send to the
server, or <code class="docutils literal"><span class="pre">None</span></code> if no such data is needed.  Currently HTTP
requests are the only ones that use <em>data</em>.  The supported object
types include bytes, file-like objects, and iterables.  If no
<code class="docutils literal"><span class="pre">Content-Length</span></code> nor <code class="docutils literal"><span class="pre">Transfer-Encoding</span></code> header field
has been provided, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a> will set these headers according
to the type of <em>data</em>.  <code class="docutils literal"><span class="pre">Content-Length</span></code> will be used to send
bytes objects, while <code class="docutils literal"><span class="pre">Transfer-Encoding:</span> <span class="pre">chunked</span></code> as specified in
<span class="target" id="index-1"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7230.html"><strong>RFC 7230</strong></a>, Section 3.3.1 will be used to send files and other iterables.</p>
<p>For an HTTP POST request method, <em>data</em> should be a buffer in the
standard <em class="mimetype">application/x-www-form-urlencoded</em> format.  The
<a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></code></a> function takes a mapping or sequence
of 2-tuples and returns an ASCII string in this format. It should
be encoded to bytes before being used as the <em>data</em> parameter.</p>
<p><em>headers</em> は辞書でなければなりません。この辞書は <a class="reference internal" href="#urllib.request.Request.add_header" title="urllib.request.Request.add_header"><code class="xref py py-meth docutils literal"><span class="pre">add_header()</span></code></a> を辞書のキーおよび値を引数として呼び出した時と同じように扱われます。この引数は、多くの場合ブラウザーが何であるかを特定する <code class="docutils literal"><span class="pre">User-Agent</span></code> ヘッダーの値を &quot;偽装&quot; するために用いられます。これは一部の HTTP サーバーが、スクリプトからのアクセスを禁止するために一般的なブラウザーの <code class="docutils literal"><span class="pre">User-Agent</span></code> ヘッダーしか許可しないためです。例えば、 Mozilla Firefox は <code class="docutils literal"><span class="pre">User-Agent</span></code> に <code class="docutils literal"><span class="pre">&quot;Mozilla/5.0</span> <span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></code> のように設定し、 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal"><span class="pre">urllib</span></code></a> はデフォルトで <code class="docutils literal"><span class="pre">&quot;Python-urllib/2.6&quot;</span></code> (Python 2.6の場合) と設定します。</p>
<p>An appropriate <code class="docutils literal"><span class="pre">Content-Type</span></code> header should be included if the <em>data</em>
argument is present.  If this header has not been provided and <em>data</em>
is not None, <code class="docutils literal"><span class="pre">Content-Type:</span> <span class="pre">application/x-www-form-urlencoded</span></code> will
be added as a default.</p>
<p>最後の二つの引数は、サードパーティの HTTP クッキーを正しく扱いたい場合にのみ関係してきます:</p>
<p><em>origin_req_host</em> は、 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a> で定義されている元のトランザクションにおけるリクエストホスト (request-host of the origin transaction) です。デフォルトの値は <code class="docutils literal"><span class="pre">http.cookiejar.request_host(self)</span></code> です。この値は、ユーザーによって開始された元々のリクエストにおけるホスト名や IP アドレスです。例えば、もしリクエストがある HTML ドキュメント内の画像を指していれば、この値は画像を含んでいるページへのリクエストにおけるリクエストホストになるはずです。</p>
<p><em>unverifiable</em> は、 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a> の定義において、該当するリクエストが証明不能 (unverifiable) であるかどうかを示します。デフォルトの値は <code class="docutils literal"><span class="pre">False</span></code> です。証明不能なリクエストとは、ユーザが受け入れの可否を選択できないような URL を持つリクエストのことです。例えば、リクエストが HTML ドキュメント中の画像であり、ユーザがこの画像を自動的に取得するか どうかを選択できない場合には、証明不能フラグは True になります。</p>
<p><em>method</em> should be a string that indicates the HTTP request method that
will be used (e.g. <code class="docutils literal"><span class="pre">'HEAD'</span></code>).  If provided, its value is stored in the
<a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal"><span class="pre">method</span></code></a> attribute and is used by <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal"><span class="pre">get_method()</span></code></a>.
The default is <code class="docutils literal"><span class="pre">'GET'</span></code> if <em>data</em> is <code class="docutils literal"><span class="pre">None</span></code> or <code class="docutils literal"><span class="pre">'POST'</span></code> otherwise.
Subclasses may indicate a different default method by setting the
<a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal"><span class="pre">method</span></code></a> attribute in the class itself.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The request will not work as expected if the data object is unable
to deliver its content more than once (e.g. a file or an iterable
that can produce the content only once) and the request is retried
for HTTP redirects or authentication.  The <em>data</em> is sent to the
HTTP server right away after the headers.  There is no support for
a 100-continue expectation in the library.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>引数 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal"><span class="pre">Request.method</span></code></a> が Request クラスに追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal"><span class="pre">Request.method</span></code></a> のデフォルト値はクラスレベルで指定されることがあります。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>Do not raise an error if the <code class="docutils literal"><span class="pre">Content-Length</span></code> has not been
provided and <em>data</em> is neither <code class="docutils literal"><span class="pre">None</span></code> nor a bytes object.
Fall back to use chunked transfer encoding instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.OpenerDirector">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">OpenerDirector</code><a class="headerlink" href="#urllib.request.OpenerDirector" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> クラスは、 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> の連鎖的に呼び出して URL を開きます。このクラスはハンドラをどのように連鎖させるか、またどのようにエラーをリカバリするかを管理します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.BaseHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">BaseHandler</code><a class="headerlink" href="#urllib.request.BaseHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはハンドラ連鎖に登録される全てのハンドラがベースとしているクラスです – このクラスでは登録のための単純なメカニズムだけを扱います。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDefaultErrorHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPDefaultErrorHandler</code><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP エラーレスポンスのデフォルトハンドラーを定義するクラスです; すべてのレスポンスは <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal"><span class="pre">HTTPError</span></code></a> 例外に変換されます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPRedirectHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPRedirectHandler</code><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リダイレクションを扱うクラスです。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPCookieProcessor">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPCookieProcessor</code><span class="sig-paren">(</span><em>cookiejar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP Cookie を扱うためのクラスです。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">ProxyHandler</code><span class="sig-paren">(</span><em>proxies=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはプロキシを通過してリクエストを送らせます。引数 <em>proxies</em> を与える場合、プロトコル名からプロキシの URL へ対応付ける辞書でなくてはなりません。標準では、プロキシのリストを環境変数 <span class="target" id="index-26"></span><code class="xref std std-envvar docutils literal"><span class="pre">&lt;protocol&gt;_proxy</span></code>  から読み出します。プロキシ環境変数が設定されていない場合は、 Windows 環境では、 レジストリのインターネット設定セクションからプロキシ設定を手に入れ、 Mac OS X 環境では、 OS X システム設定フレームワーク (System Configuration Framework) からプロキシ情報を取得します。</p>
<p>自動検出されたproxyを無効にするには、空の辞書を渡してください。</p>
<p><span class="target" id="index-27"></span><code class="xref std std-envvar docutils literal"><span class="pre">no_proxy</span></code> 環境変数は、proxyを利用せずにアクセスするべきホストを指定するために利用されます。設定する場合は、カンマ区切りの、ホストネーム suffix のリストで、オプションとして <code class="docutils literal"><span class="pre">:port</span></code> を付けることができます。例えば、 <code class="docutils literal"><span class="pre">cern.ch,ncsa.uiuc.edu,some.host:8080</span></code>.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">変数 <code class="docutils literal"><span class="pre">REQUEST_METHOD</span></code> が設定されている場合、 <code class="docutils literal"><span class="pre">HTTP_PROXY</span></code> は無視されます; <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal"><span class="pre">getproxies()</span></code></a> のドキュメンテーションを参照してください。</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgr">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPPasswordMgr</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> の対応付けデータベースを保持します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPPasswordMgrWithDefaultRealm</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code>  の対応付けデータベースを保持します。レルム <code class="docutils literal"><span class="pre">None</span></code> はその他諸々のレルムを表し、他のレルムが該当しない場合に検索されます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPPasswordMgrWithPriorAuth</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">uri</span> <span class="pre">-&gt;</span> <span class="pre">is_authenticated</span></code> マッピングのデータベースも持つ <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> のバリエーションです。最初に <code class="docutils literal"><span class="pre">401</span></code> レスポンスを待つのではなく直ちに認証情報を送るときの条件を判断するために、 BasicAuth ハンドラによって使われます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractBasicAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">AbstractBasicAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これは、リモートホストとプロキシの両方に対して HTTP 認証を行うことを助ける mixin クラスです。 <em>password_mgr</em> は、もし与えられたら <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性のあるオブジェクトでなければなりません; サポートすべきインタフェースに関する情報は <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> 節を参照してください。もし <em>passwd_mgr</em> が <code class="docutils literal"><span class="pre">is_authenticated</span></code> と <code class="docutils literal"><span class="pre">update_authenticated</span></code> メソッドも提供するなら (<a class="reference internal" href="#http-password-mgr-with-prior-auth"><span class="std std-ref">HTTPPasswordMgrWithPriorAuth オブジェクト</span></a> を参照)、ハンドラは与えられた URI に対する <code class="docutils literal"><span class="pre">is_authenticated</span></code> の結果を用いてリクエストにおいて認証情報を送るかどうかを決定します。もし <code class="docutils literal"><span class="pre">is_authenticated</span></code> がその URI に対して <code class="docutils literal"><span class="pre">True</span></code> を返すなら、認証情報が送られます。 <code class="docutils literal"><span class="pre">is_authenticated</span></code> が <code class="docutils literal"><span class="pre">False</span></code> なら認証情報は送られません。そして、もし <code class="docutils literal"><span class="pre">401</span></code> レスポンスを受け取ったら、認証情報を付けて改めてリクエストが送信されます。もし認証が成功したら、それ以降その URI またはその親 URI に対して行われるリクエストが認証情報を自動的に含むように、 URI に対して <code class="docutils literal"><span class="pre">is_authenticated</span></code> を <code class="docutils literal"><span class="pre">True</span></code> に設定するために <code class="docutils literal"><span class="pre">update_authenticated</span></code> が呼ばれます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加: </span><code class="docutils literal"><span class="pre">is_authenticated</span></code> サポートが追加されました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPBasicAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPBasicAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>遠隔ホストとの間での認証を扱います。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。HTTPBasicAuthHandler は、間違った認証スキーマが与えられると <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyBasicAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">ProxyBasicAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシとの間での認証を扱います。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性が なければなりません;  互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractDigestAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">AbstractDigestAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスはHTTP 認証を補助するための混ぜ込みクラス (mixin class) です。遠隔ホストとプロキシの両方に対応しています。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性がなければなりません; 互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDigestAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPDigestAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リモートホストとの認証を扱います。<em>password_mgr</em> を与える場合、<a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性のあるものでなければなりません。サポートしなければならないインターフェースについての情報は <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> 節を参照してください。Digest 認証ハンドラーと Basic 認証ハンドラーの両方が追加された場合、常に Digest 認証を先に試みます。Digest 認証が 40x のレスポンスを再び返すと、Basic 認証ハンドラーに送信されます。このハンドラーメソッドは、Digest および Basic 以外の認証スキームが存在する場合は <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>未サポートの認証スキームでは <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出するようになりました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyDigestAuthHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">ProxyDigestAuthHandler</code><span class="sig-paren">(</span><em>password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシとの間での認証を扱います。 <em>password_mgr</em> を与える場合、 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgr</span></code></a> と互換性が なければなりません;  互換性のためにサポートしなければならないインタフェースについての情報はセクション <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr オブジェクト</span></a> を参照してください。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPHandler</code><a class="headerlink" href="#urllib.request.HTTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP の URL を開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPSHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPSHandler</code><span class="sig-paren">(</span><em>debuglevel=0</em>, <em>context=None</em>, <em>check_hostname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTPS で URL を開きます。<em>context</em> および <em>check_hostname</em> は <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal"><span class="pre">http.client.HTTPSConnection</span></code></a> のものと同じ意味です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>context</em> および <em>check_hostname</em> が追加されました。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FileHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">FileHandler</code><a class="headerlink" href="#urllib.request.FileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローカルファイルを開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.DataHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">DataHandler</code><a class="headerlink" href="#urllib.request.DataHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>data URL を開きます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FTPHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">FTPHandler</code><a class="headerlink" href="#urllib.request.FTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>FTP の URL を開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.CacheFTPHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">CacheFTPHandler</code><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>FTP の URL を開きます。遅延を最小限にするために、開かれている FTP  接続に対するキャッシュを保持します。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.UnknownHandler">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">UnknownHandler</code><a class="headerlink" href="#urllib.request.UnknownHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>その他諸々のためのクラスで、未知のプロトコルの URL を開きます。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPErrorProcessor">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">HTTPErrorProcessor</code><a class="headerlink" href="#urllib.request.HTTPErrorProcessor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP エラー応答の処理をします。</p>
</dd></dl>

<div class="section" id="request-objects">
<span id="id1"></span><h2>21.6.1. Request オブジェクト<a class="headerlink" href="#request-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のメソッドは <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> の公開インターフェースについて説明しています。これらはすべてサブクラスでオーバーライドできます。また、解析したリクエストを調査するためにクライアントで使用するいくつかの属性も定義します。</p>
<dl class="attribute">
<dt id="urllib.request.Request.full_url">
<code class="descclassname">Request.</code><code class="descname">full_url</code><a class="headerlink" href="#urllib.request.Request.full_url" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクターに渡されたオリジナルの URL です。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更.</span></p>
</div>
<p>Request.full_url は、 setter, getter, deleter を持つプロパティです。もし存在すれば、 <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal"><span class="pre">full_url</span></code></a> はオリジナルのリクエスト URL フラグメント付きで返します。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.type">
<code class="descclassname">Request.</code><code class="descname">type</code><a class="headerlink" href="#urllib.request.Request.type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URI スキームです。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.host">
<code class="descclassname">Request.</code><code class="descname">host</code><a class="headerlink" href="#urllib.request.Request.host" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URI オーソリティです。通常はホスト名ですが、コロンで区切られたポート番号が付随することもあります。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.origin_req_host">
<code class="descclassname">Request.</code><code class="descname">origin_req_host</code><a class="headerlink" href="#urllib.request.Request.origin_req_host" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストしたオリジナルのホスト名です。ポート番号はつきません。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.selector">
<code class="descclassname">Request.</code><code class="descname">selector</code><a class="headerlink" href="#urllib.request.Request.selector" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URI パスです。<a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> がプロキシを使用する場合、セレクターはプロキシに渡される完全な URL になります。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.data">
<code class="descclassname">Request.</code><code class="descname">data</code><a class="headerlink" href="#urllib.request.Request.data" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストのエンティティボディか、指定されない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal"><span class="pre">Request.data</span></code></a> の値が変更されると、もしそれ以前に &quot;Content-Length&quot; ヘッダーの値が設定または計算されていたらヘッダーが削除されるようになりました。</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.unverifiable">
<code class="descclassname">Request.</code><code class="descname">unverifiable</code><a class="headerlink" href="#urllib.request.Request.unverifiable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストが RFC 2965 で定義された証明不能 (unverifiable) であるかどうかを示す論理値です。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.method">
<code class="descclassname">Request.</code><code class="descname">method</code><a class="headerlink" href="#urllib.request.Request.method" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP リクエストで使うメソッドです。
デフォルト値は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> で、このときは使うメソッドを <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal"><span class="pre">get_method()</span></code></a> が通常の方法で決定するということになります。
この値を設定する (従って <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal"><span class="pre">get_method()</span></code></a> のデフォルトの決定を上書きする) 方法は、 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> サブクラスでのクラスレベルの設定処理でデフォルト値を提供するか、 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> のコンストラクタの <em>method</em> 引数へ値を渡すかです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>サブクラスでデフォルト値が設定できるようになりました; 以前はコンストラクタ引数からしか設定できませんでした。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_method">
<code class="descclassname">Request.</code><code class="descname">get_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_method" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP リクエストメソッドを示す文字列を返します。<a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal"><span class="pre">Request.method</span></code></a> が <code class="docutils literal"><span class="pre">None</span></code> でなければその値を返します。そうでない場合、<a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal"><span class="pre">Request.data</span></code></a> が <code class="docutils literal"><span class="pre">None</span></code> なら <code class="docutils literal"><span class="pre">'GET'</span></code> を、そうでなければ <code class="docutils literal"><span class="pre">'POST'</span></code> を返します。これは HTTP リクエストに対してのみ意味を持ちます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>get_method は <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal"><span class="pre">Request.method</span></code></a> の値を参照するようになりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_header">
<code class="descclassname">Request.</code><code class="descname">add_header</code><span class="sig-paren">(</span><em>key</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストに新たなヘッダーを追加します。ヘッダーは HTTP ハンドラ以外のハンドラでは無視されます。HTTP ハンドラでは、引数はサーバに送信される ヘッダーのリストに追加されます。同じ名前を持つヘッダを 2 つ以上持つことはできず、 <em>key</em> の衝突が生じた場合、後で追加したヘッダーが前に 追加したヘッダーを上書きします。現時点では、この機能は HTTP の機能を損ねることはありません。というのは、複数回呼び出したときに意味を 持つようなヘッダーには、どれもただ一つのヘッダーを使って同じ機能を果たすための (ヘッダー特有の) 方法があるからです。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_unredirected_header">
<code class="descclassname">Request.</code><code class="descname">add_unredirected_header</code><span class="sig-paren">(</span><em>key</em>, <em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リダイレクトされたリクエストには追加されないヘッダーを追加します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.has_header">
<code class="descclassname">Request.</code><code class="descname">has_header</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.has_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インスタンスが名前つきヘッダーであるかどうかを (通常のヘッダーと非リダイレクトヘッダの両方を調べて) 返します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.remove_header">
<code class="descclassname">Request.</code><code class="descname">remove_header</code><span class="sig-paren">(</span><em>header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.remove_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストインスタンス (の通常のヘッダーと非リダイレクトヘッダーの両方) から名前つきヘッダーを削除します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_full_url">
<code class="descclassname">Request.</code><code class="descname">get_full_url</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_full_url" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンストラクタで与えられた URL を返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal"><span class="pre">Request.full_url</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.set_proxy">
<code class="descclassname">Request.</code><code class="descname">set_proxy</code><span class="sig-paren">(</span><em>host</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.set_proxy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストがプロキシサーバを経由するように準備します。 <em>host</em> および <em>type</em> はインスタンスのもとの設定と置き換えられ ます。インスタンスのセレクタはコンストラクタに与えたもともとの URL になります。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_header">
<code class="descclassname">Request.</code><code class="descname">get_header</code><span class="sig-paren">(</span><em>header_name</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_header" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたヘッダーの値を返します。ヘッダーがない場合は、 <em>default</em> の値を返します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.header_items">
<code class="descclassname">Request.</code><code class="descname">header_items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.header_items" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リクエストヘッダーの値を、タプル (header_name, header_value) のリストで返します。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>3.3 から非推奨だった Request オブジェクトのメソッド add_data, has_data, get_data, get_type, get_host, get_selector, get_origin_req_host, is_unverifiable が削除されました。</p>
</div>
</div>
<div class="section" id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>21.6.2. OpenerDirector オブジェクト<a class="headerlink" href="#openerdirector-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> インスタンスは以下のメソッドを持っています:</p>
<dl class="method">
<dt id="urllib.request.OpenerDirector.add_handler">
<code class="descclassname">OpenerDirector.</code><code class="descname">add_handler</code><span class="sig-paren">(</span><em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>handler</em> は <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> のインスタンスでなければなりません。以下のメソッドを使った検索が行われ、URL を取り扱うことが可能なハンドラの連鎖が追加されます (HTTP エラーは特別扱いされているので注意してください)。</p>
<ul class="simple">
<li><code class="xref py py-meth docutils literal"><span class="pre">protocol_open()</span></code> — ハンドラーが <em>protocol</em> の URL を開く方法を知っているかどうかを調べます。</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">http_error_type()</span></code> — ハンドラーが HTTP エラーコード <em>type</em> の処理方法を知っていることを示すシグナルです。</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">protocol_error()</span></code> — ハンドラーが (<code class="docutils literal"><span class="pre">http</span></code> でない) <em>protocol</em> のエラーを処理する方法を知っていることを示すシグナルです。</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">protocol_request()</span></code> — ハンドラーが <em>protocol</em> リクエストのプリプロセス方法を知っていることを示すシグナルです。</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">protocol_response()</span></code> — ハンドラーが <em>protocol</em> リクエストのポストプロセス方法を知っていることを示すシグナルです。</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.open">
<code class="descclassname">OpenerDirector.</code><code class="descname">open</code><span class="sig-paren">(</span><em>url</em>, <em>data=None</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>url</em> (リクエストオブジェクトでも文字列でもかまいません) を開きます。オプションとして <em>data</em> を与えることができます。 引数、戻り値、および送出される例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> と同じです (<a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> の場合、標準でインストールされている グローバルな <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> の <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal"><span class="pre">open()</span></code></a> メソッドを呼び出します) 。 オプションの <em>timeout</em> 引数は、接続開始のようなブロックする処理におけるタイムアウト時間を 秒数で指定します。(指定しなかった場合は、グローバルのデフォルト設定が利用されます) タイムアウト機能は、 HTTP, HTTPS, FTP 接続でのみ有効です。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.error">
<code class="descclassname">OpenerDirector.</code><code class="descname">error</code><span class="sig-paren">(</span><em>proto</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたプロトコルにおけるエラーを処理します。このメソッドは与えられたプロトコルにおける登録済みのエラーハンドラを (プロトコル固有の) 引数で呼び出します。 HTTP プロトコルは特殊なケースで、特定のエラーハンドラを選び出すのに HTTP レスポンスコードを使います; ハンドラクラスの <code class="xref py py-meth docutils literal"><span class="pre">http_error_*()</span></code> メソッドを参照してください。</p>
<p>戻り値および送出される例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> と同じものです。</p>
</dd></dl>

<p>OpenerDirector オブジェクトは、以下の 3 つのステージに分けて URL を開きます:</p>
<p>各ステージで OpenerDirector オブジェクトのメソッドがどのような順で呼び出されるかは、ハンドラインスタンスの並び方で決まります。</p>
<ol class="arabic">
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">protocol_request()</span></code> 形式のメソッドを持つすべてのハンドラーに対してそのメソッドを呼び出し、リクエストのプリプロセスを行います。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">protocol_open()</span></code> のようなメソッドでハンドラーが呼び出され、リクエストを処理します。このステージではハンドラーが非-<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 値 (例: レスポンス) か例外 (通常は <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal"><span class="pre">URLError</span></code></a>) を返した時点で終了します。例外は伝搬できます。</p>
<p>実際には、上のアルゴリズムではまず <code class="xref py py-meth docutils literal"><span class="pre">default_open()</span></code> という名前のメソッドを呼び出します。このメソッドがすべて <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返す場合、同じアルゴリズムを繰り返して、今度は <code class="xref py py-meth docutils literal"><span class="pre">protocol_open()</span></code> 形式のメソッドを試します。メソッドがすべて <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返すと、さらに同じアルゴリズムを繰り返して <code class="xref py py-meth docutils literal"><span class="pre">unknown_open()</span></code> を呼び出します。</p>
<p>これらのメソッドの実装には、親となる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> インスタンスの <code class="xref py py-meth docutils literal"><span class="pre">open()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">error()</span></code> といったメソッド呼び出しが入る場合があるので注意してください。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">protocol_response()</span></code> 形式のメソッドを持つすべてのハンドラーに対してそのメソッドを呼び出し、リクエストのポストプロセスを行います。</p>
</li>
</ol>
</div>
<div class="section" id="basehandler-objects">
<span id="base-handler-objects"></span><h2>21.6.3. BaseHandler オブジェクト<a class="headerlink" href="#basehandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> オブジェクトは直接的に役に立つ 2 つのメソッドと、その他として派生クラスで使われることを想定したメソッドを 提供します。以下は直接的に使うためのメソッドです:</p>
<dl class="method">
<dt id="urllib.request.BaseHandler.add_parent">
<code class="descclassname">BaseHandler.</code><code class="descname">add_parent</code><span class="sig-paren">(</span><em>director</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>親オブジェクトとして、 <code class="docutils literal"><span class="pre">director</span></code> を追加します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.close">
<code class="descclassname">BaseHandler.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>全ての親オブジェクトを削除します。</p>
</dd></dl>

<p>以下の属性およびメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> から派生したクラスでのみ使われます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">慣習的に、 <code class="xref py py-meth docutils literal"><span class="pre">protocol_request()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">protocol_response()</span></code> といったメソッドを定義している サブクラスは <code class="xref py py-class docutils literal"><span class="pre">*Processor</span></code> と名づけ、その他は <code class="xref py py-class docutils literal"><span class="pre">*</span> <span class="pre">Handler</span></code> と名づけることになっています</p>
</div>
<dl class="attribute">
<dt id="urllib.request.BaseHandler.parent">
<code class="descclassname">BaseHandler.</code><code class="descname">parent</code><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>有効な <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> です。この値は違うプロトコルを使って URL を開く場合やエラーを処理する際に使われます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.default_open">
<code class="descclassname">BaseHandler.</code><code class="descname">default_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかし、全ての URL をキャッチさせたいなら、サブクラスで定義する 必要があります。</p>
<p>このメソッドが実装されていれば、<a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> の親クラスによって呼び出されます。これは <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> の <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal"><span class="pre">open()</span></code></a> の戻り値で表されるファイルライクオブジェクトか、または <code class="docutils literal"><span class="pre">None</span></code> を返さなければならず、真に想定外の事態が発生した場合を除き、<a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal"><span class="pre">URLError</span></code></a> を送出しなければなりません (例えば、<a class="reference internal" href="exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal"><span class="pre">MemoryError</span></code></a> は <code class="xref py py-exc docutils literal"><span class="pre">URLError</span></code> にマップしてはなりません)。</p>
<p>このメソッドはプロトコル固有のオープンメソッドが呼び出される前に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">BaseHandler.</code><code class="descname">protocol_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかしプロトコルの URL をキャッチしたいなら、サブクラスで定義する必要があります。</p>
<p>このメソッドが定義されていた場合、 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。戻り値は <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal"><span class="pre">default_open()</span></code></a> と同じでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.unknown_open">
<code class="descclassname">BaseHandler.</code><code class="descname">unknown_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかし URL を開くための特定のハンドラが登録されていないような URL をキャッチしたいなら、サブクラスで定義する必要があります。</p>
<p>このメソッドが定義されていた場合、 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。戻り値は <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal"><span class="pre">default_open()</span></code></a> と同じでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.http_error_default">
<code class="descclassname">BaseHandler.</code><code class="descname">http_error_default</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> では定義されて <em>いません</em> 。しかしその他の処理されなかった HTTP エラーを処理する機能をもたせたいなら、サブクラスで定義する必要があります。このメソッドはエラーに遭遇した <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> から自動的に呼び出されます。その他の状況では普通呼び出すべきではありません。</p>
<p><em>req</em> は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> オブジェクトで、 <em>fp</em> は HTTP エラー本体を読み出せるようなファイル類似のオブジェクトに なります。 <em>code</em> は 3 桁の 10 進数からなるエラーコードで、 <em>msg</em> ユーザ向けのエラーコード解説です。 <em>hdrs</em> は エラー応答のヘッダーをマップしたオブジェクトです。</p>
<p>返される値および送出される例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> と同じものでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.http_error_nnn">
<code class="descclassname">BaseHandler.</code><code class="descname">http_error_nnn</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_nnn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>nnn</em> は 3 桁の 10 進数からなる HTTP エラーコードでなくてはなりません。このメソッドも <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> では定義されていませんが、サブクラスのインスタンスで定義されていた場合、エラーコード <em>nnn</em> の HTTP エラーが発生した際に呼び出されます。</p>
<p>特定の HTTP エラーに対する処理を行うためには、このメソッドをサブクラスでオーバライドする必要があります。</p>
<p>引数、返される値、および送出される例外は <a class="reference internal" href="#urllib.request.BaseHandler.http_error_default" title="urllib.request.BaseHandler.http_error_default"><code class="xref py py-meth docutils literal"><span class="pre">http_error_default()</span></code></a> と同じものでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">BaseHandler.</code><code class="descname">protocol_request</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> では <em>定義されていません</em> が、サブクラスで特定のプロトコルのリクエストのプリプロセスを行いたい場合には定義する必要があります。</p>
<p>このメソッドが定義されていると、親となる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。その際、 <em>req</em> は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> オブジェクトになります。戻り値は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> オブジェクトでなければなりません。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">BaseHandler.</code><code class="descname">protocol_response</code><span class="sig-paren">(</span><em>req</em>, <em>response</em><span class="sig-paren">)</span></dt>
<dd><p>このメソッドは <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseHandler</span></code></a> では <em>定義されていません</em> が、サブクラスで特定のプロトコルのリクエストのポストプロセスを行いたい場合には定義する必要があります。</p>
<p>このメソッドが定義されていると、親となる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> から呼び出されます。その際、 <em>req</em> は <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> オブジェクトになります。 <em>response</em> は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> の戻り値と同じインタフェースを 実装したオブジェクトになります。戻り値もまた、 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> の戻り値と同じインタフェースを実装したオブジェクトでなければなりません。</p>
</dd></dl>

</div>
<div class="section" id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>21.6.4. HTTPRedirectHandler オブジェクト<a class="headerlink" href="#httpredirecthandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>一部の HTTP リクエストはこのモジュールのクライアントモードからの操作を要求します。その場合、<a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal"><span class="pre">HTTPError</span></code></a> が送出されます。さまざまなリダイレクションコードの正確な意味についての詳細は <span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> を参照してください。</p>
<p class="last">セキュリティ上の配慮として、HTTPRedirectHandler に HTTP、HTTPS、あるいは FTP の URL ではないリダイレクトされた URL が存在した場合、<code class="xref py py-class docutils literal"><span class="pre">HTTPError</span></code> 例外が送出されます。</p>
</div>
<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.redirect_request">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">redirect_request</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em>, <em>newurl</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リダイレクトへのレスポンスの <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> または <code class="docutils literal"><span class="pre">None</span></code> を返します。これはサーバーからリダイレクションを受信した時に <code class="xref py py-meth docutils literal"><span class="pre">http_error_30*()</span></code> メソッドのデフォルトの実装によって呼び出されます。リダイレクションを行わなければならない場合、<em>newurl</em> へのリダイレクトを実行するための <code class="xref py py-meth docutils literal"><span class="pre">http_error_30*()</span></code> を許可する新しい <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> を返します。その他の場合、この URL を扱うその他のハンドラーがない場合は <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal"><span class="pre">HTTPError</span></code></a> を、他のハンドラーでできそうな場合は <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このメソッドのデフォルトの実装は、 <span class="target" id="index-29"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> に厳密に従ったものではありません。 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> では、 <code class="docutils literal"><span class="pre">POST</span></code> リクエストに対する 301 および 302 応答が、ユーザの承認なく自動的にリダイレクトされてはならないと述べています。現実には、ブラウザは POST を <code class="docutils literal"><span class="pre">GET</span></code> に変更することで、これらの応答に対して自動的にリダイレクトを行えるようにしています。デフォルトの実装でも、この挙動を再現しています。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_301">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_301</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">Location:</span></code> か <code class="docutils literal"><span class="pre">URI:</span></code> のURL にリダイレクトします。このメソッドは HTTP  における 'moved permanently' レスポンスを取得した際に 親オブジェクトとなる <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> によって呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_302">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_302</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal"><span class="pre">http_error_301()</span></code></a> と同じですが、'found' レスポンスに対して呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_303">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_303</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal"><span class="pre">http_error_301()</span></code></a> と同じですが、'see other' レスポンスに対して呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_307">
<code class="descclassname">HTTPRedirectHandler.</code><code class="descname">http_error_307</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal"><span class="pre">http_error_301()</span></code></a> と同じですが、'temporary redirect'  レスポンスに対して呼び出されます。</p>
</dd></dl>

</div>
<div class="section" id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>21.6.5. HTTPCookieProcessor オブジェクト<a class="headerlink" href="#httpcookieprocessor-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.HTTPCookieProcessor" title="urllib.request.HTTPCookieProcessor"><code class="xref py py-class docutils literal"><span class="pre">HTTPCookieProcessor</span></code></a> インスタンスは属性をひとつだけ持ちます:</p>
<dl class="attribute">
<dt id="urllib.request.HTTPCookieProcessor.cookiejar">
<code class="descclassname">HTTPCookieProcessor.</code><code class="descname">cookiejar</code><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Cookie の入っている <a class="reference internal" href="http.cookiejar.html#http.cookiejar.CookieJar" title="http.cookiejar.CookieJar"><code class="xref py py-class docutils literal"><span class="pre">http.cookiejar.CookieJar</span></code></a> オブジェクトです。</p>
</dd></dl>

</div>
<div class="section" id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>21.6.6. ProxyHandler オブジェクト<a class="headerlink" href="#proxyhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt>
<code class="descclassname">ProxyHandler.</code><code class="descname">protocol_open</code><span class="sig-paren">(</span><em>request</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyHandler</span></code></a> は、コンストラクターで与えた辞書 <em>proxies</em> にプロキシが設定されているような <em>protocol</em> すべてについて、メソッド  <code class="xref py py-meth docutils literal"><span class="pre">protocol_open()</span></code> を持つことになります。このメソッドは <code class="docutils literal"><span class="pre">request.set_proxy()</span></code> を呼び出して、リクエストがプロキシを通過できるように修正します。その後連鎖するハンドラーの中から次のハンドラーを呼び出して実際にプロトコルを実行します。</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>21.6.7. HTTPPasswordMgr オブジェクト<a class="headerlink" href="#httppasswordmgr-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のメソッドは <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgr</span></code></a> および <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> オブジェクトで利用できます。</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.add_password">
<code class="descclassname">HTTPPasswordMgr.</code><code class="descname">add_password</code><span class="sig-paren">(</span><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>uri</em> は単一の URI でも複数の URI からなるシーケンスでもかまいません。 <em>realm</em> 、 <em>user</em> および <em>passwd</em> は文字列でなくてはなりません。このメソッドによって、 <em>realm</em> と与えられた URI の上位 URI に対して <code class="docutils literal"><span class="pre">(user,</span> <span class="pre">passwd)</span></code> が認証トークンとして使われるようになります。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.find_user_password">
<code class="descclassname">HTTPPasswordMgr.</code><code class="descname">find_user_password</code><span class="sig-paren">(</span><em>realm</em>, <em>authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたレルムおよび URI に対するユーザ名またはパスワードがあればそれを取得します。該当するユーザ名／パスワードが存在しない場合、このメソッドは <code class="docutils literal"><span class="pre">(None,</span> <span class="pre">None)</span></code> を返します。</p>
<p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> オブジェクトでは、与えられた <em>realm</em> に対して該当するユーザ名/パスワードが存在しない場合、レルム <code class="docutils literal"><span class="pre">None</span></code> が検索されます。</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgrwithpriorauth-objects">
<span id="http-password-mgr-with-prior-auth"></span><h2>21.6.8. HTTPPasswordMgrWithPriorAuth オブジェクト<a class="headerlink" href="#httppasswordmgrwithpriorauth-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このパスワードマネージャは <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> を継承して、認証の証明書を常に送らないといけない URI を追跡する機能をサポートしています。</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.add_password">
<code class="descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="descname">add_password</code><span class="sig-paren">(</span><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em>, <em>is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em> は <a class="reference internal" href="#urllib.request.HTTPPasswordMgr.add_password" title="urllib.request.HTTPPasswordMgr.add_password"><code class="xref py py-meth docutils literal"><span class="pre">HTTPPasswordMgr.add_password()</span></code></a> のものと同じです。
<em>is_authenticated</em> は、与えられた URI や URI のリストの <code class="docutils literal"><span class="pre">is_authenticated</span></code> フラグの初期値に設定されます。
<em>is_authenticated</em> に <code class="docutils literal"><span class="pre">True</span></code> を指定した場合は、 <em>realm</em> は無視されます。</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descclassname">HTTPPasswordMgr.</code><code class="descname">find_user_password</code><span class="sig-paren">(</span><em>realm</em>, <em>authuri</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> オブジェクトに対する同名のメソッドと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated">
<code class="descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="descname">update_authenticated</code><span class="sig-paren">(</span><em>self</em>, <em>uri</em>, <em>is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>url</em> や URI のリストの <code class="docutils literal"><span class="pre">is_authenticated</span></code> フラグを更新します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated">
<code class="descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="descname">is_authenticated</code><span class="sig-paren">(</span><em>self</em>, <em>authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた URI の <code class="docutils literal"><span class="pre">is_authenticated</span></code> フラグの現在の状態を返します。</p>
</dd></dl>

</div>
<div class="section" id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>21.6.9. AbstractBasicAuthHandler オブジェクト<a class="headerlink" href="#abstractbasicauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<code class="descclassname">AbstractBasicAuthHandler.</code><code class="descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em>authreq</em>, <em>host</em>, <em>req</em>, <em>headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ユーザ名／パスワードを取得し、再度サーバへのリクエストを試みることで、サーバからの認証リクエストを処理します。 <em>authreq</em> はリクエストにおいて レルムに関する情報が含まれているヘッダーの名前、 <em>host</em> は認証を行う対象の URL とパスを指定します、 <em>req</em> は (失敗した) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> オブジェクト、そして <em>headers</em> はエラーヘッダーでなくてはなりません。</p>
<p><em>host</em> は、オーソリティ (例 <code class="docutils literal"><span class="pre">&quot;python.org&quot;</span></code>) か、オーソリティコンポーネントを含む URL (例 <code class="docutils literal"><span class="pre">&quot;http://python.org&quot;</span></code>) です。どちらの場合も、オーソリティはユーザ情報コンポーネントを含んではいけません (なので、 <code class="docutils literal"><span class="pre">&quot;python.org&quot;</span></code> や <code class="docutils literal"><span class="pre">&quot;python.org:80&quot;</span></code> は正しく、 <code class="docutils literal"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></code> は不正です) 。</p>
</dd></dl>

</div>
<div class="section" id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>21.6.10. HTTPBasicAuthHandler オブジェクト<a class="headerlink" href="#httpbasicauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<code class="descclassname">HTTPBasicAuthHandler.</code><code class="descname">http_error_401</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>21.6.11. ProxyBasicAuthHandler オブジェクト<a class="headerlink" href="#proxybasicauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<code class="descclassname">ProxyBasicAuthHandler.</code><code class="descname">http_error_407</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>21.6.12. AbstractDigestAuthHandler オブジェクト<a class="headerlink" href="#abstractdigestauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<code class="descclassname">AbstractDigestAuthHandler.</code><code class="descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em>authreq</em>, <em>host</em>, <em>req</em>, <em>headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>authreq</em> はリクエストにおいてレルムに関する情報が含まれているヘッダーの名前、 <em>host</em> は認証を行う対象のホスト名、 <em>req</em> は  (失敗した) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> オブジェクト、そして <em>headers</em> はエラーヘッダーでなくてはなりません。</p>
</dd></dl>

</div>
<div class="section" id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>21.6.13. HTTPDigestAuthHandler オブジェクト<a class="headerlink" href="#httpdigestauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<code class="descclassname">HTTPDigestAuthHandler.</code><code class="descname">http_error_401</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>21.6.14. ProxyDigestAuthHandler オブジェクト<a class="headerlink" href="#proxydigestauthhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<code class="descclassname">ProxyDigestAuthHandler.</code><code class="descname">http_error_407</code><span class="sig-paren">(</span><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認証情報がある場合、認証情報付きで再度リクエストを試みます。</p>
</dd></dl>

</div>
<div class="section" id="httphandler-objects">
<span id="http-handler-objects"></span><h2>21.6.15. HTTPHandler オブジェクト<a class="headerlink" href="#httphandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPHandler.http_open">
<code class="descclassname">HTTPHandler.</code><code class="descname">http_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP リクエストを送ります。 <code class="docutils literal"><span class="pre">req.has_data()</span></code> に応じて、 GET または POST のどちらでも送ることができます。</p>
</dd></dl>

</div>
<div class="section" id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>21.6.16. HTTPSHandler オブジェクト<a class="headerlink" href="#httpshandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPSHandler.https_open">
<code class="descclassname">HTTPSHandler.</code><code class="descname">https_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTPS リクエストを送ります。 <code class="docutils literal"><span class="pre">req.has_data()</span></code> に応じて、 GET または POST のどちらでも送ることができます。</p>
</dd></dl>

</div>
<div class="section" id="filehandler-objects">
<span id="file-handler-objects"></span><h2>21.6.17. FileHandler オブジェクト<a class="headerlink" href="#filehandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FileHandler.file_open">
<code class="descclassname">FileHandler.</code><code class="descname">file_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ホスト名がない場合、またはホスト名が <code class="docutils literal"><span class="pre">'localhost'</span></code> の場合にファイルをローカルでオープンします。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>このメソッドはローカルのホスト名に対してのみ適用可能です。リモートホスト名が与えられた場合、<a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal"><span class="pre">URLError</span></code></a> が送出されます。</p>
</div>
</dd></dl>

</div>
<div class="section" id="datahandler-objects">
<span id="data-handler-objects"></span><h2>21.6.18. DataHandler オブジェクト<a class="headerlink" href="#datahandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.DataHandler.data_open">
<code class="descclassname">DataHandler.</code><code class="descname">data_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.DataHandler.data_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Read a data URL. This kind of URL contains the content encoded in the URL
itself. The data URL syntax is specified in <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2397.html"><strong>RFC 2397</strong></a>. This implementation
ignores white spaces in base64 encoded data URLs so the URL may be wrapped
in whatever source file it comes from. But even though some browsers don’t
mind about a missing padding at the end of a base64 encoded data URL, this
implementation will raise an <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> in that case.</p>
</dd></dl>

</div>
<div class="section" id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>21.6.19. FTPHandler オブジェクト<a class="headerlink" href="#ftphandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FTPHandler.ftp_open">
<code class="descclassname">FTPHandler.</code><code class="descname">ftp_open</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>req</em> で表されるファイルを FTP 越しにオープンします。ログインは常に空のユーザネームおよびパスワードで行われます。</p>
</dd></dl>

</div>
<div class="section" id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>21.6.20. CacheFTPHandler オブジェクト<a class="headerlink" href="#cacheftphandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.CacheFTPHandler" title="urllib.request.CacheFTPHandler"><code class="xref py py-class docutils literal"><span class="pre">CacheFTPHandler</span></code></a> オブジェクトは <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal"><span class="pre">FTPHandler</span></code></a> オブジェクトに以下のメソッドを追加したものです:</p>
<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setTimeout">
<code class="descclassname">CacheFTPHandler.</code><code class="descname">setTimeout</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続のタイムアウトを <em>t</em> 秒に設定します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setMaxConns">
<code class="descclassname">CacheFTPHandler.</code><code class="descname">setMaxConns</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キャッシュ付き接続の最大接続数を <em>m</em> に設定します。</p>
</dd></dl>

</div>
<div class="section" id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>21.6.21. UnknownHandler オブジェクト<a class="headerlink" href="#unknownhandler-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.UnknownHandler.unknown_open">
<code class="descclassname">UnknownHandler.</code><code class="descname">unknown_open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal"><span class="pre">URLError</span></code></a> 例外を送出します。</p>
</dd></dl>

</div>
<div class="section" id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>21.6.22. HTTPErrorProcessor オブジェクト<a class="headerlink" href="#httperrorprocessor-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.http_response">
<code class="descclassname">HTTPErrorProcessor.</code><code class="descname">http_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.http_response" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTP エラー応答の処理をします。</p>
<p>エラーコード 200 の場合、レスポンスオブジェクトを即座に返します。</p>
<p>200 以外のエラーコードの場合、これは単に <code class="xref py py-meth docutils literal"><span class="pre">protocol_error_code()</span></code> ハンドラーメソッドに <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal"><span class="pre">OpenerDirector.error()</span></code></a> 経由で処理を渡します。他にそのエラーを処理するハンドラーがない場合、<a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPDefaultErrorHandler</span></code></a> は最後に <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal"><span class="pre">HTTPError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.https_response">
<code class="descclassname">HTTPErrorProcessor.</code><code class="descname">https_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.https_response" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>HTTPS エラー応答の処理をします。</p>
<p>振る舞いは <a class="reference internal" href="#urllib.request.HTTPErrorProcessor.http_response" title="urllib.request.HTTPErrorProcessor.http_response"><code class="xref py py-meth docutils literal"><span class="pre">http_response()</span></code></a> と同じです。</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="urllib-request-examples"></span><h2>21.6.23. 使用例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の例の他に <a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">urllib パッケージを使ってインターネット上のリソースを取得するには</span></a> に多くの例があります。</p>
<p>以下の例では、python.org のメインページを取得して、その最初の 300 バイト分を表示します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n\n&lt;html</span>
<span class="go">xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n</span>
<span class="go">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n</span>
<span class="go">&lt;title&gt;Python Programming &#39;</span>
</pre></div>
</div>
<p>urlopen は bytes オブジェクトを返すことに注意してください。これは urlopen が、HTTP サーバーから受信したバイトストリームのエンコーディングを自動的に決定できないためです。一般に、返された bytes オブジェクトを文字列にデコードするためのエンコーディングの決定あるいは推測はプログラム側が行います。</p>
<p>以下の W3C ドキュメント <a class="reference external" href="https://www.w3.org/International/O-charset">https://www.w3.org/International/O-charset</a>には (X)HTML や XML ドキュメントでそのエンコーディング情報を指定するさまざまな方法の一覧があります。</p>
<p>python.org ウェブサイトでは <em>utf-8</em> エンコーディングを使用しており、それをその meta タグで指定していますので、bytes オブジェクトのデコードも同様に行います。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p><a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">コンテキストマネージャー</span></a> を使用しないアプローチでも同様の結果を得ることができます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>以下の例では、データストリームを CGI の標準入力へ送信し、返されたデータを読み込みます。この例は Python が SSL をサポートするように設定してインストールされている場合のみ動作します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
</div>
<p>上の例で使われているサンプルの CGI は以下のようになっています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content-type: text/plain</span><span class="se">\n\n</span><span class="s1">Got Data: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> を使った <code class="docutils literal"><span class="pre">PUT</span></code> リクエストの例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some data&#39;</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://localhost:8080&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">DATA</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>以下はベーシック HTTP 認証の例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c1"># Create an OpenerDirector with support for Basic HTTP Authentication...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s1">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s1">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s1">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s1">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c1"># ...and install it globally so it can be used with urlopen.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.build_opener" title="urllib.request.build_opener"><code class="xref py py-func docutils literal"><span class="pre">build_opener()</span></code></a> はデフォルトで沢山のハンドラを提供しており、その中に <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyHandler</span></code></a> があります。デフォルトでは、 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyHandler</span></code></a> は <code class="docutils literal"><span class="pre">&lt;scheme&gt;_proxy</span></code> という環境変数を使います。 ここで <code class="docutils literal"><span class="pre">&lt;scheme&gt;</span></code> は URL スキームです。例えば、 HTTP プロキシの URL を得るには、環境変数 <span class="target" id="index-31"></span><code class="xref std std-envvar docutils literal"><span class="pre">http_proxy</span></code> を読み出します。</p>
<p>この例では、デフォルトの <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyHandler</span></code></a> を置き換えてプログラム的に作成したプロキシ URL を使うようにし、 <a class="reference internal" href="#urllib.request.ProxyBasicAuthHandler" title="urllib.request.ProxyBasicAuthHandler"><code class="xref py py-class docutils literal"><span class="pre">ProxyBasicAuthHandler</span></code></a> でプロキシ認証サポートを追加します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;realm&#39;</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c1"># This time, rather than install the OpenerDirector, we use it directly:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>以下は HTTP ヘッダーを追加する例です:</p>
<p><em>headers</em> 引数を使って <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> コンストラクタを呼び出す方法の他に、以下のようにできます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Referer&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="c1"># Customize the default User-Agent header value:</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s1">&#39;urllib-example/0.1 (Contact: . . .)&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal"><span class="pre">OpenerDirector</span></code></a> は全ての <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> に <em class="mailheader">User-Agent</em> ヘッダーを自動的に追加します。これを変更するには以下のようにします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s1">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>また、 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal"><span class="pre">Request</span></code></a> が <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> (や <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal"><span class="pre">OpenerDirector.open()</span></code></a>)に渡される際には、いくつかの標準ヘッダー (<em class="mailheader">Content-Length</em>, <em class="mailheader">Content-Type</em> および <em class="mailheader">Host</em>) も追加されることを忘れないでください。</p>
<p id="urllib-examples">以下は <code class="docutils literal"><span class="pre">GET</span></code> メソッドを使ってパラメータを含む URL を取得するセッションの例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下の例では、<code class="docutils literal"><span class="pre">POST</span></code> メソッドを使用しています。urlencode から出力されたパラメーターは urlopen にデータとして渡される前に bytes にエンコードされていることに注意してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://requestb.in/xrbl82xr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下の例では、環境変数による設定内容に対して上書きする形で HTTP プロキシを明示的に設定しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>以下の例では、環境変数による設定内容に対して上書きする形で、まったくプロキシを使わないよう設定しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="legacy-interface">
<h2>21.6.24. レガシーインターフェース<a class="headerlink" href="#legacy-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数およびクラスは、Python 2 のモジュール <code class="docutils literal"><span class="pre">urllib</span></code> (<code class="docutils literal"><span class="pre">urllib2</span></code> ではありません) から移植されたものです。これらは将来的に廃止されるかもしれません。</p>
<dl class="function">
<dt id="urllib.request.urlretrieve">
<code class="descclassname">urllib.request.</code><code class="descname">urlretrieve</code><span class="sig-paren">(</span><em>url</em>, <em>filename=None</em>, <em>reporthook=None</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlretrieve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL で表されるネットワークオブジェクトをローカルファイルにコピーします。 URL がローカルファイルを示している場合は、ファイル名が与えられない限りオブジェクトはコピーされません。戻り値はタプル <code class="docutils literal"><span class="pre">(filename,</span> <span class="pre">headers)</span></code> になり、 <em>filename</em> はオブジェクトが保存されたローカルファイル名、 <em>headers</em> は (リモートオブジェクトに対しては) <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> が返したオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">info()</span></code> メソッドが返すものすべてになります。例外は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> のものと同じになります。</p>
<p>2 つめの引数がある場合、オブジェクトのコピー先となるファイルの位置を指定します (もしなければ、ファイルの場所は一時ファイル (tmpfile) の置き場になり、名前は適当につけられます)。 3 つめの引数がある場合、ネットワークとの接続が確立された際に一度呼び出され、以降データのブロックが読み出されるたびに呼び出されるフック関数 (hook function) を指定します。フック関数には 3 つの引数が渡されます; これまで転送されたブロック数のカウント、バイト単位で表されたブロックサイズ、ファイルの総サイズです。3 つ目のファイルの総サイズは、ファイル取得の際の応答時にファイルサイズを返さない古い FTP サーバでは <code class="docutils literal"><span class="pre">-1</span></code> になります。</p>
<p>以下は最も一般的な使用例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_filename</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="s1">&#39;http://python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><em>url</em> が <code class="file docutils literal"><span class="pre">http:</span></code> スキーム識別子を使用していた場合、任意の引数 <em>data</em> は <code class="docutils literal"><span class="pre">POST</span></code> リクエストの指定に使用される場合があります (通常のリクエストタイプは <code class="docutils literal"><span class="pre">GET</span></code> です)。引数 <em>data</em> は標準 <em class="mimetype">application/x-www-form-urlencoded</em> 形式のバイトオブジェクトでなければなりません。 <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></code></a> 関数を参照してください。</p>
<p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal"><span class="pre">urlretrieve()</span></code></a> は、予想 (これは <em>Content-Length</em> ヘッダーにより通知されるサイズです) よりも取得できるデータ量が少ないことを検知した場合、 <code class="xref py py-exc docutils literal"><span class="pre">ContentTooShortError</span></code> を発生します。これは、例えば、ダウンロードが中断された場合などに発生します。</p>
<p><em>Content-Length</em> はデータ量の下限です: 読み込むデータ量がこれを超えている場合 urlretrieve はそれらも読み込みますが、利用できるデータがこれを下回った場合、例外が送出されます。</p>
<p>このような場合にもダウンロードされたデータを取得することは可能で、これは exception インスタンスの <code class="xref py py-attr docutils literal"><span class="pre">content</span></code> 属性に保存されています。</p>
<p><em>Content-Length</em> ヘッダーが与えられなれけば urlretrieve はダウンロードしたデータのサイズをチェックできません。この場合ダウンロードは正常に完了したとみなすしかありません。</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.urlcleanup">
<code class="descclassname">urllib.request.</code><code class="descname">urlcleanup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlcleanup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>以前の <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal"><span class="pre">urlretrieve()</span></code></a> 呼び出し後に残っているかもしれない一時ファイルをクリーンアップします。</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.URLopener">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">URLopener</code><span class="sig-paren">(</span><em>proxies=None</em>, <em>**x509</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">バージョン 3.3 で撤廃.</span></p>
</div>
<p>URL をオープンし、読み出すためのクラスの基底クラスです。<code class="file docutils literal"><span class="pre">http:</span></code>, <code class="file docutils literal"><span class="pre">ftp:</span></code>, <code class="file docutils literal"><span class="pre">file:</span></code> 以外のスキームを使ったオブジェクトのオープンをサポートしたいのでないかぎり、<a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal"><span class="pre">FancyURLopener</span></code></a> を使おうと思うことになるでしょう。</p>
<p>デフォルトでは、 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal"><span class="pre">URLopener</span></code></a> クラスは <em class="mailheader">User-Agent</em> ヘッダーとして <code class="docutils literal"><span class="pre">urllib/VVV</span></code> を送信します。ここで <em>VVV</em> は <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal"><span class="pre">urllib</span></code></a> のバージョン番号です。アプリケーションで独自の <em class="mailheader">User-Agent</em> ヘッダーを送信したい場合は、 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal"><span class="pre">URLopener</span></code></a> かまたは <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal"><span class="pre">FancyURLopener</span></code></a> のサブクラスを作成し、サブクラス定義においてクラス属性 <a class="reference internal" href="#urllib.request.URLopener.version" title="urllib.request.URLopener.version"><code class="xref py py-attr docutils literal"><span class="pre">version</span></code></a> を適切な文字列値に設定することで行うことができます。</p>
<p>オプションのパラメーター <em>proxies</em> はスキーム名をプロキシの URL にマップする辞書でなければなりません。空の辞書はプロキシ機能を完全にオフにします。デフォルトの値は <code class="docutils literal"><span class="pre">None</span></code> で、この場合、 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> の定義で述べたように、プロキシを設定する環境変数が存在するならそれを使います。</p>
<p>追加のキーワードパラメーターは <em>x509</em> に集められますが、これは <code class="file docutils literal"><span class="pre">https:</span></code> スキームを使った際のクライアント認証に使われることがあります。キーワード引数 <em>key_file</em> および <em>cert_file</em> が SSL 鍵と証明書を設定するためにサポートされています; クライアント認証をするには両方が必要です。</p>
<p><a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal"><span class="pre">URLopener</span></code></a> オブジェクトはサーバーがエラーコードを返した場合に <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> 例外を送出します。</p>
<dl class="method">
<dt id="urllib.request.URLopener.open">
<code class="descname">open</code><span class="sig-paren">(</span><em>fullurl</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>適切なプロトコルを使って <em>fullurl</em> を開きます。このメソッドはキャッシュとプロキシ情報を設定し、その後適切な open メソッドを入力引数つきで呼び出します。認識できないスキームが与えられた場合、 <a class="reference internal" href="#urllib.request.URLopener.open_unknown" title="urllib.request.URLopener.open_unknown"><code class="xref py py-meth docutils literal"><span class="pre">open_unknown()</span></code></a> が呼び出されます。 <em>data</em> 引数は <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> の引数 <em>data</em> と同じ意味を持っています。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.open_unknown">
<code class="descname">open_unknown</code><span class="sig-paren">(</span><em>fullurl</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーバライド可能な、未知のタイプの URL を開くためのインタフェースです。</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.retrieve">
<code class="descname">retrieve</code><span class="sig-paren">(</span><em>url</em>, <em>filename=None</em>, <em>reporthook=None</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>url</em> の内容を取得し、<em>filename</em> に保存します。戻り値は、ローカルファイル名と、レスポンスヘッダーが含まれる <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal"><span class="pre">email.message.Message</span></code></a> (リモート URL の場合) か <code class="docutils literal"><span class="pre">None</span></code> (ローカル URL の場合) からなるタプルになります。呼び出し側は、その後 <em>filename</em> を開いてその内容を読み込まなければなりません。<em>filename</em> が与えられず、URL がローカルファイルを参照している場合、入力ファイル名が返されます。URL がローカルでなく、<em>filename</em> が与えられていない場合、ファイル名は入力 URL のパスの最後の構成要素のサフィックスとマッチするサフィックスを持つ <a class="reference internal" href="tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal"><span class="pre">tempfile.mktemp()</span></code></a> の出力になります。<em>reporthook</em> が与えられている場合、3 つの数値 (チャンク数、読み込んだチャンクの最大サイズ、および総ダウンロードサイズ — 不明の場合は -1) の引数を受け取る関数でなければなりません。これは開始時に 1 回と、ネットワークからデータのチャンクを読み込む度に呼び出されます。<em>reporthook</em> はローカル URL に対しては無視されます。</p>
<p><em>url</em> が <code class="file docutils literal"><span class="pre">http:</span></code> スキーム識別子を使用していた場合、任意の引数 <em>data</em> は <code class="docutils literal"><span class="pre">POST</span></code> リクエストの指定に使用される場合があります (通常のリクエストタイプは <code class="docutils literal"><span class="pre">GET</span></code> です)。引数 <em>data</em> は標準 <em class="mimetype">application/x-www-form-urlencoded</em> 形式でなければなりません。<a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></code></a> 関数を参照してください。</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.URLopener.version">
<code class="descname">version</code><a class="headerlink" href="#urllib.request.URLopener.version" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL をオープンするオブジェクトのユーザエージェントを指定する変数です。 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal"><span class="pre">urllib</span></code></a> を特定のユーザエージェントであるとサーバに通知するには、サブクラスの中でこの値をクラス変数として値を設定するか、コンストラクタの中でベースクラスを呼び出す前に値を設定してください。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="urllib.request.FancyURLopener">
<em class="property">class </em><code class="descclassname">urllib.request.</code><code class="descname">FancyURLopener</code><span class="sig-paren">(</span><em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener" title="この定義へのパーマリンク">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">バージョン 3.3 で撤廃.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal"><span class="pre">FancyURLopener</span></code></a> は <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal"><span class="pre">URLopener</span></code></a> のサブクラスで、以下の HTTP レスポンスコード: 301、302、303、 307、および 401 を取り扱う機能を提供します。レスポンスコード 30x に対しては、 <em class="mailheader">Location</em> ヘッダーを使って実際の URL を取得します。レスポンスコード 401 (認証が要求されていることを示す) に対しては、BASIC認証 (basic HTTP authintication) が行われます。レスポンスコード 30x に対しては、最大で <em>maxtries</em> 属性に指定された数だけ再帰呼び出しを行うようになっています。この値はデフォルトで 10 です。</p>
<p>その他のレスポンスコードについては、 <code class="xref py py-meth docutils literal"><span class="pre">http_error_default()</span></code> が呼ばれます。これはサブクラスでエラーを適切に処理するようにオーバーライドすることができます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><span class="target" id="index-32"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a> によると、 POST 要求に対する 301 および 302 応答はユーザの承認無しに自動的にリダイレクトしてはなりません。実際は、これらの応答に対して自動リダイレクトを許すブラウザでは POST を GET に変更しており、 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal"><span class="pre">urllib</span></code></a> でもこの動作を再現します。</p>
</div>
<p>コンストラクタに与えるパラメーターは <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal"><span class="pre">URLopener</span></code></a> と同じです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">基本的な HTTP 認証を行う際、 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal"><span class="pre">FancyURLopener</span></code></a> インスタンスは <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal"><span class="pre">prompt_user_passwd()</span></code></a> メソッドを呼び出します。このメソッドはデフォルトでは実行を制御している端末上で認証に必要な情報を要求するように実装されています。必要ならば、このクラスのサブクラスにおいてより適切な動作をサポートするために <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal"><span class="pre">prompt_user_passwd()</span></code></a> メソッドをオーバライドしてもかまいません。</p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal"><span class="pre">FancyURLopener</span></code></a> クラスはオーバライド可能な追加のメソッドを提供しており、適切な振る舞いをさせることができます:</p>
<dl class="method">
<dt id="urllib.request.FancyURLopener.prompt_user_passwd">
<code class="descname">prompt_user_passwd</code><span class="sig-paren">(</span><em>host</em>, <em>realm</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたセキュリティ領域 (security realm) 下にある与えられたホストにおいて、ユーザー認証に必要な情報を返すための関数です。この関数が返す値は <code class="docutils literal"><span class="pre">(user,</span> <span class="pre">password)</span></code> からなるタプルでなければなりません。値は Basic 認証で使われます。</p>
<p>このクラスでの実装では、端末に情報を入力するようプロンプトを出します; ローカルの環境において適切な形で対話型モデルを使うには、このメソッドをオーバライドしなければなりません。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="urllib-request-restrictions">
<h2>21.6.25. <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal"><span class="pre">urllib.request</span></code></a> の制限事項<a class="headerlink" href="#urllib-request-restrictions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ul id="index-10">
<li><p class="first">現在、次のプロトコルのみサポートされています: HTTP (バージョン 0.9 および 1.0)、FTP、ローカルファイル、およびデータ URL</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>データ URL サポートが追加されました。</p>
</div>
</li>
<li><p class="first"><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal"><span class="pre">urlretrieve()</span></code></a> のキャッシュ機能は、誰かが Expiration time ヘッダーの正しい処理をハックする時間を見つけるまで無効にされています。</p>
</li>
<li><p class="first">ある URL がキャッシュにあるかどうか調べるような関数があればと思っています。</p>
</li>
<li><p class="first">後方互換性のため、 URL がローカルシステム上のファイルを指しているように見えるにも関わらずファイルを開くことができなければ、 URL は FTP プロトコルを使って再解釈されます。この機能は時として混乱を招くエラーメッセージを引き起こします。</p>
</li>
<li><p class="first">関数 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> および <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal"><span class="pre">urlretrieve()</span></code></a> は、ネットワーク接続が確立されるまでの間、一定でない長さの遅延を引き起こすことがあります。このことは、これらの関数を使ってインタラクティブな Web クライアントを構築するのはスレッドなしには難しいことを意味します。</p>
</li>
<li id="index-11"><p class="first"><a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal"><span class="pre">urlopen()</span></code></a> あるいは <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal"><span class="pre">urlretrieve()</span></code></a> が返すデータはサーバーから返された生データです。これは (画像のような) バイナリ、プレーンテキスト、あるいは (例えば) HTML などになります。HTTP プロトコルはレスポンスヘッダー内でタイプ情報を提供しており、<em class="mailheader">Content-Type</em> ヘッダーを見ることで調査できます。返されたデータが HTML の場合、モジュール <a class="reference internal" href="html.parser.html#module-html.parser" title="html.parser: A simple parser that can handle HTML and XHTML."><code class="xref py py-mod docutils literal"><span class="pre">html.parser</span></code></a> を使用してこれを解析できます。</p>
</li>
<li id="index-12"><p class="first">FTP プロトコルを扱うコードでは、ファイルとディレクトリを区別できません。このことから、アクセスできないファイルを指している URL からデータを読み出そうとすると、予期しない動作を引き起こす場合があります。 URL が <code class="docutils literal"><span class="pre">/</span></code> で終わっていれば、ディレクトリを指しているものとみなして、それに適した処理を行います。しかし、ファイルの読み出し操作が 550 エラー (URL が存在しないか、主にパーミッションの理由でアクセスできない) になった場合、 URL がディレクトリを指していて、末尾の <code class="docutils literal"><span class="pre">/</span></code> を忘れたケースを処理するため、パスをディレクトリとして扱います。このために、パーミッションのためにアクセスできないファイルを fetch しようとすると、FTP コードはそのファイルを開こうとして 550 エラーに陥り、次にディレクトリ一覧を表示しようとするため、誤解を生むような結果を引き起こす可能性があるのです。よく調整された制御が必要なら、 <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">ftplib</span></code></a> モジュールを使うか、 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal"><span class="pre">FancyURLopener</span></code></a> をサブクラス化するか、 <em>_urlopener</em> を変更して目的に合わせるよう検討してください。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="module-urllib.response">
<span id="urllib-response-response-classes-used-by-urllib"></span><h1>21.7. <a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal"><span class="pre">urllib.response</span></code></a> — urllib で使用するレスポンスクラス<a class="headerlink" href="#module-urllib.response" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal"><span class="pre">urllib.response</span></code></a> モジュールは、<code class="docutils literal"><span class="pre">read()</span></code> および <code class="docutils literal"><span class="pre">readline()</span></code> を含む 最小限のファイルライクインターフェースを定義する関数およびクラスを定義しています。代表的なレスポンスオブジェクトは addinfourl インスタンスで、レスポンスヘッダーを返す <code class="docutils literal"><span class="pre">info()</span></code> メソッドおよび URL を返す <code class="docutils literal"><span class="pre">geturl()</span></code> メソッドを定義しています。このモジュールで定義された関数は、<a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal"><span class="pre">urllib.request</span></code></a> モジュール内で使用されます。</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">21.6. <code class="docutils literal"><span class="pre">urllib.request</span></code> — URL を開くための拡張可能なライブラリ</a><ul>
<li><a class="reference internal" href="#request-objects">21.6.1. Request オブジェクト</a></li>
<li><a class="reference internal" href="#openerdirector-objects">21.6.2. OpenerDirector オブジェクト</a></li>
<li><a class="reference internal" href="#basehandler-objects">21.6.3. BaseHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">21.6.4. HTTPRedirectHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">21.6.5. HTTPCookieProcessor オブジェクト</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">21.6.6. ProxyHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">21.6.7. HTTPPasswordMgr オブジェクト</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">21.6.8. HTTPPasswordMgrWithPriorAuth オブジェクト</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">21.6.9. AbstractBasicAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">21.6.10. HTTPBasicAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">21.6.11. ProxyBasicAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">21.6.12. AbstractDigestAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">21.6.13. HTTPDigestAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">21.6.14. ProxyDigestAuthHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httphandler-objects">21.6.15. HTTPHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httpshandler-objects">21.6.16. HTTPSHandler オブジェクト</a></li>
<li><a class="reference internal" href="#filehandler-objects">21.6.17. FileHandler オブジェクト</a></li>
<li><a class="reference internal" href="#datahandler-objects">21.6.18. DataHandler オブジェクト</a></li>
<li><a class="reference internal" href="#ftphandler-objects">21.6.19. FTPHandler オブジェクト</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">21.6.20. CacheFTPHandler オブジェクト</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">21.6.21. UnknownHandler オブジェクト</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">21.6.22. HTTPErrorProcessor オブジェクト</a></li>
<li><a class="reference internal" href="#examples">21.6.23. 使用例</a></li>
<li><a class="reference internal" href="#legacy-interface">21.6.24. レガシーインターフェース</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions">21.6.25. <code class="docutils literal"><span class="pre">urllib.request</span></code> の制限事項</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response">21.7. <code class="docutils literal"><span class="pre">urllib.response</span></code> — urllib で使用するレスポンスクラス</a></li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="urllib.html"
                        title="前の章へ">21.5. <code class="docutils literal"><span class="pre">urllib</span></code> — URL を扱うモジュール群</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="urllib.parse.html"
                        title="次の章へ">21.8. <code class="docutils literal"><span class="pre">urllib.parse</span></code> — URL を解析して構成要素にする</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/urllib.request.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="21.8. urllib.parse — URL を解析して構成要素にする"
             >次へ</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="21.5. urllib — URL を扱うモジュール群"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >21. インターネットプロトコルとサポート</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 5月 17, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>