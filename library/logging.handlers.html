
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>16.8. logging.handlers — ロギングハンドラ &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="16.9. getpass — 可搬性のあるパスワード入力機構" href="getpass.html" />
    <link rel="prev" title="16.7. logging.config — ロギングの環境設定" href="logging.config.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/library/logging.handlers.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/library/logging.handlers.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="16.9. getpass — 可搬性のあるパスワード入力機構"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="16.7. logging.config — ロギングの環境設定"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">16. 汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-logging.handlers">
<span id="logging-handlers-logging-handlers"></span><h1>16.8. <a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> — ロギングハンドラ<a class="headerlink" href="#module-logging.handlers" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/logging/handlers.py">Lib/logging/handlers.py</a></p>
<div class="sidebar">
<p class="first sidebar-title">Important</p>
<p>このページには、リファレンス情報だけが含まれています。チュートリアルは、以下のページを参照してください</p>
<ul class="last simple">
<li><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">基本チュートリアル</span></a></li>
<li><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">上級チュートリアル</span></a></li>
<li><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">ロギングクックブック</span></a></li>
</ul>
</div>
<hr class="docutils" />
<p>このパッケージでは、以下の便利なハンドラが提供されています。なお、これらのハンドラのうち、3 つ (<a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a>, <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code></a> および <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a>) は、実際には <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> モジュール自身で定義されていますが、他のハンドラと一緒にここでドキュメント化します。</p>
<div class="section" id="streamhandler">
<span id="stream-handler"></span><h2>16.8.1. StreamHandler<a class="headerlink" href="#streamhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> コアパッケージに含まれる <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a> クラスは、ログ出力を <em>sys.stdout</em>, <em>sys.stderr</em> あるいは何らかのファイル風 (file-like) オブジェクト (あるいは、より正確に言えば <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code> メソッドをサポートする何らかのオブジェクト) といったストリームに送信します。</p>
<dl class="class">
<dt id="logging.StreamHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">StreamHandler</code><span class="sig-paren">(</span><em>stream=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a> クラスの新たなインスタンスを返します。 <em>stream</em> が指定された場合、インスタンスはログ出力先として指定されたストリームを使います; そうでない場合、 <em>sys.stderr</em> が使われます。</p>
<dl class="method">
<dt id="logging.StreamHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フォーマッタが指定されていれば、フォーマッタを使ってレコードを書式化します。 次に、レコードが終端記号とともにストリームに書き込まれます。 例外情報が存在する場合、 <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal"><span class="pre">traceback.print_exception()</span></code></a> を使って書式化され、 ストリームの末尾につけられます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.StreamHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ストリームの <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> メソッドを呼び出してバッファをフラッシュします。 <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> メソッドは <a class="reference internal" href="logging.html#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal"><span class="pre">Handler</span></code></a> から継承しているため何も出力を行わないので、 <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> 呼び出しを明示的に行う必要があるかもしれません。</p>
</dd></dl>

</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><code class="docutils literal"><span class="pre">StreamHandler</span></code> クラスに <code class="docutils literal"><span class="pre">terminator</span></code> 属性が追加されました (デフォルト値は <code class="docutils literal"><span class="pre">'\n'</span></code>)。これは、書式化されたレコードをストリームに書き込むときの終端記号として使用されます。このような改行による終端を望まなければ、ハンドラ・インスタンスの <code class="docutils literal"><span class="pre">terminator</span></code> 属性を空の文字列に設定することができます。初期のバージョンでは、終端記号は <code class="docutils literal"><span class="pre">'\n'</span></code> としてハードコードされていました。</p>
</div>
</div>
<div class="section" id="filehandler">
<span id="file-handler"></span><h2>16.8.2. FileHandler<a class="headerlink" href="#filehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> コアパッケージに含まれる <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code></a> クラスは、ログ出力をディスク上のファイルに送信します。このクラスは出力機能を <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a> から継承しています。</p>
<dl class="class">
<dt id="logging.FileHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">FileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code></a> クラスの新たなインスタンスを返します。
指定されたファイルが開かれ、ログ記録のためのストリームとして使われます。
<em>mode</em> が指定されなかった場合、 <code class="xref py py-const docutils literal"><span class="pre">'a'</span></code> が使われます。
<em>encoding</em> が <code class="docutils literal"><span class="pre">None</span></code> でない場合、その値はファイルを開くときのエンコーディングとして使われます。
<em>delay</em> が真ならば、ファイルを開くのは最初の <a class="reference internal" href="#logging.FileHandler.emit" title="logging.FileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a> 呼び出しまで遅らせられます。
デフォルトでは、ファイルは無制限に大きくなりつづけます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>As well as string values, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> objects are also accepted
for the <em>filename</em> argument.</p>
</div>
<dl class="method">
<dt id="logging.FileHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.FileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>record</em> をファイルに出力します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nullhandler">
<span id="null-handler"></span><h2>16.8.3. NullHandler<a class="headerlink" href="#nullhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加.</span></p>
</div>
<p><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> コアパッケージに含まれる <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a> クラスは、いかなる書式化も出力も行いません。これは本質的には、ライブラリ開発者に使われる 'no-op' ハンドラです。</p>
<dl class="class">
<dt id="logging.NullHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">NullHandler</code><a class="headerlink" href="#logging.NullHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a> クラスの新しいインスタンスを返します。</p>
<dl class="method">
<dt id="logging.NullHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="logging.NullHandler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは何もしません。</p>
</dd></dl>

<dl class="method">
<dt id="logging.NullHandler.createLock">
<code class="descname">createLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.createLock" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アクセスが特殊化される必要がある I/O が下にないので、このメソッドはロックに対して <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal"><span class="pre">NullHandler</span></code></a> の使い方の詳しい情報は、 <a class="reference internal" href="../howto/logging.html#library-config"><span class="std std-ref">ライブラリのためのロギングの設定</span></a> を参照してください。</p>
</div>
<div class="section" id="watchedfilehandler">
<span id="watched-file-handler"></span><h2>16.8.4. WatchedFileHandler<a class="headerlink" href="#watchedfilehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal"><span class="pre">WatchedFileHandler</span></code></a> クラスは、ログ記録先のファイルを監視する <code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code> の一種です。ファイルが変更された場合、ファイルを閉じてからファイル名を使って開き直します。</p>
<p>ファイルはログファイルをローテーションさせる <em>newsyslog</em> や <em>logrotate</em> のようなプログラムを使うことで変更されることがあります。このハンドラは、 Unix/Linux で使われることを意図していますが、ファイルが最後にログを出力してから変わったかどうかを監視します。 (ファイルはデバイスや inode が変わることで変わったと判断します。) ファイルが変わったら古いファイルのストリームは閉じて、現在のファイルを新しいストリームを取得するために開きます。</p>
<p>このハンドラを Windows で使うことは適切ではありません。というのも Windows では開いているログファイルを移動したり削除したりできないからです - logging はファイルを排他的ロックを掛けて開きます - そのためこうしたハンドラは必要ないのです。さらに、 Windows では <em>ST_INO</em> がサポートされていません; <a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a> はこの値として常に 0 を返します。</p>
<dl class="class">
<dt id="logging.handlers.WatchedFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">WatchedFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal"><span class="pre">WatchedFileHandler</span></code></a> クラスの新たなインスタンスを返します。
指定されたファイルが開かれ、ログ記録のためのストリームとして使われます。
<em>mode</em> が指定されなかった場合、 <code class="xref py py-const docutils literal"><span class="pre">'a'</span></code> が使われます。
<em>encoding</em> が <code class="docutils literal"><span class="pre">None</span></code> でない場合、その値はファイルを開くときのエンコーディングとして使われます。
<em>delay</em> が真ならば、ファイルを開くのは最初の <a class="reference internal" href="#logging.handlers.WatchedFileHandler.emit" title="logging.handlers.WatchedFileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a> 呼び出しまで遅らせられます。
デフォルトでは、ファイルは無制限に大きくなりつづけます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>As well as string values, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> objects are also accepted
for the <em>filename</em> argument.</p>
</div>
<dl class="method">
<dt id="logging.handlers.WatchedFileHandler.reopenIfNeeded">
<code class="descname">reopenIfNeeded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler.reopenIfNeeded" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Checks to see if the file has changed.  If it has, the existing stream is
flushed and closed and the file opened again, typically as a precursor to
outputting the record to the file.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.WatchedFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Outputs the record to the file, but first calls <a class="reference internal" href="#logging.handlers.WatchedFileHandler.reopenIfNeeded" title="logging.handlers.WatchedFileHandler.reopenIfNeeded"><code class="xref py py-meth docutils literal"><span class="pre">reopenIfNeeded()</span></code></a> to
reopen the file if it has changed.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="baserotatinghandler">
<span id="base-rotating-handler"></span><h2>16.8.5. BaseRotatingHandler<a class="headerlink" href="#baserotatinghandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに存在する <a class="reference internal" href="#logging.handlers.BaseRotatingHandler" title="logging.handlers.BaseRotatingHandler"><code class="xref py py-class docutils literal"><span class="pre">BaseRotatingHandler</span></code></a> クラスは、ローテートを行うファイルハンドラ <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> と <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a> のベースクラスです。このクラスをインスタンス化する必要はありませんが、オーバーライドすることになるかもしれない属性とメソッドを持っています。</p>
<dl class="class">
<dt id="logging.handlers.BaseRotatingHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BaseRotatingHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>パラメータは <code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code> と同じです。属性は次の通りです:</p>
<dl class="attribute">
<dt id="logging.handlers.BaseRotatingHandler.namer">
<code class="descname">namer</code><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.namer" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性に callable がセットされた場合、 <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal"><span class="pre">rotation_filename()</span></code></a> メソッドはこの callable に委譲されます。 callable に渡されるパラメータは <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal"><span class="pre">rotation_filename()</span></code></a> に渡されたものです。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">namer 関数はロールオーバー中にかなりの回数呼ばれます。そのため、できるだけ単純で、速くあるべきです。さらに、それは与えられた入力に対しては常に同じ出力を返すべきです。そうでなければ、ロールオーバーの振る舞いは期待通りに動かないかもしれません。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="logging.handlers.BaseRotatingHandler.rotator">
<code class="descname">rotator</code><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>この属性に callable がセットされた場合、 <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal"><span class="pre">rotate()</span></code></a> メソッドはこの callable に委譲されます。 callable に渡されるパラメータは <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal"><span class="pre">rotate()</span></code></a> に渡されたものです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BaseRotatingHandler.rotation_filename">
<code class="descname">rotation_filename</code><span class="sig-paren">(</span><em>default_name</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローテートを行う際にログファイルのファイル名を変更します。</p>
<p>このメソッドは、ファイル名をカスタマイズするために提供されます。</p>
<p>デフォルト実装は、ハンドラの 'namer' 属性が callable だった場合、その callable を呼んでデフォルト名を渡します。属性が callable でない場合 (デフォルトは <code class="docutils literal"><span class="pre">None</span></code> です)、名前は変更せずに返されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><strong>default_name</strong> – ログファイルのデフォルトのファイル名。</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BaseRotatingHandler.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>source</em>, <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローテートが行われる時、現在のログをローテートします。</p>
<p>デフォルト実装は、 ハンドラの 'rotator' 属性が callable だった場合、その callable を呼んで source と dest 引数を渡します。属性が callable でない場合 (デフォルトは <code class="docutils literal"><span class="pre">None</span></code> です)、単に source が destination に改名されます。</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">パラメータ:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> – ソースファイル名。これは通常ベースファイル名 、例えば 'test.log' となります。</li>
<li><strong>dest</strong> – 変更先ファイル名。これは通常ソースファイルをローテートしたもの (例えば 'test.log.1') です。</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>これらの属性が存在する理由は、サブクラス化を省略できるようにするためです。 <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> と <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a> のインスタンスに対して同じ callable が使えます。もし namer や rotator callable が例外を上げれば、 <code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code> 呼び出しで発生した他の例外と同じ方法で、つまりハンドラの <code class="xref py py-meth docutils literal"><span class="pre">handleError()</span></code> メソッドによって扱われます。</p>
<p>ローテート処理に大幅な変更を加える必要があれば、メソッドをオーバーライドすることができます。</p>
<p>例えば、 <a class="reference internal" href="../howto/logging-cookbook.html#cookbook-rotator-namer"><span class="std std-ref">rotator と namer を使ってログローテートをカスタマイズする</span></a> を参照してください。</p>
</div>
<div class="section" id="rotatingfilehandler">
<span id="rotating-file-handler"></span><h2>16.8.6. RotatingFileHandler<a class="headerlink" href="#rotatingfilehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> クラスは、ディスク上のログファイルに対するローテーション処理をサポートします。</p>
<dl class="class">
<dt id="logging.handlers.RotatingFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">RotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>maxBytes=0</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code></a> クラスの新たなインスタンスを返します。
指定されたファイルが開かれ、ログ記録のためのストリームとして使われます。
<em>mode</em> が指定されなかった場合、 <code class="docutils literal"><span class="pre">'a'</span></code> が使われます。
<em>encoding</em> が <code class="docutils literal"><span class="pre">None</span></code> でない場合、その値はファイルを開くときのエンコーディングとして使われます。
<em>delay</em> が真ならば、ファイルを開くのは最初の <a class="reference internal" href="#logging.handlers.RotatingFileHandler.emit" title="logging.handlers.RotatingFileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a> 呼び出しまで遅らせられます。
デフォルトでは、ファイルは無制限に大きくなりつづけます。</p>
<p>You can use the <em>maxBytes</em> and <em>backupCount</em> values to allow the file to
<em class="dfn">rollover</em> at a predetermined size. When the size is about to be exceeded,
the file is closed and a new file is silently opened for output. Rollover occurs
whenever the current log file is nearly <em>maxBytes</em> in length; but if either of
<em>maxBytes</em> or <em>backupCount</em> is zero, rollover never occurs, so you generally want
to set <em>backupCount</em> to at least 1, and have a non-zero <em>maxBytes</em>.
When <em>backupCount</em> is non-zero, the system will save old log files by appending
the extensions '.1', '.2' etc., to the filename. For example, with a <em>backupCount</em>
of 5 and a base file name of <code class="file docutils literal"><span class="pre">app.log</span></code>, you would get <code class="file docutils literal"><span class="pre">app.log</span></code>,
<code class="file docutils literal"><span class="pre">app.log.1</span></code>, <code class="file docutils literal"><span class="pre">app.log.2</span></code>, up to <code class="file docutils literal"><span class="pre">app.log.5</span></code>. The file being
written to is always <code class="file docutils literal"><span class="pre">app.log</span></code>.  When this file is filled, it is closed
and renamed to <code class="file docutils literal"><span class="pre">app.log.1</span></code>, and if files <code class="file docutils literal"><span class="pre">app.log.1</span></code>,
<code class="file docutils literal"><span class="pre">app.log.2</span></code>, etc. exist, then they are renamed to <code class="file docutils literal"><span class="pre">app.log.2</span></code>,
<code class="file docutils literal"><span class="pre">app.log.3</span></code> etc. respectively.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>As well as string values, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> objects are also accepted
for the <em>filename</em> argument.</p>
</div>
<dl class="method">
<dt id="logging.handlers.RotatingFileHandler.doRollover">
<code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler.doRollover" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上述のような方法でロールオーバを行います。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.RotatingFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上述のようなロールオーバを行いながら、レコードをファイルに出力します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="timedrotatingfilehandler">
<span id="timed-rotating-file-handler"></span><h2>16.8.7. TimedRotatingFileHandler<a class="headerlink" href="#timedrotatingfilehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a> クラスは、特定の時間間隔でのログローテーションをサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.TimedRotatingFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">TimedRotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>when='h'</em>, <em>interval=1</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>utc=False</em>, <em>atTime=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code></a> クラスの新たなインスタンスを返します。 <em>filename</em> に指定したファイルを開き、ログ出力先のストリームとして使います。ログファイルのローテーション時には、ファイル名に拡張子 (suffix) をつけます。ログファイルのローテーションは <em>when</em> および <em>interval</em> の積に基づいて行います。</p>
<p><em>when</em> は <em>interval</em> の単位を指定するために使います。使える値は下表の通りです。大小文字の区別は行いません。</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="41%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">値</th>
<th class="head"><em>interval</em> の単位</th>
<th class="head">If/how <em>atTime</em> is used</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'S'</span></code></td>
<td>秒</td>
<td>無視</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'M'</span></code></td>
<td>分</td>
<td>無視</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'H'</span></code></td>
<td>時間</td>
<td>無視</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'D'</span></code></td>
<td>日</td>
<td>無視</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'W0'-'W6'</span></code></td>
<td>曜日 (0=月曜)</td>
<td>Used to compute initial
rollover time</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'midnight'</span></code></td>
<td>Roll over at midnight, if
<em>atTime</em> not specified,
else at time <em>atTime</em></td>
<td>Used to compute initial
rollover time</td>
</tr>
</tbody>
</table>
<p>曜日ベースのローテーションを使う場合は、月曜として 'W0' を、火曜として 'W1' を、…、日曜として 'W6' を指定します。このケースの場合は、 <em>interval</em> は使われません。</p>
<p>古いログファイルの保存時、ロギングシステムによりファイル名に拡張子が付けられます。 ロールオーバ間隔によって、strftime の <code class="docutils literal"><span class="pre">%Y-%m-%d_%H-%M-%S</span></code> 形式またはその前方の一部を使って、日付と時間に基づいた拡張子が付けられます。</p>
<p>最初に次のロールオーバー時間を計算するとき (ハンドラが生成されるとき)、次のローテーションがいつ起こるかを計算するために、既存のログファイルの最終変更時刻または現在の時間が使用されます。</p>
<p><em>utc</em> 引数が true の場合時刻は UTC になり、それ以外では現地時間が使われます。</p>
<p><em>backupCount</em> がゼロでない場合、保存されるファイル数は高々 <em>backupCount</em> 個で、それ以上のファイルがロールオーバされる時に作られるならば、一番古いものが削除されます。削除のロジックは interval で決まるファイルを削除するので、 interval を変えると古いファイルが残ったままになることもあります。</p>
<p><em>delay</em> が true なら、ファイルを開くのは <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler.emit" title="logging.handlers.TimedRotatingFileHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a> の最初の呼び出しまで延期されます。</p>
<p>If <em>atTime</em> is not <code class="docutils literal"><span class="pre">None</span></code>, it must be a <code class="docutils literal"><span class="pre">datetime.time</span></code> instance which
specifies the time of day when rollover occurs, for the cases where rollover
is set to happen &quot;at midnight&quot; or &quot;on a particular weekday&quot;. Note that in
these cases, the <em>atTime</em> value is effectively used to compute the <em>initial</em>
rollover, and subsequent rollovers would be calculated via the normal
interval calculation.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Calculation of the initial rollover time is done when the handler
is initialised. Calculation of subsequent rollover times is done only
when rollover occurs, and rollover occurs only when emitting output. If
this is not kept in mind, it might lead to some confusion. For example,
if an interval of &quot;every minute&quot; is set, that does not mean you will
always see log files with times (in the filename) separated by a minute;
if, during application execution, logging output is generated more
frequently than once a minute, <em>then</em> you can expect to see log files
with times separated by a minute. If, on the other hand, logging messages
are only output once every five minutes (say), then there will be gaps in
the file times corresponding to the minutes where no output (and hence no
rollover) occurred.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><em>atTime</em> パラメータが追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>As well as string values, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> objects are also accepted
for the <em>filename</em> argument.</p>
</div>
<dl class="method">
<dt id="logging.handlers.TimedRotatingFileHandler.doRollover">
<code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler.doRollover" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上述のような方法でロールオーバを行います。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.TimedRotatingFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>上で説明した方法でロールオーバを行いながら、レコードをファイルに出力します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sockethandler">
<span id="socket-handler"></span><h2>16.8.8. SocketHandler<a class="headerlink" href="#sockethandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> クラスは、ログ出力をネットワークソケットに送信します。基底クラスでは TCP ソケットを用います。</p>
<dl class="class">
<dt id="logging.handlers.SocketHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SocketHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アドレスが <em>host</em> および <em>port</em> で与えられた遠隔のマシンと通信するようにした <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> クラスのインスタンスを生成して返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><code class="docutils literal"><span class="pre">port</span></code> に <code class="docutils literal"><span class="pre">None</span></code> を指定すると、Unix ドメインソケットが <code class="docutils literal"><span class="pre">host</span></code> 値を用いて作られます - そうでない場合は TCP ソケットが作られます。</p>
</div>
<dl class="method">
<dt id="logging.handlers.SocketHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle して <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> にするには、 <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal"><span class="pre">makeLogRecord()</span></code></a> 関数を使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.handleError">
<code class="descname">handleError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.handleError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.SocketHandler.emit" title="logging.handlers.SocketHandler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a> の処理中に発生したエラーを処理します。よくある原因は接続の消失です。次のイベント発生時に再試行できるようにソケットを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.makeSocket">
<code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makeSocket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>サブクラスで必要なソケット形式を詳細に定義できるようにするためのファクトリメソッドです。デフォルトの実装では、 TCP ソケット (<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a>) を生成します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.makePickle">
<code class="descname">makePickle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makePickle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードの属性辞書を pickle してから先頭に長さ情報を付けてバイナリ形式にして、ソケットを介して送信できるようにして返します。</p>
<p>pickle が完全に安全というわけではないことに注意してください。セキュリティに関して心配なら、より安全なメカニズムを実装するためにこのメソッドをオーバーライドすると良いでしょう。例えば、 HMAC を使って pickle に署名して、受け取る側ではそれを検証することができます。あるいはまた、受け取る側でグローバルなオブジェクトの unpickle を無効にすることができます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>packet</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>pickle された文字列 <em>packet</em> をソケットに送信します。この関数はネットワークがビジーの時に発生する部分的送信に対応しています。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.createSocket">
<code class="descname">createSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.createSocket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソケットの生成を試みます。失敗時には、指数的な減速アルゴリズムを使います。最初の失敗時には、ハンドラは送ろうとしていたメッセージを落とします。続くメッセージが同じインスタンスで扱われたとき、幾らかの時間が経過するまで接続を試みません。デフォルトのパラメタは、最初の遅延時間が 1 秒で、その遅延時間の後でそれでも接続が確保できないなら、遅延時間は 2 倍づつになり、最大で 30 秒になります。</p>
<p>この働きは、以下のハンドラ属性で制御されます:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">retryStart</span></code> (最初の遅延時間、デフォルトは 1.0 秒)。</li>
<li><code class="docutils literal"><span class="pre">retryFactor</span></code> (乗数、デフォルトは 2.0)。</li>
<li><code class="docutils literal"><span class="pre">retryMax</span></code> (最大遅延時間、デフォルトは 30.0 秒)。</li>
</ul>
<p>つまり、ハンドラが使われた <em>後に</em> リモートリスナが起動した場合、メッセージが失われてしまうことがあります (ハンドラは、遅延時間が経過するまで接続を試みようとさえせず、その遅延時間中に通知なくメッセージを捨てるので)。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="datagramhandler">
<span id="datagram-handler"></span><h2>16.8.9. DatagramHandler<a class="headerlink" href="#datagramhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal"><span class="pre">DatagramHandler</span></code></a> クラスは、 <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> を継承しており、 UDP ソケットを介したログ記録メッセージの送信をサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.DatagramHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">DatagramHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アドレスが <em>host</em> および <em>port</em> で与えられた遠隔のマシンと通信するようにした <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal"><span class="pre">DatagramHandler</span></code></a> クラスのインスタンスを生成して返します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>If <code class="docutils literal"><span class="pre">port</span></code> is specified as <code class="docutils literal"><span class="pre">None</span></code>, a Unix domain socket is created
using the value in <code class="docutils literal"><span class="pre">host</span></code> - otherwise, a UDP socket is created.</p>
</div>
<dl class="method">
<dt id="logging.handlers.DatagramHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードの属性辞書を pickle して、バイナリ形式でソケットに書き込みます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは捨てられます。事前に接続が失われていた場合、接続を再度確立します。受信端でレコードを unpickle して <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> にするには、 <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal"><span class="pre">makeLogRecord()</span></code></a> 関数を使ってください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.DatagramHandler.makeSocket">
<code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.makeSocket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ここで <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal"><span class="pre">SocketHandler</span></code></a> のファクトリメソッドをオーバライドして、 UDP ソケット (<a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_DGRAM</span></code></a>) を生成しています。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.DatagramHandler.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>pickle された文字列をソケットに送信します。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sysloghandler">
<span id="syslog-handler"></span><h2>16.8.10. SysLogHandler<a class="headerlink" href="#sysloghandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> クラスは、ログ記録メッセージを遠隔またはローカルの Unix syslog に送信する機能をサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.SysLogHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SysLogHandler</code><span class="sig-paren">(</span><em>address=('localhost'</em>, <em>SYSLOG_UDP_PORT)</em>, <em>facility=LOG_USER</em>, <em>socktype=socket.SOCK_DGRAM</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>遠隔の Unix マシンと通信するための、 <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> クラスの新たなインスタンスを返します。マシンのアドレスは <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> のタプル形式をとる <em>address</em> で与えられます。 <em>address</em> が指定されない場合、 <code class="docutils literal"><span class="pre">('localhost',</span> <span class="pre">514)</span></code> が使われます。アドレスは UDP ソケットを使って開かれます。 <code class="docutils literal"><span class="pre">(host,</span> <span class="pre">port)</span></code> のタプル形式の代わりに文字列で &quot;/dev/log&quot; のように与えることもできます。この場合、 Unix ドメインソケットが syslog にメッセージを送るのに使われます。 <em>facility</em> が指定されない場合、 <code class="xref py py-const docutils literal"><span class="pre">LOG_USER</span></code> が使われます。開かれるソケットの型は、 <em>socktype</em> 引数に依り、デフォルトは <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_DGRAM</span></code></a> で、UDP ソケットを開きます。 (rsyslog のような新しい syslog デーモンと使うために) TCP ソケットを開くには、 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a> の値を指定してください。</p>
<p>使用中のサーバが UDP ポート 514 を待機していない場合、 <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> が正常に動作していないように見える場合があります。その場合、ドメインソケットに使うべきアドレスを調べてください。そのアドレスはシステムによって異なります。例えば、Linux システムでは通常 '/dev/log' ですが、 OS X では '/var/run/syslog' です。プラットフォームを確認し、適切なアドレスを使う必要があります (アプリケーションを複数のプラットフォーム上で動作させる必要がある場合、実行時に確認する必要があるかもしれません)。Windows では、多くの場合、UDP オプションを使用する必要があります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span><em>socktype</em> が追加されました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.SysLogHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>遠隔ホストへのソケットを閉じます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードは書式化された後、 syslog サーバに送信されます。例外情報が存在しても、サーバには <em>送信されません</em> 。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2.1 で変更: </span>(See: <a class="reference external" href="https://bugs.python.org/issue12168">bpo-12168</a>.) In earlier versions, the message sent to the
syslog daemons was always terminated with a NUL byte, because early
versions of these daemons expected a NUL terminated message - even
though it’s not in the relevant specification (RFC 5424). More recent
versions of these daemons don’t expect the NUL byte but strip it off
if it’s there, and even more recent daemons (which adhere more closely
to RFC 5424) pass the NUL byte on as part of the message.</p>
<p>このような異なるデーモンの振る舞いすべてに対して syslog メッセージの取り扱いをより容易にするため、 NUL バイトの追加はクラスレベル属性 <code class="docutils literal"><span class="pre">append_nul</span></code> を使用して設定できるようになりました。これはデフォルトで <code class="docutils literal"><span class="pre">True</span></code> (既存の振る舞いを保持) ですが、 <code class="docutils literal"><span class="pre">SysLogHandler</span></code> インスタンスが NUL 終端文字を追加 <em>しない</em> ように <code class="docutils literal"><span class="pre">False</span></code> にセットすることができます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>(参照: <a class="reference external" href="https://bugs.python.org/issue12419">bpo-12419</a>) 以前のバージョンでは、メッセージソースを識別するための &quot;ident&quot; あるいは &quot;tag&quot; プリフィックス機能はありませんでした。これは、今ではクラスレベル属性を使用して指定することができるようになりました。デフォルトでは既存の振る舞いを保持するために <code class="docutils literal"><span class="pre">&quot;&quot;</span></code> ですが、特定の <code class="docutils literal"><span class="pre">SysLogHandler</span></code> インスタンスが扱うすべてのメッセージに識別子を前置するようにそれをオーバーライドすることができます。識別子はバイトではなくテキストでなければならず、正確にそのままメッセージに前置されることに注意してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.encodePriority">
<code class="descname">encodePriority</code><span class="sig-paren">(</span><em>facility</em>, <em>priority</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.encodePriority" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファシリティおよび優先度を整数に符号化します。値は文字列でも整数でも渡すことができます。文字列が渡された場合、内部の対応付け辞書が使われ、整数に変換されます。</p>
<p>シンボリックな <code class="docutils literal"><span class="pre">LOG_</span></code> 値は <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal"><span class="pre">SysLogHandler</span></code></a> で定義されています。これは <code class="docutils literal"><span class="pre">sys/syslog.h</span></code> ヘッダーファイルで定義された値を反映しています。</p>
<p><strong>優先度</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">名前 (文字列)</th>
<th class="head">シンボル値</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">alert</span></code></td>
<td>LOG_ALERT</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">crit</span></code> or <code class="docutils literal"><span class="pre">critical</span></code></td>
<td>LOG_CRIT</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">debug</span></code></td>
<td>LOG_DEBUG</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">emerg</span></code> or <code class="docutils literal"><span class="pre">panic</span></code></td>
<td>LOG_EMERG</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">err</span></code> or <code class="docutils literal"><span class="pre">error</span></code></td>
<td>LOG_ERR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">info</span></code></td>
<td>LOG_INFO</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">notice</span></code></td>
<td>LOG_NOTICE</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">warn</span></code> or <code class="docutils literal"><span class="pre">warning</span></code></td>
<td>LOG_WARNING</td>
</tr>
</tbody>
</table>
<p><strong>ファシリティ</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">名前 (文字列)</th>
<th class="head">シンボル値</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">auth</span></code></td>
<td>LOG_AUTH</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">authpriv</span></code></td>
<td>LOG_AUTHPRIV</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">cron</span></code></td>
<td>LOG_CRON</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">daemon</span></code></td>
<td>LOG_DAEMON</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">ftp</span></code></td>
<td>LOG_FTP</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">kern</span></code></td>
<td>LOG_KERN</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">lpr</span></code></td>
<td>LOG_LPR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">mail</span></code></td>
<td>LOG_MAIL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">news</span></code></td>
<td>LOG_NEWS</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">syslog</span></code></td>
<td>LOG_SYSLOG</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">user</span></code></td>
<td>LOG_USER</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">uucp</span></code></td>
<td>LOG_UUCP</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">local0</span></code></td>
<td>LOG_LOCAL0</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">local1</span></code></td>
<td>LOG_LOCAL1</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">local2</span></code></td>
<td>LOG_LOCAL2</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">local3</span></code></td>
<td>LOG_LOCAL3</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">local4</span></code></td>
<td>LOG_LOCAL4</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">local5</span></code></td>
<td>LOG_LOCAL5</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">local6</span></code></td>
<td>LOG_LOCAL6</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">local7</span></code></td>
<td>LOG_LOCAL7</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.mapPriority">
<code class="descname">mapPriority</code><span class="sig-paren">(</span><em>levelname</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.mapPriority" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ログレベル名を syslog 優先度名に対応付けます。カスタムレベルを使用している場合や、デフォルトアルゴリズムがニーズに適していない場合には、このメソッドをオーバーライドする必要があるかもしれません。デフォルトアルゴリズムは、 <code class="docutils literal"><span class="pre">DEBUG</span></code>, <code class="docutils literal"><span class="pre">INFO</span></code>, <code class="docutils literal"><span class="pre">WARNING</span></code>, <code class="docutils literal"><span class="pre">ERROR</span></code>, <code class="docutils literal"><span class="pre">CRITICAL</span></code> を等価な syslog 名に、他のすべてのレベル名を &quot;warning&quot; に対応付けます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nteventloghandler">
<span id="nt-eventlog-handler"></span><h2>16.8.11. NTEventLogHandler<a class="headerlink" href="#nteventloghandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal"><span class="pre">NTEventLogHandler</span></code></a> クラスは、ログ記録メッセージをローカルな Windows NT, Windows 2000, または Windows XP のイベントログに送信する機能をサポートします。この機能を使えるようにするには、 Mark Hammond による Python 用 Win32 拡張パッケージをインストールする必要があります。</p>
<dl class="class">
<dt id="logging.handlers.NTEventLogHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">NTEventLogHandler</code><span class="sig-paren">(</span><em>appname</em>, <em>dllname=None</em>, <em>logtype='Application'</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal"><span class="pre">NTEventLogHandler</span></code></a> クラスの新たなインスタンスを返します。 <em>appname</em> はイベントログに表示する際のアプリケーション名を定義するために使われます。この名前を使って適切なレジストリエントリが生成されます。 <em>dllname</em> はログに保存するメッセージ定義の入った .dll または .exe ファイルへの完全修飾パス名を与えなければなりません (指定されない場合、 <code class="docutils literal"><span class="pre">'win32service.pyd'</span></code> が使われます - このライブラリは Win32 拡張とともにインストールされ、いくつかのプレースホルダとなるメッセージ定義を含んでいます)。これらのプレースホルダを利用すると、メッセージの発信源全体がログに記録されるため、イベントログは巨大になるので注意してください。 <em>logtype</em> は <code class="docutils literal"><span class="pre">'Application'</span></code>, <code class="docutils literal"><span class="pre">'System'</span></code>, <code class="docutils literal"><span class="pre">'Security'</span></code> のいずれかで、デフォルトは <code class="docutils literal"><span class="pre">'Application'</span></code> です。</p>
<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>現時点では、イベントログエントリの発信源としてのアプリケーション名をレジストリから除去することはできます。しかしこれを行うと、イベントログビューアで意図した通りにログが見えなくなるでしょう - これはイベントログが .dll 名を取得するためにレジストリにアクセスできなければならないからです。現在のバージョンではこの操作を行いません。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メッセージ ID、イベントカテゴリ、イベント型を決定し、メッセージを NT イベントログに記録します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getEventCategory">
<code class="descname">getEventCategory</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getEventCategory" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードに対するイベントカテゴリを返します。自作のカテゴリを指定したい場合、このメソッドをオーバライドしてください。このクラスのバージョンのメソッドは 0 を返します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getEventType">
<code class="descname">getEventType</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getEventType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードのイベント型を返します。自作の型を指定したい場合、このメソッドをオーバライドしてください。このクラスのバージョンのメソッドは、ハンドラの <em>typemap</em> 属性を使って対応付けを行います。この属性は <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> で初期化され、 <code class="xref py py-const docutils literal"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal"><span class="pre">INFO</span></code>, <code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal"><span class="pre">CRITICAL</span></code> が入っています。自作のレベルを使っているのなら、このメソッドをオーバライドするか、ハンドラの <em>typemap</em> 属性に適切な辞書を配置する必要があるでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getMessageID">
<code class="descname">getMessageID</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getMessageID" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードのメッセージ ID を返します。自作のメッセージを使っているのなら、ロガーに渡される <em>msg</em> を書式化文字列ではなく ID にします。その上で、辞書参照を行ってメッセージ ID を得ます。このクラスのバージョンでは 1 を返します。この値は <code class="file docutils literal"><span class="pre">win32service.pyd</span></code> における基本メッセージ ID です。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="smtphandler">
<span id="smtp-handler"></span><h2>16.8.12. SMTPHandler<a class="headerlink" href="#smtphandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a> クラスは、 SMTP を介したログ記録メッセージの送信機能をサポートします。</p>
<dl class="class">
<dt id="logging.handlers.SMTPHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SMTPHandler</code><span class="sig-paren">(</span><em>mailhost</em>, <em>fromaddr</em>, <em>toaddrs</em>, <em>subject</em>, <em>credentials=None</em>, <em>secure=None</em>, <em>timeout=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>新たな <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a> クラスのインスタンスを返します。インスタンスは email の from および to アドレス行、および subject 行とともに初期化されます。 <em>toaddrs</em> は文字列からなるリストでなければなりません。非標準の SMTP ポートを指定するには、 <em>mailhost</em> 引数に (host, port) のタプル形式を指定します。文字列を使った場合、標準の SMTP ポートが使われます。もし SMTP サーバが認証を必要とするならば、 (username, password) のタプル形式を <em>credentials</em> 引数に指定することができます。</p>
<p>セキュアプロトコル (TLS) の使用を指定するには <em>secure</em> 引数にタプルを渡してください。これは認証情報が渡された場合のみ使用されます。タプルは、空のタプルか、キーファイルの名前を持つ1要素のタプルか、またはキーファイルと証明書ファイルの名前を持つ2要素のタプルのいずれかでなければなりません。 (このタプルは <a class="reference internal" href="smtplib.html#smtplib.SMTP.starttls" title="smtplib.SMTP.starttls"><code class="xref py py-meth docutils literal"><span class="pre">smtplib.SMTP.starttls()</span></code></a> メソッドに渡されます。)</p>
<p>SMTP サーバとのコミュニケーションのために、 <em>timeout</em> 引数を使用してタイムアウトを指定することができます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加: </span><em>timeout</em> 引数が追加されました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.SMTPHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを書式化し、指定されたアドレスに送信します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SMTPHandler.getSubject">
<code class="descname">getSubject</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler.getSubject" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードに応じたサブジェクト行を指定したいなら、このメソッドをオーバライドしてください。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="memoryhandler">
<span id="memory-handler"></span><h2>16.8.13. MemoryHandler<a class="headerlink" href="#memoryhandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a> は、ログ記録するレコードをメモリ上にバッファリングし、定期的にその内容をターゲット (<em class="dfn">target</em>) となるハンドラにフラッシュする機能をサポートしています。フラッシュ処理はバッファが一杯になるか、ある深刻度かそれ以上のレベルを持つイベントが観測された際に行われます。</p>
<p><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a> はより一般的な抽象クラス、 <a class="reference internal" href="#logging.handlers.BufferingHandler" title="logging.handlers.BufferingHandler"><code class="xref py py-class docutils literal"><span class="pre">BufferingHandler</span></code></a> のサブクラスです。この抽象クラスでは、ログ記録するレコードをメモリ上にバッファリングします。各レコードがバッファに追加される毎に、 <code class="xref py py-meth docutils literal"><span class="pre">shouldFlush()</span></code> を呼び出してバッファをフラッシュすべきかどうか調べます。フラッシュする必要がある場合、 <code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code> がフラッシュ処理を行うものと想定されます。</p>
<dl class="class">
<dt id="logging.handlers.BufferingHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BufferingHandler</code><span class="sig-paren">(</span><em>capacity</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定した許容量のバッファでハンドラを初期化します。</p>
<dl class="method">
<dt id="logging.handlers.BufferingHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードをバッファに追加します。 <a class="reference internal" href="#logging.handlers.BufferingHandler.shouldFlush" title="logging.handlers.BufferingHandler.shouldFlush"><code class="xref py py-meth docutils literal"><span class="pre">shouldFlush()</span></code></a> が true を返す場合、バッファを処理するために <a class="reference internal" href="#logging.handlers.BufferingHandler.flush" title="logging.handlers.BufferingHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> を呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BufferingHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドをオーバライドして、自作のフラッシュ動作を実装することができます。このクラスのバージョンのメソッドでは、単にバッファの内容を削除して空にします。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BufferingHandler.shouldFlush">
<code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.shouldFlush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファが許容量に達している場合に true を返します。このメソッドは自作のフラッシュ処理方針を実装するためにオーバライドすることができます。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="logging.handlers.MemoryHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">MemoryHandler</code><span class="sig-paren">(</span><em>capacity</em>, <em>flushLevel=ERROR</em>, <em>target=None</em>, <em>flushOnClose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns a new instance of the <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a> class. The instance is
initialized with a buffer size of <em>capacity</em>. If <em>flushLevel</em> is not specified,
<code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code> is used. If no <em>target</em> is specified, the target will need to be
set using <a class="reference internal" href="#logging.handlers.MemoryHandler.setTarget" title="logging.handlers.MemoryHandler.setTarget"><code class="xref py py-meth docutils literal"><span class="pre">setTarget()</span></code></a> before this handler does anything useful. If
<em>flushOnClose</em> is specified as <code class="docutils literal"><span class="pre">False</span></code>, then the buffer is <em>not</em> flushed when
the handler is closed. If not specified or specified as <code class="docutils literal"><span class="pre">True</span></code>, the previous
behaviour of flushing the buffer will occur when the handler is closed.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>The <em>flushOnClose</em> parameter was added.</p>
</div>
<dl class="method">
<dt id="logging.handlers.MemoryHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.MemoryHandler.flush" title="logging.handlers.MemoryHandler.flush"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> を呼び出し、ターゲットを <code class="docutils literal"><span class="pre">None</span></code> に設定してバッファを消去します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.flush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal"><span class="pre">MemoryHandler</span></code></a> の場合、フラッシュ処理は単に、バッファされたレコードをターゲットがあれば送信することを意味します。これと異なる動作を行いたい場合、オーバライドしてください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.setTarget">
<code class="descname">setTarget</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.setTarget" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ターゲットハンドラをこのハンドラに設定します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.shouldFlush">
<code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.shouldFlush" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バッファが一杯になっているか、 <em>flushLevel</em> またはそれ以上のレコードでないかを調べます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="httphandler">
<span id="http-handler"></span><h2>16.8.14. HTTPHandler<a class="headerlink" href="#httphandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a> クラスは、ログ記録メッセージを <code class="docutils literal"><span class="pre">GET</span></code> または <code class="docutils literal"><span class="pre">POST</span></code> セマンティクスを使って Web サーバに送信する機能をサポートしています。</p>
<dl class="class">
<dt id="logging.handlers.HTTPHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">HTTPHandler</code><span class="sig-paren">(</span><em>host</em>, <em>url</em>, <em>method='GET'</em>, <em>secure=False</em>, <em>credentials=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a> クラスの新たなインスタンスを返します。特別なポートを使う必要がある場合、<em>host</em> は <code class="docutils literal"><span class="pre">host:port</span></code> の形式で使うことができます。 <em>method</em> が指定されない場合、 <code class="docutils literal"><span class="pre">GET</span></code> が使われます。 <em>secure</em> が真の場合、HTTPS 接続が使われます。 HTTPS 接続で使用する SSL 設定のために <em>context</em> 引数を <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a> のインスタンスに設定することができます。 <em>credentials</em> を指定する場合、BASIC 認証の際の HTTP 'Authorization' ヘッダに使われるユーザIDとパスワードからなる 2要素タプルを渡してください。 credentials を指定する場合、ユーザIDとパスワードが通信中に平文として剥き出しにならないよう、secure=True も指定すべきです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span><em>context</em> パラメータが追加されました。</p>
</div>
<dl class="method">
<dt id="logging.handlers.HTTPHandler.mapLogRecord">
<code class="descname">mapLogRecord</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler.mapLogRecord" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>URL エンコードされて Web サーバに送信することになる、 <code class="docutils literal"><span class="pre">record</span></code> に基づく辞書を供給します。デフォルトの実装では単に <code class="docutils literal"><span class="pre">record.__dict__</span></code> を返します。例えば <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> のサブセットのみを Web サーバに送信する場合や、 サーバーに送信する内容を特別にカスタマイズする必要がある場合には、このメソッドをオーバライドできます。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.HTTPHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを URL エンコードされた辞書形式で Web サーバに送信します。レコードを送信のために辞書に変換するために <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal"><span class="pre">mapLogRecord()</span></code></a> が呼び出されます。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Web server に送信するためのレコードを準備することは一般的な書式化操作とは同じではありませんので、 <a class="reference internal" href="logging.html#logging.Handler.setFormatter" title="logging.Handler.setFormatter"><code class="xref py py-meth docutils literal"><span class="pre">setFormatter()</span></code></a> を使って <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> を指定することは、 <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal"><span class="pre">HTTPHandler</span></code></a> には効果はありません。 <a class="reference internal" href="logging.html#logging.Handler.format" title="logging.Handler.format"><code class="xref py py-meth docutils literal"><span class="pre">format()</span></code></a> を呼び出す代わりに、このハンドラは <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal"><span class="pre">mapLogRecord()</span></code></a> を呼び出し、その後その返却辞書を Web server に送信するのに適した様式にエンコードするために <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal"><span class="pre">urllib.parse.urlencode()</span></code></a>  を呼び出します。</p>
</div>
</dd></dl>

</div>
<div class="section" id="queuehandler">
<span id="queue-handler"></span><h2>16.8.15. QueueHandler<a class="headerlink" href="#queuehandler" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> クラスは、 <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">queue</span></code></a> モジュールや <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> のモジュールで実装されるようなキューにログメッセージを送信する機能をサポートしています。</p>
<p><a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> クラスとともに <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> を使うと、ロギングを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。これは、クライアントに対してサービスするスレッドができるだけ速く応答する必要がある一方、別のスレッド上で (<a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a> によって電子メールを送信するような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他のサービスアプリケーションにおいて重要です。</p>
<dl class="class">
<dt id="logging.handlers.QueueHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueHandler</code><span class="sig-paren">(</span><em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> クラスの新しいインスタンスを返します。インスタンスは、キューにメッセージを送るように初期化されます。キューは任意のキューのようなオブジェクトが可能です; それはそのまま <a class="reference internal" href="#logging.handlers.QueueHandler.enqueue" title="logging.handlers.QueueHandler.enqueue"><code class="xref py py-meth docutils literal"><span class="pre">enqueue()</span></code></a> メソッドによって使用されます。そのメソッドはメッセージを送る方法を知っている必要があります。</p>
<dl class="method">
<dt id="logging.handlers.QueueHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.emit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>準備した LogRecord の結果をキューに追加します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueHandler.prepare">
<code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.prepare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューに追加するためレコードを準備します。このメソッドが返したオブジェクトがキューに追加されます。</p>
<p>メッセージと引数を合成するためにレコードを書式化して、レコードから pickle 不可能なアイテムを in-place で取り除くベース実装です。</p>
<p>レコードを dict や JSON 文字列に変換したい場合や、オリジナルのレコードを変更せずに修正済のコピーを送りたい場合は、このメソッドをオーバーライドすると良いでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueHandler.enqueue">
<code class="descname">enqueue</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.enqueue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューにレコードを  <code class="docutils literal"><span class="pre">put_nowait()</span></code> を使ってエンキューします; ブロッキングやタイムアウト、あるいはなにか特別なキューの実装を使いたければ、これをオーバライドしてみてください。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="queuelistener">
<span id="queue-listener"></span><h2>16.8.16. QueueListener<a class="headerlink" href="#queuelistener" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> モジュールに含まれる <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> クラスは、 <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal"><span class="pre">queue</span></code></a> モジュールや <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> のモジュールで実装されるようなキューからログメッセージを受信する機能をサポートしています。メッセージは内部スレッドのキューから受信され、同じスレッド上の複数のハンドラに渡されて処理されます。 <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> それ自体はハンドラではありませんが、 <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> と連携して動作するのでここで文書化されています。</p>
<p><a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal"><span class="pre">QueueHandler</span></code></a> クラスとともに <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> を使うと、ロギングを行うスレッドから分離されたスレッド上でハンドラを動かすことができます。これは、クライアントに対してサービスするスレッドができるだけ速く応答する必要がある一方、別のスレッド上で (<a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal"><span class="pre">SMTPHandler</span></code></a> によって電子メールを送信するような) 潜在的に遅い操作が行われるような、ウェブアプリケーションおよびその他のサービスアプリケーションにおいて重要です。</p>
<dl class="class">
<dt id="logging.handlers.QueueListener">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueListener</code><span class="sig-paren">(</span><em>queue</em>, <em>*handlers</em>, <em>respect_handler_level=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal"><span class="pre">QueueListener</span></code></a> クラスの新しいインスタンスを返します。インスタンスは、メッセージの送信先キューと、キュー上に配置されたエントリーを扱うハンドラのリストとともに初期化されます。キューには、任意のキューのようなオブジェクトを使用できます。キューのようなオブジェクトは、そのまま <a class="reference internal" href="#logging.handlers.QueueListener.dequeue" title="logging.handlers.QueueListener.dequeue"><code class="xref py py-meth docutils literal"><span class="pre">dequeue()</span></code></a> メソッドに渡されます。そのメソッドはメッセージをキューから取得する方法を知っている必要があります。 <code class="docutils literal"><span class="pre">respect_handler_level</span></code> が <code class="docutils literal"><span class="pre">True</span></code> の場合、メッセージをそのハンドラーに渡すかどうかを判断する際、(メッセージに対するレベルと比較して)ハンドラのレベルは尊重されます。<code class="docutils literal"><span class="pre">False</span></code> の場合、以前の Python のバージョンと同様に動作し、各メッセージを各ハンドラに常に渡します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>The <code class="docutils literal"><span class="pre">respect_handler_levels</span></code> argument was added.</p>
</div>
<dl class="method">
<dt id="logging.handlers.QueueListener.dequeue">
<code class="descname">dequeue</code><span class="sig-paren">(</span><em>block</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.dequeue" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キューからレコードを取り除き、それを返します。ブロッキングすることがあります。</p>
<p>ベース実装は <code class="docutils literal"><span class="pre">get()</span></code> を使用します。タイムアウトを有効にしたい場合や、カスタムのキュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.prepare">
<code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.prepare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを扱うための準備をします。</p>
<p>この実装は渡されたレコードをそのまま返します。その値をハンドラに渡す前に何らかのカスタムな整列化 (marshalling) あるいはレコードに対する操作を行う必要があれば、このメソッドをオーバーライドすると良いでしょう。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.handle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>レコードを処理します。</p>
<p>これは、ハンドラをループしてそれらに処理すべきレコードを渡します。ハンドラに渡される実際のオブジェクトは、 <a class="reference internal" href="#logging.handlers.QueueListener.prepare" title="logging.handlers.QueueListener.prepare"><code class="xref py py-meth docutils literal"><span class="pre">prepare()</span></code></a> から返されたものです。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.start" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーを開始します。</p>
<p>これは、 LogRecord を処理するキューを監視するために、バックグラウンドスレッドを開始します。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.stop" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーを停止します。</p>
<p>スレッドに終了するように依頼し、終了するまで待ちます。アプリケーションの終了前にこのメソッドを呼ばないと、いくつかのレコードがキューに残り、処理されなくなるかもしれないことに注意してください。</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.enqueue_sentinel">
<code class="descname">enqueue_sentinel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.enqueue_sentinel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>リスナーに停止するように指示するためキューに番兵を書き込みます。この実装は <code class="docutils literal"><span class="pre">put_nowait()</span></code> を使用します。タイムアウトを有効にしたい場合や、カスタムのキュー実装を使いたい場合は、このメソッドをオーバーライドすると良いでしょう。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> モジュール</dt>
<dd>logging モジュールの API リファレンス。</dd>
<dt><a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.config</span></code></a> モジュール</dt>
<dd>logging モジュールの環境設定 API です。</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">16.8. <code class="docutils literal"><span class="pre">logging.handlers</span></code> — ロギングハンドラ</a><ul>
<li><a class="reference internal" href="#streamhandler">16.8.1. StreamHandler</a></li>
<li><a class="reference internal" href="#filehandler">16.8.2. FileHandler</a></li>
<li><a class="reference internal" href="#nullhandler">16.8.3. NullHandler</a></li>
<li><a class="reference internal" href="#watchedfilehandler">16.8.4. WatchedFileHandler</a></li>
<li><a class="reference internal" href="#baserotatinghandler">16.8.5. BaseRotatingHandler</a></li>
<li><a class="reference internal" href="#rotatingfilehandler">16.8.6. RotatingFileHandler</a></li>
<li><a class="reference internal" href="#timedrotatingfilehandler">16.8.7. TimedRotatingFileHandler</a></li>
<li><a class="reference internal" href="#sockethandler">16.8.8. SocketHandler</a></li>
<li><a class="reference internal" href="#datagramhandler">16.8.9. DatagramHandler</a></li>
<li><a class="reference internal" href="#sysloghandler">16.8.10. SysLogHandler</a></li>
<li><a class="reference internal" href="#nteventloghandler">16.8.11. NTEventLogHandler</a></li>
<li><a class="reference internal" href="#smtphandler">16.8.12. SMTPHandler</a></li>
<li><a class="reference internal" href="#memoryhandler">16.8.13. MemoryHandler</a></li>
<li><a class="reference internal" href="#httphandler">16.8.14. HTTPHandler</a></li>
<li><a class="reference internal" href="#queuehandler">16.8.15. QueueHandler</a></li>
<li><a class="reference internal" href="#queuelistener">16.8.16. QueueListener</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="logging.config.html"
                        title="前の章へ">16.7. <code class="docutils literal"><span class="pre">logging.config</span></code> — ロギングの環境設定</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="getpass.html"
                        title="次の章へ">16.9. <code class="docutils literal"><span class="pre">getpass</span></code> — 可搬性のあるパスワード入力機構</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/logging.handlers.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="16.9. getpass — 可搬性のあるパスワード入力機構"
             >次へ</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="16.7. logging.config — ロギングの環境設定"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >16. 汎用オペレーティングシステムサービス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 7月 24, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>