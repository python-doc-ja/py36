
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5. インポートシステム &#8212; Python 3.6.4 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="6. 式 (expression)" href="expressions.html" />
    <link rel="prev" title="4. 実行モデル" href="executionmodel.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/reference/import.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/reference/import.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 式 (expression)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.4</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-import-system">
<span id="importsystem"></span><h1>5. インポートシステム<a class="headerlink" href="#the-import-system" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">ある 1 つの <a class="reference internal" href="../glossary.html#term-module"><span class="xref std std-term">module</span></a> にある Python コードから他のモジュールをインポート (<a class="reference internal" href="../glossary.html#term-importing"><span class="xref std std-term">importing</span></a>) することで、そこにあるコードへアクセスできるようになります。 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文はインポート機構を動かす最も一般的な方法ですが、それが唯一の方法ではありません。 <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> や組み込みの <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> といった関数を使っても、インポート機構を動かすことができます。</p>
<p><a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文は 2 つの処理を連続して行っています; ある名前のモジュールを探し、その検索結果をローカルスコープの名前に束縛します。 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文の検索処理は、適切な引数で <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 関数を呼び出すこととして定義されています。 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> の戻り値は <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文の名前束縛処理の実行で使われます。名前束縛処理の厳密な詳細は <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文を参照してください。</p>
<p><a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> を直接呼び出すとモジュールの検索のみが行われ、見つかった場合、モジュールの作成処理が行われます。親パッケージのインポートや (<a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> を含む) 様々なキャッシュの更新などの副作用は起きるかもしれませんが、 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文のみが名前束縛処理を行います。</p>
<p>import 文の一部として <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> を呼び出したときは標準の組み込みの <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> が呼ばれます。インポートシステムを起動する他の機構 (たとえば <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> など) は、 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> を覆すことを選んで固有のインポートセマンティクスを実装するための方法を用いることがあります。</p>
<p>When a module is first imported, Python searches for the module and if found,
it creates a module object <a class="footnote-reference" href="#fnmo" id="id1">[1]</a>, initializing it.  If the named module
cannot be found, a <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">ModuleNotFoundError</span></code></a> is raised.  Python implements various
strategies to search for the named module when the import machinery is
invoked.  These strategies can be modified and extended by using various hooks
described in the sections below.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>インポートシステムが <span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> の第 2 フェーズの完全な実装へ更新されました。もはや暗黙的なインポート機構はありません - インポート機構全体は <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> を通して公開されています。加えて、ネイティブの名前空間パッケージのサポートは実装されています (<span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> を参照) 。</p>
</div>
<div class="section" id="importlib">
<h2>5.1. <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a><a class="headerlink" href="#importlib" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a> モジュールはインポート機構とやり取りするための便利な API を提供します。例えば <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> は、インポート機構を実行するための組み込みの <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> よりもシンプルで推奨される API を提供します。より詳細なことは <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a> ライブラリのドキュメントを参照してください。</p>
</div>
<div class="section" id="packages">
<h2>5.2. パッケージ<a class="headerlink" href="#packages" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-3">Python にはモジュールオブジェクトの種類は 1 種類しかなく、 Python 、 C 、それ以外のもののどれで実装されているかに関係なく、すべてのモジュールはこの種類になります。モジュールの組織化を助け、名前階層を提供するために、 Python には <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">パッケージ</span></a> という概念があります。</p>
<p>パッケージはファイルシステムのディレクトリ、モジュールはディレクトリにあるファイルと考えることができますが、パッケージやモジュールはファイルシステムから生まれる必要はないので、この比喩を額面通りに受け取ってはいけません。この文書の目的のために、ディレクトリとファイルという便利な比喩を使うことにします。ファイルシステムのディレクトリのように、パッケージは階層構造を成し、通常のモジュールだけでなく、サブパッケージを含むこともあります。</p>
<p>すべてのパッケージはモジュールですが、すべてのモジュールがパッケージとは限らないことを心に留めておくのが重要です。もしくは他の言い方をすると、パッケージは単なる特別な種類のモジュールであると言えます。特に、<code class="docutils literal"><span class="pre">__path__</span></code> 属性を持つ任意のモジュールはパッケージと見なされます。</p>
<p>すべてのモジュールには名前があります。サブパッケージ名は、 Python の標準の属性アクセスの構文に似て、親パッケージ名とドットで区切られています。したがって、 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> と呼ばれるモジュールや <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal"><span class="pre">email</span></code></a> と呼ばれるパッケージを見掛けることがあるでしょう。その中には <a class="reference internal" href="../library/email.mime.html#module-email.mime" title="email.mime: Build MIME messages."><code class="xref py py-mod docutils literal"><span class="pre">email.mime</span></code></a> と呼ばれるサブパッケージと、そのサブパッケージの中に <code class="xref py py-mod docutils literal"><span class="pre">email.mime.text</span></code> と呼ばれるモジュールがあります。</p>
<div class="section" id="regular-packages">
<h3>5.2.1. 通常のパッケージ<a class="headerlink" href="#regular-packages" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-4">Python では、 <a class="reference internal" href="../glossary.html#term-regular-package"><span class="xref std std-term">通常のパッケージ</span></a> と <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">名前空間パッケージ</span></a> の 2 種類のパッケージが定義されています。通常のパッケージは Python 3.2 以前から存在する伝統的なパッケージです。典型的な通常のパッケージは <code class="docutils literal"><span class="pre">__init__.py</span></code> ファイルを含むディレクトリとして実装されます。通常のパッケージがインポートされたとき、この <code class="docutils literal"><span class="pre">__init__.py</span></code> ファイルが暗黙的に実行され、それで定義しているオブジェクトがパッケージ名前空間にある名前に束縛されます。 <code class="docutils literal"><span class="pre">__init__.py</span></code> ファイルは、他のモジュールに書ける Python コードと同じものを含むことができ、モジュールがインポートされたときに Python はモジュールに属性を追加したりします。</p>
<p>例えば、以下のようなファイルシステム配置は、3 つのサブパッケージを持つ最上位の <code class="docutils literal"><span class="pre">parent</span></code> パッケージを定義します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">parent</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">one</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">two</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">three</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">parent.one</span></code> をインポートすると暗黙的に <code class="docutils literal"><span class="pre">parent/__init__.py</span></code> と <code class="docutils literal"><span class="pre">parent/one/__init__.py</span></code> が実行されます。その後に <code class="docutils literal"><span class="pre">parent.two</span></code> もしくは <code class="docutils literal"><span class="pre">parent.three</span></code> をインポートすると、それぞれ <code class="docutils literal"><span class="pre">parent/two/__init__.py</span></code> や <code class="docutils literal"><span class="pre">parent/three/__init__.py</span></code> が実行されます。</p>
</div>
<div class="section" id="namespace-packages">
<h3>5.2.2. 名前空間パッケージ<a class="headerlink" href="#namespace-packages" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-5">名前空間パッケージは様々な <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">ポーション</span></a> を寄せ集めたもので、それぞれのポーションはサブパッケージを親パッケージに提供します。ポーションはファイルシステムの別々の場所にあることもあります。ポーションは、 zip ファイルの中やネットワーク上や、それ以外のインポート時に Python が探すどこかの場所で見つかることもあります。名前空間パッケージはファイルシステム上のオブジェクトに対応することもあるし、そうでないこともあります; それらは実際の実体のない仮想モジュールです。</p>
<p>名前空間パッケージは、  <code class="docutils literal"><span class="pre">__path__</span></code> 属性に普通のリストは使いません。その代わりに独自の iterable 型を使っていて、ポーションの親パッケージのパス (もしくは最上位パッケージのための <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a>) が変わった場合、そのパッケージでの次のインポートの際に、新たに自動でパッケージポーションを検索します。</p>
<p>名前空間パッケージには <code class="docutils literal"><span class="pre">parent/__init__.py</span></code> ファイルはありません。それどころか、異なるポーションがそれぞれ提供する複数の <code class="docutils literal"><span class="pre">parent</span></code> ディレクトリがインポート検索の際に見つかることもあります。したがって <code class="docutils literal"><span class="pre">parent/one</span></code> は物理的に <code class="docutils literal"><span class="pre">parent/two</span></code> の隣りにあるとは限りません。その場合、そのパッケージかサブパッケージのうち 1 つがインポートされたとき、Python は最上位の <code class="docutils literal"><span class="pre">parent</span></code> パッケージのための名前空間パッケージを作成します。</p>
<p>名前空間パッケージの仕様については <span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> も参照してください。</p>
</div>
</div>
<div class="section" id="searching">
<h2>5.3. 検索<a class="headerlink" href="#searching" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>検索を始めるためには、 Python はインポートされるモジュール (もしくはパッケージですが、ここでの議論の目的においてはささいな違いです) の <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">完全修飾</span></a> 名を必要とします。この名前は、 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文の様々な引数や <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> および <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 関数のパラメータから得られます。</p>
<p>This name will be used in various phases of the import search, and it may be
the dotted path to a submodule, e.g. <code class="docutils literal"><span class="pre">foo.bar.baz</span></code>.  In this case, Python
first tries to import <code class="docutils literal"><span class="pre">foo</span></code>, then <code class="docutils literal"><span class="pre">foo.bar</span></code>, and finally <code class="docutils literal"><span class="pre">foo.bar.baz</span></code>.
If any of the intermediate imports fail, a <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">ModuleNotFoundError</span></code></a> is raised.</p>
<div class="section" id="the-module-cache">
<h3>5.3.1. モジュールキャッシュ<a class="headerlink" href="#the-module-cache" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-7">インポート検索で最初に調べる場所は <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> です。このマッピングは、中間のパスを含む、これまでにインポートされたすべてのモジュールのキャッシュを提供します。なので <code class="docutils literal"><span class="pre">foo.bar.baz</span></code> がインポート済みの場合、 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> は <code class="docutils literal"><span class="pre">foo</span></code> 、 <code class="docutils literal"><span class="pre">foo.bar</span></code> 、 <code class="docutils literal"><span class="pre">foo.bar.baz</span></code> のエントリーを含みます。それぞれのキーはその値として対応するモジュールオブジェクトを持ちます。</p>
<p>During import, the module name is looked up in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> and if
present, the associated value is the module satisfying the import, and the
process completes.  However, if the value is <code class="docutils literal"><span class="pre">None</span></code>, then a
<a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">ModuleNotFoundError</span></code></a> is raised.  If the module name is missing, Python will
continue searching for the module.</p>
<p><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> is writable.  Deleting a key may not destroy the
associated module (as other modules may hold references to it),
but it will invalidate the cache entry for the named module, causing
Python to search anew for the named module upon its next
import. The key can also be assigned to <code class="docutils literal"><span class="pre">None</span></code>, forcing the next import
of the module to result in a <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">ModuleNotFoundError</span></code></a>.</p>
<p>たとえモジュールオブジェクトへの参照を保持しておいて、 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> にキャッシュされたエントリーを無効にし、その指定したモジュールを再インポートしたとしても、 2 つのモジュールオブジェクトは同じでは <em>ない</em> ことに注意してください。それとは対照的に、 <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal"><span class="pre">importlib.reload()</span></code></a> は <em>同じ</em> モジュールオブジェクトを再利用し、モジュールのコードを再実行することで単にモジュールの内容を再初期化するだけです。</p>
</div>
<div class="section" id="finders-and-loaders">
<h3>5.3.2. ファインダーとローダー<a class="headerlink" href="#finders-and-loaders" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-8"><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に指定されたモジュールが見つからなかった場合は、 Python のインポートプロトコルが起動され、モジュールを見つけロードします。このプロトコルは 2 つの概念的なオブジェクト、 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">ファインダー</span></a> と <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">ローダー</span></a> から成ります。ファインダーの仕事は、知っている戦略を使って指定されたモジュールを見つけられるかどうか判断することです。両方のインターフェースを実装しているオブジェクトは <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">インポーター</span></a> と呼ばれます - インポーターは要求されたモジュールがロードできると分かったとき、自分自身を返します。</p>
<p>Python にはデフォルトのファインダーとインポーターがいくつかあります。 1 つ目のものは組み込みモジュールの見つけ方を知っていて、 2 つ目のものは凍結されたモジュール (訳注: freeze ツールで処理されたモジュールのこと。 <a class="reference internal" href="../faq/programming.html"><span class="doc">プログラミング FAQ</span></a> の「どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？」の項目を参照) の見つけ方を知っています。 3 つ目のものは <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">インポートパス</span></a> からモジュールを探します。 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">インポートパス</span></a> はファイルシステムのパスや zip ファイルの位置を示すリストです。このリストは、 URL で特定できるもののような、位置を示すことのできる任意のリソースの検索にまで拡張することもできます。</p>
<p>インポート機構は拡張可能なので、モジュール検索の範囲とスコープを拡張するために新しいファインダーを付け加えることができます。</p>
<p>ファインダーは実際にはモジュールをロードしません。指定されたモジュールが見つかった場合、ファインダーは <em class="dfn">module spec</em> (モジュール仕様)、すなわちモジュールのインポート関連の情報をカプセル化したものを返します。モジュールのロード時にインポート機構はそれを利用します。</p>
<p>次の節では、インポート機構を拡張するための新しいファインダーやローダーの作成と登録を含め、ファインダーとローダーのプロトコルについてより詳しく解説します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Python の以前のバージョンでは、ファインダーは直接 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">ローダー</span></a> を返していましたが、現在はローダーを <em>含む</em> モジュール仕様を返します。ローダーはインポート中はまだ使われていますが、責任は減りました。</p>
</div>
</div>
<div class="section" id="import-hooks">
<h3>5.3.3. インポートフック<a class="headerlink" href="#import-hooks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-9">インポート機構は拡張可能なように設計されています; その主となる仕組みは <em>インポートフック</em> です。インポートフックには 2 種類あります: <em>メタフック</em> と <em>インポートパスフック</em> です。</p>
<p>メタフックはインポート処理の最初、 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> キャッシュの検索以外のインポート処理より前に呼び出されます。これにより、 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> の処理や凍結されたモジュールや組み込みのモジュールでさえも、メタフックで上書きすることができます。メタフックは以下で解説するように、 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> に新しいファインダーオブジェクトを追加することで登録されます。</p>
<p>インポートパスフックは、 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> (もしくは <code class="docutils literal"><span class="pre">package.__path__</span></code>) の処理の一部として、対応するパス要素を取り扱うところで呼び出されます。インポートパスフックは以下で解説するように、新しい呼び出し可能オブジェクトを <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> に追加することで登録されます。</p>
</div>
<div class="section" id="the-meta-path">
<h3>5.3.4. メタパス<a class="headerlink" href="#the-meta-path" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-10">指定されたモジュールが <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に見つからなかったとき、 Python は次にメタパス・ファインダー・オブジェクトが格納されている <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> を検索します。指定されたモジュールを扱うことができるかどうかを調べるために、各ファインダーに問い合わせを行います。メタパス・ファインダーには、名前とインポートパスと (オプションの) ターゲットモジュールの 3 つの引数を取る <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> という名前のメソッドが実装されていなければいけません。メタパス・ファインダーでは、指定されたモジュールを扱えるかどうかを判定するための戦略は任意のものを使って構いません。</p>
<p>If the meta path finder knows how to handle the named module, it returns a
spec object.  If it cannot handle the named module, it returns <code class="docutils literal"><span class="pre">None</span></code>.  If
<a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> processing reaches the end of its list without returning
a spec, then a <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">ModuleNotFoundError</span></code></a> is raised.  Any other exceptions
raised are simply propagated up, aborting the import process.</p>
<p>The <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> method of meta path
finders is called with two or three arguments.  The first is the fully
qualified name of the module being imported, for example <code class="docutils literal"><span class="pre">foo.bar.baz</span></code>.
The second argument is the path entries to use for the module search.  For
top-level modules, the second argument is <code class="docutils literal"><span class="pre">None</span></code>, but for submodules or
subpackages, the second argument is the value of the parent package’s
<code class="docutils literal"><span class="pre">__path__</span></code> attribute. If the appropriate <code class="docutils literal"><span class="pre">__path__</span></code> attribute cannot
be accessed, a <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">ModuleNotFoundError</span></code></a> is raised.  The third argument
is an existing module object that will be the target of loading later.
The import system passes in a target module only during reload.</p>
<p>メタパスは、1 回のインポート要求で複数回走査される可能性があります。例えば、関係するモジュールがどれもまだキャッシュされていないとしたときに <code class="docutils literal"><span class="pre">foo.bar.baz</span></code> をインポートすると、最初は各メタパス・ファインダー (<code class="docutils literal"><span class="pre">mpf</span></code>) に対して <code class="docutils literal"><span class="pre">mpf.find_spec(&quot;foo&quot;,</span> <span class="pre">None,</span> <span class="pre">None)</span></code> を呼び出して、最上位のインポート処理を行います。<code class="docutils literal"><span class="pre">foo</span></code> がインポートされた後に、<code class="docutils literal"><span class="pre">mpf.find_spec(&quot;foo.bar&quot;,</span> <span class="pre">foo.__path__,</span> <span class="pre">None)</span></code> を呼び出していく 2 回目のメタパスの走査が行われ、<code class="docutils literal"><span class="pre">foo.bar</span></code> がインポートされます。<code class="docutils literal"><span class="pre">foo.bar</span></code> のインポートまで行われたら、最後の走査で <code class="docutils literal"><span class="pre">mpf.find_spec(&quot;foo.bar.baz&quot;,</span> <span class="pre">foo.bar.__path__,</span> <span class="pre">None)</span></code> を呼び出していきます。</p>
<p>あるメタパス・ファインダーは最上位のインポートのみサポートしています。これらのインポーターは、2 つ目の引数に <code class="docutils literal"><span class="pre">None</span></code> 以外のものが渡されたとき、常に <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>Python のデフォルトの <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> は 3 つのパスファインダーを持っています。組み込みモジュールのインポートの方法を知っているもの、凍結されたモジュールのインポートの方法を知っているもの、 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">インポートパス</span></a> からのモジュールのインポートの方法を知っているもの (つまり <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">パスベース・ファインダー</span></a>) があります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>メタパス・ファインダーの <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> メソッドは <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_module" title="importlib.abc.MetaPathFinder.find_module"><code class="xref py py-meth docutils literal"><span class="pre">find_module()</span></code></a> を置き換えました。 <code class="docutils literal"><span class="pre">find_module()</span></code> メソッドは deprecated です。それは今でも変更なしに動きますが、インポート機構はファインダーが <code class="docutils literal"><span class="pre">find_spec()</span></code> を実装していない場合にのみそれを試します。</p>
</div>
</div>
</div>
<div class="section" id="loading">
<h2>5.4. ロード<a class="headerlink" href="#loading" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>モジュール仕様が見つかった場合、インポート機構はモジュールをロードする時にそれ (およびそれに含まれるローダー) を使います。これは、インポートのロード部分で起こることの近似です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;create_module&#39;</span><span class="p">):</span>
    <span class="c1"># It is assumed &#39;exec_module&#39; will also be defined on the loader.</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">create_module</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">ModuleType</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># The import-related module attributes get set here:</span>
<span class="n">_init_module_attrs</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>

<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># namespace package</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># unsupported</span>
        <span class="k">raise</span> <span class="ne">ImportError</span>
<span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;exec_module&#39;</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="c1"># Set __loader__ and __package__ if missing.</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">raise</span>
<span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>以下の詳細に注意してください:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> の中に与えられた名前を持つ既存のモジュールオブジェクトがあるなら、 import は既にそれを返しているでしょう。</li>
<li>モジュールは、ローダーがモジュールコードを実行する前に <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に存在しています。 モジュールコードが (直接的または間接的に) 自分自身をインポートする可能性があるので、これは重要です; モジュールを <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に追加することで、最悪のケースでは無限の再帰が、そして最良のケースでは複数回のロードが、前もって防止されます。</li>
<li>ロード処理に失敗した場合、その失敗したモジュールは – そして、そのモジュールだけが – <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> から取り除かれます。 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> キャッシュに既に含まれていたすべてのモジュールと、副作用としてロードに成功したすべてのモジュールは、常にキャッシュに残されます。これはリロードとは対照的で、リロードの場合は失敗したモジュールも <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に残されます。</li>
<li><a class="reference internal" href="#import-mod-attrs"><span class="std std-ref">後のセクション</span></a> で要約されるように、モジュールが作られてから実行されるまでの間にインポート機構はインポート関連のモジュール属性を設定します (上記擬似コード例の &quot;_init_module_attrs&quot;)。</li>
<li>モジュール実行はモジュールの名前空間が構築されるロードの重要な瞬間です。実行はローダーに完全に委任され、ローダーは何をどのように構築するかを決定することになります。</li>
<li>ロードの間に作成されて exec_module() に渡されたモジュールは、インポートの終わりに返されるものとは異なるかもしれません <a class="footnote-reference" href="#fnlo" id="id2">[2]</a>。</li>
</ul>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>インポートシステムはローダーの定型的な責任を引き継ぎました。これらは以前は <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> メソッドによって実行されました。</p>
</div>
<div class="section" id="loaders">
<h3>5.4.1. ローダー<a class="headerlink" href="#loaders" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールローダーは、ロードの重要な機能であるモジュール実行機能を提供します。インポート機構は、実行しようとするモジュールオブジェクトを単一の引数として <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> メソッドを呼び出します。 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> から返された任意の値は無視されます。</p>
<p>ローダーは以下の仕様を満たしていなければいけません:</p>
<blockquote>
<div><ul class="simple">
<li>モジュールが (組み込みモジュールや動的に読み込まれる拡張モジュールではなくて) Python モジュールだった場合、ローダーはモジュールのグローバル名前空間 (<code class="docutils literal"><span class="pre">module.__dict__</span></code>) で、モジュールのコードを実行すべきです。</li>
<li><a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a> の呼び出し中に <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> 以外の例外が送出され、伝播されてきたとしても、モジュールをロードできない場合は <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出すべきです。</li>
</ul>
</div></blockquote>
<p>多くの場合、ファインダーとローダーは同じオブジェクトで構いません; そのような場合では <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> メソッドは単に <code class="docutils literal"><span class="pre">self</span></code> (訳注: オブジェクト自身) を返すだけです。</p>
<p>モジュールローダーは、 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal"><span class="pre">create_module()</span></code></a> メソッドを実装することでロード中にモジュールオブジェクトを作成することを選択できます。このメソッドは、モジュール仕様を引数に取って、ロード中に使う新しいモジュールオブジェクトを返します。 <code class="docutils literal"><span class="pre">create_module()</span></code> はモジュールオブジェクトに属性を設定する必要はありません。もしこのメソッドが <code class="docutils literal"><span class="pre">None</span></code> を返すなら、インポート機構は新しいモジュールを自身で作成します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加: </span>The <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal"><span class="pre">create_module()</span></code></a> method of loaders.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">load_module()</span></code></a> メソッドは <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a> によって置き換えられ、インポート機構がロードのすべての定型責任を引き受けました。</p>
<p>既存のローダーとの互換性のため、もしローダーに <code class="docutils literal"><span class="pre">load_module()</span></code> メソッドが存在し、かつローダーが <code class="docutils literal"><span class="pre">exec_module()</span></code> を実装していなければ、インポート機構はローダーの <code class="docutils literal"><span class="pre">load_module()</span></code> メソッドを使います。しかし、 <code class="docutils literal"><span class="pre">load_module()</span></code> は deprecated であり、ローダーは代わりに <code class="docutils literal"><span class="pre">exec_module()</span></code> を実装すべきです。</p>
<p><code class="docutils literal"><span class="pre">load_module()</span></code> メソッドは、モジュールを実行することに加えて上記で説明されたすべての定型的なロード機能を実施しなければなりません。同じ制約が適用されます。以下は追加の明確化です:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に与えられた名前のモジュールが存在している場合、ローダーはその既存のモジュールを使わなければいけません。 (そうしないと <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal"><span class="pre">importlib.reload()</span></code></a> は正しく動かないでしょう。) 指定されたモジュールが <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に存在しない場合、ローダーは新しいモジュールオブジェクトを作成し、 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に追加しなければいけません。</li>
<li>無限の再帰または複数回のロードを防止するために、ローダーがモジュールコードを実行する前にモジュールは <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に存在しなければなりません (<em>must</em>)。</li>
<li>ロード処理に失敗した場合、ローダーは <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に追加したモジュールを取り除かなければいけませんが、それはロードに失敗したモジュール <strong>のみ</strong> を、そのモジュールがローダー自身に明示的にロードされた場合に限り、除去しなければなりません。</li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>A <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a> is raised when <code class="docutils literal"><span class="pre">exec_module()</span></code> is defined but
<code class="docutils literal"><span class="pre">create_module()</span></code> is not.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>An <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> is raised when <code class="docutils literal"><span class="pre">exec_module()</span></code> is defined but
<code class="docutils literal"><span class="pre">create_module()</span></code> is not.</p>
</div>
</div>
<div class="section" id="submodules">
<h3>5.4.2. サブモジュール<a class="headerlink" href="#submodules" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サブモジュールをロードするのにどのようなメカニズム (例えば、 <code class="docutils literal"><span class="pre">importlib</span></code> API 、 <code class="docutils literal"><span class="pre">import</span></code> または <code class="docutils literal"><span class="pre">import-from</span></code> ステートメント、またはビルトイン関数の <code class="docutils literal"><span class="pre">__import__</span></code>) が使われた場合でも、バインディングはサブモジュールオブジェクトを親モジュールの名前空間に配置します。例えば、もしパッケージ <code class="docutils literal"><span class="pre">spam</span></code> がサブモジュール <code class="docutils literal"><span class="pre">foo</span></code> を持っていた場合、 <code class="docutils literal"><span class="pre">spam.foo</span></code> をインポートした後は <code class="docutils literal"><span class="pre">spam</span></code> は値がサブモジュールに束縛された属性 <code class="docutils literal"><span class="pre">foo</span></code> を持ちます。以下のディレクトリ構造を持っているとしましょう:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">spam</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">py</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>そして <code class="docutils literal"><span class="pre">spam/__init__.py</span></code> は以下のようになっているとします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.foo</span> <span class="k">import</span> <span class="n">Foo</span>
<span class="kn">from</span> <span class="nn">.bar</span> <span class="k">import</span> <span class="n">Bar</span>
</pre></div>
</div>
<p>このとき、以下を実行することにより <code class="docutils literal"><span class="pre">spam</span></code> モジュールの中に <code class="docutils literal"><span class="pre">foo</span></code> と <code class="docutils literal"><span class="pre">bar</span></code> に束縛された名前が置かれます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;module &#39;spam.foo&#39; from &#39;/tmp/imports/spam/foo.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">bar</span>
<span class="go">&lt;module &#39;spam.bar&#39; from &#39;/tmp/imports/spam/bar.py&#39;&gt;</span>
</pre></div>
</div>
<p>Python の慣れ親しんだ名前束縛ルールからするとこれは驚きかもしれませんが、それは実際インポートシステムの基本的な機能です。不変に保たなければならないのは (上記のインポートの後などで) <code class="docutils literal"><span class="pre">sys.modules['spam']</span></code> と <code class="docutils literal"><span class="pre">sys.modules['spam.foo']</span></code> が存在する場合、後者が前者の <code class="docutils literal"><span class="pre">foo</span></code> 属性として存在しなければならないということです。</p>
</div>
<div class="section" id="module-spec">
<h3>5.4.3. モジュール仕様<a class="headerlink" href="#module-spec" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>インポート機構は、インポートの間 (特にロードの前) に、個々のモジュールについてのさまざまな情報を扱います。情報のほとんどはすべてのモジュールで共通です。モジュール仕様の目的は、このインポート関連の情報をモジュールの単位でカプセル化することです。</p>
<p>インポートの際にモジュール仕様を使うことは、インポートシステムコンポーネント間、例えばモジュール仕様を作成するファインダーとそれを実行するローダーの間で状態を転送することを可能にします。最も重要なのは、それによってインポート機構がロードの定型的な作業を実行できるようになるということです。これに対して、モジュール仕様なしではローダがその責任を担っていました。</p>
<p>The module’s spec is exposed as the <code class="docutils literal"><span class="pre">__spec__</span></code> attribute on a module object.
See <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal"><span class="pre">ModuleSpec</span></code></a> for details on the contents of
the module spec.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</div>
<div class="section" id="import-related-module-attributes">
<span id="import-mod-attrs"></span><h3>5.4.4. インポート関連のモジュール属性<a class="headerlink" href="#import-related-module-attributes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>インポート機構はロードの間、モジュールの仕様に基づいて、ローダーがモジュールが実行する前に以下の属性を書き込みます。</p>
<dl class="attribute">
<dt id="__name__">
<code class="descname">__name__</code><a class="headerlink" href="#__name__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">__name__</span></code> 属性はモジュールの完全修飾名に設定されなければなりません。この名前を利用してインポートシステムでモジュールを一意に識別します。</p>
</dd></dl>

<dl class="attribute">
<dt id="__loader__">
<code class="descname">__loader__</code><a class="headerlink" href="#__loader__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">__loader__</span></code> 属性はモジュールロード時にインポート機構が使用したローダーオブジェクトに設定されなければなりません。この属性は普通は内省用のものですが、ローダー固有の追加機能のために用いることが出来ます。例えばローダー関連のデータの取得です。</p>
</dd></dl>

<dl class="attribute">
<dt id="__package__">
<code class="descname">__package__</code><a class="headerlink" href="#__package__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールの <code class="docutils literal"><span class="pre">__package__</span></code> 属性は設定されなければなりません。値は文字列でなければなりませんが、<code class="docutils literal"><span class="pre">__name__</span></code> と同じ値でも構いません。モジュールがパッケージの場合、<code class="docutils literal"><span class="pre">__package__</span></code> の値はその <code class="docutils literal"><span class="pre">__name__</span></code> でなければなりません。モジュールがパッケージでない場合、トップレベルのモジュールでは <code class="docutils literal"><span class="pre">__package__</span></code> 空の文字列、サブモジュールでは親のパッケージ名でなければなりません。詳細は <span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> を参照してください。</p>
<p>This attribute is used instead of <code class="docutils literal"><span class="pre">__name__</span></code> to calculate explicit
relative imports for main modules, as defined in <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a>. It is
expected to have the same value as <code class="docutils literal"><span class="pre">__spec__.parent</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>The value of <code class="docutils literal"><span class="pre">__package__</span></code> is expected to be the same as
<code class="docutils literal"><span class="pre">__spec__.parent</span></code>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="__spec__">
<code class="descname">__spec__</code><a class="headerlink" href="#__spec__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">__spec__</span></code> attribute must be set to the module spec that was
used when importing the module. Setting <code class="docutils literal"><span class="pre">__spec__</span></code>
appropriately applies equally to <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">modules initialized during
interpreter startup</span></a>.  The one exception is <code class="docutils literal"><span class="pre">__main__</span></code>,
where <code class="docutils literal"><span class="pre">__spec__</span></code> is <a class="reference internal" href="#main-spec"><span class="std std-ref">set to None in some cases</span></a>.</p>
<p>When <code class="docutils literal"><span class="pre">__package__</span></code> is not defined, <code class="docutils literal"><span class="pre">__spec__.parent</span></code> is used as
a fallback.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span><code class="docutils literal"><span class="pre">__spec__.parent</span></code> is used as a fallback when <code class="docutils literal"><span class="pre">__package__</span></code> is
not defined.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="__path__">
<code class="descname">__path__</code><a class="headerlink" href="#__path__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールが (通常のまたは名前空間) パッケージの場合、モジュールオブジェクトの  <code class="docutils literal"><span class="pre">__path__</span></code> 属性が設定される必要があります。値はイテレート可能でなければなりませんが、<code class="docutils literal"><span class="pre">__path__</span></code> に意味がない場合は空でも構いません。<code class="docutils literal"><span class="pre">__path__</span></code> が空でない場合、イテレート時に文字列を生成しなければなりません。<code class="docutils literal"><span class="pre">__path__</span></code> のセマンティクスの詳細は  <a class="reference internal" href="#package-path-rules"><span class="std std-ref">下記</span></a> の通りです。</p>
<p>パッケージでないモジュールは <code class="docutils literal"><span class="pre">__path__</span></code> 属性を持ってはいけません。</p>
</dd></dl>

<dl class="attribute">
<dt id="__file__">
<code class="descname">__file__</code><a class="headerlink" href="#__file__" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="__cached__">
<code class="descname">__cached__</code><a class="headerlink" href="#__cached__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">__file__</span></code> はオプションです。もし設定されるならば、この属性の値は文字列でなければなりません。もしそのような属性が意味を持たない場合 (例えばモジュールがデータベースからロードされた場合) インポートシステムは <code class="docutils literal"><span class="pre">__file__</span></code> を未設定のままにしても構いません。</p>
<p>もし <code class="docutils literal"><span class="pre">__file__</span></code> を設定するなら、 <code class="docutils literal"><span class="pre">__cached__</span></code> 属性もコードのコンパイルされたバージョンのどれか (例えば、バイトコンパイルされたファイル) へのパスに設定することが適切でしょう。この属性を設定するにあたってファイルが存在する必要はありません; パスは、単にコンパイルされたファイルが存在するかもしれない場所を示しているだけです (<span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> を参照)。</p>
<p><code class="docutils literal"><span class="pre">__file__</span></code> が設定されない場合にも <code class="docutils literal"><span class="pre">__cached__</span></code> を設定することは適切です。しかし、そのシナリオはかなり変則的です。究極的には、ローダーとは <code class="docutils literal"><span class="pre">__file__</span></code> と <code class="docutils literal"><span class="pre">__cached__</span></code> のどちらかまたは両方を利用するものです。したがって、もしローダーがキャッシュされたモジュールからロードする一方でファイルからはロードしないなら、その変則的なシナリオは適切でしょう。</p>
</dd></dl>

</div>
<div class="section" id="module-path">
<span id="package-path-rules"></span><h3>5.4.5. module.__path__<a class="headerlink" href="#module-path" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By definition, if a module has a <code class="docutils literal"><span class="pre">__path__</span></code> attribute, it is a package,
regardless of its value.</p>
<p>パッケージの <code class="docutils literal"><span class="pre">__path__</span></code> 属性は、そのサブパッケージのインポート中に使われます。インポート機構の内部では、それは <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> とほとんど同じように機能します。つまり、インポート中にモジュールを探す場所のリストを提供します。しかし、一般的に <code class="docutils literal"><span class="pre">__path__</span></code> は <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> よりも制約が強いです。</p>
<p><code class="docutils literal"><span class="pre">__path__</span></code> は文字列の iterable でなければいけませんが、空でも構いません。 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> と同じ規則がパッケージの <code class="docutils literal"><span class="pre">__path__</span></code> にも適用され、パッケージの <code class="docutils literal"><span class="pre">__path__</span></code> を走査するときに (後で解説する) <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> が考慮に入れられます。</p>
<p>パッケージの <code class="docutils literal"><span class="pre">__init__.py</span></code> ファイルは、パッケージの <code class="docutils literal"><span class="pre">__path__</span></code> 属性を設定もしくは変更することがあり、これが <span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 以前の名前空間パッケージの典型的な実装方法でした。 <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> の採択により、もはや名前空間パッケージは、 <code class="docutils literal"><span class="pre">__path__</span></code> を操作するコードだけを含む <code class="docutils literal"><span class="pre">__init__.py</span></code> ファイルを提供する必要がなくなりました;インポート機構は、名前空間パッケージに対し自動的に適切な <code class="docutils literal"><span class="pre">__path__</span></code> をセットします。</p>
</div>
<div class="section" id="module-reprs">
<h3>5.4.6. モジュールの repr<a class="headerlink" href="#module-reprs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>デフォルトでは、すべてのモジュールは利用可能な repr を持っています。ただしこれは上位で設定された属性に依存しており、モジュール仕様によってモジュールオブジェクトの repr をより明示的に制御することができます。</p>
<p>もしモジュールが仕様 (<code class="docutils literal"><span class="pre">__spec__</span></code>) を持っていれば、インポート機構はそこから repr を生成しようとします。もしそれが失敗するか、または仕様が存在しなければ、インポートシステムはモジュールで入手可能なあらゆる情報を使ってデフォルトの repr を構築します。それは <code class="docutils literal"><span class="pre">module.__name__</span></code>, <code class="docutils literal"><span class="pre">module.__file__</span></code>, <code class="docutils literal"><span class="pre">module.__loader__</span></code> を (足りない情報についてはデフォルト値を使って補いながら) repr への入力として使おうと試みます。</p>
<p>これが使われている正確な規則です:</p>
<blockquote>
<div><ul class="simple">
<li>モジュールが <code class="docutils literal"><span class="pre">__spec__</span></code> 属性を持っていれば、仕様に含まれる情報が repr を生成するために使われます。 &quot;name&quot;, &quot;loader&quot;, &quot;origin&quot;, &quot;has_location&quot; 属性が参照されます。</li>
<li>モジュールに <code class="docutils literal"><span class="pre">__file__</span></code> 属性がある場合は、モジュールの repr の一部として使われます。</li>
<li>モジュールに <code class="docutils literal"><span class="pre">__file__</span></code> はないが <code class="docutils literal"><span class="pre">__loader__</span></code> があり、その値が <code class="docutils literal"><span class="pre">None</span></code> ではない場合は、ローダーの repr がモジュールの repr の一部として使われます。</li>
<li>そうでなければ、単にモジュールの <code class="docutils literal"><span class="pre">__name__</span></code> を repr の中で使います。</li>
</ul>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.module_repr" title="importlib.abc.Loader.module_repr"><code class="xref py py-meth docutils literal"><span class="pre">loader.module_repr()</span></code></a> の使用は deprecated です。インポート機構によりモジュール仕様がモジュール repr を生成するために使用されるようになりました。</p>
<p>Python 3.3 との後方互換性のために、ローダーの <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.module_repr" title="importlib.abc.Loader.module_repr"><code class="xref py py-meth docutils literal"><span class="pre">module_repr()</span></code></a> メソッドが定義されていたら、モジュール repr を生成するために上記のいずれかのアプローチを試す前にそのメソッドが呼ばれます。ただし、このメソッドは deprecated です。</p>
</div>
</div>
</div>
<div class="section" id="the-path-based-finder">
<h2>5.5. パスベース・ファインダー<a class="headerlink" href="#the-path-based-finder" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-16">上で触れた通り、 Python にはいくつかのデフォルトのメタパス・ファインダーが備わっています。そのうちの 1 つは <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">パスベース・ファインダー</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal"><span class="pre">PathFinder</span></code></a>) と呼ばれ、 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">パスエントリ</span></a> のリストである <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">インポートパス</span></a> を検索します。それぞれのパスエントリは、モジュールを探す場所を指しています。</p>
<p>パスベース・ファインダー自体は何かのインポート方法を知っているわけではありません。その代わりに、個々のパスエントリを走査し、それぞれに特定の種類のパスの扱いを知っているパスエントリ・ファインダーを関連付けます。</p>
<p>デフォルトのパスエントリ・ファインダーは、ファイルシステム上のモジュールを見つけるためのすべてのセマンティクスを実装しています。それは Python ソースコード (<code class="docutils literal"><span class="pre">.py</span></code> ファイル) 、Python バイトコード (<code class="docutils literal"><span class="pre">.pyc</span></code> ファイル) 、共有ライブラリ (例えば <code class="docutils literal"><span class="pre">.so</span></code> ファイル) などの特別なファイルタイプを処理します。標準ライブラリの <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal"><span class="pre">zipimport</span></code></a> モジュールによってサポートされる場合は、デフォルトのパスエントリ・ファインダーは (共有ライブラリ以外の) すべてのファイルタイプの zip ファイルからのロードも扱います。</p>
<p>パスエントリはファイルシステム上の場所に限定される必要はありません。URL やデータベースクエリやその他文字列で指定できる場所を参照することも可能です。</p>
<p>パスベース・ファインダーにはフックやプロトコルを追加することができ、それによって検索可能なパスエントリの種類を拡張し、カスタマイズすることができます。例えば、ネットワーク上の URL をパスエントリとしてサポートしたい場合、 web 上のモジュールを見つけるために HTTP の取り扱い方を実装したフックを書くことができます。この (呼び出し可能オブジェクトである) フックは、下で解説するプロトコルをサポートする <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">パスエントリ・ファインダー</span></a> を返します。このプロトコルは  web からモジュールのローダーを取得するのに使われます。</p>
<p>警告の言葉: この節と前の節の両方で <em>ファインダー</em> という言葉が、 <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">メタパス・ファインダー</span></a> と <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">パスエントリ・ファインダー</span></a> という用語で区別されて使われています。これら 2 種類のファインダーは非常に似ており、似たプロトコルをサポートし、インポート処理で同じように機能しますが、微妙に異なっているのを心に留めておくのは重要です。特に、メタパス・ファインダーはインポート処理の開始時、 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> の走査が動くときに動作します。</p>
<p>それとは対照的に、パスエントリ・ファインダーはある意味でパスベース・ファインダーの実装詳細であり、実際 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> からパスベース・ファインダーが取り除かれた場合、パスエントリ・ファインダーの実装は何も実行されないでしょう。</p>
<div class="section" id="path-entry-finders">
<h3>5.5.1. パスエントリ・ファインダー<a class="headerlink" href="#path-entry-finders" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-17"><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">パスベース・ファインダー</span></a> には、文字列 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">パスエントリ</span></a> で指定された場所の Python モジュールや Python パッケージを見つけ、ロードする責任があります。ほとんどのパスエントリはファイルシステム上の場所を指定していますが、そこに制限される必要はありません。</p>
<p>メタパス・ファインダーとして、 <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">パスベース・ファインダー</span></a> には前に解説した <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> プロトコルが実装されていますが、これに加えて <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">インポートパス</span></a> からモジュールを見つけ、ロードする方法をカスタマイズするために使えるフックを提供しています。</p>
<p><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">パスベース・ファインダー</span></a> は <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> 、 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> 、 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> という 3 つの変数を使います。さらにパッケージオブジェクトの <code class="docutils literal"><span class="pre">__path__</span></code> 属性も使います。これらによって、インポート処理をカスタマイズする方法が提供されます。</p>
<p><a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> には、モジュールとパッケージを探す場所文字列の一覧があります。これは <code class="xref py py-data docutils literal"><span class="pre">PYTHONPATH</span></code> 環境変数とその他様々なインストール方法や実装に依存するデフォルト値で初期化されます。 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> 内の要素は、ファイルシステム上のディレクトリや zip ファイルやその他モジュールを探すべき &quot;場所&quot; となりうるもの (<a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> モジュールを参照) を指すことができます。文字列およびバイト列のみを <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> に入れるべきです; 他のデータ型は無視されます。バイト列の要素のエンコーディングは、各 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">パスエントリ・ファインダー</span></a> によって判別されます。</p>
<p><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">パスベース・ファインダー</span></a> は <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">メタパス・ファインダー</span></a> なので、インポート機構は、前で解説したパスベース・ファインダーの <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>  メソッドを呼び出すことで <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">インポートパス</span></a> の検索を始めます。 <code class="docutils literal"><span class="pre">path</span></code> 引数が <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> に渡されたときは、それは走査するパス文字列のリスト - 典型的にはそのパッケージの中でインポートしているパッケージの <code class="docutils literal"><span class="pre">__path__</span></code> 属性になります。 <code class="docutils literal"><span class="pre">path</span></code> 引数が <code class="docutils literal"><span class="pre">None</span></code> だった場合、それは最上位のインポートであることを示していて、 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> が使われます。</p>
<p>パスベース・ファインダーは検索パスのすべての要素について反復処理をし、それぞれのパスに対して適切な <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">パスエントリ・ファインダー</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal"><span class="pre">PathEntryFinder</span></code></a>) を探します。これは時間のかかる処理 (例えば、この検索のための <cite>stat()</cite> 呼び出しのオーバーヘッド) になり得るので、パスベース・ファインダーはパス要素からパスエントリ・ファインダーへの対応付けをキャッシュとして持っておきます。このキャッシュは <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> に持っています (名前に反して、このキャッシュは実際には <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">インポーター</span></a> には制限されておらず、ファインダーオブジェクトを保持します) 。このようにして、時間のかかる特定の <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">パスエントリ</span></a> の場所のための <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">パスエントリ・ファインダー</span></a> の検索を一度だけ検索すれば良くなります。パスベース・ファインダーにパスエントリの検索を再度行わせるために、ユーザコードでは自由に <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> からキャッシュを取り除いて構いません  <a class="footnote-reference" href="#fnpic" id="id3">[3]</a> 。</p>
<p>path entry がキャッシュの中に無かった場合、 path based finder は <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> の中の呼び出し可能オブジェクトを全て辿ります。
このリストのそれぞれの <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry フック</span></a> は、検索する path entry という引数 1 つを渡して呼び出されます。
その呼び出し可能オブジェクトは path entry を扱える <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> を返すか、  <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出します。
<a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> は、フックが <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a> のための <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> を探せないことを報せるために path based finder が使います。
この例外は処理されず、 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a> を辿っていく処理が続けられます。
フックは引数として文字列またはバイト列オブジェクトを期待します;
バイト列オブジェクトのエンコーディングはフックに任されていて (例えば、ファイルシステムのエンコーディングの UTF-8 やそれ以外などです) 、フックが引数をデコードできなかった場合は <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出すべきです。</p>
<p><a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> を辿る処理が <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">パスエントリ・ファインダー</span></a> を何も返さずに終わった場合、パスベース・ファインダーの <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> メソッドは、 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> に (このパスエントリに対するファインダーが存在しないことを示すために) <code class="docutils literal"><span class="pre">None</span></code> を保存し、 <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">メタパス・ファインダー</span></a> はモジュールが見つからなかったことを伝えるために <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p><a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> 上の <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">パスエントリフック</span></a> 呼び出し可能オブジェクトの戻り値のいずれかが <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">パスエントリ・ファインダー</span></a> <em>であった</em> 場合、後で出てくるモジュール仕様を探すためのプロトコルが使われ、それがモジュールをロードするために使われます。</p>
<p>（空の文字列によって表される）現在のディレクトリは、 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> の他のエントリとは多少異なる方法で処理されます。まず、現在のディレクトリが存在しないことが判明した場合、 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> には何も追加されません。次に、現在のディレクトリに対する値は個々のモジュールのルックアップで毎回新たに検索されます。 3番目に、 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> に使われ、 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">importlib.machinery.PathFinder.find_spec()</span></code></a> が返すパスは、実際のディレクトリであって空の文字列ではありません。</p>
</div>
<div class="section" id="path-entry-finder-protocol">
<h3>5.5.2. パスエントリ・ファインダー・プロトコル<a class="headerlink" href="#path-entry-finder-protocol" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールと初期化されたパッケージのインポートをサポートするため、および名前空間パッケージのポーションとして提供するために、パスエントリ・ファインダーは <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a>  メソッドを実装しなければいけません。</p>
<p><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> は 2 つの引数を取ります。インポートしようとしているモジュールの完全修飾名と、 (オプションの) 対象モジュールです。 <cite>find_spec()</cite> はモジュールに対応する完全に初期化 (populated) された仕様を返します。この仕様は (1つの例外を除いて) 常に &quot;loader&quot; セットを持っています。</p>
<p>モジュール仕様が名前空間 <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">ポーション</span></a> を表していることをインポート機構に示すために、パスエントリ・ファインダーはモジュール仕様の &quot;loader&quot; を <code class="docutils literal"><span class="pre">None</span></code> に、 &quot;submodule_search_locations&quot; を名前空間ポーションを含むリストに設定します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> は <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_loader" title="importlib.abc.PathEntryFinder.find_loader"><code class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></code></a> と <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_module" title="importlib.abc.PathEntryFinder.find_module"><code class="xref py py-meth docutils literal"><span class="pre">find_module()</span></code></a> を置き換えました。両者は deprecated ですが、 <cite>find_spec()</cite> が定義されていなければ使われます。</p>
<p>古いパスエントリ・ファインダーの中には、 <code class="docutils literal"><span class="pre">find_spec()</span></code> の代わりにこれら 2 つの deperecated なメソッドのうちのいずれかを実装しているものがあるかもしれません。これらのメソッドは後方互換性のためにまだ考慮されています。しかし、パスエントリ・ファインダーに <code class="docutils literal"><span class="pre">find_spec()</span></code> が実装されていれば、古いメソッドは無視されます。</p>
<p><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_loader" title="importlib.abc.PathEntryFinder.find_loader"><code class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></code></a> はインポートされるモジュールの完全修飾名を引数に取ります。 <code class="docutils literal"><span class="pre">find_loader()</span></code> は、第 1 要素がローダで第  2要素が名前空間 <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">ポーション</span></a> である 2 要素のタプルを返します。第 1 要素 (つまりローダー) が <code class="docutils literal"><span class="pre">None</span></code> の場合、その意味は、パスエントリ・ファインダー自身は指定されたモジュールのためのローダーを持っていないものの、パスエントリがモジュールの名前空間ポーションに関係している (contribute) のをパスエントリ・ファインダーが知っているということです。これは、ほとんど常にファイルシステム上に物理的な実体のない名前空間パッケージをインポートしようとした場合です。パスエントリ・ファインダーがローダーとして <code class="docutils literal"><span class="pre">None</span></code> を返す場合には、 2 要素タプルである戻り値の第 2 要素はシーケンスでなければなりません。ただし、シーケンスは空でも構いません。</p>
<p><code class="docutils literal"><span class="pre">find_loader()</span></code> が <code class="docutils literal"><span class="pre">None</span></code> でないローダー値を返した場合、ポーションは無視され、パスベース・ファインダーからローダーが返され、パスエントリ上の検索が終了します。</p>
<p>他のインポート機構の実装に対する後方互換性のために、多くのパスエントリ・ファインダーは、メタパス・ファインダーがサポートするのと同じ伝統的な <code class="docutils literal"><span class="pre">find_module()</span></code>  メソッドもサポートしています。しかし、パスエントリ・ファインダーの <code class="docutils literal"><span class="pre">find_module()</span></code>  メソッドは、決して <code class="docutils literal"><span class="pre">path</span></code> 引数では呼び出されません (このメソッドは、パスフックの最初の呼び出しから適切なパス情報を記録する動作が期待されています)。</p>
<p>パスエントリ・ファインダーの <code class="docutils literal"><span class="pre">find_module()</span></code> メソッドは deprecated です。なぜなら、その方法ではパスエントリ・ファインダーが名前空間パッケージに対してポーションを提供することができないからです。もし <code class="docutils literal"><span class="pre">find_loader()</span></code> と <code class="docutils literal"><span class="pre">find_module()</span></code> の両方がパスエントリ・ファインダーに存在したら、インポートシステムは常に <code class="docutils literal"><span class="pre">find_module()</span></code> よりも <code class="docutils literal"><span class="pre">find_loader()</span></code> を優先して呼び出します。</p>
</div>
</div>
</div>
<div class="section" id="replacing-the-standard-import-system">
<h2>5.6. 標準のインポートシステムを置き換える<a class="headerlink" href="#replacing-the-standard-import-system" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>インポートシステム全体を置き換えるための最も信頼性のある仕組みは、 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> のデフォルトの内容を削除し、全部をカスタムのメタパスフックで置き換えるものです。</p>
<p>もし、 import 文の動作だけを変更し、インポートシステムにアクセスする他の API には影響を与えなくてもよければ、組み込みの <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 関数を置き換えるだけで十分です。この手法は、ある 1 つのモジュール内だけで import 文の動作を変更するのにも用いられます。</p>
<p>To selectively prevent import of some modules from a hook early on the
meta path (rather than disabling the standard import system entirely),
it is sufficient to raise <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">ModuleNotFoundError</span></code></a> directly from
<a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> instead of returning
<code class="docutils literal"><span class="pre">None</span></code>. The latter indicates that the meta path search should continue,
while raising an exception terminates it immediately.</p>
</div>
<div class="section" id="special-considerations-for-main">
<h2>5.7. __main__ に対する特別な考慮<a class="headerlink" href="#special-considerations-for-main" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a> モジュールは、 Python のインポートシステムに関連する特別なケースです。 <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">他の場所</span></a> で言及されているように、 <code class="docutils literal"><span class="pre">__main__</span></code> モジュールは <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> や <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> などと同様にインタプリタースタートアップで直接初期化されます。しかし、前者 2 つのモジュールと違って、 <code class="docutils literal"><span class="pre">__main__</span></code> は厳密にはビルトインのモジュールとしての資格を持っていません。これは、 <code class="docutils literal"><span class="pre">__main__</span></code> が初期化される方法がインタプリタが起動されるときのフラグやその他のオプションに依存するためです。</p>
<div class="section" id="main-spec">
<span id="id4"></span><h3>5.7.1. __main__.__spec__<a class="headerlink" href="#main-spec" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a> がどのように初期化されるかに依存して、 <code class="docutils literal"><span class="pre">__main__.__spec__</span></code> は適切に設定されることもあれば <code class="docutils literal"><span class="pre">None</span></code> になることもあります。</p>
<p>Python が <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> オプションを付けて実行された場合には、 <code class="docutils literal"><span class="pre">__spec__</span></code> は対応するモジュールまたはパッケージのモジュール仕様に設定されます。また、ディレクトリや zip ファイル、または他の <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> エントリを実行する処理の一部として <code class="docutils literal"><span class="pre">__main__</span></code> モジュールがロードされる場合にも <code class="docutils literal"><span class="pre">__spec__</span></code> が生成 (populate) されます。</p>
<p><a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">それ以外のケース</span></a> では、 <code class="docutils literal"><span class="pre">__main__.__spec__</span></code> は <code class="docutils literal"><span class="pre">None</span></code> に設定されます。これは、 <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a> を生成 (populate) するために使われたコードがインポート可能なモジュールと直接一致していないためです:</p>
<ul class="simple">
<li>対話プロンプト</li>
<li>-c スイッチ</li>
<li>stdin から起動された場合</li>
<li>ソースファイルやバイトコードファイルから直接起動された場合</li>
</ul>
<p>最後のケースでは、たとえ技術的にはファイルがモジュールとして直接インポートできた <em>としても</em> <code class="docutils literal"><span class="pre">__main__.__spec__</span></code> は常に <code class="docutils literal"><span class="pre">None</span></code> になることに注意してください。もし <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a> において有効なモジュールメタデータが必要なら <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> スイッチを使ってください。</p>
<p><code class="docutils literal"><span class="pre">__main__</span></code> がインポート可能なモジュールと一致し、 <code class="docutils literal"><span class="pre">__main__.__spec__</span></code> がそれに応じて設定されていたとしても、それでもなお、この 2 つのモジュールは別物とみなされることに注意してください。これは、 <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;:</span></code> チェックによって保証されるブロックは、 <code class="docutils literal"><span class="pre">__main__</span></code> 名前空間を生成 (populate) するためにモジュールが使用される時にだけ実行され、通常のインポート時には実行されない、という事実に起因しています。</p>
</div>
</div>
<div class="section" id="open-issues">
<h2>5.8. 取り掛かり中の問題<a class="headerlink" href="#open-issues" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>XXX 図があるととても良い。</p>
<p>XXX * (import_machinery.rst) モジュールとパッケージの属性のみに紙面を割いた節を設けるのは何如でしょうか? もしかしたらデータモデルについての言語リファレンスのページにある関係する内容を拡張したり、置き換えるようなものになるかもしれません。</p>
<p>XXX ライブラリマニュアルの runpy や pkgutil の解説の先頭すべてに、&quot;こちらも参照 (See Also)&quot; という、この新しいインポートシステムの節へのリンクを置くべき。</p>
<p>XXX <code class="docutils literal"><span class="pre">__main__</span></code> が初期化される様々な方法についてより多くの説明を追加する?</p>
<p>XXX <code class="docutils literal"><span class="pre">__main__</span></code> の特異性/落とし穴についてより多くの情報を追加する (つまり <span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0395"><strong>PEP 395</strong></a> からコピーする)</p>
</div>
<div class="section" id="references">
<h2>5.9. 参考資料<a class="headerlink" href="#references" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The import machinery has evolved considerably since Python’s early days.  The
original <a class="reference external" href="https://www.python.org/doc/essays/packages/">specification for packages</a> is still available to read,
although some details have changed since the writing of that document.</p>
<p>オリジナルの <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> の仕様は <span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> で、その後継となる拡張が <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> です。</p>
<p><span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> は Python 3.3 に <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">名前空間パッケージ</span></a> を導入しています。 <span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> はまた <code class="xref py py-meth docutils literal"><span class="pre">find_module()</span></code> に代わるものとして <code class="xref py py-meth docutils literal"><span class="pre">find_loader()</span></code> プロトコルを導入しています。</p>
<p><span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> は、メインモジュールでの明示的な相対インポートのために追加した <code class="docutils literal"><span class="pre">__package__</span></code> 属性の解説をしています。</p>
<p><span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> は絶対インポート、明示的な相対インポート、および、当初 <code class="docutils literal"><span class="pre">__name__</span></code> で提案し、後に <span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a> が <code class="docutils literal"><span class="pre">__package__</span></code> で定めた仕様を導入しました。</p>
<p><span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0338"><strong>PEP 338</strong></a> はモジュールをスクリプトとして実行するときの仕様を定めています。</p>
<p><span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a> は、モジュール仕様オブジェクトにおけるモジュール毎のインポート状態のカプセル化を追加しています。また、ローダーの定型的な責任のほとんどをインポート機構に肩代わりさせています。これらの変更により、インポートシステムのいくつかの API が deprecate され、またファインダーとローダーには新しいメソッドが追加されました。</p>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="fnmo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal"><span class="pre">types.ModuleType</span></code></a> を参照してください。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnlo" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>importlib の実装は、戻り値を直接使うことは避けています。その代わりに、モジュール名を調べて <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> からモジュールオブジェクトを得ます。こうすることの間接的な効果は、インポートされたモジュールが <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> にいる自分自身を置き換えることがあるということです。これは実装依存の動作であり、他の Python 実装では保証されていない動作です。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fnpic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>レガシーなコードでは、 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> に <a class="reference internal" href="../library/imp.html#imp.NullImporter" title="imp.NullImporter"><code class="xref py py-class docutils literal"><span class="pre">imp.NullImporter</span></code></a> のインスタンスがいることがあります。それの代わりに <code class="docutils literal"><span class="pre">None</span></code> を使うようにコードを変更することが推奨されます。より詳しいことは <a class="reference internal" href="../whatsnew/3.3.html#portingpythoncode"><span class="std std-ref">Python コードの移植</span></a> を参照してください。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. インポートシステム</a><ul>
<li><a class="reference internal" href="#importlib">5.1. <code class="docutils literal"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="#packages">5.2. パッケージ</a><ul>
<li><a class="reference internal" href="#regular-packages">5.2.1. 通常のパッケージ</a></li>
<li><a class="reference internal" href="#namespace-packages">5.2.2. 名前空間パッケージ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#searching">5.3. 検索</a><ul>
<li><a class="reference internal" href="#the-module-cache">5.3.1. モジュールキャッシュ</a></li>
<li><a class="reference internal" href="#finders-and-loaders">5.3.2. ファインダーとローダー</a></li>
<li><a class="reference internal" href="#import-hooks">5.3.3. インポートフック</a></li>
<li><a class="reference internal" href="#the-meta-path">5.3.4. メタパス</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loading">5.4. ロード</a><ul>
<li><a class="reference internal" href="#loaders">5.4.1. ローダー</a></li>
<li><a class="reference internal" href="#submodules">5.4.2. サブモジュール</a></li>
<li><a class="reference internal" href="#module-spec">5.4.3. モジュール仕様</a></li>
<li><a class="reference internal" href="#import-related-module-attributes">5.4.4. インポート関連のモジュール属性</a></li>
<li><a class="reference internal" href="#module-path">5.4.5. module.__path__</a></li>
<li><a class="reference internal" href="#module-reprs">5.4.6. モジュールの repr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-path-based-finder">5.5. パスベース・ファインダー</a><ul>
<li><a class="reference internal" href="#path-entry-finders">5.5.1. パスエントリ・ファインダー</a></li>
<li><a class="reference internal" href="#path-entry-finder-protocol">5.5.2. パスエントリ・ファインダー・プロトコル</a></li>
</ul>
</li>
<li><a class="reference internal" href="#replacing-the-standard-import-system">5.6. 標準のインポートシステムを置き換える</a></li>
<li><a class="reference internal" href="#special-considerations-for-main">5.7. __main__ に対する特別な考慮</a><ul>
<li><a class="reference internal" href="#main-spec">5.7.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">5.8. 取り掛かり中の問題</a></li>
<li><a class="reference internal" href="#references">5.9. 参考資料</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="前の章へ">4. 実行モデル</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="expressions.html"
                        title="次の章へ">6. 式 (expression)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/import.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 式 (expression)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.4</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 3月 07, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>