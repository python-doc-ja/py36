<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. 単純文 (simple statement) &#8212; Python 3.6.1 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.1 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python 言語リファレンス" href="index.html" />
    <link rel="next" title="8. 複合文 (compound statement)" href="compound_stmts.html" />
    <link rel="prev" title="6. 式 (expression)" href="expressions.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/reference/simple_stmts.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/reference/simple_stmts.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 複合文 (compound statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 式 (expression)"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="simple-statements">
<span id="simple"></span><h1>7. 単純文 (simple statement)<a class="headerlink" href="#simple-statements" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">単純文とは、単一の論理行内に収められる文です。単一の行内には、複数の単純文をセミコロンで区切って入れることができます。単純文の構文は以下の通りです:</p>
<pre>
<strong id="grammar-token-simple_stmt">simple_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-expression_stmt"><code class="xref docutils literal"><span class="pre">expression_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-assert_stmt"><code class="xref docutils literal"><span class="pre">assert_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-assignment_stmt"><code class="xref docutils literal"><span class="pre">assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-augmented_assignment_stmt"><code class="xref docutils literal"><span class="pre">augmented_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-annotated_assignment_stmt"><code class="xref docutils literal"><span class="pre">annotated_assignment_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-pass_stmt"><code class="xref docutils literal"><span class="pre">pass_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-del_stmt"><code class="xref docutils literal"><span class="pre">del_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-return_stmt"><code class="xref docutils literal"><span class="pre">return_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-yield_stmt"><code class="xref docutils literal"><span class="pre">yield_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-raise_stmt"><code class="xref docutils literal"><span class="pre">raise_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-break_stmt"><code class="xref docutils literal"><span class="pre">break_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-continue_stmt"><code class="xref docutils literal"><span class="pre">continue_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-import_stmt"><code class="xref docutils literal"><span class="pre">import_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-global_stmt"><code class="xref docutils literal"><span class="pre">global_stmt</span></code></a>
                 | <a class="reference internal" href="#grammar-token-nonlocal_stmt"><code class="xref docutils literal"><span class="pre">nonlocal_stmt</span></code></a>
</pre>
<div class="section" id="expression-statements">
<span id="exprstmts"></span><h2>7.1. 式文 (expression statement)<a class="headerlink" href="#expression-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">式文は、(主に対話的な使い方では) 値を計算して出力するために使ったり、(通常は) プロシジャ (procedure: 有意な結果を返さない関数のことです; Python では、プロシジャは値 <code class="docutils literal"><span class="pre">None</span></code> を返します) を呼び出すために使います。その他の使い方でも式文を使うことができますし、有用なこともあります。式文の構文は以下の通りです:</p>
<pre>
<strong id="grammar-token-expression_stmt">expression_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-starred_expression"><code class="xref docutils literal"><span class="pre">starred_expression</span></code></a>
</pre>
<p>式文は式のリスト (単一の式のこともあります) を値評価します。</p>
<p id="index-3">対話モードでは、値が <code class="docutils literal"><span class="pre">None</span></code> でなければ、値を組み込み関数 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> で文字列に変換して、その結果の文字列を標準出力に一行使って書き出します。 (<code class="docutils literal"><span class="pre">None</span></code> になる式文の値は書き出されないので、プロシジャの呼び出しを行っても出力は得られません。)</p>
</div>
<div class="section" id="assignment-statements">
<span id="assignment"></span><h2>7.2. 代入文 (assignment statement)<a class="headerlink" href="#assignment-statements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">代入文は、名前を値に (再) 束縛したり、変更可能なオブジェクトの属性や要素を変更したりするために使われます:</p>
<pre>
<strong id="grammar-token-assignment_stmt">assignment_stmt</strong> ::=  (<a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a> &quot;=&quot;)+ (<a class="reference internal" href="expressions.html#grammar-token-starred_expression"><code class="xref docutils literal"><span class="pre">starred_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><code class="xref docutils literal"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-target_list">target_list    </strong> ::=  <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal"><span class="pre">target</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal"><span class="pre">target</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-target">target         </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>
                     | &quot;(&quot; [<a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a>] &quot;)&quot;
                     | &quot;[&quot; [<a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a>] &quot;]&quot;
                     | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><code class="xref docutils literal"><span class="pre">attributeref</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-subscription"><code class="xref docutils literal"><span class="pre">subscription</span></code></a>
                     | <a class="reference internal" href="expressions.html#grammar-token-slicing"><code class="xref docutils literal"><span class="pre">slicing</span></code></a>
                     | &quot;*&quot; <a class="reference internal" href="#grammar-token-target"><code class="xref docutils literal"><span class="pre">target</span></code></a>
</pre>
<p>(<em>attributeref</em>, <em>subscription</em>, <em>slicing</em> の構文については <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">プライマリ</span></a> 節を参照してください。)</p>
<p>代入文は式のリスト (これは単一の式でも、カンマで区切られた式リストでもよく、後者はタプルになることを思い出してください) を評価し、得られた単一の結果オブジェクトをターゲット (target) のリストに対して左から右へと代入してゆきます。</p>
<p id="index-5">代入はターゲット (リスト) の形式に従って再帰的に行われます。ターゲットが変更可能なオブジェクト (属性参照、添字表記、またはスライス) の一部である場合、この変更可能なオブジェクトは最終的に代入を実行して、その代入が有効な操作であるか判断しなければなりません。代入が不可能な場合には例外を発行することもできます。型ごとにみられる規則や、送出される例外は、そのオブジェクト型定義で与えられています (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 節を参照してください).</p>
<p id="index-6">ターゲットリストは、丸括弧や角括弧で囲まれていてもよく、それに対するオブジェクトの代入は、以下のように再帰的に定義されています。</p>
<ul class="simple">
<li><p class="first">ターゲットリストが空の場合: オブジェクトも空のイテラブルでなければなりません。</p>
</li>
<li><p class="first">ターゲットリストのターゲットが1つだけの場合: オブジェクトはそのターゲットに代入されます。</p>
</li>
<li><p class="first">ターゲットリストが、カンマで区切られた複数のターゲットからなるリスト、もしくは角括弧で囲まれた単一のターゲットの場合: オブジェクトはターゲットリスト中のターゲット数と同じ数の要素からなるイテレート可能オブジェクトでなければならず、その各要素は左から右へと対応するターゲットに代入されます。</p>
<ul>
<li><p class="first">&#8220;星付き&#8221;のターゲットと呼ばれる、頭にアスタリスクが一つ付いたターゲットがターゲットリストに一つだけ含まれている場合: オブジェクトはイテラブルで、少なくともターゲットリストのターゲットの数よりも一つ少ない要素を持たなければはなりません。
星付きのターゲットより前のターゲットに、イテラブルの先頭の要素が左から右へ代入されます。
星付きのターゲットより後ろのターゲットに、イテラブルの末尾の要素が代入されます。
星付きのターゲットに、イテラブルの残った要素のリストが代入されます (リスト空でもかまいません)。</p>
</li>
<li><p class="first">そうでない場合: オブジェクトは、ターゲットリストのターゲットと同じ数の要素を持つイテラブルでなければならず、要素は左から右へ対応するターゲットに代入されます。</p>
</li>
</ul>
</li>
</ul>
<p>単一のターゲットへの単一のオブジェクトの代入は、以下のようにして再帰的に定義されています。</p>
<ul>
<li><p class="first">ターゲットが識別子 (名前) の場合:</p>
<ul class="simple">
<li><p class="first">名前が現在のコードブロック内の <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> や <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> 文に書かれていないければ: 名前は現在のローカル名前空間内のオブジェクトに束縛されます。</p>
</li>
<li><p class="first">そうでなければ: 名前はそれぞれグローバル名前空間内か、 <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> で決められた外側の名前空間内のオブジェクトに束縛されます。</p>
</li>
</ul>
<p id="index-7">名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。再束縛によって、以前その名前に束縛されていたオブジェクトの参照カウント (reference count) がゼロになった場合、オブジェクトは解放 (deallocate) され、デストラクタ  (destructor) が (存在すれば) 呼び出されます。</p>
</li>
<li id="index-8"><p class="first">ターゲットが属性参照の場合: 参照されている一次語の式が値評価されます。値は代入可能な属性を伴うオブジェクトでなければなりません; そうでなければ、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。次に、このオブジェクトに対して、被代入オブジェクトを指定した属性に代入してよいか問い合わせます; 代入を実行できない場合、例外 (通常は <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> ですが、必然ではありません) を送出します。</p>
<p id="attr-target-note">注意: オブジェクトがクラスインスタンスで、代入演算子の両辺に属性参照があるとき、右辺式の <code class="docutils literal"><span class="pre">a.x</span></code> はインスタンスの属性と (インスタンスの属性が存在しなければ) クラス属性のどちらにもアクセスする可能性があります。左辺のターゲット <code class="docutils literal"><span class="pre">a.x</span></code> は常にインスタンスの属性として割り当てられ、必要ならば生成されます。このとおり、現れる二つの <code class="docutils literal"><span class="pre">a.x</span></code> は同じ値を参照するとは限りません: 右辺式はクラス属性を参照し、左辺は新しいインスタンス属性を代入のターゲットとして生成するようなとき:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cls</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>             <span class="c1"># class variable</span>
<span class="n">inst</span> <span class="o">=</span> <span class="n">Cls</span><span class="p">()</span>
<span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># writes inst.x as 4 leaving Cls.x as 3</span>
</pre></div>
</div>
<p>このことは、 <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a> で作成されたプロパティのようなデスクリプタ属性に対しては、必ずしもあてはまるとは限りません。</p>
</li>
<li id="index-9"><p class="first">ターゲットが添字表記なら: 参照されている一次語式が評価されます。参照から (リストのような) ミュータブルなシーケンスオブジェクトか、(辞書のような) マッピングオブジェクトが得られなければなりません。次に、添字表記の表す式が評価されます。</p>
<p id="index-10">一次語が (リストのような) ミュータブルなシーケンスオブジェクトであれば、添字表記は整数を与えなければなりません。整数が負なら、シーケンスの長さが加算されます。整数は最終的に、シーケンスの長さよりも小さな非負の整数でなくてはならず、シーケンスは、そのインデクスに持つ要素に被代入オブジェクトを代入してよいか問い合わせられます。インデクスが範囲外なら、 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> が送出されます (添字指定されたシーケンスに代入を行っても、リスト要素の新たな追加はできません)。</p>
<p id="index-11">一次語が (辞書のような) マップオブジェクトの場合、まず添字はマップのキー型と互換性のある型でなくてはなりません。次に、添字を被代入オブジェクトに関連付けるようなキー/データの対を生成するようマップオブジェクトに問い合わせます。この操作では、既存のキー/値の対を同じキーと別の値で置き換えてもよく、(同じ値を持つキーが存在しない場合) 新たなキー/値の対を挿入してもかまいません。</p>
<p>ユーザ定義のオブジェクトには、適切な引数で <a class="reference internal" href="datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a> メソッドが呼び出されます。</p>
</li>
<li id="index-12"><p class="first">ターゲットがスライスなら: 参照されている一次語式が評価されます。一次語式は、(リストのような) ミュータブルなシーケンスオブジェクトを与えなければなりません。被代入オブジェクトは同じ型のシーケンスオブジェクトでなければなりません。次に、スライスの下限と上限を示す式があれば評価されます; デフォルト値はそれぞれ 0 とシーケンスの長さです。上限と下限の評価は整数でなければなりません。いずれかの境界が負数なら、シーケンスの長さが加算されます。最終的に、境界は 0 からシーケンスの長さまでに収まるように刈りこまれます。最後に、スライスを被代入オブジェクトで置き換えてよいかシーケンスオブジェクトに問い合わせます。ターゲットシーケンスで許されている限り、スライスの長さは被代入シーケンスの長さと異なっていてよく、この場合にはターゲットシーケンスの長さが変更されます。</p>
</li>
</ul>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 現在の実装では、ターゲットの構文は式の構文と同じであるとみなされており、無効な構文はコード生成フェーズ中に詳細なエラーメッセージを伴って拒否されます。</p>
</div>
<p>代入の定義によれば、左辺と右辺のオーバーラップは &#8216;同時 (simultaneous)&#8217; です (例えば <code class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b,</span> <span class="pre">a</span></code> は二つの変数を入れ替えます) が、代入対象となる変数群 <em>どうし</em> のオーバーラップは左から右へ起こり、混乱の元です。例えば、以下のプログラムは <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">2]</span></code> を出力してしまいます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>         <span class="c1"># i is updated, then x[i] is updated</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3132"><strong>PEP 3132</strong></a> - Extended Iterable Unpacking</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">*target</span></code> の指定機能。</p>
</dd>
</dl>
</div>
<div class="section" id="augmented-assignment-statements">
<span id="augassign"></span><h3>7.2.1. 累算代入文 (augmented assignment statement)<a class="headerlink" href="#augmented-assignment-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-14">累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです:</p>
<pre>
<strong id="grammar-token-augmented_assignment_stmt">augmented_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-augtarget"><code class="xref docutils literal"><span class="pre">augtarget</span></code></a> <a class="reference internal" href="#grammar-token-augop"><code class="xref docutils literal"><span class="pre">augop</span></code></a> (<a class="reference internal" href="expressions.html#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><code class="xref docutils literal"><span class="pre">yield_expression</span></code></a>)
<strong id="grammar-token-augtarget">augtarget                </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-attributeref"><code class="xref docutils literal"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-subscription"><code class="xref docutils literal"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-slicing"><code class="xref docutils literal"><span class="pre">slicing</span></code></a>
<strong id="grammar-token-augop">augop                    </strong> ::=  &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;&#64;=&quot; | &quot;/=&quot; | &quot;//=&quot; | &quot;%=&quot; | &quot;**=&quot;
                               | &quot;&gt;&gt;=&quot; | &quot;&lt;&lt;=&quot; | &quot;&amp;=&quot; | &quot;^=&quot; | &quot;|=&quot;
</pre>
<p>(最後の3つの構文定義については <a class="reference internal" href="expressions.html#primaries"><span class="std std-ref">プライマリ</span></a> を参照してください。)</p>
<p>累算代入文は、ターゲット (通常の代入文と違って、アンパックは起こりません) と式リストを評価し、それら二つの被演算子間で特定の累算代入型の二項演算を行い、結果をもとのターゲットに代入します。ターゲットは一度しか評価されません。</p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></code> のような累算代入式は、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> のように書き換えてほぼ同様の動作にできますが、厳密に等価にはなりません。累算代入の方では、 <code class="docutils literal"><span class="pre">x</span></code> は一度しか評価されません。また、実際の処理として、可能ならば <em>インプレース (in-place)</em> 演算が実行されます。これは、代入時に新たなオブジェクトを生成してターゲットに代入するのではなく、以前のオブジェクトの内容を変更するということです。</p>
<p>通常の代入とは違い、累算代入文は右辺を評価する*前に*左辺を評価します。たとえば、<code class="docutils literal"><span class="pre">a[i]</span> <span class="pre">+=</span> <span class="pre">f(x)</span></code> はまず <code class="docutils literal"><span class="pre">a[i]</span></code> を調べ、<code class="docutils literal"><span class="pre">f(x)</span></code> を評価して加算を行い、最後に結果を <code class="docutils literal"><span class="pre">a[i]</span></code> に割り当てます。</p>
<p>累算代入文で行われる代入は、タプルへの代入や、一文中に複数のターゲットが存在する場合を除き、通常の代入と同じように扱われます。同様に、累算代入で行われる二項演算は、場合によって <em>インプレース演算</em> が行われることを除き、通常の二項演算と同じです。</p>
<p>属性参照のターゲットの場合、 <a class="reference internal" href="#attr-target-note"><span class="std std-ref">クラスとインスタンスの属性についての注意</span></a> と同様に通常の代入が適用されます。</p>
</div>
<div class="section" id="annotated-assignment-statements">
<span id="annassign"></span><h3>7.2.2. アノテート付き代入文 (annotated assignment statements)<a class="headerlink" href="#annotated-assignment-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-15">Annotation assignment is the combination, in a single statement,
of a variable or attribute annotation and an optional assignment statement:</p>
<pre>
<strong id="grammar-token-annotated_assignment_stmt">annotated_assignment_stmt</strong> ::=  <a class="reference internal" href="#grammar-token-augtarget"><code class="xref docutils literal"><span class="pre">augtarget</span></code></a> &quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> [&quot;=&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
</pre>
<p><a class="reference internal" href="#assignment"><span class="std std-ref">代入文 (assignment statement)</span></a> との違いは、代入先が一つに限定され右手側の値も１つに限定されることです。</p>
<p>For simple names as assignment targets, if in class or module scope,
the annotations are evaluated and stored in a special class or module
attribute <code class="xref py py-attr docutils literal"><span class="pre">__annotations__</span></code>
that is a dictionary mapping from variable names (mangled if private) to
evaluated annotations. This attribute is writable and is automatically
created at the start of class or module body execution, if annotations
are found statically.</p>
<p>For expressions as assignment targets, the annotations are evaluated if
in class or module scope, but not stored.</p>
<p>If a name is annotated in a function scope, then this name is local for
that scope. Annotations are never evaluated and stored in function scopes.</p>
<p>If the right hand side is present, an annotated
assignment performs the actual assignment before evaluating annotations
(where applicable). If the right hand side is not present for an expression
target, then the interpreter evaluates the target except for the last
<a class="reference internal" href="datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a> or <a class="reference internal" href="datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> call.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> - 変数と属性のアノテーション文法 <span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> - 型ヒント</p>
</div>
</div>
</div>
<div class="section" id="the-assert-statement">
<span id="assert"></span><h2>7.3. <a class="reference internal" href="#assert"><code class="xref std std-keyword docutils literal"><span class="pre">assert</span></code></a> 文<a class="headerlink" href="#the-assert-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-18">assert 文は、プログラム内にデバッグ用アサーション (debugging assertion) を仕掛けるための便利な方法です:</p>
<pre>
<strong id="grammar-token-assert_stmt">assert_stmt</strong> ::=  &quot;assert&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
</pre>
<p>単純な形式 <code class="docutils literal"><span class="pre">assert</span> <span class="pre">expression</span></code> は</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span>
</pre></div>
</div>
<p>と等価です。拡張形式 <code class="docutils literal"><span class="pre">assert</span> <span class="pre">expression1,</span> <span class="pre">expression2</span></code> は、これと等価です</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expression1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">expression2</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-19">上記の等価関係は、 <a class="reference internal" href="../library/constants.html#__debug__" title="__debug__"><code class="xref py py-const docutils literal"><span class="pre">__debug__</span></code></a> と <a class="reference internal" href="../library/exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal"><span class="pre">AssertionError</span></code></a> が、同名の組み込み変数を参照しているという前提の上に成り立っています。現在の実装では、組み込み変数 <a class="reference internal" href="../library/constants.html#__debug__" title="__debug__"><code class="xref py py-const docutils literal"><span class="pre">__debug__</span></code></a> は通常の状況では <code class="docutils literal"><span class="pre">True</span></code> であり、最適化がリクエストされた場合（コマンドラインオプション -O）は <code class="docutils literal"><span class="pre">False</span></code> です。現状のコード生成器は、コンパイル時に最適化が要求されていると assert 文に対するコードを全く出力しません。実行に失敗した式のソースコードをエラーメッセージ内に入れる必要はありません; コードはスタックトレース内で表示されます。</p>
<p><a class="reference internal" href="../library/constants.html#__debug__" title="__debug__"><code class="xref py py-const docutils literal"><span class="pre">__debug__</span></code></a> への代入は不正な操作です。組み込み変数の値は、インタプリタが開始するときに決定されます。</p>
</div>
<div class="section" id="the-pass-statement">
<span id="pass"></span><h2>7.4. <a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal"><span class="pre">pass</span></code></a> 文<a class="headerlink" href="#the-pass-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-20">
<strong id="grammar-token-pass_stmt">pass_stmt</strong> ::=  &quot;pass&quot;
</pre>
<p><a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal"><span class="pre">pass</span></code></a> はヌル操作 (null operation) です &#8212; <a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal"><span class="pre">pass</span></code></a> が実行されても、何も起きません。 <a class="reference internal" href="#pass"><code class="xref std std-keyword docutils literal"><span class="pre">pass</span></code></a> は、構文法的には文が必要だが、コードとしては何も実行したくない場合のプレースホルダとして有用です。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> <span class="k">pass</span>    <span class="c1"># a function that does nothing (yet)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="k">pass</span>       <span class="c1"># a class with no methods (yet)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-del-statement">
<span id="del"></span><h2>7.5. <a class="reference internal" href="#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> 文<a class="headerlink" href="#the-del-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-21">
<strong id="grammar-token-del_stmt">del_stmt</strong> ::=  &quot;del&quot; <a class="reference internal" href="#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a>
</pre>
<p>オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で再帰的に定義されています。ここでは完全な詳細は記述せず、いくつかのヒントを述べるにとどめます。</p>
<p>ターゲットリストに対する削除は、各々のターゲットを左から右へと順に再帰的に削除します。</p>
<p id="index-22">名前の削除は、ローカルまたはグローバル名前空間からその名前の束縛を取り除きます。どちらの名前空間かは、名前が同じコードブロック内の <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文で宣言されているかどうかによります。名前が未束縛 (unbound) なら、 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a> 例外が送出されます。</p>
<p id="index-23">属性参照、添字表記、およびスライスの削除操作は、対象となる一次語オブジェクトに渡されます; スライスの削除は一般的には適切な型の空のスライスを代入するのと等価です (が、この仕様自体もスライスされるオブジェクトで決定されています)。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>以前は、ある名前がネストしたブロックの自由変数として表れる場合は、ローカル名前空間からその名前を削除することは不正な処理でした。</p>
</div>
</div>
<div class="section" id="the-return-statement">
<span id="return"></span><h2>7.6. <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文<a class="headerlink" href="#the-return-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-24">
<strong id="grammar-token-return_stmt">return_stmt</strong> ::=  &quot;return&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a>]
</pre>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> は、関数定義内で構文法的にネストして現れますが、ネストしたクラス定義内には現れません。</p>
<p>式リストがある場合、リストが値評価されます。それ以外の場合は <code class="docutils literal"><span class="pre">None</span></code> で置き換えられます。</p>
<p><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> を使うと、式リスト (または <code class="docutils literal"><span class="pre">None</span></code>) を戻り値として、現在の関数呼び出しから抜け出します。</p>
<p id="index-25"><a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> によって、 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節をともなう <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 文の外に処理が引き渡されると、実際に関数から抜ける前に <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節が実行されます。</p>
<p>ジェネレータ関数では、 <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文はジェネレータの終わりを示し、 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外を送出させます。返された値は (あれば)、 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を構成する引数に使われ、 <code class="xref py py-attr docutils literal"><span class="pre">StopIteration.value</span></code> 属性になります。</p>
<p>In an asynchronous generator function, an empty <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> statement
indicates that the asynchronous generator is done and will cause
<a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopAsyncIteration</span></code></a> to be raised.  A non-empty <a class="reference internal" href="#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a>
statement is a syntax error in an asynchronous generator function.</p>
</div>
<div class="section" id="the-yield-statement">
<span id="yield"></span><h2>7.7. <a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文<a class="headerlink" href="#the-yield-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-26">
<strong id="grammar-token-yield_stmt">yield_stmt</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-yield_expression"><code class="xref docutils literal"><span class="pre">yield_expression</span></code></a>
</pre>
<p><a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文は意味的に <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">yield expression</span></a> 式と同じです。yield 文を用いると yield 式文で必要な括弧を省略することが出来ます。例えば、yield 文</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
<span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>は以下の yield 式文と等価です</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">yield</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">yield from</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>yield 式及び文は <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> を定義するときに、その本体内でのみ使うことが出来ます。関数定義内で yield を使用することで、その定義は通常の関数でなくジェネレータ関数になります。</p>
<p><a class="reference internal" href="#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> の意味の完全な説明は、 <a class="reference internal" href="expressions.html#yieldexpr"><span class="std std-ref">Yield 式</span></a> 節を参照してください。</p>
</div>
<div class="section" id="the-raise-statement">
<span id="raise"></span><h2>7.8. <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal"><span class="pre">raise</span></code></a> 文<a class="headerlink" href="#the-raise-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-27">
<strong id="grammar-token-raise_stmt">raise_stmt</strong> ::=  &quot;raise&quot; [<a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> [&quot;from&quot; <a class="reference internal" href="expressions.html#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]]
</pre>
<p>式を伴わなければ、 <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal"><span class="pre">raise</span></code></a> は現在のスコープで最終的に有効になっている例外を再送出します。そのような例外が現在のスコープでアクティブでない場合、 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 例外が送出されて、これがエラーであることを示します。</p>
<p>そうでなければ、 <a class="reference internal" href="#raise"><code class="xref std std-keyword docutils literal"><span class="pre">raise</span></code></a> は最初の式を、例外オブジェクトとして評価します。これは、 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-class docutils literal"><span class="pre">BaseException</span></code></a> のサブクラスまたはインスタンスでなければなりません。クラスなら、例外インスタンスが必要なとき、クラスを無引数でインスタンス化することで得られます。</p>
<p>例外の <em class="dfn">型</em> は例外インスタンスのクラスで、 <em class="dfn">値</em> はインスタンスそのものです。</p>
<p id="index-28">トレースバックオブジェクトは通常、例外が送出される時に自動で作られ、その例外に書き込み可能の <code class="xref py py-attr docutils literal"><span class="pre">__traceback__</span></code> 属性として付与されます。 <code class="xref py py-meth docutils literal"><span class="pre">with_traceback()</span></code> 例外メソッド (トレースバックを引数に設定した同じ例外を返します) を使い、例外を作って独自のトレースバックを設定するのを一度に出来ます。このように:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;foo occurred&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tracebackobj</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-29"><code class="docutils literal"><span class="pre">from</span></code> 節は例外の連鎖に使われます: 第二の <em>expression</em> は、与えられるなら、別の例外クラスまたはインスタンスでなければならず、これが送出された例外に (書き込み可能の) <code class="xref py py-attr docutils literal"><span class="pre">__cause__</span></code> 属性として付与されます。送出された例外がハンドルされなければ、両方の例外が印字されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">int division or modulo by zero</span>

<span class="go">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>例外ハンドラまたは <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節の中で例外が送出された時も、同じような機構が暗黙に働きます。このとき、先に起こった例外が、新しい例外の <code class="xref py py-attr docutils literal"><span class="pre">__context__</span></code> 属性に付与されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something bad happened&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">int division or modulo by zero</span>

<span class="go">During handling of the above exception, another exception occurred:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">4</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">Something bad happened</span>
</pre></div>
</div>
<p>例外に関する追加情報は <a class="reference internal" href="executionmodel.html#exceptions"><span class="std std-ref">例外</span></a> 節にあります。また、例外処理に関する情報は <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 文</span></a> 節にあります。</p>
</div>
<div class="section" id="the-break-statement">
<span id="break"></span><h2>7.9. <a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal"><span class="pre">break</span></code></a> 文<a class="headerlink" href="#the-break-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-30">
<strong id="grammar-token-break_stmt">break_stmt</strong> ::=  &quot;break&quot;
</pre>
<p><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal"><span class="pre">break</span></code></a> 文は、構文としては <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループや <a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal"><span class="pre">while</span></code></a> ループの内側でのみ出現することができますが、ループ内の関数定義やクラス定義の内側には出現できません。</p>
<p id="index-31"><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal"><span class="pre">break</span></code></a> 文は、文を囲う最も内側のループを終了させ、ループにオプションの <a class="reference internal" href="compound_stmts.html#else"><code class="xref std std-keyword docutils literal"><span class="pre">else</span></code></a> 節がある場合にはそれをスキップします。</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループを <a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal"><span class="pre">break</span></code></a> によって終了すると、ループ制御ターゲットはその時の値を保持します。</p>
<p id="index-32"><a class="reference internal" href="#break"><code class="xref std std-keyword docutils literal"><span class="pre">break</span></code></a> が <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節を伴う <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 文の外側に処理を渡す際には、ループを実際に抜ける前にその <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節が実行されます。</p>
</div>
<div class="section" id="the-continue-statement">
<span id="continue"></span><h2>7.10. <a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal"><span class="pre">continue</span></code></a> 文<a class="headerlink" href="#the-continue-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-33">
<strong id="grammar-token-continue_stmt">continue_stmt</strong> ::=  &quot;continue&quot;
</pre>
<p><a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal"><span class="pre">continue</span></code></a> 文は <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループや <a class="reference internal" href="compound_stmts.html#while"><code class="xref std std-keyword docutils literal"><span class="pre">while</span></code></a> ループ内のネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義、 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 句の中には現れません。 <a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal"><span class="pre">continue</span></code></a> 文は、文を囲う最も内側のループの次の周期に処理を継続します。</p>
<p><a class="reference internal" href="#continue"><code class="xref std std-keyword docutils literal"><span class="pre">continue</span></code></a> が <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 句を持った <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 文を抜けるとき、その <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 句が次のループサイクルを始める前に実行されます。</p>
</div>
<div class="section" id="the-import-statement">
<span id="from"></span><span id="import"></span><h2>7.11. <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文<a class="headerlink" href="#the-import-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-34">
<strong id="grammar-token-import_stmt">import_stmt    </strong> ::=  &quot;import&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal"><span class="pre">name</span></code></a>] ( &quot;,&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal"><span class="pre">module</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal"><span class="pre">name</span></code></a>] )*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative_module"><code class="xref docutils literal"><span class="pre">relative_module</span></code></a> &quot;import&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal"><span class="pre">name</span></code></a>]
                     ( &quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal"><span class="pre">name</span></code></a>] )*
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-relative_module"><code class="xref docutils literal"><span class="pre">relative_module</span></code></a> &quot;import&quot; &quot;(&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal"><span class="pre">name</span></code></a>]
                     ( &quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> [&quot;as&quot; <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal"><span class="pre">name</span></code></a>] )* [&quot;,&quot;] &quot;)&quot;
                     | &quot;from&quot; <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal"><span class="pre">module</span></code></a> &quot;import&quot; &quot;*&quot;
<strong id="grammar-token-module">module         </strong> ::=  (<a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> &quot;.&quot;)* <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>
<strong id="grammar-token-relative_module">relative_module</strong> ::=  &quot;.&quot;* <a class="reference internal" href="#grammar-token-module"><code class="xref docutils literal"><span class="pre">module</span></code></a> | &quot;.&quot;+
<strong id="grammar-token-name">name           </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>
</pre>
<p>(<a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> 節が無い) 基本の import 文は 2 つのステップで実行されます:</p>
<ol class="arabic simple">
<li><p class="first">モジュールを見付け出し、必要であればロードし初期化する</p>
</li>
<li><p class="first"><a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文が表れるスコープのローカル名前空間で名前を定義する。</p>
</li>
</ol>
<p>文が (カンマで区切られた) 複数の節を含んでいるときは、ちょうどその節が個別の import 文に分割されたかのように、2つのステップが節ごとに個別に実行されます。</p>
<p>モジュールを見付け、ロードする 1 つ目のステップの詳細については、 <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">インポートシステム</span></a> の節により詳しく書かれています。そこでは、インポートシステムの動作をカスタマイズするのに使える全てのフックの仕組みだけでなく、様々な種類のインポートできるパッケージとモジュールについても解説されています。このステップが失敗するということは、おそらくモジュールが見付からないか、 <em>あるいは</em> モジュールにあるコードの実行を含め、モジュールの初期化の途中でエラーが起きるかのどちらかが起きていることに注意してください。</p>
<p>要求したモジュールが無事に取得できた場合、次の 3 つのうちの 1 つの方法でローカル名前空間で使えるようになります:</p>
<ul class="simple" id="index-35">
<li><p class="first">モジュール名の後に <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> が続いていた場合は、 <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> の後ろの名前を直接、インポートされたモジュールが束縛します。</p>
</li>
<li><p class="first">他の名前が指定されておらず、インポートされているモジュールが最上位のモジュールだった場合、そのモジュール名がインポートされたモジュールへの参照として、ローカル名前空間で束縛されます</p>
</li>
<li><p class="first">インポートされているモジュールが最上位のモジュール <em>でない</em> 場合、モジュールを含む最上位のパッケージ名が、そのパッケージへの参照として、ローカル名前空間で束縛されます。インポートされたモジュールには、直接ではなく完全修飾名を使ってアクセスしなければなりません</p>
</li>
</ul>
<p id="index-36"><a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> 形式ではもう少し複雑な手順を踏みます:</p>
<ol class="arabic simple">
<li><p class="first"><a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> 節で指定されたモジュールを見付け出し、必要であればロードし初期化する;</p>
</li>
<li><p class="first"><a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 節で指定されたそれぞれの識別子に対し以下の処理を行う:</p>
<ol class="arabic">
<li><p class="first">インポートされたモジュールがその識別子名の属性を持っているかを確認する</p>
</li>
<li><p class="first">持っていなかった場合は、その識別子名でサブモジュールのインポートを試み、再度その属性がインポートされたモジュールにあるか確認する</p>
</li>
<li><p class="first">属性が見付からない場合は、 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出する。</p>
</li>
<li><p class="first">属性が見付かった場合は、 <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節があるならそこの名前、そうでないなら属性名を使って、その値への参照がローカル名前空間に保存される</p>
</li>
</ol>
</li>
</ol>
<p>例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>                 <span class="c1"># foo imported and bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span>         <span class="c1"># foo.bar.baz imported, foo bound locally</span>
<span class="kn">import</span> <span class="nn">foo.bar.baz</span> <span class="k">as</span> <span class="nn">fbb</span>  <span class="c1"># foo.bar.baz imported and bound as fbb</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="k">import</span> <span class="n">baz</span>    <span class="c1"># foo.bar.baz imported and bound as baz</span>
<span class="kn">from</span> <span class="nn">foo</span> <span class="k">import</span> <span class="n">attr</span>       <span class="c1"># foo imported and foo.attr bound as attr</span>
</pre></div>
</div>
<p>識別子のリストが星 (<code class="docutils literal"><span class="pre">'*'</span></code>) に置き換わっている場合は、モジュールで定義されている公開された全ての名前が、 <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文がいるスコープのローカル名前空間に束縛されます。</p>
<p id="index-37">モジュールで定義される <em>公開された名前</em> は、モジュールの名前空間にある <code class="docutils literal"><span class="pre">__all__</span></code> という名前の変数を調べることで決定されます; その変数が定義されている場合は、それはモジュールで定義されたかインポートされた名前からなる、文字列のシーケンスでなければいけません。<code class="docutils literal"><span class="pre">__all__</span></code> で列挙された名前は、全て公開されていると見なされ、存在することが要求されます。<code class="docutils literal"><span class="pre">__all__</span></code> が定義されていない場合、公開された名前とは、モジュールの名前空間で見付かった、アンダースコア文字 (<code class="docutils literal"><span class="pre">'_'</span></code>) で始まらない全ての名前のことです。<code class="docutils literal"><span class="pre">__all__</span></code> は全ての公開 API を含むべきです。これは API の一部でないもの (そのモジュールでインポートされ使われているライブラリモジュールなど) をうっかり外部に公開してしまわないための仕組みです。</p>
<p>インポートのワイルドカード形式 &#8212; <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> &#8212; は、モジュールレベルでのみ許されます。クラスや関数定義でこの形式を使おうとすると、 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a> が送出されます。</p>
<p id="index-38">インポートするモジュールを指定するとき、そのモジュールの絶対名 (absolute name) を指定する必要はありません。モジュールやパッケージが他のパッケージに含まれている場合、共通のトップパッケージからそのパッケージ名を記述することなく相対インポートすることができます。 <a class="reference internal" href="#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> の後に指定されるモジュールやパッケージの先頭に複数個のドットを付けることで、正確な名前を指定することなしに現在のパッケージ階層からいくつ上の階層へ行くかを指定することができます。先頭のドットが 1 つの場合、 import をおこなっているモジュールが存在する現在のパッケージを示します。 3 つのドットは 2 つ上のレベルを示します。なので、 <code class="docutils literal"><span class="pre">pkg</span></code> パッケージの中のモジュールで <code class="docutils literal"><span class="pre">from</span> <span class="pre">.</span> <span class="pre">import</span> <span class="pre">mod</span></code> を実行すると、 <code class="docutils literal"><span class="pre">pkg.mod</span></code> をインポートすることになります。 <code class="docutils literal"><span class="pre">pkg.subpkg1</span></code> の中から <code class="docutils literal"><span class="pre">from</span> <span class="pre">..subpkg2</span> <span class="pre">import</span> <span class="pre">mod</span></code> を実行すると、 <code class="docutils literal"><span class="pre">pkg.subpkg2.mod</span></code> をインポートします。相対インポートの仕様は <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> に含まれています。</p>
<p>どのモジュールがロードされるべきかを動的に決めたいアプリケーションのために、組み込み関数 <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> が提供されています。</p>
<div class="section" id="future-statements">
<span id="future"></span><h3>7.11.1. future 文 (future statement)<a class="headerlink" href="#future-statements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-40"><em class="dfn">future 文</em> は、将来の特定の新たな機能が標準化された Python のリリースで利用可能になるような構文や意味付けを使って、特定のモジュールをコンパイルさせるための、コンパイラに対する指示句 (directive) です。</p>
<p>future 文は互換性のない変更がされた将来の Python のバージョンに容易に移行するためのものです。future 文によって新機能が標準となるリリースの前にそれをモジュール単位で使用することが出来ます。</p>
<pre>
<strong id="grammar-token-future_statement">future_statement</strong> ::=  &quot;from&quot; &quot;__future__&quot; &quot;import&quot; feature [&quot;as&quot; name]
                      (&quot;,&quot; feature [&quot;as&quot; name])*
                      | &quot;from&quot; &quot;__future__&quot; &quot;import&quot; &quot;(&quot; feature [&quot;as&quot; name]
                      (&quot;,&quot; feature [&quot;as&quot; name])* [&quot;,&quot;] &quot;)&quot;
<strong id="grammar-token-feature">feature         </strong> ::=  identifier
<strong id="id1">name            </strong> ::=  identifier
</pre>
<p>future 文は、モジュールの先頭周辺に書かなければなりません。 future 文の前に書いてよい内容は以下です :</p>
<ul class="simple">
<li><p class="first">モジュールのドキュメンテーション文字列 ( あれば )</p>
</li>
<li><p class="first">コメント ,</p>
</li>
<li><p class="first">空行 ,</p>
</li>
<li><p class="first">その他の future 文。</p>
</li>
</ul>
<p>Python 3.0 で認識される機能は、<code class="docutils literal"><span class="pre">absolute_import</span></code>、<code class="docutils literal"><span class="pre">division</span></code>、<code class="docutils literal"><span class="pre">generators</span></code>、<code class="docutils literal"><span class="pre">unicode_literals</span></code>、<code class="docutils literal"><span class="pre">print_function</span></code>、<code class="docutils literal"><span class="pre">nested_scopes</span></code>、および <code class="docutils literal"><span class="pre">with_statement</span></code> です。これらはすべてすでに有効で、後方互換性のためだけに残されているので、冗長です。</p>
<p>future 文は、コンパイル時に特別なやり方で認識され、扱われます: 言語の中核をなす構文構成 (construct) に対する意味付けが変更されている場合、変更部分はしばしば異なるコードを生成することで実現されています。新たな機能によって、(新たな予約語のような) 互換性のない新たな構文が取り入れられることさえあります。この場合、コンパイラはモジュールを別のやりかたで解析する必要があるかもしれません。こうしたコード生成に関する決定は、実行時まで先延ばしすることはできません。</p>
<p>これまでの全てのリリースにおいて、コンパイラはどの機能が定義済みかを知っており、 future 文に未知の機能が含まれている場合にはコンパイル時エラーを送出します。</p>
<p>future 文の実行時における直接的な意味付けは、 import 文と同じです。標準モジュール <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> があり、これについては後で述べます。 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> は、 future 文が実行される際に通常の方法で import されます。</p>
<p>future 文の実行時における特別な意味付けは、 future 文で有効化される特定の機能によって変わります。</p>
<p>以下の文には、何ら特殊な意味はないので注意してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">__future__</span> <span class="p">[</span><span class="k">as</span> <span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>これは future 文ではありません; この文は通常の import 文であり、その他の特殊な意味付けや構文的な制限はありません。</p>
<p>future 文の入ったモジュール <code class="xref py py-mod docutils literal"><span class="pre">M</span></code> 内で使われている組み込み関数 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> や <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> によってコンパイルされるコードは、デフォルトの設定では、 future 文に関係する新たな構文や意味付けを使うようになっています。この仕様は <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> のオプション引数で制御できます &#8212; 詳細はこの関数に関するドキュメントを参照してください。</p>
<p>対話的インタプリタのプロンプトでタイプ入力した future 文は、その後のインタプリタセッション中で有効になります。インタプリタを <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal"><span class="pre">-i</span></code></a> オプションで起動して実行すべきスクリプト名を渡し、スクリプト中に future 文を入れておくと、新たな機能はスクリプトが実行された後に開始する対話セッションで有効になります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> - Back to the __future__</dt>
<dd><p class="first last">__future__ 機構の原案</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="the-global-statement">
<span id="global"></span><h2>7.12. <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文<a class="headerlink" href="#the-global-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-42">
<strong id="grammar-token-global_stmt">global_stmt</strong> ::=  &quot;global&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文は、現在のコードブロック全体で維持される宣言文です。 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文は、列挙した識別子をグローバル変数として解釈するよう指定することを意味します。 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> を使わずにグローバル変数に代入を行うことは不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずにグローバル変数を参照することができます。</p>
<p><a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文で列挙する名前は、同じコードブロック中で、プログラムテキスト上 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文より前に使ってはなりません。</p>
<p>Names listed in a <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> statement must not be defined as formal
parameters or in a <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> loop control target, <a class="reference internal" href="compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a>
definition, function definition, <a class="reference internal" href="#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> statement, or variable
annotation.</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 現在の実装では、これらの制限のうち幾つかについては強制していませんが、プログラムでこの緩和された仕様を乱用すべきではありません。将来の実装では、この制限を強制したり、暗黙のうちにプログラムの意味付けを変更したりする可能性があります。</p>
</div>
<p id="index-43"><strong>プログラマのための注意点:</strong> <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> はパーザに対する指示句 (directive) です。この指示句は、 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文と同時に読み込まれたコードに対してのみ適用されます。特に、組み込みの <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> 関数内に入っている <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文は、関数の呼び出しを <em>含んでいる</em> コードブロック内に効果を及ぼすことはなく、そのような文字列に含まれているコードは、関数の呼び出しを含むコード内の <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文に影響を受けません。同様のことが、関数 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> および <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> にも当てはまります。</p>
</div>
<div class="section" id="the-nonlocal-statement">
<span id="nonlocal"></span><h2>7.13. <a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> 文<a class="headerlink" href="#the-nonlocal-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-44">
<strong id="grammar-token-nonlocal_stmt">nonlocal_stmt</strong> ::=  &quot;nonlocal&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> (&quot;,&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>)*
</pre>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> 文は、列挙された識別子がグローバルを除く一つ外側のスコープで先に束縛された変数を参照するようにします。これは、束縛のデフォルトの動作がまずローカル名前空間を探索するので重要です。この文は、中にあるコードが、グローバル (モジュール) スコープ以外のローカルスコープの外側の変数を再束縛できるようにします。</p>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> 文で列挙された名前は、 <a class="reference internal" href="#global"><code class="xref std std-keyword docutils literal"><span class="pre">global</span></code></a> 文で列挙された名前と違い、外側のスコープですでに存在する束縛を参照しなければなりません (新しい束縛が作られるべきスコープの選択が曖昧さを排除できません)。</p>
<p><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> 文で列挙された名前は、ローカルスコープですでに存在する束縛と衝突してはなりません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3104"><strong>PEP 3104</strong></a> - Access to Names in Outer Scopes</dt>
<dd><p class="first last"><a class="reference internal" href="#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> 文の詳細。</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. 単純文 (simple statement)</a><ul>
<li><a class="reference internal" href="#expression-statements">7.1. 式文 (expression statement)</a></li>
<li><a class="reference internal" href="#assignment-statements">7.2. 代入文 (assignment statement)</a><ul>
<li><a class="reference internal" href="#augmented-assignment-statements">7.2.1. 累算代入文 (augmented assignment statement)</a></li>
<li><a class="reference internal" href="#annotated-assignment-statements">7.2.2. アノテート付き代入文 (annotated assignment statements)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-assert-statement">7.3. <code class="docutils literal"><span class="pre">assert</span></code> 文</a></li>
<li><a class="reference internal" href="#the-pass-statement">7.4. <code class="docutils literal"><span class="pre">pass</span></code> 文</a></li>
<li><a class="reference internal" href="#the-del-statement">7.5. <code class="docutils literal"><span class="pre">del</span></code> 文</a></li>
<li><a class="reference internal" href="#the-return-statement">7.6. <code class="docutils literal"><span class="pre">return</span></code> 文</a></li>
<li><a class="reference internal" href="#the-yield-statement">7.7. <code class="docutils literal"><span class="pre">yield</span></code> 文</a></li>
<li><a class="reference internal" href="#the-raise-statement">7.8. <code class="docutils literal"><span class="pre">raise</span></code> 文</a></li>
<li><a class="reference internal" href="#the-break-statement">7.9. <code class="docutils literal"><span class="pre">break</span></code> 文</a></li>
<li><a class="reference internal" href="#the-continue-statement">7.10. <code class="docutils literal"><span class="pre">continue</span></code> 文</a></li>
<li><a class="reference internal" href="#the-import-statement">7.11. <code class="docutils literal"><span class="pre">import</span></code> 文</a><ul>
<li><a class="reference internal" href="#future-statements">7.11.1. future 文 (future statement)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-global-statement">7.12. <code class="docutils literal"><span class="pre">global</span></code> 文</a></li>
<li><a class="reference internal" href="#the-nonlocal-statement">7.13. <code class="docutils literal"><span class="pre">nonlocal</span></code> 文</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="expressions.html"
                        title="前の章へ">6. 式 (expression)</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="compound_stmts.html"
                        title="次の章へ">8. 複合文 (compound statement)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/simple_stmts.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="compound_stmts.html" title="8. 複合文 (compound statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 式 (expression)"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 6月 25, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>