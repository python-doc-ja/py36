
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>6. 式 (expression) &#8212; Python 3.6.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="7. 単純文 (simple statement)" href="simple_stmts.html" />
    <link rel="prev" title="5. インポートシステム" href="import.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/reference/expressions.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/reference/expressions.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>6. 式 (expression)<a class="headerlink" href="#expressions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">この章では、Python の式における個々の要素の意味について解説します。</p>
<p><strong>表記法に関する注意:</strong> この章と以降の章での拡張BNF (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式</p>
<pre>
<strong id="grammar-token-name">name</strong> ::=  <code class="xref docutils literal"><span class="pre">othername</span></code>
</pre>
<p>で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 <code class="docutils literal"><span class="pre">name</span></code> の形式をとる構文の意味付けは <code class="docutils literal"><span class="pre">othername</span></code> の意味付けと同じになります。</p>
<div class="section" id="arithmetic-conversions">
<span id="conversions"></span><h2>6.1. 算術変換 (arithmetic conversion)<a class="headerlink" href="#arithmetic-conversions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-1">以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれているとき、組み込み型に対する演算子の実装は以下の通りに動作します:</p>
<ul class="simple">
<li>片方の引数が複素数型であれば、他方は複素数型に変換されます;</li>
<li>それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます;</li>
<li>それ以外場合は、両方の引数は整数でなければならず、変換の必要はありません。</li>
</ul>
<p>特定の演算子 ('%' 演算子の左引数としての文字列) には、さらに別の規則が適用されます。拡張は、それ自身の型変換のふるまいを定義していなければなりません。</p>
</div>
<div class="section" id="atoms">
<span id="id2"></span><h2>6.2. アトム、原子的要素 (atom)<a class="headerlink" href="#atoms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-2">atom は、式の一番基本的な要素です。もっとも単純な atom は、識別子またはリテラルです。丸括弧、角括弧、または波括弧で囲われた形式 (form) もまた、構文上アトムに分類されます。atom の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-literal"><code class="xref docutils literal"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-enclosure"><code class="xref docutils literal"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-enclosure">enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-parenth_form"><code class="xref docutils literal"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-list_display"><code class="xref docutils literal"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-dict_display"><code class="xref docutils literal"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-set_display"><code class="xref docutils literal"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-generator_expression"><code class="xref docutils literal"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-yield_atom"><code class="xref docutils literal"><span class="pre">yield_atom</span></code></a>
</pre>
<div class="section" id="atom-identifiers">
<span id="identifiers-names"></span><h3>6.2.1. 識別子 (identifier、または名前 (name))<a class="headerlink" href="#atom-identifiers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-3">アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義については <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">識別子 (identifier) およびキーワード (keyword)</span></a> 節を、名前付けや束縛については <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">名前づけと束縛 (naming and binding)</span></a> 節を参照してください。</p>
<p id="index-4">名前があるオブジェクトに束縛されている場合、名前 atom を評価するとそのオブジェクトになります。名前が束縛されていない場合、 atom を評価しようとすると <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a> 例外を送出します。</p>
<p id="index-5"><strong>プライベートな名前のマングリング:</strong> クラス定義内に書かれた識別子で、2つ以上のアンダースコアから始まり、末尾が2つ以上のアンダースコアで終わっていないものは、そのクラスの <em class="dfn">プライベートな名前</em> とみなされます。プライベートな名前は、コードが生成される前により長い形式に変換されます。この変換によって、クラス名の先頭にアンダースコアがあれば除去し、先頭にアンダースコアを1つ付加し、名前の前に挿入されます。例えば、クラス名 <code class="docutils literal"><span class="pre">Ham</span></code> の中の識別子 <code class="docutils literal"><span class="pre">__spam</span></code> は、<code class="docutils literal"><span class="pre">_Ham__spam</span></code> に変換されます。変換は識別子が使用されている構文のコンテキストからは独立しています。変換された名前が非常に長い (255文字を超える) 場合、実装によっては名前の切り詰めが行われるかもしれません。クラス名がアンダースコアのみから成る場合は変換は行われません。</p>
</div>
<div class="section" id="literals">
<span id="atom-literals"></span><h3>6.2.2. リテラル<a class="headerlink" href="#literals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-6">Python では、文字列やバイト列リテラルと、様々な数値リテラルをサポートしています:</p>
<pre>
<strong id="grammar-token-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-stringliteral"><code class="xref docutils literal"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-bytesliteral"><code class="xref docutils literal"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-integer"><code class="xref docutils literal"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-imagnumber"><code class="xref docutils literal"><span class="pre">imagnumber</span></code></a>
</pre>
<p>リテラルの評価は、与えられた型 (文字列、バイト列、整数、浮動小数点数、複素数) の与えられた値を持つオブジェクトを与えます。浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合があります。詳しくは <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">リテラル</span></a> を参照してください。</p>
<p id="index-7">リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトのアイデンティティはオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても) 同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。</p>
</div>
<div class="section" id="parenthesized-forms">
<span id="parenthesized"></span><h3>6.2.3. 丸括弧形式 (parenthesized form)<a class="headerlink" href="#parenthesized-forms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-8">丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:</p>
<pre>
<strong id="grammar-token-parenth_form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-starred_expression"><code class="xref docutils literal"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p>丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少なくとも一つのカンマが入っていた場合、タプルになります; そうでない場合、式のリストを構成している単一の式自体の値になります。</p>
<p id="index-9">中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。</p>
<p id="index-10">タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。例外は空のタプルで、この場合には丸括弧が <em>必要です</em> — 丸括弧のつかない &quot;何も記述しない式 (nothing)&quot; を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。</p>
</div>
<div class="section" id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3>6.2.4. リスト、集合、辞書の表示<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python は、リスト、集合、または辞書を構成するために、 &quot;表示 (display)&quot; と呼ばれる特殊な構文を、それぞれ二種類づつ提供していて、コンテナの内容は:</p>
<ul class="simple">
<li>明示的に列挙される、または</li>
<li><em class="dfn">内包表記 (comprehension)</em> と呼ばれる、ループ処理とフィルター処理の命令の組み合わせを通じて計算されます。</li>
</ul>
<p>内包表記の共通の構文要素はこの通りです:</p>
<pre>
<strong id="grammar-token-comprehension">comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-comp_for">comp_for     </strong> ::=  [ASYNC] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-comp_iter">comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-comp_if"><code class="xref docutils literal"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-comp_if">comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-expression_nocond"><code class="xref docutils literal"><span class="pre">expression_nocond</span></code></a> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>内包表記はまず単一の式、続いて <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節、さらに続いて 0 個以上の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節や <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節からなります。この場合、新たなコンテナの各要素は、各々の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> や <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節を、左から右にネストしたブロックとみなして実行し、ネストの最内のブロックに到達する度に式を評価することで作成されたものになります。</p>
<p>なお、これらの内包表記は別のスコープで実行されるので、対象のリスト内で代入された名前が外側のスコープに &quot;漏れる&quot; ことはありません。</p>
<p>Since Python 3.6, in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> function, an <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a>
clause may be used to iterate over a <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.
A comprehension in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> function may consist of either a
<a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> or <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> clause following the leading
expression, may contain additional <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> or <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a>
clauses, and may also use <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal"><span class="pre">await</span></code></a> expressions.
If a comprehension contains either <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> clauses
or <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal"><span class="pre">await</span></code></a> expressions it is called an
<em class="dfn">asynchronous comprehension</em>.  An asynchronous comprehension may
suspend the execution of the coroutine function in which it appears.
See also <span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0530"><strong>PEP 530</strong></a>.</p>
</div>
<div class="section" id="list-displays">
<span id="lists"></span><h3>6.2.5. リスト表現<a class="headerlink" href="#list-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-12">リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-list_display">list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-starred_list"><code class="xref docutils literal"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>リスト表示は、新しいリストオブジェクトを与えます。リストの内容は、式リストか、リスト内包表記 (list comprehension) で指定されます。カンマで区切られた一連の式が与えられたときは、それらの各要素は左から右へと順に評価され、その順にリスト内に配置されます。内包表記が与えられたときは、内包表記の結果の要素でリストが構成されます。</p>
</div>
<div class="section" id="set-displays">
<span id="set"></span><h3>6.2.6. 集合表現<a class="headerlink" href="#set-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-13">集合表現は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別されます:</p>
<pre>
<strong id="grammar-token-set_display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-starred_list"><code class="xref docutils literal"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>集合表示は、一連の式または内包表記によって指定された内容の、ミュータブルな集合オブジェクトを与えます。カンマ区切りの一連の式が与えられたときは、その要素は左から右へ順に評価され、集合オブジェクトに加えられます。内包表記が与えられたときは、内包表記の結果となる要素で集合が構成されます。</p>
<p>空集合は <code class="docutils literal"><span class="pre">{}</span></code> で構成できません。このリテラルは空の辞書を構成します。</p>
</div>
<div class="section" id="dictionary-displays">
<span id="dict"></span><h3>6.2.7. 辞書表現<a class="headerlink" href="#dictionary-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-14">辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-dict_display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-key_datum_list"><code class="xref docutils literal"><span class="pre">key_datum_list</span></code></a> | <a class="reference internal" href="#grammar-token-dict_comprehension"><code class="xref docutils literal"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-key_datum_list">key_datum_list    </strong> ::=  <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal"><span class="pre">key_datum</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal"><span class="pre">key_datum</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-key_datum">key_datum         </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-dict_comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a>
</pre>
<p>辞書表現は、新たな辞書オブジェクトを表します。</p>
<p>カンマ区切りの一連のキー/データの対が与えられたときは、その要素は左から右へ評価され、辞書の項目を定義します。すなわち、それぞれのキーオブジェクトが、辞書内で対応するデータを保存するキーとして使われます。これにより、キー/データリストの中で同じキーを複数回指定することができ、そのキーに対する最終的な辞書の値は、最後に与えられたものになります。</p>
<p id="index-15">A double asterisk <code class="docutils literal"><span class="pre">**</span></code> denotes <em class="dfn">dictionary unpacking</em>.
Its operand must be a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>.  Each mapping item is added
to the new dictionary.  Later values replace values already set by
earlier key/datum pairs and earlier dictionary unpackings.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加: </span>Unpacking into dictionary displays, originally proposed by <span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a>.</p>
</div>
<p>辞書内包表記は、リストや集合の内包表記とは対照的に、通常の &quot;for&quot; や &quot;if&quot; 節の前に、コロンで分けられた 2 つの式が必要です。内包表記が起動すると、結果のキーと値の要素が、作られた順に新しい辞書に挿入されます。</p>
<p id="index-17">キーの値として使える型に関する制限は <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 節ですでに列挙しています。(一言でいうと、キーは変更可能なオブジェクトを全て排除した <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> でなければなりません。) 重複するキー間で衝突が起きても、衝突が検出されることはありません; あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、辞書表記の最も右側値となるもの) が使われます。</p>
</div>
<div class="section" id="generator-expressions">
<span id="genexpr"></span><h3>6.2.8. ジェネレータ式<a class="headerlink" href="#generator-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-18">ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です:</p>
<pre>
<strong id="grammar-token-generator_expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。</p>
<p>ジェネレータ式の中で使われている変数は、 (通常のジェネレータと同じように) そのジェネレータオブジェクトに対して <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドが呼ばれたときに遅延評価されます。ただし、最も左に位置する <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節は直ちに評価されるため、そこで生じたエラーは、 ジェネレータ式を扱うコードの中で起きる他のエラーよりも前に表示されます。前の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループに依存するかもしれないので、後の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節は即座に評価することができません。例えば: <code class="docutils literal"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">bar(x))</span></code> 。</p>
<p>関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは <a class="reference internal" href="#calls"><span class="std std-ref">呼び出し (call)</span></a> 節を参照してください。</p>
<p>Since Python 3.6, if the generator appears in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> function,
then <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> clauses and <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal"><span class="pre">await</span></code></a> expressions are permitted
as with an asynchronous comprehension.  If a generator expression
contains either <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> clauses or <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal"><span class="pre">await</span></code></a> expressions
it is called an <em class="dfn">asynchronous generator expression</em>.
An asynchronous generator expression yields a new asynchronous
generator object, which is an asynchronous iterator
(see <a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">非同期イテレータ (Asynchronous Iterator)</span></a>).</p>
</div>
<div class="section" id="yield-expressions">
<span id="yieldexpr"></span><h3>6.2.9. Yield 式<a class="headerlink" href="#yield-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<pre id="index-19">
<strong id="grammar-token-yield_atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-yield_expression"><code class="xref docutils literal"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-yield_expression">yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> | &quot;from&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
</pre>
<p>The yield expression is used when defining a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> function
or an <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function and
thus can only be used in the body of a function definition.  Using a yield
expression in a function’s body causes that function to be a generator,
and using it in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> function’s body causes that
coroutine function to be an asynchronous generator. For example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>  <span class="c1"># defines a generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span> <span class="c1"># defines an asynchronous generator function (PEP 525)</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p>Generator functions are described below, while asynchronous generator
functions are described separately in section
<a class="reference internal" href="#asynchronous-generator-functions"><span class="std std-ref">非同期ジェネレータ関数 (asynchronous generator function)</span></a>.</p>
<p>ジェネレータ関数が呼び出された時、ジェネレータとしてのイテレータを返します。ジェネレータはその後ジェネレータ関数の実行を制御します。ジェネレータのメソッドが呼び出されると実行が開始されます。開始されると、最初の yield 式まで処理して一時停止し、呼び出し元へ <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> の値を返します。ここで言う一時停止とは、ローカル変数の束縛、命令ポインタや内部の評価スタック、そして例外処理のを含むすべてのローカル状態が保持されることを意味します。再度、ジェネレータのメソッドが呼び出されて実行を再開した時、ジェネレータは yield 式がただの外部呼び出しであったかのように処理を継続します。再開後の yield 式の値は実行を再開するメソッドに依存します。<a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> を使用した場合 (一般に <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 文や組み込み関数 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a> など) の結果は <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> となり、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> を使用した場合はそのメソッドに渡された値が結果になります。</p>
<p id="index-20">これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ています。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行は一時停止されます。ジェネレータ関数は yield した後で実行の継続を制御できないことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。</p>
<p>yield 式は <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 構造内で使用できます。ジェネレータの (参照カウントがゼロに達するか、ガベージコレクションによる) 完了前に再開されない場合、ジェネレータ-イテレータの <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> メソッドが呼ばれ、<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節が実行されます。</p>
<p><code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> を使用した場合、与えられた式はサブイテレータとして扱われます。サブイテレータによって生成されたすべての値は現在のジェネレータのメソッドの呼び出し元へ直接渡されます。<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> で渡されたあらゆる値と <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal"><span class="pre">throw()</span></code></a> で渡されたあらゆる例外は根底のイテレータに適切なメソッドがあれば渡されます。適切なメソッドがない場合、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> は <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> か <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を、<a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal"><span class="pre">throw()</span></code></a> は渡された例外を即座に送出します。</p>
<p>根底のイテレータの完了時、引き起こされた <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> インスタンスの <code class="xref py py-attr docutils literal"><span class="pre">value</span></code> 属性はその yield 式の値となります。 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を起こす際に明示的にセットされるか、サブイテレータがジェネレータであれば (サブイテレータからかえる値で) 自動的にセットされるかのどちらかです。</p>
<blockquote>
<div><div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>サブイテレータに制御フローを委譲するために <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> が追加されました。</p>
</div>
</div></blockquote>
<p>yield 式が代入文の単独の右辺式であるとき、括弧は省略できます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-91"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 255</strong></a> - 単純なジェネレータ</dt>
<dd>Python へのジェネレータと <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文の導入提案。</dd>
<dt><span class="target" id="index-92"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 0342</strong></a> - 拡張されたジェネレータを用いたコルーチン</dt>
<dd>シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張する提案です。</dd>
<dt><span class="target" id="index-93"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0380"><strong>PEP 380</strong></a> - サブジェネレータへの委譲構文</dt>
<dd>サブジェネレータの委譲を簡単にするための、 <code class="xref std std-token docutils literal"><span class="pre">yield_from</span></code> 構文の導入提案。</dd>
</dl>
</div>
<div class="section" id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-24"></span><h4>6.2.9.1. ジェネレータ-イテレータメソッド<a class="headerlink" href="#generator-iterator-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この説ではジェネレータイテレータのメソッドについて説明します。これらはジェネレータ関数の実行制御に使用できます。</p>
<p>以下のジェネレータメソッドの呼び出しは、ジェネレータが既に実行中の場合 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外を送出する点に注意してください。</p>
<span class="target" id="index-25"></span><dl class="method">
<dt id="generator.__next__">
<code class="descclassname">generator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の実行を開始するか、最後に yield 式が実行されたところから再開します。ジェネレータ関数が <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドによって再開された時、その時点の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式の値は常に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> と評価されます。その後次の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式まで実行し、ジェネレータは一時停止し、<a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> の値を <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドの呼び出し元に返します。ジェネレータが次の値を yield せずに終了した場合、<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外が送出されます。</p>
<p>このメソッドは通常、例えば <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループや組み込みの <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a> 関数によって暗黙に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="generator.send">
<code class="descclassname">generator.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の内部へ値を &quot;送り&quot;、実行を再開します。引数の <em>value</em> はその時点の yield 式の結果になります。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> メソッドは次にジェネレータが生成した値を返し、ジェネレータが次の値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を送出します。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> が呼び出されてジェネレータが開始するときは、値を受け取る yield 式が存在しないので、 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を引数として呼び出さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="generator.throw">
<code class="descclassname">generator.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータが中断した位置で <code class="docutils literal"><span class="pre">type</span></code> 型の例外を発生させて、そのジェネレータ関数が生成する次の値を返します。ジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> が発生します。ジェネレータ関数が渡された例外を捕捉しない、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。</p>
</dd></dl>

<span class="target" id="index-26"></span><dl class="method">
<dt id="generator.close">
<code class="descclassname">generator.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Raises a <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> at the point where the generator function was
paused.  If the generator function then exits gracefully, is already closed,
or raises <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> (by not catching the exception), close
returns to its caller.  If the generator yields a value, a
<a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> is raised.  If the generator raises any other exception,
it is propagated to the caller.  <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> does nothing if the generator
has already exited due to an exception or normal exit.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="index-27"></span><h4>6.2.9.2. 使用例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> の使用例は、&quot;What’s New in Python.&quot; の <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: サブジェネレータへの委譲構文</span></a> を参照してください。</p>
</div>
<div class="section" id="asynchronous-generator-functions">
<span id="id3"></span><h4>6.2.9.3. 非同期ジェネレータ関数 (asynchronous generator function)<a class="headerlink" href="#asynchronous-generator-functions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The presence of a yield expression in a function or method defined using
<a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> further defines the function as a
<a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function.</p>
<p>When an asynchronous generator function is called, it returns an
asynchronous iterator known as an asynchronous generator object.
That object then controls the execution of the generator function.
An asynchronous generator object is typically used in an
<a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> statement in a coroutine function analogously to
how a generator object would be used in a <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> statement.</p>
<p>Calling one of the asynchronous generator’s methods returns an
<a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object, and the execution starts when this object
is awaited on. At that time, the execution proceeds to the first yield
expression, where it is suspended again, returning the value of
<a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> to the awaiting coroutine. As with a generator,
suspension means that all local state is retained, including the
current bindings of local variables, the instruction pointer, the internal
evaluation stack, and the state of any exception handling.  When the execution
is resumed by awaiting on the next object returned by the asynchronous
generator’s methods, the function can proceed exactly as if the yield
expression were just another external call. The value of the yield expression
after resuming depends on the method which resumed the execution.  If
<a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal"><span class="pre">__anext__()</span></code></a> is used then the result is <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>. Otherwise, if
<a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal"><span class="pre">asend()</span></code></a> is used, then the result will be the value passed in to
that method.</p>
<p>In an asynchronous generator function, yield expressions are allowed anywhere
in a <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> construct. However, if an asynchronous generator is not
resumed before it is finalized (by reaching a zero reference count or by
being garbage collected), then a yield expression within a <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>
construct could result in a failure to execute pending <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>
clauses.  In this case, it is the responsibility of the event loop or
scheduler running the asynchronous generator to call the asynchronous
generator-iterator’s <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal"><span class="pre">aclose()</span></code></a> method and run the resulting
coroutine object, thus allowing any pending <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> clauses
to execute.</p>
<p>To take care of finalization, an event loop should define
a <em>finalizer</em> function which takes an asynchronous generator-iterator
and presumably calls <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal"><span class="pre">aclose()</span></code></a> and executes the coroutine.
This  <em>finalizer</em> may be registered by calling <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal"><span class="pre">sys.set_asyncgen_hooks()</span></code></a>.
When first iterated over, an asynchronous generator-iterator will store the
registered <em>finalizer</em> to be called upon finalization. For a reference example
of a <em>finalizer</em> method see the implementation of
<code class="docutils literal"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> in <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a>.</p>
<p>The expression <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> is a syntax error when used in an
asynchronous generator function.</p>
</div>
<div class="section" id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-28"></span><h4>6.2.9.4. Asynchronous generator-iterator methods<a class="headerlink" href="#asynchronous-generator-iterator-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>This subsection describes the methods of an asynchronous generator iterator,
which are used to control the execution of a generator function.</p>
<span class="target" id="index-29"></span><dl class="method">
<dt id="agen.__anext__">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">__anext__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.__anext__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable which when run starts to execute the asynchronous
generator or resumes it at the last executed yield expression.  When an
asynchronous generator function is resumed with a <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal"><span class="pre">__anext__()</span></code></a>
method, the current yield expression always evaluates to <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> in
the returned awaitable, which when run will continue to the next yield
expression. The value of the <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> of the yield
expression is the value of the <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> exception raised by
the completing coroutine.  If the asynchronous generator exits without
yielding another value, the awaitable instead raises an
<a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopAsyncIteration</span></code></a> exception, signalling that the asynchronous
iteration has completed.</p>
<p>This method is normally called implicitly by a <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> loop.</p>
</dd></dl>

<dl class="method">
<dt id="agen.asend">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">asend</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#agen.asend" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable which when run resumes the execution of the
asynchronous generator. As with the <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> method for a
generator, this &quot;sends&quot; a value into the asynchronous generator function,
and the <em>value</em> argument becomes the result of the current yield expression.
The awaitable returned by the <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal"><span class="pre">asend()</span></code></a> method will return the next
value yielded by the generator as the value of the raised
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>, or raises <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopAsyncIteration</span></code></a> if the
asynchronous generator exits without yielding another value.  When
<a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal"><span class="pre">asend()</span></code></a> is called to start the asynchronous
generator, it must be called with <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> as the argument,
because there is no yield expression that could receive the value.</p>
</dd></dl>

<dl class="method">
<dt id="agen.athrow">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">athrow</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.athrow" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable that raises an exception of type <code class="docutils literal"><span class="pre">type</span></code> at the point
where the asynchronous generator was paused, and returns the next value
yielded by the generator function as the value of the raised
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> exception.  If the asynchronous generator exits
without yielding another value, an <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopAsyncIteration</span></code></a> exception is
raised by the awaitable.
If the generator function does not catch the passed-in exception, or
raises a different exception, then when the awaitable is run that exception
propagates to the caller of the awaitable.</p>
</dd></dl>

<span class="target" id="index-30"></span><dl class="method">
<dt id="agen.aclose">
<em class="property">coroutine </em><code class="descclassname">agen.</code><code class="descname">aclose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.aclose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns an awaitable that when run will throw a <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> into
the asynchronous generator function at the point where it was paused.
If the asynchronous generator function then exits gracefully, is already
closed, or raises <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> (by not catching the exception),
then the returned awaitable will raise a <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> exception.
Any further awaitables returned by subsequent calls to the asynchronous
generator will raise a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopAsyncIteration</span></code></a> exception.  If the
asynchronous generator yields a value, a <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> is raised
by the awaitable.  If the asynchronous generator raises any other exception,
it is propagated to the caller of the awaitable.  If the asynchronous
generator has already exited due to an exception or normal exit, then
further calls to <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal"><span class="pre">aclose()</span></code></a> will return an awaitable that does nothing.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="primaries">
<span id="id4"></span><h2>6.3. プライマリ<a class="headerlink" href="#primaries" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-31">プライマリは、言語において最も結合の強い操作を表します。文法は以下のようになります:</p>
<pre>
<strong id="grammar-token-primary">primary</strong> ::=  <a class="reference internal" href="#grammar-token-atom"><code class="xref docutils literal"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-attributeref"><code class="xref docutils literal"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-subscription"><code class="xref docutils literal"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-slicing"><code class="xref docutils literal"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-call"><code class="xref docutils literal"><span class="pre">call</span></code></a>
</pre>
<div class="section" id="attribute-references">
<span id="id5"></span><h3>6.3.1. 属性参照<a class="headerlink" href="#attribute-references" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-32">属性参照は、プライマリの後ろにピリオドと名前を連ねたものです:</p>
<pre>
<strong id="grammar-token-attributeref">attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-33">プライマリの評価は、属性参照をサポートする型のオブジェクトでなければならず、これにはほとんどのオブジェクトが当てはまります。そしてこのオブジェクトは、名前が指定した識別子名であるような属性を生成しなければなりません。この生成は <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドをオーバーライドすることでカスタマイズできます。その属性が得られなければ、例外 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。そうでなければ、生成されるオブジェクトの型と値は、属性を生成したオブジェクトにより決まります。同じ属性参照を複数回評価すると、互いに異なる属性オブジェクトが得られることがあります。</p>
</div>
<div class="section" id="subscriptions">
<span id="id6"></span><h3>6.3.2. 添字表記 (subscription)<a class="headerlink" href="#subscriptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-34"></span><p id="index-35">添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書) オブジェクトから、要素を一つ選択します:</p>
<pre>
<strong id="grammar-token-subscription">subscription</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>プライマリの評価は、添字表記をサポートするオブジェクト (例えばリストや辞書) でなければなりません。ユーザ定義のオブジェクトは、 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドを定義することで添字表記をサポートできます。</p>
<p>組み込みオブジェクトでは、添字表記をサポートするオブジェクトには 2 種類あります:</p>
<p>プライマリがマップであれば、式リストの値評価結果はマップ内のいずれかのキー値に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応するマップ内の値 (value) を選択します。 (式リストの要素が単独である場合を除き、式リストはタプルでなければなりません。)</p>
<p>プライマリがシーケンスであれば、式 (リスト) の評価は整数またはスライス (以下の節で論じます) でなければなりません。</p>
<p>形式的な構文はシーケンスの負のインデックスにいかなる特例も与えません。しかし、すべての組み込みのシーケンスが与える <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドは、負のインデックスを、インデックスにシーケンスの長さを加えて解釈します (つまり、 <code class="docutils literal"><span class="pre">x[-1]</span></code> は <code class="docutils literal"><span class="pre">x</span></code> の最後の要素を選択します)。結果の値はシーケンスの要素数より小さな非負の整数でなければなりません。添字表記は、(0 から数えた) インデックスを持つ要素を選択します。負のインデックスのサポートは、オブジェクトの <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドに現れるので、このメソッドをオーバーライドするサブクラスは、明示的にこのサポートを追加する必要があります。</p>
<p id="index-36">文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1 文字だけからなる文字列です。</p>
</div>
<div class="section" id="slicings">
<span id="id7"></span><h3>6.3.3. スライス表記 (slicing)<a class="headerlink" href="#slicings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-37"></span><p id="index-38">スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。スライス表記は式として用いたり、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> 文の対象として用いたりできます。スライス表記の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-slicing">slicing     </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-slice_list"><code class="xref docutils literal"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-slice_list">slice_list  </strong> ::=  <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-slice_item">slice_item  </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-proper_slice"><code class="xref docutils literal"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-proper_slice">proper_slice</strong> ::=  [<a class="reference internal" href="#grammar-token-lower_bound"><code class="xref docutils literal"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-upper_bound"><code class="xref docutils literal"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-stride"><code class="xref docutils literal"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-lower_bound">lower_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-upper_bound">upper_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-stride">stride      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
</pre>
<p>上記の形式的な構文法にはあいまいなところがあります: 式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。(スライスリストが適切なスライスを含まない場合)、これ以上の構文の複雑化はせず、スライス表記としての解釈よりも添字表記としての解釈が優先されるように定義することで、あいまいさを取り除いています。</p>
<p id="index-39">スライス表記に対する意味付けは、以下のようになります。プライマリの値評価結果は、以下に述べるようにしてスライスリストから生成されたキーによって (通常の添字表記と同じ <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドを使って) インデクス指定できなければなりません。スライスリストに一つ以上のカンマが含まれている場合、キーは各スライス要素を値変換したものからなるタプルになります; それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。一個の式であるスライス要素は、その式に変換されます。適切なスライスは、スライスオブジェクト (<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a> 参照) に変換され、その <code class="xref py py-attr docutils literal"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">stop</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">step</span></code>  属性は、それぞれ指定した下境界、上境界、およびとび幅 (stride) になります。式がない場所は <code class="docutils literal"><span class="pre">None</span></code> で置き換えられます。</p>
</div>
<div class="section" id="calls">
<span id="index-40"></span><span id="id8"></span><h3>6.3.4. 呼び出し (call)<a class="headerlink" href="#calls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>呼び出しは、呼び出し可能オブジェクト (例えば <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">function</span></a>) を <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">arguments</span></a> の系列とともに呼び出します。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-call">call                </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-argument_list"><code class="xref docutils literal"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-argument_list">argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-positional_arguments"><code class="xref docutils literal"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-starred_and_keywords"><code class="xref docutils literal"><span class="pre">starred_and_keywords</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="#grammar-token-keywords_arguments"><code class="xref docutils literal"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-starred_and_keywords"><code class="xref docutils literal"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keywords_arguments"><code class="xref docutils literal"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-keywords_arguments"><code class="xref docutils literal"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-positional_arguments">positional_arguments</strong> ::=  [&quot;*&quot;] <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> (&quot;,&quot; [&quot;*&quot;] <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-starred_and_keywords">starred_and_keywords</strong> ::=  (&quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a>)
                          (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-keywords_arguments">keywords_arguments  </strong> ::=  (<a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>)
                          (&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-keyword_item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
</pre>
<p>最後の位置引数やキーワード引数の後にカンマをつけてもかまいません。構文の意味付けに影響を及ぼすことはありません。</p>
<p id="index-41">プライマリの評価は呼び出し可能オブジェクトでなければなりません。 (ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、クラスオブジェクト、クラスインスタンスのメソッド、および <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドを持つ全てのオブジェクトが呼び出し可能です)。引数式は全て、呼び出しを試みる前に評価されます。仮引数 (formal <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a>) リストの構文については <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。</p>
<p>キーワード引数が存在する場合、以下のようにして最初に位置引数 (positional argument) に変換されます。まず、値の入っていないスロットが仮引数に対して生成されます。N 個の位置引数がある場合、位置引数は先頭の N スロットに配置されます。次に、各キーワード引数について、識別子を使って対応するスロットを決定します (識別子が最初の仮引数名と同じなら、最初のスロットを使う、といった具合です)。スロットがすでにすべて埋まっていたなら <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。それ以外の場合、引数値をスロットに埋めていきます。 (式が <code class="docutils literal"><span class="pre">None</span></code> であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます; このような状況は通常避けるべきです。) デフォルト値が指定されていない、値の埋められていないスロットが残っている場合 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数として使われます。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 実装では、名前を持たない位置引数を受け取る組み込み関数を提供されるかもしれません。そういった引数がドキュメント化のために '名付けられて' いたとしても、実際には名付けられていないのでキーワードでは提供されません。 CPython では、C 言語で実装された関数の、名前を持たない位置引数をパースするために <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> を使用します。</p>
</div>
<p>仮引数スロットの数よりも多くの位置引数がある場合、構文 <code class="docutils literal"><span class="pre">*identifier</span></code> を使って指定された仮引数がないかぎり、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal"><span class="pre">*identifier</span></code> がある場合、この仮引数は余分な位置引数が入ったタプル (もしくは、余分な位置引数がない場合には空のタプル) を受け取ります。</p>
<p>キーワード引数のいずれかが仮引数名に対応しない場合、構文 <code class="docutils literal"><span class="pre">**identifier</span></code> を使って指定された仮引数がない限り、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal"><span class="pre">**identifier</span></code> がある場合、この仮引数は余分なキーワード引数が入った (キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。</p>
<p id="index-42">If the syntax <code class="docutils literal"><span class="pre">*expression</span></code> appears in the function call, <code class="docutils literal"><span class="pre">expression</span></code> must
evaluate to an <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>.  Elements from these iterables are
treated as if they were additional positional arguments.  For the call
<code class="docutils literal"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code>, if <em>y</em> evaluates to a sequence <em>y1</em>, …, <em>yM</em>,
this is equivalent to a call with M+4 positional arguments <em>x1</em>, <em>x2</em>,
<em>y1</em>, …, <em>yM</em>, <em>x3</em>, <em>x4</em>.</p>
<p>A consequence of this is that although the <code class="docutils literal"><span class="pre">*expression</span></code> syntax may appear
<em>after</em> explicit keyword arguments, it is processed <em>before</em> the
keyword arguments (and any <code class="docutils literal"><span class="pre">**expression</span></code> arguments – see below).  So:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>キーワード引数と <code class="docutils literal"><span class="pre">*expression</span></code> 構文を同じ呼び出しで一緒に使うことはあまりないので、実際に上記のような混乱が生じることはありません。</p>
<p id="index-43">If the syntax <code class="docutils literal"><span class="pre">**expression</span></code> appears in the function call, <code class="docutils literal"><span class="pre">expression</span></code> must
evaluate to a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>, the contents of which are treated as
additional keyword arguments.  If a keyword is already present
(as an explicit keyword argument, or from another unpacking),
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p><code class="docutils literal"><span class="pre">*identifier</span></code> や <code class="docutils literal"><span class="pre">**identifier</span></code> 構文を使った仮引数は、位置引数スロットやキーワード引数名にすることができません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span>Function calls accept any number of <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">**</span></code> unpackings,
positional arguments may follow iterable unpackings (<code class="docutils literal"><span class="pre">*</span></code>),
and keyword arguments may follow dictionary unpackings (<code class="docutils literal"><span class="pre">**</span></code>).
Originally proposed by <span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a>.</p>
</div>
<p>呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。 <code class="docutils literal"><span class="pre">None</span></code> を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェクトの形態によって異なります。</p>
<p>各形態では—</p>
<dl class="docutils">
<dt>ユーザ定義関数:</dt>
<dd><p class="first last" id="index-45">関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> で記述しています。コードブロックで <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文が実行される際に、関数呼び出しの戻り値 (return value) が決定されます。</p>
</dd>
<dt>組み込み関数またはメソッド:</dt>
<dd><p class="first last" id="index-46">結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">組み込み関数</span></a> を参照してください。</p>
</dd>
<dt>クラスオブジェクト:</dt>
<dd><p class="first last" id="index-47">そのクラスの新しいインスタンスが返されます。</p>
</dd>
<dt>クラスインスタンスメソッド:</dt>
<dd><p class="first last" id="index-48">対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加されます。</p>
</dd>
<dt>クラスインスタンス:</dt>
<dd><p class="first last" id="index-49">クラスで <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドが定義されていなければなりません; <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドが呼び出された場合と同じ効果をもたらします。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="await-expression">
<span id="await"></span><h2>6.4. Await 式<a class="headerlink" href="#await-expression" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトでの <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> 実行を一時停止します。
<a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a> 内でのみ使用できます。</p>
<pre>
<strong id="grammar-token-await_expr">await_expr</strong> ::=  &quot;await&quot; <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</div>
<div class="section" id="the-power-operator">
<span id="power"></span><h2>6.5. べき乗演算 (power operator)<a class="headerlink" href="#the-power-operator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>べき乗演算は、左側にある単項演算子よりも強い結合優先順位があります; 一方、右側にある単項演算子よりは低い結合優先順位になっています。構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-power">power</strong> ::=  ( <a class="reference internal" href="#grammar-token-await_expr"><code class="xref docutils literal"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> ) [&quot;**&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>]
</pre>
<p>従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます (この場合は演算子の評価順序を強制しません。つまり <code class="docutils literal"><span class="pre">-1**2</span></code> は <code class="docutils literal"><span class="pre">-1</span></code> になります)。</p>
<p>べき乗演算子の意味は、二つの引数で呼び出される組み込み関数 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a> と同じで、左引数を右引数乗して与えます。数値引数はまず共通の型に変換され、結果はその型です。</p>
<p>整数の被演算子では、第二引数が負でない限り、結果は被演算子と同じ型になります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。例えば <code class="docutils literal"><span class="pre">10**2</span></code> は <code class="docutils literal"><span class="pre">100</span></code> を返しますが、<code class="docutils literal"><span class="pre">10**-2</span></code> は <code class="docutils literal"><span class="pre">0.01</span></code> を返します。</p>
<p><code class="docutils literal"><span class="pre">0.0</span></code> を負の数でべき乗すると <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> を送出します。負の数を小数でべき乗した結果は複素数 (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a> number) になります。 (以前のバージョンでは <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出していました)</p>
</div>
<div class="section" id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2>6.6. 単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-50">全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:</p>
<pre>
<strong id="grammar-token-u_expr">u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-power"><code class="xref docutils literal"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-51">単項演算子 <code class="docutils literal"><span class="pre">-</span></code> (マイナス) は、引数となる数値の符号を反転 (negation) します。</p>
<p id="index-52">単項演算子 <code class="docutils literal"><span class="pre">+</span></code> (プラス) は、数値引数を変更しません。</p>
<p id="index-53">単項演算子 <code class="docutils literal"><span class="pre">~</span></code> (反転) は、整数引数をビット単位反転 (bitwise invert) したものを与えます。<code class="docutils literal"><span class="pre">x</span></code> のビット単位反転は、<code class="docutils literal"><span class="pre">-(x+1)</span></code> として定義されています。この演算子は整数にのみ適用されます。</p>
<p id="index-54">上記の三つはいずれも、引数が正しい型でない場合には <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
</div>
<div class="section" id="binary-arithmetic-operations">
<span id="binary"></span><h2>6.7. 二項算術演算 (binary arithmetic operation)<a class="headerlink" href="#binary-arithmetic-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-55">二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の非数値型にも適用されるので注意してください。べき乗 (power) 演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません:</p>
<pre>
<strong id="grammar-token-m_expr">m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>| <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-a_expr">a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-56"><code class="docutils literal"><span class="pre">*</span></code> (乗算: multiplication) 演算子は、引数同士の積を与えます。引数は、両方とも数値であるか、片方が整数で他方がシーケンスかのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負にすると、空のシーケンスを与えます。</p>
<p id="index-57"><code class="docutils literal"><span class="pre">&#64;</span></code> (at) 演算子は行列の乗算に対し使用されます。
Python の組み込み型はこの演算子を実装していません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<p id="index-58"><code class="docutils literal"><span class="pre">/</span></code> (除算: division) および <code class="docutils literal"><span class="pre">//</span></code> (切り捨て除算: floor division) は、引数同士の商を与えます。数値引数はまず共通の型に変換されます。整数の除算結果は浮動小数点になりますが、整数の切り捨て除算結果は整数になります; この場合、結果は数学的な除算に 'floor' 関数 を適用したものになります。ゼロによる除算を行うと <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> 例外を送出します。</p>
<p id="index-59"><code class="docutils literal"><span class="pre">%</span></code> (剰余: modulo) 演算は、第一引数を第二引数で除算したときの剰余になります。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> 例外が送出されます。引数値は浮動小数点でもよく。例えば <code class="docutils literal"><span class="pre">3.14%0.7</span></code> は <code class="docutils literal"><span class="pre">0.34</span></code> になります (<code class="docutils literal"><span class="pre">3.14</span></code> は <code class="docutils literal"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code> だからです)。剰余演算子は常に第二引数と同じ符号 (またはゼロ) の結果になります; 剰余演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 <a class="footnote-reference" href="#id17" id="id9">[1]</a></p>
<p>切り捨て除算演算と剰余演算は、恒等式: <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code> の関係にあります。切り捨て除算や剰余はまた、組み込み関数 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a>: <code class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code> とも関係しています。 <a class="footnote-reference" href="#id18" id="id10">[2]</a> 。</p>
<p><code class="docutils literal"><span class="pre">%</span></code> 演算子は、数値に対する剰余演算を行うのに加えて、文字列 (string) オブジェクトにオーバーロードされ、旧式の文字列の書式化 (いわゆる補間) を行います。文字列の書式化の構文は Python ライブラリリファレンス <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">printf 形式の文字列書式化</span></a> 節を参照してください。</p>
<p>切り捨て除算演算子、剰余演算子、および <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a> 関数は、複素数に対しては定義されていません。目的に合うならば、代わりに <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> を使って浮動小数点に変換してください。</p>
<p id="index-60"><code class="docutils literal"><span class="pre">+</span></code> (加算) 演算は、引数同士の和を与えます。引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換され、加算されます。後者の場合、シーケンスは結合 (concatenate) されます。</p>
<p id="index-61"><code class="docutils literal"><span class="pre">-</span></code> (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型に変換されます。</p>
</div>
<div class="section" id="shifting-operations">
<span id="shifting"></span><h2>6.8. シフト演算 (shifting operation)<a class="headerlink" href="#shifting-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-62">シフト演算は、算術演算よりも低い優先順位を持っています:</p>
<pre>
<strong id="grammar-token-shift_expr">shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a> ( &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; ) <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a>
</pre>
<p>これらは整数を引数にとります。引数は共通の型に変換されます。シフト演算は第一引数を、第二引数で与えられたビット数だけ、左または右にビットシフトします。</p>
<p id="index-63"><em>n</em> ビットの右シフトは <code class="docutils literal"><span class="pre">pow(2,n)</span></code> による除算として定義されます。<em>n</em> ビットの左シフトは <code class="docutils literal"><span class="pre">pow(2,n)</span></code> による乗算として定義されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">現在の実装では、右辺被演算子は最大でも <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> でなければなりません。右辺被演算子が <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> よりも大きいと、 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 例外が送出されます。</p>
</div>
</div>
<div class="section" id="binary-bitwise-operations">
<span id="bitwise"></span><h2>6.9. ビット単位演算の二項演算 (binary bitwise operation)<a class="headerlink" href="#binary-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-64">以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:</p>
<pre>
<strong id="grammar-token-and_expr">and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-xor_expr">xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-or_expr">or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-65"><code class="docutils literal"><span class="pre">&amp;</span></code> 演算子は、引数同士のビット単位の AND を与えます。引数は整数でなければなりません。</p>
<p id="index-66"><code class="docutils literal"><span class="pre">^</span></code> 演算子は、引数同士のビット単位の XOR (排他的 OR) を与えます。引数は整数でなければなりません。</p>
<p id="index-67"><code class="docutils literal"><span class="pre">|</span></code> 演算子は、引数同士のビット単位の (包含的) OR を与えます。引数は整数でなければなりません。</p>
</div>
<div class="section" id="comparisons">
<span id="id11"></span><h2>6.10. 比較<a class="headerlink" href="#comparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<span class="target" id="index-68"></span><p id="index-69">C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また <code class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:</p>
<pre>
<strong id="grammar-token-comparison">comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> ( <a class="reference internal" href="#grammar-token-comp_operator"><code class="xref docutils literal"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> )*
<strong id="grammar-token-comp_operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>比較演算の結果はブール値: <code class="docutils literal"><span class="pre">True</span></code> または <code class="docutils literal"><span class="pre">False</span></code> になります。</p>
<p id="index-70">比較はいくらでも連鎖することができます。例えば <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> と等価になります。ただしこの場合、前者では <code class="docutils literal"><span class="pre">y</span></code> はただ一度だけ評価される点が異なります (どちらの場合でも、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> が偽になると <code class="docutils literal"><span class="pre">z</span></code> の値はまったく評価されません)。</p>
<p>形式的には、 <em>a</em>, <em>b</em>, <em>c</em>, …, <em>y</em>, <em>z</em> が式で <em>op1</em>, <em>op2</em>, …, <em>opN</em> が比較演算子である場合、 <code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> と等価になります。ただし、前者では各式は多くても一度しか評価されません。</p>
<p><code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> と書いた場合、 <em>a</em> から <em>c</em> までの範囲にあるかどうかのテストを指すのではないことに注意してください。例えば <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> は (きれいな書き方ではありませんが) 完全に正しい文法です。</p>
<div class="section" id="value-comparisons">
<h3>6.10.1. 値の比較<a class="headerlink" href="#value-comparisons" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, および <code class="docutils literal"><span class="pre">!=</span></code> は2つのオブジェクトの値を比較します。
オブジェクトが同じ型を持つ必要はりません。</p>
<p><a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">オブジェクト、値、および型</span></a> の章では、オブジェクトは (型や id のに加えて) 値を持つことを述べています。
オブジェクトの値は Python ではやや抽象的な概念です: 例えば、オブジェクトの値にアクセスする正統な方法はありません。
また、その全てのデータ属性から構成されるなどの特定の方法で、オブジェクトの値を構築する必要性もありません。
比較演算子は、オブジェクトの値とは何かについての特定の概念を実装しています。
この比較の実装によって、間接的にオブジェクトの値を定義している考えることもできます。</p>
<p>Because all types are (direct or indirect) subtypes of <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>, they
inherit the default comparison behavior from <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>.  Types can
customize their comparison behavior by implementing
<em class="dfn">rich comparison methods</em> like <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a>, described in
<a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">基本的なカスタマイズ</span></a>.</p>
<p>等価性比較 (<code class="docutils literal"><span class="pre">==</span></code> および <code class="docutils literal"><span class="pre">!=</span></code>) のデフォルトの振る舞いは、オブジェクトの同一性に基づいています。
従って、同一のインスタンスの等価性比較の結果は等しいとなり、同一でないインスタンスの等価性比較の結果は等しくないとなります。
デフォルトの振る舞いをこのようにしたのは、全てのオブジェクトを反射的 (reflexive つまり <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> ならば <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>) なものにしたかったからです。</p>
<p>A default order comparison (<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, and <code class="docutils literal"><span class="pre">&gt;=</span></code>) is not provided;
an attempt raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>.  A motivation for this default behavior is
the lack of a similar invariant as for equality.</p>
<p>同一でないインスタンスは常に等価でないとする等価性比較のデフォルトの振る舞いは、型が必要とするオブジェクトの値や値に基づいた等価性の実用的な定義とは対照的に思えるでしょう。
そのような型では比較の振る舞いをカスタマイズする必要が出てきて、実際にたくさんの組み込み型でそれが行われています。</p>
<p>次のリストでは、最重要の組み込み型の比較の振る舞いを解説しています。</p>
<ul>
<li><p class="first">いくつかの組み込みの数値型 (<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, complex</span></a>) と標準ライブラリの型 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> および <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a> は、同じ型や別の型どうしで比較できますが、複素数では順序比較がサポートされていないという制限があります。
関わる型の制限の範囲内では、精度のロス無しに数学的に (アルゴリズム的に) 正しい比較が行われます。</p>
<p>The not-a-number values <code class="xref py py-const docutils literal"><span class="pre">float('NaN')</span></code> and <code class="xref py py-const docutils literal"><span class="pre">Decimal('NaN')</span></code>
are special.  They are identical to themselves (<code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">x</span></code> is true) but
are not equal to themselves (<code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> is false).  Additionally,
comparing any number to a not-a-number value
will return <code class="docutils literal"><span class="pre">False</span></code>.  For example, both <code class="docutils literal"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">float('NaN')</span></code> and
<code class="docutils literal"><span class="pre">float('NaN')</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> will return <code class="docutils literal"><span class="pre">False</span></code>.</p>
</li>
<li><p class="first">Binary sequences (instances of <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> or <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) can be
compared within and across their types.  They compare lexicographically using
the numeric values of their elements.</p>
</li>
<li><p class="first">Strings (instances of <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) compare lexicographically using the
numerical Unicode code points (the result of the built-in function
<a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a>) of their characters. <a class="footnote-reference" href="#id19" id="id12">[3]</a></p>
<p>Strings and binary sequences cannot be directly compared.</p>
</li>
<li><p class="first">Sequences (instances of <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, or <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>) can
be compared only within each of their types, with the restriction that ranges
do not support order comparison.  Equality comparison across these types
results in inequality, and ordering comparison across these types raises
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>.</p>
<p>Sequences compare lexicographically using comparison of corresponding
elements, whereby reflexivity of the elements is enforced.</p>
<p>In enforcing reflexivity of elements, the comparison of collections assumes
that for a collection element <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> is always true.  Based on
that assumption, element identity is compared first, and element comparison
is performed only for distinct elements.  This approach yields the same
result as a strict element comparison would, if the compared elements are
reflexive.  For non-reflexive elements, the result is different than for
strict element comparison, and may be surprising:  The non-reflexive
not-a-number values for example result in the following comparison behavior
when used in a list:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nan</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nan</span> <span class="ow">is</span> <span class="n">nan</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nan</span> <span class="o">==</span> <span class="n">nan</span>
<span class="go">False                 &lt;-- the defined non-reflexive behavior of NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">nan</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">nan</span><span class="p">]</span>
<span class="go">True                  &lt;-- list enforces reflexivity and tests identity first</span>
</pre></div>
</div>
<p>組み込みのコレクションどうしの辞書式比較は次のように動作します:</p>
<ul class="simple">
<li>比較の結果が等価となる2つのコレクションは、同じ型、同じ長さ、対応する要素どうしの比較の結果が等価でなければなりません (例えば、 <code class="docutils literal"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> は型が同じでないので偽です)。</li>
<li>Collections that support order comparison are ordered the same as their
first unequal elements (for example, <code class="docutils literal"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> has the same
value as <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>).  If a corresponding element does not exist, the
shorter collection is ordered first (for example, <code class="docutils literal"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> is
true).</li>
</ul>
</li>
<li><p class="first">マッピング (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のインスタンス) の比較の結果が等価となるのは、同じ <cite>(key, value)</cite> を持っているときかつそのときに限ります。
キーと値の等価性比較では反射性が強制されます。</p>
<p>Order comparisons (<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, and <code class="docutils literal"><span class="pre">&gt;=</span></code>) raise <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>.</p>
</li>
<li><p class="first">Sets (instances of <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> or <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>) can be compared within
and across their types.</p>
<p>They define order
comparison operators to mean subset and superset tests.  Those relations do
not define total orderings (for example, the two sets <code class="docutils literal"><span class="pre">{1,2}</span></code> and <code class="docutils literal"><span class="pre">{2,3}</span></code>
are not equal, nor subsets of one another, nor supersets of one
another).  Accordingly, sets are not appropriate arguments for functions
which depend on total ordering (for example, <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a>, and
<a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> produce undefined results given a list of sets as inputs).</p>
<p>Comparison of sets enforces reflexivity of its elements.</p>
</li>
<li><p class="first">Most other built-in types have no comparison methods implemented, so they
inherit the default comparison behavior.</p>
</li>
</ul>
<p>比較の振る舞いをカスタマイズしたユーザ定義クラスは、可能なら次の一貫性の規則に従う必要があります:</p>
<ul>
<li><p class="first">等価比較は反射的でなければなりません。
つまり、同一のオブジェクトは等しくなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> は暗黙的に <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較は対称でなければなりません。
つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較は推移的でなければなりません。
以下の (包括的でない) 例がその説明です:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> は暗黙的に <code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は暗黙的に <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code></p>
</div></blockquote>
</li>
<li><p class="first">比較の逆はブールの否定でなければなりません。
つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
</div></blockquote>
<p>最後の2式は全順序の集まりに適用されます (たとえばシーケンスには適用されますがセットやマッピングには適用されません)。
<a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal"><span class="pre">total_ordering()</span></code></a> デコレータも参照してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> の結果は等価性と一貫している必要があります。
等価なオブジェクトどうしは同じハッシュ値を持つか、ハッシュ値が計算できないものとされる必要があります。</p>
</li>
</ul>
<p>Python does not enforce these consistency rules. In fact, the not-a-number
values are an example for not following these rules.</p>
</div>
<div class="section" id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3>6.10.2. 帰属検査演算<a class="headerlink" href="#membership-test-operations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>演算子 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> および <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> は、帰属 (membership) を調べます。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の評価は、 <em>x</em> が <em>s</em> の要素であれば <code class="docutils literal"><span class="pre">True</span></code> となり、そうでなければ <code class="docutils literal"><span class="pre">False</span></code> となります。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の否定 (negation) を返します。すべての組み込みのシーケンスと集合型に加えて、辞書も、 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> を辞書が与えられたキーを持っているかを調べるものとしてサポートしています。リスト、タプル、集合、凍結集合、辞書、あるいは collection.deque のようなコンテナ型について、式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code> と等価です。</p>
<p>文字列やバイト列型については、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <em>x</em> が <em>y</em> の部分文字列であるとき、かつそのときに限り <code class="docutils literal"><span class="pre">True</span></code> になります。これは <code class="docutils literal"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code> と等価です。空文字列は、他の任意の文字列の部分文字列とみなされます。従って <code class="docutils literal"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> は <code class="docutils literal"><span class="pre">True</span></code> を返すことになります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> メソッドを実装したユーザ定義クラスでは、 <code class="docutils literal"><span class="pre">y.__contains__(x)</span></code> の返り値が真となる場合に <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> の返り値は <code class="docutils literal"><span class="pre">True</span></code> となり、そうでない場合は <code class="docutils literal"><span class="pre">False</span></code> となります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> を定義していないが <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> は定義しているユーザ定義クラスでは、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> となるようなある値 <cite>z</cite> が <code class="docutils literal"><span class="pre">y</span></code> 内にわたる反復で生成された場合、 <code class="docutils literal"><span class="pre">True</span></code> となります。もし、反復の間に例外が発生すれば、 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> が例外を発生させたようにみえます。</p>
<p>Lastly, the old-style iteration protocol is tried: if a class defines
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>, <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal"><span class="pre">True</span></code> if and only if there is a non-negative
integer index <em>i</em> such that <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code>, and all lower integer indices do not
raise <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> exception.  (If any other exception is raised, it is as
if <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> raised that exception).</p>
<p id="index-71">演算子 <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> は <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> の真値を反転した値として定義されています。</p>
</div>
<div class="section" id="is-not">
<span id="is"></span><span id="index-72"></span><span id="identity-comparisons"></span><h3>6.10.3. 同一性の比較<a class="headerlink" href="#is-not" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The operators <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> and <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a> test for object identity: <code class="docutils literal"><span class="pre">x</span>
<span class="pre">is</span> <span class="pre">y</span></code> is true if and only if <em>x</em> and <em>y</em> are the same object.  Object identity
is determined using the <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal"><span class="pre">id()</span></code></a> function.  <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> yields the inverse
truth value. <a class="footnote-reference" href="#id20" id="id13">[4]</a></p>
</div>
</div>
<div class="section" id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2>6.11. ブール演算 (boolean operation)<a class="headerlink" href="#boolean-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-73">
<strong id="grammar-token-or_test">or_test </strong> ::=  <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-and_test">and_test</strong> ::=  <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-not_test">not_test</strong> ::=  <a class="reference internal" href="#grammar-token-comparison"><code class="xref docutils literal"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a>
</pre>
<p>ブール演算のコンテキストや、式が制御フロー文中で使われる際には、以下の値: <code class="docutils literal"><span class="pre">False</span></code> 、 <code class="docutils literal"><span class="pre">None</span></code> すべての型における数値の 0、空の文字列、空のコンテナ (文字列、タプル、リスト、辞書、集合、凍結集合など) は偽 (false) であると解釈されます。それ以外の値は真 (true) であると解釈されます。ユーザ定義のメソッドは、 <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> メソッドを与えることで、真理値をカスタマイズできます。</p>
<p id="index-74">演算子 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> は、引数が偽である場合には <code class="docutils literal"><span class="pre">True</span></code> を、それ以外の場合には <code class="docutils literal"><span class="pre">False</span></code> になります。</p>
<p id="index-75">式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が偽なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> の値を評価し、その結果を返します。</p>
<p id="index-76">式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が真なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> の値を評価し、その結果を返します。</p>
<p>(なお、 <a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a> も <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a> も、返す値を <code class="docutils literal"><span class="pre">True</span></code> や <code class="docutils literal"><span class="pre">False</span></code> に制限せず、最後に評価した引数を返します。この仕様が便利なこともあり、例えば <code class="docutils literal"><span class="pre">s</span></code> が文字列で、空文字列ならデフォルトの値に置き換えたいとき、式 <code class="docutils literal"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> は望んだ値を与えます。 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> は引数の型に関係なく、必ずブール値を返すからです。例えば、 <code class="docutils literal"><span class="pre">not</span> <span class="pre">'foo'</span></code> は、 <code class="docutils literal"><span class="pre">''</span></code> ではなく <code class="docutils literal"><span class="pre">False</span></code> を与えます。)</p>
</div>
<div class="section" id="conditional-expressions">
<h2>6.12. 条件式 (Conditional Expressions)<a class="headerlink" href="#conditional-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-77">
<strong id="grammar-token-conditional_expression">conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-expression">expression            </strong> ::=  <a class="reference internal" href="#grammar-token-conditional_expression"><code class="xref docutils literal"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-lambda_expr"><code class="xref docutils literal"><span class="pre">lambda_expr</span></code></a>
<strong id="grammar-token-expression_nocond">expression_nocond     </strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> | <a class="reference internal" href="#grammar-token-lambda_expr_nocond"><code class="xref docutils literal"><span class="pre">lambda_expr_nocond</span></code></a>
</pre>
<p>条件式 (しばしば &quot;三項演算子&quot; と呼ばれます) は最も優先度が低いPython の演算です。</p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> という式は最初に条件 <em>x</em> ではなく <em>C</em> を評価します; <em>C</em> が true の場合 <em>x</em> が評価され値が返されます; それ以外の場合には <em>y</em> が評価され返されます。</p>
<p>条件演算に関してより詳しくは <span class="target" id="index-94"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> を参照してください。</p>
</div>
<div class="section" id="lambda">
<span id="lambdas"></span><span id="id14"></span><h2>6.13. ラムダ (lambda)<a class="headerlink" href="#lambda" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-79">
<strong id="grammar-token-lambda_expr">lambda_expr       </strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-lambda_expr_nocond">lambda_expr_nocond</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-expression_nocond"><code class="xref docutils literal"><span class="pre">expression_nocond</span></code></a>
</pre>
<p>Lambda expressions (sometimes called lambda forms) are used to create anonymous
functions. The expression <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">arguments:</span> <span class="pre">expression</span></code> yields a function
object.  The unnamed object behaves like a function object defined with:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(arguments):
    return expression
</pre></div>
</div>
<p>引数の一覧の構文は <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。ラムダ式で作成された関数は文やアノテーションを含むことができない点に注意してください。</p>
</div>
<div class="section" id="expression-lists">
<span id="exprlists"></span><h2>6.14. 式のリスト<a class="headerlink" href="#expression-lists" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-80">
<strong id="grammar-token-expression_list">expression_list   </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> ( &quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> )* [&quot;,&quot;]
<strong id="grammar-token-starred_list">starred_list      </strong> ::=  <a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal"><span class="pre">starred_item</span></code></a> ( &quot;,&quot; <a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal"><span class="pre">starred_item</span></code></a> )* [&quot;,&quot;]
<strong id="grammar-token-starred_expression">starred_expression</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | ( <a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal"><span class="pre">starred_item</span></code></a> &quot;,&quot; )* [<a class="reference internal" href="#grammar-token-starred_item"><code class="xref docutils literal"><span class="pre">starred_item</span></code></a>]
<strong id="grammar-token-starred_item">starred_item      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a>
</pre>
<p id="index-81">Except when part of a list or set display, an expression list
containing at least one comma yields a tuple.  The length of
the tuple is the number of expressions in the list.  The expressions are
evaluated from left to right.</p>
<p id="index-82">An asterisk <code class="docutils literal"><span class="pre">*</span></code> denotes <em class="dfn">iterable unpacking</em>.  Its operand must be
an <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>.  The iterable is expanded into a sequence of items,
which are included in the new tuple, list, or set, at the site of
the unpacking.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加: </span>Iterable unpacking in expression lists, originally proposed by <span class="target" id="index-83"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a>.</p>
</div>
<p id="index-84">単一要素のタプル (別名 <em>単集合 (singleton)</em> ) を作りたければ、末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその式の値になります (空のタプルを作りたいなら、中身が空の丸括弧ペア: <code class="docutils literal"><span class="pre">()</span></code> を使います。)</p>
</div>
<div class="section" id="evaluation-order">
<span id="evalorder"></span><h2>6.15. 評価順序<a class="headerlink" href="#evaluation-order" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-85">Python は、式を左から右へと順に評価します。ただし、代入式を評価するときは、代入演算子の右側項が左側項よりも先に評価されます。</p>
<p>以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-precedence">
<span id="operator-summary"></span><h2>6.16. 演算子の優先順位<a class="headerlink" href="#operator-precedence" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-86">以下の表は Python における演算子の優先順位を要約したものです。優先順位の最も低い (結合が最も弱い) ものから最も高い (結合が最も強い) ものに並べてあります。同じボックス内の演算子の優先順位は同じです。構文が明示的に示されていないものは二項演算子です。同じボックス内の演算子は、左から右へとグループ化されます (例外として、べき乗は右から左にグループ化されます)。</p>
<p><a class="reference internal" href="#comparisons"><span class="std std-ref">比較</span></a> で述べられているように、比較、帰属、同一性のテストは全てが同じ優先順位を持っていて、左から右に連鎖する特徴を持っていることに注意してください。</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算子</th>
<th class="head">説明</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a></td>
<td>ラムダ式</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> – <a class="reference internal" href="compound_stmts.html#else"><code class="xref std std-keyword docutils literal"><span class="pre">else</span></code></a></td>
<td>条件式</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a></td>
<td>ブール演算 OR</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a></td>
<td>ブール演算 AND</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> <code class="docutils literal"><span class="pre">x</span></code></td>
<td>ブール演算 NOT</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal"><span class="pre">&lt;</span></code>,
<code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">==</span></code></td>
<td>帰属や同一性のテストを含む比較</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">|</span></code></td>
<td>ビット単位 OR</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">^</span></code></td>
<td>ビット単位 XOR</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&amp;</span></code></td>
<td>ビット単位 AND</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code></td>
<td>シフト演算</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code></td>
<td>加算および減算</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">&#64;</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">//</span></code>, <code class="docutils literal"><span class="pre">%</span></code></td>
<td>Multiplication, matrix
multiplication, division, floor
division, remainder <a class="footnote-reference" href="#id21" id="id15">[5]</a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">+x</span></code>, <code class="docutils literal"><span class="pre">-x</span></code>, <code class="docutils literal"><span class="pre">~x</span></code></td>
<td>正数、負数、ビット単位 NOT</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">**</span></code></td>
<td>べき乗 <a class="footnote-reference" href="#id22" id="id16">[6]</a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">await</span></code> <code class="docutils literal"><span class="pre">x</span></code></td>
<td>Await 式</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x[index]</span></code>, <code class="docutils literal"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal"><span class="pre">x.attribute</span></code></td>
<td>添字指定、スライス操作、呼び出し、属性参照</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">(expressions...)</span></code>,
<code class="docutils literal"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal"><span class="pre">{expressions...}</span></code></td>
<td>式結合またはタプル表示、リスト表示、辞書表示、集合表示</td>
</tr>
</tbody>
</table>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[1]</a></td><td><code class="docutils literal"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> は数学的には真となりますが、浮動小数点に対する演算の場合には、値丸め (roundoff) のために数値計算的に真にならない場合があります。例えば、Python の浮動小数点型が IEEE754 倍精度数型になっているプラットフォームを仮定すると、 <code class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> は <code class="docutils literal"><span class="pre">1e100</span></code> と同じ符号になるはずなのに、計算結果は <code class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code> となります。これは数値計算的には厳密に <code class="docutils literal"><span class="pre">1e100</span></code> と等価です。関数 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal"><span class="pre">math.fmod()</span></code></a> は、最初の引数と符号が一致するような値を返すので、上記の場合には <code class="docutils literal"><span class="pre">-1e-100</span></code> を返します。どちらのアプローチが適切かは、アプリケーションに依存します。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[2]</a></td><td>x が y の正確な整数倍に非常に近いと、丸めのために <code class="docutils literal"><span class="pre">x//y</span></code> が <code class="docutils literal"><span class="pre">(x-x%y)//y</span></code> よりも 1 だけ大きくなる可能性があります。そのような場合、Python は <code class="docutils literal"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> が <code class="docutils literal"><span class="pre">x</span></code> に非常に近くなるという関係を保つために、後者の値を返します。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[3]</a></td><td><p class="first">Unicode 標準では、 <em class="dfn">コードポイント (code point)</em> (例えば、U+0041) と <em class="dfn">抽象文字 (abstract character)</em> (例えば、&quot;LATIN CAPITAL LETTER A&quot;) を区別します。
Unicode のほとんどの抽象文字は 1 つのコードポイントだけを使って表現されますが、複数のコードポイントの列を使っても表現できる抽象文字もたくさんあります。
例えば、抽象文字 &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot; はコード位置 U+00C7 にある <em class="dfn">合成済み文字 (precomposed character)</em> 1 つだけでも表現できますし、コード位置 U+0043 (LATIN CAPITAL LETTER C) にある <em class="dfn">基底文字 (base character)</em> の後ろに、コード位置 U+0327 (COMBINING CEDILLA) にある <em class="dfn">結合文字 (combining character)</em> が続く列としても表現できます。</p>
<p>The comparison operators on strings compare at the level of Unicode code
points. This may be counter-intuitive to humans.  For example,
<code class="docutils literal"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, even though both strings
represent the same abstract character &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot;.</p>
<p class="last">抽象文字のレベルで (つまり、人間にとって直感的な方法で) 文字列を比較するには <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal"><span class="pre">unicodedata.normalize()</span></code></a> を使ってください。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td>自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のために、インスタンスメソッドや定数の比較を行うようなときに <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> 演算子の利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞれのドキュメントを確認してください。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[5]</a></td><td><code class="docutils literal"><span class="pre">%</span></code> 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[6]</a></td><td>べき乗演算子 <code class="docutils literal"><span class="pre">**</span></code> はその右側にある単項演算子かビット単位演算子よりも優先して結合します。つまり <code class="docutils literal"><span class="pre">2**-1</span></code> は <code class="docutils literal"><span class="pre">0.5</span></code> になります。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. 式 (expression)</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. 算術変換 (arithmetic conversion)</a></li>
<li><a class="reference internal" href="#atoms">6.2. アトム、原子的要素 (atom)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. 識別子 (identifier、または名前 (name))</a></li>
<li><a class="reference internal" href="#literals">6.2.2. リテラル</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. 丸括弧形式 (parenthesized form)</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. リスト、集合、辞書の表示</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. リスト表現</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. 集合表現</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. 辞書表現</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. ジェネレータ式</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Yield 式</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. ジェネレータ-イテレータメソッド</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. 使用例</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. 非同期ジェネレータ関数 (asynchronous generator function)</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. Asynchronous generator-iterator methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. プライマリ</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. 属性参照</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. 添字表記 (subscription)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. スライス表記 (slicing)</a></li>
<li><a class="reference internal" href="#calls">6.3.4. 呼び出し (call)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Await 式</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. べき乗演算 (power operator)</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. 単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. 二項算術演算 (binary arithmetic operation)</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. シフト演算 (shifting operation)</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. ビット単位演算の二項演算 (binary bitwise operation)</a></li>
<li><a class="reference internal" href="#comparisons">6.10. 比較</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. 値の比較</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. 帰属検査演算</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. 同一性の比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. ブール演算 (boolean operation)</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.12. 条件式 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#lambda">6.13. ラムダ (lambda)</a></li>
<li><a class="reference internal" href="#expression-lists">6.14. 式のリスト</a></li>
<li><a class="reference internal" href="#evaluation-order">6.15. 評価順序</a></li>
<li><a class="reference internal" href="#operator-precedence">6.16. 演算子の優先順位</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="import.html"
                        title="前の章へ">5. インポートシステム</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="次の章へ">7. 単純文 (simple statement)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/expressions.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 1月 22, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>