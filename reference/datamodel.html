<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. データモデル &#8212; Python 3.6.1 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.1 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python 言語リファレンス" href="index.html" />
    <link rel="next" title="4. 実行モデル" href="executionmodel.html" />
    <link rel="prev" title="2. 字句解析" href="lexical_analysis.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/reference/datamodel.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/reference/datamodel.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 字句解析"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="data-model">
<span id="datamodel"></span><h1>3. データモデル<a class="headerlink" href="#data-model" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="objects-values-and-types">
<span id="objects"></span><h2>3.1. オブジェクト、値、および型<a class="headerlink" href="#objects-values-and-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-0">Python における <em class="dfn">オブジェクト (object)</em> とは、データを抽象的に表したものです。Python プログラムにおけるデータは全て、オブジェクトまたはオブジェクト間の関係として表されます。(ある意味では、プログラムコードもまたオブジェクトとして表されます。これはフォン・ノイマン: Von Neumann の &#8220;プログラム記憶方式コンピュータ: stored program computer&#8221; のモデルに適合します。)</p>
<span class="target" id="index-1"></span><p>すべての属性は、同一性 (identity)、型、値をもっています。 <em>同一性</em> は生成されたあとは変更されません。これはオブジェクトのアドレスのようなものだと考えられるかもしれません。 &#8216;<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a>&#8216; 演算子は2つのオブジェクトの同一性を比較します。 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a> 関数は同一性を表す整数を返します。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> CPython では、<code class="docutils literal"><span class="pre">id(x)</span></code> は <code class="docutils literal"><span class="pre">x</span></code> が格納されているメモリ上のアドレスを返します。</p>
</div>
<p>オブジェクトの型はオブジェクトがサポートする操作 (例: <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> をサポートするか) と、オブジェクトが取りうる値を決定します。 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> 関数はオブジェクトの型 (型自体もオブジェクトです) を返します。同一性と同じく、オブジェクトの型(<em class="dfn">type</em>) も変更不可能です。 <a class="footnote-reference" href="#id8" id="id1">[1]</a></p>
<p>オブジェクトによっては <em>値</em> を変更することが可能です。値を変更できるオブジェクトのことを <em>mutable</em> と呼びます。生成後に値を変更できないオブジェクトのことを <em>immutable</em> と呼びます。(mutable なオブジェクトへの参照を格納している immutableなコンテナオブジェクトの値は、その格納しているオブジェクトの値が変化した時に変化しますが、コンテナがどのオブジェクトを格納しているのかが変化しないのであれば immutable だと考えることができます。したがって、immutable かどうかは値が変更可能かどうかと完全に一致するわけではありません) オブジェクトが mutable かどうかはその型によって決まります。例えば、数値型、文字列型とタプル型のインスタンスは immutable で、dict や list は mutable です。</p>
<p id="index-2">オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不能 (unreachable) になると、ガベージコレクション (garbage-collection) によって処理されます。実装では、ごみ収集を遅らせたり、全く行わないようにすることができます &#8212; 到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装するかは実装品質の問題です。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 現在の CPython 実装では参照カウント(reference-counting) 方式を使っており、(オプションとして) 循環参照を行っているごみオブジェクトを遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができますが、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけではありません。循環参照を持つごみオブジェクト収集の制御については、 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> モジュールを参照してください。 CPython以外の実装は別の方式を使っており、CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不能になったときに即座に終了処理されることに頼らないでください (ですからファイルは必ず明示的に閉じてください)。</p>
</div>
<p>実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまうようなオブジェクトを生存させることがあるので注意してください。また、 &#8216;<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a>&#8216; 文を使って例外を捕捉できるようにすると、オブジェクトを生存させることがあります。</p>
<p>オブジェクトには、開かれたファイルやウィンドウといった、 &#8220;外部 (external) の&#8221; リソースへの参照を含むものがあります。これらのリソースは、オブジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行われる保証はないので、こうしたオブジェクトは外部リソースを明示的に解放する方法、大抵は <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> メソッドも提供しています。こうしたオブジェクトは明示的に close するよう強く奨めます。この操作をする際には、&#8217;<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>...<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a>&#8216; 文や、 &#8216;<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; 文を使うと便利です。</p>
<p id="index-3">他のオブジェクトに対する参照をもつオブジェクトもあります; これらは <em>コンテナ (container)</em> と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、および辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のことを指し、それらオブジェクトのアイデンティティではありません; しかしながら、コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェクトのアイデンティティのことを指します。したがって、 (タプルのように) 変更不能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化するのは変更可能なオブジェクトが変更された時、ということになります。</p>
<p>型はオブジェクトの動作のほとんど全てに影響します。オブジェクトのアイデンティティが重要かどうかでさえ、ある意味では型に左右されます: 変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェクトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作は起こりえません。例えば、 <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> とすると、 <code class="docutils literal"><span class="pre">a</span></code> と <code class="docutils literal"><span class="pre">b</span></code> は値 1 を持つ同じオブジェクトを参照するときもあるし、そうでないときもあります。これは実装に依存します。しかし、 <code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> とすると、 <code class="docutils literal"><span class="pre">c</span></code> と <code class="docutils literal"><span class="pre">d</span></code> はそれぞれ二つの異なった、互いに一意な、新たに作成された空のリストを参照することが保証されています。 (<code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> とすると、 <code class="docutils literal"><span class="pre">c</span></code> と <code class="docutils literal"><span class="pre">d</span></code> の両方に同じオブジェクトを代入します)</p>
</div>
<div class="section" id="the-standard-type-hierarchy">
<span id="types"></span><h2>3.2. 標準型の階層<a class="headerlink" href="#the-standard-type-hierarchy" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">以下は Python に組み込まれている型のリストです。(実装によって、C、Java、またはその他の言語で書かれた) 拡張モジュールで、その他の型が定義されていることがあります。新たな型 (有理数や、整数を効率的に記憶する配列、など) の追加は、たいてい標準ライブラリを通して提供されますが、将来のバージョンの Python では、型の階層構造にこのような追加がなされるかもしれません。</p>
<p id="index-5">以下に説明する型のいくつかには、 &#8216;特殊属性 (special attribute)&#8217; を列挙した段落があります。これらの属性は実装へのアクセス手段を提供するもので、一般的な用途に利用するためのものではありません。特殊属性の定義は将来変更される可能性があります。</p>
<dl class="docutils">
<dt>None</dt>
<dd><p class="first last" id="index-6">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 <code class="docutils literal"><span class="pre">None</span></code> でアクセスされます。このオブジェクトは、様々な状況で値が存在しないことをしめします。例えば、明示的に値を返さない関数は <code class="docutils literal"><span class="pre">None</span></code> を返します。 <code class="docutils literal"><span class="pre">None</span></code> の真値 (truth value) は偽 (false) です。</p>
</dd>
<dt>NotImplemented</dt>
<dd><p class="first" id="index-7">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトは組み込み名 <code class="docutils literal"><span class="pre">NotImplemented</span></code> でアクセスされます。数値演算に関するメソッドや拡張比較 (rich comparison) メソッドは、被演算子が該当する演算を行うための実装をもたない場合、この値を返すべきです。(演算子によっては、インタプリタが関連のある演算を試したり、他の代替操作を行います。) 真値は真 (true) です。</p>
<p class="last">詳細は <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">算術演算の実装</span></a> を参照してください。</p>
</dd>
<dt>Ellipsis</dt>
<dd><p class="first last" id="index-8">この型には単一の値しかありません。この値を持つオブジェクトはただ一つしか存在しません。このオブジェクトはリテラル <code class="docutils literal"><span class="pre">...</span></code> または組み込み名 <code class="docutils literal"><span class="pre">Ellipsis</span></code> でアクセスされます。真理値は真 (true)です。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal"><span class="pre">numbers.Number</span></code></a></dt>
<dd><p class="first" id="index-9">数値リテラルによって作成されたり、算術演算や組み込みの算術関数によって返されるオブジェクトです。数値オブジェクトは変更不能です; 一度値が生成されると、二度と変更されることはありません。Python の数値オブジェクトはいうまでもなく数学で言うところの数値と強く関係していますが、コンピュータ内で数値を表現する際に伴う制限を受けています。</p>
<p>Python は整数、浮動小数点数、複素数の間で区別を行っています:</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></code></a> (整数)</dt>
<dd><p class="first" id="index-10">整数型は、整数(正の数および負の数)を表す数学的集合内における要素を表現する型です。</p>
<p>整数には 2 種類あります:</p>
<p>整数 (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>)</p>
<blockquote>
<div><p>無制限の範囲の数を表現しますが、利用可能な (仮想) メモリサイズの制限のみを受けます。シフト演算やマスク演算のために2進数表現を持つと想定されます。負の数は符号ビットが左に無限に延びているような錯覚を与える 2 の補数表現の変型で表されます。</p>
</div></blockquote>
<dl class="docutils">
<dt>ブール値 (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a>)</dt>
<dd><p class="first last" id="index-11">真偽値の False と True を表します。<code class="docutils literal"><span class="pre">False</span></code> と <code class="docutils literal"><span class="pre">True</span></code> を表す 2 つのオブジェクトのみがブール値オブジェクトです。ブール型は整数型の派生型であり、ほとんどの状況でそれぞれ 0 と 1 のように振る舞いますが、例外として文字列に変換されたときはそれぞれ <code class="docutils literal"><span class="pre">&quot;False&quot;</span></code> および <code class="docutils literal"><span class="pre">&quot;True&quot;</span></code> という文字列が返されます。</p>
</dd>
</dl>
<p class="last" id="index-12">整数表現に関する規則は、負の整数を含むシフト演算やマスク演算において、最も有意義な解釈ができるように意図されています。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) (実数)</dt>
<dd><p class="first last" id="index-13">この型は計算機レベルの倍精度浮動小数点数を表現します。表現可能な値の範囲やオーバーフローの扱いは計算機のアーキテクチャ（および、CやJavaによる実装）に従います。Pythonは単精度浮動小数点数をサポートしません。一般的に単精度浮動小数点数を使う理由はプロセッサーとメモリの使用を節約するためと説明されます。しかし、こうした節約はPythonでオブジェクトを扱う際のオーバーヘッドに比べれば微々たるものです。また、2種類の浮動小数点数型を持つことで複雑になる理由はありません。</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a>)</dt>
<dd><p class="first last" id="index-14">この型は、計算機レベルで倍精度とされている浮動小数点を 2 つ一組にして複素数を表現します。浮動小数点について述べたのと同じ性質が当てはまります。複素数 <code class="docutils literal"><span class="pre">z</span></code> の実数部および虚数部は、それぞれ読み出し専用属性 <code class="docutils literal"><span class="pre">z.real</span></code> および <code class="docutils literal"><span class="pre">z.imag</span></code> で取り出すことができます。</p>
</dd>
</dl>
</dd>
<dt>シーケンス型 (sequence)</dt>
<dd><p class="first" id="index-15">この型は、有限の順序集合 (ordered set) を表現します。要素は非負の整数でインデクス化されています。組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> を使うと、シーケンスの要素数を返します。シーケンスの長さが <em>n</em> の場合、インデクスは 0, 1, ..., <em>n</em> -1 からなる集合です。シーケンス <em>a</em> の要素 <em>i</em> は <code class="docutils literal"><span class="pre">a[i]</span></code> で選択します。</p>
<p id="index-16">シーケンスはスライス操作 (slice) もサポートしています: <code class="docutils literal"><span class="pre">a[i:j]</span></code> とすると、 <em>i</em> <code class="docutils literal"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal"><span class="pre">&lt;</span></code> <em>j</em> であるインデクス <em>k</em> をもつ全ての要素を選択します。式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを表します。新たなシーケンス内では、インデクス集合が 0 から始まるようにインデクスの値を振りなおします。</p>
<p>シーケンスによっては、第三の &#8220;ステップ (step)&#8221; パラメタを持つ &#8220;拡張スライス (extended slice)&#8221; もサポートしています: <code class="docutils literal"><span class="pre">a[i:j:k]</span></code> は、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal"><span class="pre">&gt;=</span></code> <code class="docutils literal"><span class="pre">0</span></code> かつ <em>i</em> <code class="docutils literal"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal"><span class="pre">&lt;</span></code> <em>j</em> であるようなインデクス <em>x</em> を持つような <em>a</em> 全ての要素を選択します。</p>
<p>シーケンスは、変更可能なものか、そうでないかで区別されています:</p>
<dl class="last docutils">
<dt>変更不能なシーケンス (immutable sequence)</dt>
<dd><p class="first" id="index-17">変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を変更することができません。 (オブジェクトに他のオブジェクトへの参照が入っている場合、参照されているオブジェクトは変更可能なオブジェクトでもよく、その値は変更される可能性があります; しかし、変更不能なオブジェクトが直接参照しているオブジェクトの集合自体は、変更することができません。)</p>
<p>以下の型は変更不能なシーケンス型です:</p>
<dl class="last docutils" id="index-18">
<dt>文字列型 (string)</dt>
<dd><p class="first last" id="index-19">文字列はUnicodeコードポイントを表現する値の配列です。文字列中のどのコードポイントも <code class="docutils literal"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> の範囲で表現されることができます。Pythonは <code class="xref c c-type docutils literal"><span class="pre">char</span></code> 型を持ちません。代わりに、文字列中のどのコードポイントも長さ &#8216;&#8216;1&#8217;&#8217; の文字列オブジェクトとして表現することができます。組み込み関数 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> は文字列形式を0 - 10FFFFの範囲の整数に変換します。また、組み込み関数 <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal"><span class="pre">chr()</span></code></a> は <code class="docutils literal"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> の範囲の整数を対応する長さ <code class="docutils literal"><span class="pre">1</span></code> の文字列に変換します。<a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a> はテキストエンコーディングを使うことで <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> を <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> に変換するために使うことができます。また、<a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a> によりその逆が実行することができます。</p>
</dd>
<dt>タプル型 (tuple)</dt>
<dd><p class="first last" id="index-20">タプルの要素は任意の Python オブジェクトです。二つ以上の要素からなるタプルは、個々の要素を表現する式をカンマで区切って構成します。単一の要素からなるタプル (単集合 &#8216;singleton&#8217;) を作るには、要素を表現する式の直後にカンマをつけます (単一の式だけではタプルを形成しません。これは、式をグループ化するのに丸括弧を使えるようにしなければならないからです)。要素の全くない丸括弧の対を作ると空のタプルになります。</p>
</dd>
<dt>bytes</dt>
<dd><p class="first last" id="index-21">bytes オブジェクトは不変な配列です。要素は 8-bit バイトで、 0 &lt;= x &lt; 256 の範囲の整数で表現されます。 (<code class="docutils literal"><span class="pre">b'abc'</span></code> のような) bytes リテラルや組み込み関数の <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-func docutils literal"><span class="pre">bytes()</span></code></a> を使って bytes オブジェクトを作成できます。また、 bytes オブジェクトは <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a> メソッドを通して文字列にデコードできます。</p>
</dd>
</dl>
</dd>
<dt>変更可能なシーケンス型 (mutable sequence)</dt>
<dd><p class="first" id="index-22">変更可能なシーケンスは、作成した後で変更することができます。変更可能なシーケンスでは、添字表記やスライス表記を使って指定された要素に代入を行うことができ、 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> (delete) 文を使って要素を削除することができます。</p>
<p>Python に最初から組み込まれている変更可能なシーケンス型は、今のところ二つです:</p>
<dl class="docutils">
<dt>リスト型 (list)</dt>
<dd><p class="first last" id="index-23">リストの要素は任意の Python オブジェクトにできます。リストは、角括弧の中にカンマで区切られた式を並べて作ります。 (長さが 0 や 1 のシーケンスを作るために特殊な場合分けは必要ないことに注意してください。)</p>
</dd>
<dt>バイト配列</dt>
<dd><p class="first last" id="index-24">bytearray オブジェクトは変更可能な配列です。組み込みの <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal"><span class="pre">bytearray()</span></code></a> コンストラクタによって作成されます。変更可能なことを除けば (つまりハッシュ化できない)、 byte array は変更不能な bytes オブジェクトと同じインターフェースと機能を提供します。</p>
</dd>
</dl>
<p class="last" id="index-25">拡張モジュール <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> や、 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールには、さらなるミュータブルなシーケンス型の例があります。</p>
</dd>
</dl>
</dd>
<dt>集合型</dt>
<dd><p class="first" id="index-26">集合型は、順序のない、ユニークで不変なオブジェクトの有限集合を表現します。そのため、(配列の)添字を使ったインデックスアクセスはできません。ただし、イテレートは可能で、組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> は集合の要素数を返します。集合型の一般的な使い方は、集合に属しているかの高速なテスト、シーケンスからの重複の排除、共通集合・和集合・差・対称差といった数学的な演算の計算です。</p>
<p>集合の要素には、辞書のキーと同じ普遍性に関するルールが適用されます。数値型は通常の数値比較のルールに従うことに注意してください。もし2つの数値の比較結果が同値である(例えば、 <code class="docutils literal"><span class="pre">1</span></code> と <code class="docutils literal"><span class="pre">1.0</span></code>)なら、そのうちの1つのみを集合に含めることができます。</p>
<p>現在、2つの組み込み集合型があります:</p>
<dl class="last docutils">
<dt>集合型</dt>
<dd><p class="first last" id="index-27">可変な集合型です。組み込みの <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal"><span class="pre">set()</span></code></a> コンストラクタで作成され、後から <a class="reference internal" href="../library/stdtypes.html#set.add" title="set.add"><code class="xref py py-meth docutils literal"><span class="pre">add()</span></code></a> などのいくつかのメソッドで更新できます。</p>
</dd>
<dt>Frozen set 型</dt>
<dd><p class="first last" id="index-28">不変な集合型です。組み込みの <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal"><span class="pre">frozenset()</span></code></a> コンストラクタによって作成されます。 frozenset は不変でハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>)なので、別の集合型の要素になったり、辞書のキーにすることができます。</p>
</dd>
</dl>
</dd>
<dt>マッピング型 (mapping)</dt>
<dd><p class="first" id="index-29">任意のインデクス集合でインデクス化された、オブジェクトからなる有限の集合を表現します。添字表記 <code class="docutils literal"><span class="pre">a[k]</span></code> は、 <code class="docutils literal"><span class="pre">k</span></code> でインデクス指定された要素を <code class="docutils literal"><span class="pre">a</span></code> から選択します; 選択された要素は式の中で使うことができ、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> 文の対象にすることができます。組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> は、マッピング内の要素数を返します。</p>
<p>Python に最初から組み込まれているマッピング型は、今のところ一つだけです:</p>
<dl class="last docutils">
<dt>辞書型 (dictionary)</dt>
<dd><p class="first" id="index-30">ほぼ任意の値でインデクスされたオブジェクトからなる有限の集合を表します。
キー (key) として使えない値の唯一の型は、リストや辞書、そしてオブジェクトの同一性でなく値で比較されるその他の変更可能な型です。
これは、辞書型を効率的に実装する上で、キーのハッシュ値が不変である必要があるためです。
数値型をキーに使う場合、キー値は通常の数値比較における規則に従います: 二つの値が等しくなる場合 (例えば <code class="docutils literal"><span class="pre">1</span></code> と <code class="docutils literal"><span class="pre">1.0</span></code>)、互いに同じ辞書のエントリを表すインデクスとして使うことができます。</p>
<p>辞書は変更可能な型です; 辞書は <code class="docutils literal"><span class="pre">{...}</span></code> 表記で生成します (<a class="reference internal" href="expressions.html#dict"><span class="std std-ref">辞書表現</span></a> を参照してください)。</p>
<p class="last" id="index-31">拡張モジュール <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">dbm.ndbm</span></code></a> 、 <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">dbm.gnu</span></code></a> は、 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールのように、別のマッピング型の例を提供しています。</p>
</dd>
</dl>
</dd>
<dt>呼び出し可能型 (callable type)</dt>
<dd><p class="first" id="index-32">関数呼び出し操作 (<a class="reference internal" href="expressions.html#calls"><span class="std std-ref">呼び出し (call)</span></a> 参照) を行うことができる型です:</p>
<dl class="last docutils">
<dt>ユーザ定義関数 (user-defined function)</dt>
<dd><p class="first" id="index-33">ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます (<a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> 参照)。関数は、仮引数 (formal parameter) リストと同じ数の要素が入った引数リストとともに呼び出されます。</p>
<p>特殊属性:</p>
<table border="1" class="docutils" id="index-34">
<colgroup>
<col width="37%" />
<col width="46%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">属性</p>
</th>
<th class="head"><p class="first last">意味</p>
</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code></td>
<td><p class="first last">関数のドキュメンテーション文字列です。ドキュメンテーションがない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。サブクラスに継承されません</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a></td>
<td><p class="first last">関数の名前です</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal"><span class="pre">__qualname__</span></code></a></td>
<td><p class="first">関数の <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a> です</p>
<div class="last versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code></td>
<td><p class="first last">関数が定義されているモジュールの名前です。モジュール名がない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__defaults__</span></code></td>
<td><p class="first last">デフォルト値を持つ引数に対するデフォルト値が収められたタプルで、デフォルト値を持つ引数がない場合には <code class="docutils literal"><span class="pre">None</span></code> になります</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">__code__</span></code></td>
<td><p class="first last">コンパイルされた関数本体を表現するコードオブジェクトです。</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__globals__</span></code></td>
<td><p class="first last">関数のグローバル変数の入った辞書 (への参照) です &#8212; この辞書は、関数が定義されているモジュールのグローバルな名前空間を決定します。</p>
</td>
<td><p class="first last">読み込み専用</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a></td>
<td><p class="first last">任意の関数属性をサポートするための名前空間が収められています。</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__closure__</span></code></td>
<td><p class="first last"><code class="docutils literal"><span class="pre">None</span></code> または関数の個々の自由変数 (引数以外の変数) に対して値を結び付けているセル (cell) 群からなるタプルになります。</p>
</td>
<td><p class="first last">読み込み専用</p>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-attr docutils literal"><span class="pre">__annotations__</span></code></td>
<td><p class="first last">パラメータの注釈が入った辞書です。辞書のキーはパラメータ名で、返り値の注釈がある場合は、<code class="docutils literal"><span class="pre">'return'</span></code> がそのキーとなります。</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-attr docutils literal"><span class="pre">__kwdefaults__</span></code></td>
<td><p class="first last">キーワード専用パラメータのデフォルト値を含む辞書です。</p>
</td>
<td><p class="first last">書き込み可能</p>
</td>
</tr>
</tbody>
</table>
<p>「書き込み可能」とラベルされている属性のほとんどは、代入された値の型をチェックします。</p>
<p>関数オブジェクトはまた、任意の属性を設定したり取得したりできます。この機能は、例えば関数にメタデータを付与したい場合などに使えます。関数の get や set には、通常のドット表記を使います。 <em>現在の実装では、ユーザ定義の関数でのみ属性をサポートしているので注意して下さい。組み込み関数の属性は将来サポートする予定です。</em></p>
<p class="last">関数定義に関するその他の情報は、関数のコードオブジェクトから得られます; 後述の内部型 (internal type) に関する説明を参照してください。</p>
</dd>
<dt>インスタンスメソッド</dt>
<dd><p class="first" id="index-35">インスタンスメソッドオブジェクトは、クラス、クラスインスタンスと任意の呼び出し可能オブジェクト (通常はユーザ定義関数) を結びつけます。</p>
<p id="index-36">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> はクラスインスタンスオブジェクトで、 <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> は関数オブジェクトです;
<code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> はメソッドのドキュメンテーション文字列 (<code class="docutils literal"><span class="pre">__func__.__doc__</span></code> と同じ) です;
<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> はメソッドの名前 (<code class="docutils literal"><span class="pre">__func__.__name__</span></code> と同じ) です;
<code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> はメソッドが定義されたモジュールの名前か、モジュール名がない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
<p>メソッドもまた、根底にある関数オブジェクトの任意の関数属性に (値の設定はできませんが) アクセスできます。</p>
<p>クラスの属性を (場合によってはそのクラスのインスタンスを介して) 取得するとき、その属性がユーザ定義の関数オブジェクトまたはクラスメソッドオブジェクトであれば、ユーザ定義メソッドオブジェクトが生成されることがあります。</p>
<p>クラスからインスタンスを経由してユーザ定義関数オブジェクトを取得することによってインスタンスメソッドオブジェクトが生成されたとき、 <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> 属性はそのインスタンスで、このメソッドオブジェクトは束縛されている (bound) といいます。新しいメソッドの <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> 属性はもとの関数オブジェクトです。</p>
<p>クラスやインスタンスから他のメソッドオブジェクトを取得することによってユーザ定義メソッドオブジェクトが生成されたとき、その動作は関数オブジェクトの場合と同様ですが、新しいインスタンスの <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> 属性はもとのメソッドオブジェクトではなく、その <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> 属性です。</p>
<p>クラスやインスタンスからクラスメソッドオブジェクトを取得することによってインスタンスメソッドオブジェクトが生成されたとき、 <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> 属性はクラスそのもので、 <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> 属性はクラスメソッドの根底にある関数オブジェクトです。</p>
<p>インスタンスメソッドオブジェクトが呼び出される際、根底にある関数 (<code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code>) が呼び出されます。このとき、クラスインスタンス (<code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code>) が引数リストの先頭に挿入されます。例えば、 <code class="xref py py-class docutils literal"><span class="pre">C</span></code> を関数 <code class="xref py py-meth docutils literal"><span class="pre">f()</span></code> の定義を含むクラス、 <code class="docutils literal"><span class="pre">x</span></code> を <code class="xref py py-class docutils literal"><span class="pre">C</span></code> のインスタンスとすると、 <code class="docutils literal"><span class="pre">x.f(1)</span></code> の呼び出しは <code class="docutils literal"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code> の呼び出しと同じです。</p>
<p>クラスメソッドオブジェクトからインスタンスメソッドオブジェクトが導出される際、 <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> に記憶されている &#8220;クラスインスタンス&#8221; は実際はクラスそのものなので、 <code class="docutils literal"><span class="pre">x.f(1)</span></code> や <code class="docutils literal"><span class="pre">C.f(1)</span></code> の呼び出しは、根底にある関数を <code class="docutils literal"><span class="pre">f</span></code> として <code class="docutils literal"><span class="pre">f(C,1)</span></code> の呼び出しと等価です。</p>
<p class="last">なお、関数オブジェクトからインスタンスメソッドオブジェクトへの変換は、インスタンスから属性が取り出されるたびに行われます。場合によっては、属性をローカル変数に代入しておき、そのローカル変数を呼び出すようにするのが効果的な最適化になります。また、上記の変換はユーザ定義関数に対してのみ行われます; その他の呼び出し可能オブジェクト (および呼び出し可能でない全てのオブジェクト) は、変換されずに取り出されます。それから、クラスインスタンスの属性になっているユーザ定義関数は、束縛メソッドに変換されません; 変換されるのは、関数がクラスの属性である場合 <em>だけ</em> です。</p>
</dd>
<dt>ジェネレータ関数 (generator function)</dt>
<dd><p class="first last" id="index-37"><a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文 (<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">yield 文</span></a> の節を参照) を使う関数もしくはメソッドを <em class="dfn">ジェネレータ関数</em> と呼びます。そのような関数が呼び出されたときは常に、関数の本体を実行するのに使えるイテレータオブジェクトを返します: イテレータの <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">iterator.__next__()</span></code></a> メソッドを呼び出すと、 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文を使って値が提供されるまで関数を実行します。関数の <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文を実行するか終端に達したときは、 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外が送出され、イテレータが返すべき値の最後まで到達しています。</p>
</dd>
<dt>コルーチン関数 (coroutine function)</dt>
<dd><p class="first last" id="index-38"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> を使用して定義された関数やメソッドを <em class="dfn">コルーチン関数 (coroutine function)</em> と呼びます。
呼び出された時、そのような関数は <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> オブジェクトを返します。
コルーチン関数は <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">with</span></code></a> や <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> 文だけでなく <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal"><span class="pre">await</span></code></a> 式を持つことが出来ます。
<a class="reference internal" href="#coroutine-objects"><span class="std std-ref">コルーチンオブジェクト</span></a> を参照してください。</p>
</dd>
<dt>Asynchronous generator functions</dt>
<dd><p class="first" id="index-39">A function or method which is defined using <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> and
which uses the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> statement is called a
<em class="dfn">asynchronous generator function</em>.  Such a function, when called,
returns an asynchronous iterator object which can be used in an
<a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> statement to execute the body of the function.</p>
<p class="last">Calling the asynchronous iterator&#8217;s <code class="xref py py-meth docutils literal"><span class="pre">aiterator.__anext__()</span></code> method
will return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> which when awaited
will execute until it provides a value using the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a>
expression.  When the function executes an empty <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a>
statement or falls off the end, a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopAsyncIteration</span></code></a> exception
is raised and the asynchronous iterator will have reached the end of
the set of values to be yielded.</p>
</dd>
<dt>組み込み関数 (built-in function)</dt>
<dd><p class="first last" id="index-40">組み込み関数オブジェクトはC関数へのラッパーです。
組み込み関数の例は <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> や <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> は標準の組み込みモジュール) です。
引数の数や型は C 関数で決定されています。
読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> は関数のドキュメンテーション文字列です。
ドキュメンテーションがない場合は <code class="docutils literal"><span class="pre">None</span></code> になります;
<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> は関数の名前です;
<code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> は <code class="docutils literal"><span class="pre">None</span></code> に設定されています (組み込みメソッドの節も参照してください);
<code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> は、関数が定義されているモジュールの名前です。
モジュール名がない場合は <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
</dd>
<dt>組み込みメソッド (built-in method)</dt>
<dd><p class="first last" id="index-41">実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には C 関数に渡される何らかのオブジェクトを非明示的な外部引数として持っています。組み込みメソッドの例は、 <em>alist</em> をリストオブジェクトとしたときの <code class="docutils literal"><span class="pre">alist.append()</span></code> です。この場合には、読み出し専用の属性 <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> は <em>alist</em> で表されるオブジェクトになります。</p>
</dd>
<dt>クラス</dt>
<dd><p class="first last">クラスは呼び出し可能です。そのオブジェクトは通常、そのクラスの新たなインスタンスのファクトリとして振舞いますが、 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> をオーバーライドして、バリエーションを持たせることもできます。呼び出しに使われた引数は、 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> と、典型的な場合では <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> に渡され、新たなインスタンスの初期化に使われます。</p>
</dd>
<dt>クラスのインスタンス</dt>
<dd><p class="first last">任意のクラスのインスタンスは、クラスで <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドを定義することで呼び出し可能になります。</p>
</dd>
</dl>
</dd>
<dt>モジュール (module)</dt>
<dd><p class="first" id="index-42">モジュールは Python コードの基礎的な組織単位で、 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文あるいは <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">importlib.import_module()</span></code></a> や組み込みの <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> のような関数を呼び出すことで起動される <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a> によって作成されます (<a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> を参照)。モジュールオブジェクトは、辞書オブジェクト (これは、モジュール内で定義された関数の <code class="docutils literal"><span class="pre">__globals__</span></code> 属性から参照される辞書です) で実装された名前空間を持っています。属性の参照は、この辞書の検索に翻訳されます。例えば、 <code class="docutils literal"><span class="pre">m.x</span></code> は <code class="docutils literal"><span class="pre">m.__dict__[&quot;x&quot;]</span></code> と等価です。モジュールオブジェクトは、モジュールの初期化に使われるコードオブジェクトを含んでいません (初期化が終わればもう必要ないからです)。</p>
<p>属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。例えば、 <code class="docutils literal"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> は <code class="docutils literal"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code> と同じです。</p>
<p id="index-43">Predefined (writable) attributes: <a class="reference internal" href="import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> is the module&#8217;s name;
<code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> is the module&#8217;s documentation string, or <code class="docutils literal"><span class="pre">None</span></code> if
unavailable; <code class="xref py py-attr docutils literal"><span class="pre">__annotations__</span></code> (optional) is a dictionary containing
<a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> collected during module
body execution; <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a> is the pathname of the file from which the
module was loaded, if it was loaded from a file. The <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a>
attribute may be missing for certain types of modules, such as C modules
that are statically linked into the interpreter; for extension modules
loaded dynamically from a shared library, it is the pathname of the shared
library file.</p>
<p id="index-44">読み出し専用の特殊属性: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> はモジュールの名前空間で、辞書オブジェクトです。</p>
<div class="impl-detail last compound">
<p><strong>CPython 実装の詳細:</strong> CPython がモジュール辞書を削除する方法により、モジュール辞書が生きた参照を持っていたとしてもその辞書はモジュールがスコープから外れた時に削除されます。これを避けるには、辞書をコピーするか、辞書を直接使っている間モジュールを保持してください。</p>
</div>
</dd>
<dt>カスタムクラス型</dt>
<dd><p class="first">カスタムクラス型は通常、クラス定義 (<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">クラス定義</span></a> 参照) で生成されます。クラスは辞書オブジェクトで実装された名前空間を持っています。クラス属性の参照は、この辞書に対する探索 (lookup) に翻訳されます。例えば、 <code class="docutils literal"><span class="pre">C.x</span></code> は <code class="docutils literal"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> に翻訳されます (ただし、属性参照の意味を変えられる幾つかのフックがあります)。属性がこの探索で見つからないとき、その基底クラスで探索が続けられます。基底クラスのこの探索は、C3 メソッド解決順序 (MRO=method resolution order) を利用していて、複数の継承経路が共通の祖先につながる「ダイアモンド」継承構造があっても正しく動作します。 C3 MRO についてのより詳細な情報は、 2.3リリースに付属するドキュメント <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> にあります。</p>
<p id="index-45">クラス (<code class="xref py py-class docutils literal"><span class="pre">C</span></code> とします) 属性参照がクラスメソッドオブジェクトを返そうとするときには、 そのオブジェクトは <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> 属性が <code class="xref py py-class docutils literal"><span class="pre">C</span></code> であるようなインスタンスメソッドオブジェクトに変換されます。
静的メソッドオブジェクトを返そうとするときには、静的メソッドオブジェクトでラップされたオブジェクトに変換されます。
<a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> 節を参照すると、また別の理由でクラスから取り出した属性と実際に <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> に保存されているものが異なることがあるのが分かります。</p>
<p id="index-46">クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの辞書は更新しません。</p>
<p id="index-47">クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを生成します (下記を参照)。</p>
<p class="last" id="index-48">Special attributes: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> is the class name; <code class="xref py py-attr docutils literal"><span class="pre">__module__</span></code> is
the module name in which the class was defined; <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> is the
dictionary containing the class&#8217;s namespace; <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal"><span class="pre">__bases__</span></code></a> is a
tuple containing the base classes, in the order of their occurrence in the
base class list; <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> is the class&#8217;s documentation string,
or <code class="docutils literal"><span class="pre">None</span></code> if undefined; <code class="xref py py-attr docutils literal"><span class="pre">__annotations__</span></code> (optional) is a dictionary
containing <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> collected during
class body execution.</p>
</dd>
<dt>クラスインスタンス (class instance)</dt>
<dd><p class="first" id="index-49">クラスインスタンスは、クラスオブジェクト (上記参照) を呼び出して生成します。
クラスインスタンスは辞書で実装された名前空間を持っており、属性参照の時にはまずこの辞書が探索されます。
ここで属性が見つからず、インスタンスのクラスにその名前の属性があるときは、続けてクラス属性を検索します。
見つかったクラス属性がユーザ定義関数オブジェクトだった場合、クラスインスタンスを <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> 属性とするインスタンスメソッドオブジェクトに変換します。
静的メソッドオブジェクトやクラスメソッドオブジェクトも同様に変換されます;
上記の &#8220;クラス&#8221; を参照してください。
<a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> 節を参照すると、また別の理由でインスタンスを通してクラスから取り出した属性と実際に <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> に保存されているものが異なることがあるのが分かります。
クラス属性が見つからず、かつオブジェクトのクラスが <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドを持っている場合は、探索の義務を果たすためにこのメソッドが呼び出されます。</p>
<p id="index-50">属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの辞書を更新することはありません。クラスで <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> や <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal"><span class="pre">__delattr__()</span></code></a> メソッドが定義されている場合、直接インスタンスの辞書を更新する代わりにこれらのメソッドが呼び出されます。</p>
<p id="index-51">クラスインスタンスは、ある特定の名前のメソッドを持っている場合、数値型やシーケンス型、あるいはマップ型のように振舞うことができます。 <a class="reference internal" href="#specialnames"><span class="std std-ref">特殊メソッド名</span></a> を参照してください。</p>
<p class="last" id="index-52">特殊属性: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> は属性の辞書です; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal"><span class="pre">__class__</span></code></a> はインスタンスのクラスです。</p>
</dd>
<dt>I/O オブジェクト (ファイルオブジェクトの別名)</dt>
<dd><p class="first" id="index-53"><a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> は開かれたファイルを表します。ファイルオブジェクトを作るための様々なショートカットがあります: <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 組み込み関数、 <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">os.popen()</span></code></a> 、 <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">os.fdopen()</span></code></a> 、ソケットオブジェクトの <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a> メソッド (あるいは拡張モジュールから提供される他の関数やメソッド) 。</p>
<p class="last">オブジェクト <code class="docutils literal"><span class="pre">sys.stdin</span></code> 、 <code class="docutils literal"><span class="pre">sys.stdout</span></code> および <code class="docutils literal"><span class="pre">sys.stderr</span></code> は、インタプリタの標準入力、標準出力、および標準エラー出力ストリームに対応するファイルオブジェクトに初期化されます。これらはすべてテキストモードで開かれ、 <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.TextIOBase</span></code></a> 抽象クラスによって定義されたインタフェースに従います。</p>
</dd>
<dt>内部型 (internal type)</dt>
<dd><p class="first" id="index-54">インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。これらの定義は将来のインタプリタのバージョンでは変更される可能性がありますが、ここでは記述の完全性のために触れておきます。</p>
<dl class="docutils" id="index-55">
<dt>コードオブジェクト</dt>
<dd><p class="first">コードオブジェクトは <em>バイトコンパイルされた (byte-compiled)</em> 実行可能な Python コード、別名バイトコード(<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>) を表現します。コードオブジェクトと関数オブジェクトの違いは、関数オブジェクトが関数のグローバル変数 (関数を定義しているモジュールのグローバル) に対して明示的な参照を持っているのに対し、コードオブジェクトにはコンテキストがないということです; また、関数オブジェクトではデフォルト引数値を記憶できますが、コードオブジェクトではできません (実行時に計算される値を表現するため)。関数オブジェクトと違い、コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を (直接、間接に関わらず) 含みません。</p>
<p id="index-56">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">co_name</span></code> は関数名を表します; <code class="xref py py-attr docutils literal"><span class="pre">co_argcount</span></code> は固定引数 (positional argument) の数です; <code class="xref py py-attr docutils literal"><span class="pre">co_nlocals</span></code> は関数が使う (引数を含めた) ローカル変数の数です; <code class="xref py py-attr docutils literal"><span class="pre">co_varnames</span></code> はローカル変数名の入ったタプルです (引数名から始まっています); <code class="xref py py-attr docutils literal"><span class="pre">co_cellvars</span></code> はネストされた関数で参照されているローカル変数の名前が入ったタプルです; <code class="xref py py-attr docutils literal"><span class="pre">co_freevars</span></code> は自由変数の名前が入ったタプルです。 <code class="xref py py-attr docutils literal"><span class="pre">co_code</span></code> はバイトコード列を表現している文字列です; <code class="xref py py-attr docutils literal"><span class="pre">co_consts</span></code> はバイトコードで使われているリテラルの入ったタプルです; <code class="xref py py-attr docutils literal"><span class="pre">co_names</span></code> はバイトコードで使われている名前の入ったタプルです; <code class="xref py py-attr docutils literal"><span class="pre">co_filename</span></code> はバイトコードのコンパイルが行われたファイル名です; <code class="xref py py-attr docutils literal"><span class="pre">co_firstlineno</span></code> は関数の最初の行番号です; <code class="xref py py-attr docutils literal"><span class="pre">co_lnotab</span></code> はバイトコードオフセットから行番号への対応付けをコード化した文字列です (詳細についてはインタプリタのソースコードを参照してください); <code class="xref py py-attr docutils literal"><span class="pre">co_stacksize</span></code> は関数で (ローカル変数の分も含めて) 必要なスタックサイズです; <code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> はインタプリタ用の様々なフラグをコード化した整数です。</p>
<p id="index-57">以下のフラグビットが <code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> で定義されています: <code class="docutils literal"><span class="pre">0x04</span></code> ビットは、関数が <code class="docutils literal"><span class="pre">*arguments</span></code> 構文を使って任意の数の固定引数を受理できる場合に立てられます; <code class="docutils literal"><span class="pre">0x08</span></code> ビットは、関数が <code class="docutils literal"><span class="pre">**keywords</span></code> 構文を使ってキーワード引数を受理できる場合に立てられます; <code class="docutils literal"><span class="pre">0x20</span></code> ビットは、関数がジェネレータである場合に立てられます。</p>
<p>将来機能 (future feature) 宣言 (<code class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) もまた、 <code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> のビットを立てることで、コードオブジェクトが特定の機能を有効にしてコンパイルされていることを示します: <code class="docutils literal"><span class="pre">0x2000</span></code> ビットは、関数が将来機能を有効にしてコンパイルされている場合に立てられます; 以前のバージョンの Python では、 <code class="docutils literal"><span class="pre">0x10</span></code> および <code class="docutils literal"><span class="pre">0x1000</span></code> ビットが使われていました。</p>
<p><code class="xref py py-attr docutils literal"><span class="pre">co_flags</span></code> のその他のビットは将来に内部的に利用するために予約されています。</p>
<p class="last" id="index-58">コードオブジェクトが関数を表現している場合、 <code class="xref py py-attr docutils literal"><span class="pre">co_consts</span></code> の最初の要素は関数のドキュメンテーション文字列になります。ドキュメンテーション文字列が定義されていない場合には <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
</dd>
</dl>
<dl class="last docutils" id="frame-objects">
<dt>フレーム (frame) オブジェクト</dt>
<dd><p class="first" id="index-59">フレームオブジェクトは実行フレーム (execution frame) を表します。実行フレームはトレースバックオブジェクト内に出現します (下記参照)。</p>
<p id="index-60">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">f_back</span></code> は直前のスタックフレーム (呼び出し側の方向) で、それがスタックフレームの最下段なら <code class="docutils literal"><span class="pre">None</span></code> です; <code class="xref py py-attr docutils literal"><span class="pre">f_code</span></code> はそのフレームで実行されているコードオブジェクトです; <code class="xref py py-attr docutils literal"><span class="pre">f_locals</span></code> はローカル変数の探索に使われる辞書です; <code class="xref py py-attr docutils literal"><span class="pre">f_globals</span></code> はグローバル変数に使われます; <code class="xref py py-attr docutils literal"><span class="pre">f_builtins</span></code> は組み込みの (Python 固有の) 名前に使われます; <code class="xref py py-attr docutils literal"><span class="pre">f_lasti</span></code> は厳密な命令コード (コードオブジェクトのバイトコード文字列へのインデックス) です。</p>
<p id="index-61">書き込み可能な特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">f_trace</span></code> は、 <code class="docutils literal"><span class="pre">None</span></code> でなければ、ソースコードの各行の先頭で呼び出される関数です (デバッガに使われます); <code class="xref py py-attr docutils literal"><span class="pre">f_lineno</span></code> はフレーム中における現在の行番号です &#8212; トレース関数 (trace function) 側でこの値に書き込みを行うと、指定した行にジャンプします (最下段の実行フレームにいるときのみ)。デバッガでは、 f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement 命令とも) を実装できます。</p>
<p>フレームオブジェクトはメソッドを一つサポートします:</p>
<dl class="last method">
<dt id="frame.clear">
<code class="descclassname">frame.</code><code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドはフレームが保持しているローカル変数への参照を全て削除します。
また、フレームがジェネレータに属していた場合は、ジェネレータにも終了処理が行われます。
これによってフレームオブジェクトを含んだ循環参照が解消されるようになります (例えば、例外を捕捉し、後で使うためにトレースバックを保存する場合)。</p>
<p>フレームが現在実行中の場合 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

</dd>
<dt>トレースバック (traceback) オブジェクト</dt>
<dd><p class="first" id="index-62">トレースバックオブジェクトは例外のスタックトレースを表します。トレースバックオブジェクトは例外が発生した際に生成されます。例外ハンドラの検索が実行スタックを戻っていく際、戻ったレベル毎に、トレースバックオブジェクトが現在のトレースバックの前に挿入されます。例外ハンドラに入ると、スタックトレースをプログラム側で利用できるようになります。 (<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 文</span></a> を参照。) トレースバックは、 <code class="docutils literal"><span class="pre">sys.exc_info()</span></code> が返すタプルの三番目の要素として得られます。プログラムに適切なハンドラがないとき、スタックトレースは (うまく書式化されて) 標準エラーストリームに書き出されます; インタプリタが対話的に実行されている場合、 <code class="docutils literal"><span class="pre">sys.last_traceback</span></code> として得ることもできます。</p>
<p class="last" id="index-63">読み出し専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">tb_next</span></code> はスタックトレース内の (例外の発生しているフレームに向かって) 次のレベルです。次のレベルが存在しない場合には <code class="docutils literal"><span class="pre">None</span></code> になります; <code class="xref py py-attr docutils literal"><span class="pre">tb_frame</span></code> は現在のレベルにおける実行フレームを指します; <code class="xref py py-attr docutils literal"><span class="pre">tb_lineno</span></code> は例外の発生した行番号です; <code class="xref py py-attr docutils literal"><span class="pre">tb_lasti</span></code> は厳密な命令コードです。トレースバック内の行番号や最後に実行された命令は、 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 文内で例外が発生し、かつ対応する <a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> 節や <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節がない場合には、フレームオブジェクト内の行番号とは異なるかもしれません。</p>
</dd>
<dt>スライス (slice) オブジェクト</dt>
<dd><p class="first" id="index-64">スライスオブジェクトは、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドのためのスライスを表すのに使われます。スライスオブジェクトは組み込みの <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a> 関数でも生成されます。</p>
<p id="index-65">読み込み専用の特殊属性: <code class="xref py py-attr docutils literal"><span class="pre">start</span></code> は下限です; <code class="xref py py-attr docutils literal"><span class="pre">stop</span></code> は上限です; <code class="xref py py-attr docutils literal"><span class="pre">step</span></code> はステップの値です; それぞれ省略された場合は <code class="docutils literal"><span class="pre">None</span></code> となっています。これらの属性は任意の型を持てます。</p>
<p>スライスオブジェクトはメソッドを一つサポートします:</p>
<dl class="last method">
<dt id="slice.indices">
<code class="descclassname">slice.</code><code class="descname">indices</code><span class="sig-paren">(</span><em>self</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは単一の整数引数 <em>length</em> を取り、スライスオブジェクトが <em>length</em> 要素のシーケンスに適用されたときに表現する、スライスに関する情報を計算します。このメソッドは 3 つの整数からなるタプルを返します; それぞれ <em>start</em> および <em>stop</em> のインデックスと、<em>step</em> すなわちスライスのまたぎ幅です。インデックス値がないか、範囲外の値であれば、通常のスライスと変わらないやりかたで扱われます。</p>
</dd></dl>

</dd>
<dt>静的メソッド (static method) オブジェクト</dt>
<dd><p class="first last">静的メソッドは、上で説明したような関数オブジェクトからメソッドオブジェクトへの変換を阻止するための方法を提供します。静的メソッドオブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッドオブジェクトを包むラッパです。静的メソッドをクラスやクラスインスタンスから取得すると、実際に返されるオブジェクトはラップされたオブジェクトになり、それ以上は変換の対象にはなりません。静的メソッドオブジェクトは通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は呼び出すことができません。静的オブジェクトは組み込みコンストラクタ <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a> で生成されます。</p>
</dd>
<dt>クラスメソッドオブジェクト</dt>
<dd><p class="first last">クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、別のオブジェクトを包むラッパであり、そのオブジェクトをクラスやクラスインスタンスから取り出す方法を代替します。このようにして取得したクラスメソッドオブジェクトの動作については、上の &#8220;ユーザ定義メソッド (user-defined method)&#8221; で説明されています。クラスメソッドオブジェクトは組み込みのコンストラクタ <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> で生成されます。</p>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="special-method-names">
<span id="specialnames"></span><h2>3.3. 特殊メソッド名<a class="headerlink" href="#special-method-names" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-66">クラスは、特殊な名前のメソッドを定義して、特殊な構文 (算術演算や添え字表記、スライス表記など) による特定の演算を実装できます。これは、Python の演算子オーバロード (<em class="dfn">operator overloading</em>) へのアプローチです。これにより、クラスは言語の演算子に対する独自の振る舞いを定義できます。例えば、あるクラスが <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> という名前のメソッドを定義しており、 <code class="docutils literal"><span class="pre">x</span></code> がこのクラスのインスタンスであるとすると、 <code class="docutils literal"><span class="pre">x[i]</span></code> は <code class="docutils literal"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code> とほぼ等価です。特に注釈のない限り、適切なメソッドが定義されていないとき、このような演算を試みると例外 (たいていは <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> か <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>) が送出されます。</p>
<p>Setting a special method to <code class="docutils literal"><span class="pre">None</span></code> indicates that the corresponding
operation is not available.  For example, if a class sets
<a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> to <code class="docutils literal"><span class="pre">None</span></code>, the class is not iterable, so calling
<a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal"><span class="pre">iter()</span></code></a> on its instances will raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> (without
falling back to <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>). <a class="footnote-reference" href="#id9" id="id2">[2]</a></p>
<p>組み込み型をエミュレートするクラスを実装するときは、模範とされるオブジェクトにとって意味がある範囲に実装をとどめるのが重要です。例えば、あるシーケンスは個々の要素の取得はきちんと動くかもしれませんが、スライスの展開が意味を為さないかもしれません。 (W3C のドキュメントオブジェクトモデルにある <code class="xref py py-class docutils literal"><span class="pre">NodeList</span></code> インターフェースがその一例です。)</p>
<div class="section" id="basic-customization">
<span id="customization"></span><h3>3.3.1. 基本的なカスタマイズ<a class="headerlink" href="#basic-customization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="method">
<dt id="object.__new__">
<code class="descclassname">object.</code><code class="descname">__new__</code><span class="sig-paren">(</span><em>cls</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-67">クラス <em>cls</em> の新しいインスタンスを作るために呼び出されます。 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> は静的メソッドで (このメソッドは特別扱いされているので、明示的に静的メソッドと宣言する必要はありません)、インスタンスを生成するよう要求されているクラスを第一引数にとります。残りの引数はオブジェクトのコンストラクタの式 (クラスの呼び出し文) に渡されます。 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> の戻り値は新しいオブジェクトのインスタンス (通常は <em>cls</em> のインスタンス) でなければなりません。</p>
<p>典型的な実装では、クラスの新たなインスタンスを生成するときには <code class="docutils literal"><span class="pre">super(currentclass,</span> <span class="pre">cls).__new__(cls[,</span> <span class="pre">...])</span></code> に適切な引数を指定してスーパクラスの <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> メソッドを呼び出し、新たに生成されたインスタンスに必要な変更を加えてから返します。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> が <em>cls</em> のインスタンスを返した場合、 <code class="docutils literal"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code> のようにしてインスタンスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> が呼び出されます。このとき、 <em>self</em> は新たに生成されたインスタンスで、残りの引数は <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> に渡された引数と同じになります。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> が <em>cls</em> のインスタンスを返さない場合、インスタンスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドは呼び出されません。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> の主な目的は、変更不能な型 (int, str, tuple など) のサブクラスでインスタンス生成をカスタマイズすることにあります。また、クラス生成をカスタマイズするために、カスタムのメタクラスでよくオーバーライドされます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__init__">
<code class="descclassname">object.</code><code class="descname">__init__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-68">インスタンスが (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> によって) 生成された後、それが呼び出し元に返される前に呼び出されます。引数はクラスのコンストラクタ式に渡したものです。基底クラスとその派生クラスがともに <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドを持つ場合、派生クラスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドは基底クラスの <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に初期化されること保証しなければなりません。例えば、 <code class="docutils literal"><span class="pre">BaseClass.__init__(self,</span> <span class="pre">[args...])</span></code> 。</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> と <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> は連携してオブジェクトを構成する (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> が作成し、 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> がそれをカスタマイズする) ので、 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> から非 <code class="docutils literal"><span class="pre">None</span></code> 値を返してはいけません; そうしてしまうと、実行時に <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されてしまいます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__del__">
<code class="descclassname">object.</code><code class="descname">__del__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-69">インスタンスが消滅させられる際に呼び出されます。このメソッドはデストラクタ (destructor)  とも呼ばれます。基底クラスとその派生クラスがともに <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドを持つ場合、派生クラスの <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドは基底クラスの <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドを明示的に呼び出して、インスタンスの基底クラス部分が適切に消滅処理されること保証しなければなりません。 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドでインスタンスに対する新たな参照を作ることで、インスタンスの消滅を遅らせることができます (とはいえ、推奨しません！)。このようにすると、新たに作成された参照がその後削除された際にもう一度 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが呼び出されます。インタプリタが終了する際に残っているオブジェクトに対して、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが呼び出される保証はありません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal"><span class="pre">del</span> <span class="pre">x</span></code> は <code class="docutils literal"><span class="pre">x.__del__()</span></code> を直接呼び出すことはしません &#8212;  前者は <code class="docutils literal"><span class="pre">x</span></code> への参照カウント (reference count) を 1 つ減らし、後者は <code class="docutils literal"><span class="pre">x</span></code> への参照カウントが 0 になった際にのみ呼び出されます。よくオブジェクトの参照カウントが 0 になるのを妨げる要因となる状況には、以下のようなものがあります: 複数のオブジェクト間における循環参照 (二重リンクリストや、親と子へのポインタを持つツリーデータ構造); 例外を捕捉した関数におけるスタックフレーム上にあるオブジェクトへの参照 (<code class="docutils literal"><span class="pre">sys.exc_info()[2]</span></code> に記憶されているトレースバックが、スタックフレームを生き延びさせます); または、対話モードでハンドルされなかった例外を送出したスタックフレーム上のオブジェクトへの参照 (<code class="docutils literal"><span class="pre">sys.last_traceback</span></code> に記憶されているトレースバックが、スタックフレームを生き延びさせます); 最初の状況を解決するには、明示的に循環参照を壊すしかありません; 二つ目は、トレースバックオブジェクトが必要なくなった際にその参照を解放することで解決できます。三つ目は、 <code class="docutils literal"><span class="pre">sys.last_traceback</span></code> に <code class="docutils literal"><span class="pre">None</span></code> を格納することで解決できます。ごみである循環参照は、ガベージコレクタが有効 (デフォルト) であるときのみ検知されクリーンアップされます。この話題について詳しい情報は、 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> モジュールのドキュメントを参照してください。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドの呼び出しが起きるのは不安定な状況下なので、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> の実行中に発生した例外は無視され、代わりに <code class="docutils literal"><span class="pre">sys.stderr</span></code> に警告が出力されます。また、 (例えばプログラムの実行終了による) モジュールの削除に伴って <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> が呼び出される際には、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが参照している他のグローバル変数はすでに削除されていたり、削除中(例えば、import機構のシャットダウン中)かもしれません。この理由から、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドでは外部の不変関係を維持する上で絶対最低限必要なことだけをすべきです。バージョン 1.5 からは、単一のアンダースコアで始まるようなグローバル変数は、他のグローバル変数が削除される前にモジュールから削除されるように Python 側で保証しています; これらのアンダースコア付きグローバル変数は、 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> が呼び出された際に、import されたモジュールがまだ残っているか確認する上で役に立ちます。</p>
<span class="target" id="index-70"></span></div>
</dd></dl>

<dl class="method">
<dt id="object.__repr__">
<code class="descclassname">object.</code><code class="descname">__repr__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 組み込み関数によって呼び出され、オブジェクトを表す「公式の (official)」文字列を計算します。可能なら、これは (適切な環境が与えられれば) 同じ値のオブジェクトを再生成するのに使える、有効な Python 式のようなものであるべきです。できないなら、 <code class="docutils literal"><span class="pre">&lt;...some</span> <span class="pre">useful</span> <span class="pre">description...&gt;</span></code> 形式の文字列が返されるべきです。戻り値は文字列オブジェクトでなければなりません。クラスが <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> を定義していて <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code></a> は定義していなければ、そのクラスのインスタンスの「非公式の (informal)」文字列表現が要求されたときにも <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> が使われます。</p>
<p>この関数はデバッグの際によく用いられるので、たくさんの情報を含み、あいまいでないような表記にすることが重要です。</p>
<span class="target" id="index-71"></span></dd></dl>

<dl class="method">
<dt id="object.__str__">
<code class="descclassname">object.</code><code class="descname">__str__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトの「非公式の (informal)」あるいは表示に適した文字列表現を計算するために、 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str(object)</span></code></a> と組み込み関数 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a>, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> によって呼ばれます。戻り値は <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">string</span></a> オブジェクトでなければなりません。</p>
<p><a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code></a> が有効な Python 表現を返すことが期待されないという点で、このメソッドは <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">object.__repr__()</span></code></a> とは異なります: より便利な、または簡潔な表現を使用することができます。</p>
<p>組み込み型 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> によって定義されたデフォルト実装は、 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">object.__repr__()</span></code></a> を呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__bytes__">
<code class="descclassname">object.</code><code class="descname">__bytes__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-72"><a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-func docutils literal"><span class="pre">bytes()</span></code></a> によって呼び出され、オブジェクトのバイト文字列表現を計算します。これは <code class="docutils literal"><span class="pre">bytes</span></code> オブジェクトを返すべきです。</p>
<span class="target" id="index-73"></span></dd></dl>

<dl class="method">
<dt id="object.__format__">
<code class="descclassname">object.</code><code class="descname">__format__</code><span class="sig-paren">(</span><em>self</em>, <em>format_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Called by the <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a> built-in function,
and by extension, evaluation of <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a> and the <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> method, to produce a &#8220;formatted&#8221;
string representation of an object. The <code class="docutils literal"><span class="pre">format_spec</span></code> argument is
a string that contains a description of the formatting options desired.
The interpretation of the <code class="docutils literal"><span class="pre">format_spec</span></code> argument is up to the type
implementing <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal"><span class="pre">__format__()</span></code></a>, however most classes will either
delegate formatting to one of the built-in types, or use a similar
formatting option syntax.</p>
<p>標準のフォーマット構文の解説は、 <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">書式指定ミニ言語仕様</span></a> を参照してください。</p>
<p>戻り値は文字列オブジェクトでなければなりません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>空でない文字列が渡された場合 <code class="docutils literal"><span class="pre">object</span></code> 自身の __format__ メソッドは <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="method">
<dt id="object.__lt__">
<code class="descclassname">object.</code><code class="descname">__lt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__le__">
<code class="descclassname">object.</code><code class="descname">__le__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__eq__">
<code class="descclassname">object.</code><code class="descname">__eq__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ne__">
<code class="descclassname">object.</code><code class="descname">__ne__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__gt__">
<code class="descclassname">object.</code><code class="descname">__gt__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ge__">
<code class="descclassname">object.</code><code class="descname">__ge__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-74">これらはいわゆる &#8220;拡張比較 (rich comparison)&#8221; メソッドです。演算子シンボルとメソッド名の対応は以下の通りです: <code class="docutils literal"><span class="pre">x&lt;y</span></code> は <code class="docutils literal"><span class="pre">x.__lt__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x&lt;=y</span></code> は <code class="docutils literal"><span class="pre">x.__le__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x==y</span></code> は <code class="docutils literal"><span class="pre">x.__eq__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x!=y</span></code> は <code class="docutils literal"><span class="pre">x.__ne__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x&gt;y</span></code> は <code class="docutils literal"><span class="pre">x.__gt__(y)</span></code> を呼び出します; <code class="docutils literal"><span class="pre">x&gt;=y</span></code> は <code class="docutils literal"><span class="pre">x.__ge__(y)</span></code> を呼び出します。</p>
<p>拡張比較メソッドは与えられた引数のペアに対する演算を実装していないときに、 シングルトン <code class="docutils literal"><span class="pre">NotImplemented</span></code> を返すかもしれません。
慣例として、正常に比較が行われたときには <code class="docutils literal"><span class="pre">False</span></code> か <code class="docutils literal"><span class="pre">True</span></code> を返します。
しかし、これらのメソッドは任意の値を返すことができるので、比較演算子がブール値のコンテキスト (たとえば <code class="docutils literal"><span class="pre">if</span></code> 文の条件部分) で使われた場合、 Python はその値に対して <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a> を呼び出して結果の真偽を判断します。</p>
<p>デフォルトでは <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a> は <code class="docutils literal"><span class="pre">NotImplemented</span></code> でない限り <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> に委譲して結果を反転させます。比較演算の間には他に暗黙の関係はありません。例えば <code class="docutils literal"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> が真であることは暗黙的に <code class="docutils literal"><span class="pre">x&lt;=y</span></code> ではありません。元となる一つの演算から自動的に順序の演算を生成するには <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal"><span class="pre">functools.total_ordering()</span></code></a> を参照してください。</p>
<p>カスタムの比較演算をサポートしていて、辞書のキーに使うことができるハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) オブジェクトを作るときの重要な注意点について、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> のドキュメント内に書かれているので参照してください。</p>
<p>これらのメソッドには (左引数が演算をサポートしないが、右引数はサポートする場合に用いられるような) 引数を入れ替えたバージョンは存在しません。
むしろ、 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> と <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a> は互いの反射、 <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a> と <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a> は互いの反射、および <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a> はそれら自身の反射です。
被演算子が異なる型で右の被演算子の型が左の被演算子の直接的または間接的サブクラスの場合、右被演算子の反射されたメソッドが優先されます。
そうでない場合左の被演算子のメソッドが優先されます。
仮想サブクラス化は考慮されません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__hash__">
<code class="descclassname">object.</code><code class="descname">__hash__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-75">組み込みの <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> 関数や、 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のようなハッシュを使ったコレクション型の要素に対する操作から呼び出されます。
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> は整数を返さなければなりません。
このメソッドに必要な性質は、比較結果が等しいオブジェクトは同じハッシュ値を持つということです;
オブジェクトを比較するときでも利用される要素をタプルに詰めてハッシュ値を計算することで、それぞれの要素のハッシュ値を混合することをおすすめします。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> はオブジェクト独自の <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a>  メソッドが返す値を <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> のサイズに切り詰めます。
これは 64-bit でビルドされていると 8 バイトで、 32-bit でビルドされていると 4 バイトです。
オブジェクトの <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> が異なる bit サイズのビルドでも可搬性が必要である場合は、必ず全てのサポートするビルドの bit 幅をチェックしてください。
そうする簡単な方法は <code class="docutils literal"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code> を実行することです。</p>
</div>
<p>クラスが <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> メソッドを定義していないなら、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドも定義してはなりません; クラスが <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> を定義していても <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を定義していないなら、そのインスタンスはハッシュ可能コレクションの要素として使えません。クラスがミュータブルなオブジェクトを定義しており、 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> メソッドを実装しているなら、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を定義してはなりません。これは、ハッシュ可能コレクションの実装においてキーのハッシュ値がイミュータブルであることが要求されているからです (オブジェクトのハッシュ値が変化すると、誤ったハッシュバケツ: hash bucket に入ってしまいます)。</p>
<p>ユーザー定義クラスはデフォルトで <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドを持っています。 このとき、(同一でない) すべてのオブジェクトは比較して異なり、 <code class="docutils literal"><span class="pre">x.__hash__()</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> が <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> と <code class="docutils literal"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> の両方を意味するような適切な値を返します。</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> をオーバーライドしていて <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を定義していないクラスでは、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> は暗黙的に <code class="docutils literal"><span class="pre">None</span></code> に設定されます。
クラスの <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドが <code class="docutils literal"><span class="pre">None</span></code> の場合、そのクラスのインスタンスのハッシュ値を取得しようとすると適切な <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出され、 <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">collections.Hashable)</span></code> をチェックするとハッシュ不能なものとして正しく認識されます。</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> をオーバーライドしたクラスが親クラスからの <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> の 実装を保持したいなら、明示的に <code class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code> を設定することで、それをインタプリタに伝えなければなりません。</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> をオーバーライドしていないクラスがハッシュサポートを抑制したい場合、クラス定義に <code class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> を含めてください。クラス自身で明示的に <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出する <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を定義すると、 <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">collections.Hashable)</span></code> 呼び出しで誤ってハッシュ可能と識別されるでしょう。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>デフォルトでは、文字列、バイト列、datetime オブジェクトの <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> 値は予測不可能なランダム値で &#8220;塩漬け&#8221; されます。 ハッシュ値は単独の Python プロセス内では定数であり続けますが、Python を繰り返し起動する毎に、予測できなくなります。</p>
<p>この目的は、慎重に選ばれた入力で辞書挿入の最悪性能 O(n^2) 計算量を悪用することで引き起こされるサービス妨害 (denial-of-service, DoS) に対する保護です。
詳細は <a class="reference external" href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> を参照してください。</p>
<p>ハッシュ値の変更は、辞書、集合、その他のマップ型のイテレーション順序に影響します。Python はこの順序付けを保証していません (そして通常 32-bit と 64-bit の間でも異なります)。</p>
<p class="last"><span class="target" id="index-102"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONHASHSEED</span></code></a> も参照してください。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>ハッシュのランダム化がデフォルトで有効になりました。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__bool__">
<code class="descclassname">object.</code><code class="descname">__bool__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-77">真理値テストや組み込み演算 <code class="docutils literal"><span class="pre">bool()</span></code> を実装するために呼び出されます; <code class="docutils literal"><span class="pre">False</span></code> または <code class="docutils literal"><span class="pre">True</span></code> を返さなければなりません。このメソッドが定義されていないとき、 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> が定義されていれば呼び出され、その結果が非 0 であれば真とみなされます。クラスが <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> も <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> も定義していないければ、そのクラスのインスタンスはすべて真とみなされます。</p>
</dd></dl>

</div>
<div class="section" id="customizing-attribute-access">
<span id="attribute-access"></span><h3>3.3.2. 属性値アクセスをカスタマイズする<a class="headerlink" href="#customizing-attribute-access" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドを定義して、クラスインスタンスへの属性値アクセス ( 属性値の使用、属性値への代入、 <code class="docutils literal"><span class="pre">x.name</span></code> の削除) の意味をカスタマイズすることができます。</p>
<dl class="method">
<dt id="object.__getattr__">
<code class="descclassname">object.</code><code class="descname">__getattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>属性値の検索を行った結果、通常の場所に属性値が見つからなかった場合 (すなわち、 <code class="docutils literal"><span class="pre">self</span></code> のインスタンス属性でなく、かつクラスツリーにも見つからなかった場合) に呼び出されます。<code class="docutils literal"><span class="pre">name</span></code> は属性名です。このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出しなければなりません。</p>
<p>なお、通常の過程で属性が見つかれば、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> は呼び出されません。(これは、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a>  と <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> が意図的に非対称にされている点です。) これは、効率のためと、こうしないと <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> がインスタンスの他の属性値にアクセスする方法がなくなるためです。また、少なくともインスタンス変数に対しては、値をインスタンスの属性値辞書に挿入しないことで (代わりに他のオブジェクトに挿入することで)、属性値を完全に制御しているふりができます。実際に属性アクセスを完全に制御する方法は、以下の <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> メソッドを参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="object.__getattribute__">
<code class="descclassname">object.</code><code class="descname">__getattribute__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>クラスのインスタンスに対する属性アクセスを実装するために、無条件に呼び出されます。クラスが <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> も定義している場合、 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> は、 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> で明示的に呼び出すか、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出しない限り呼ばれません。このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出します。このメソッドが再帰的に際限なく呼び出されてしまうのを防ぐため、実装の際には常に、必要な属性全てへのアクセスで、例えば <code class="docutils literal"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code> のように基底クラスのメソッドを同じ属性名を使って呼び出さなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">言語構文や組み込み関数から暗黙に呼び出された特殊メソッドの検索では、このメソッドも回避されることがあります。 <a class="reference internal" href="#special-lookup"><span class="std std-ref">特殊メソッド検索</span></a> を参照してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__setattr__">
<code class="descclassname">object.</code><code class="descname">__setattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>属性の代入が試みられた際に呼び出されます。これは通常の代入の過程 (すなわち、インスタンス辞書への値の代入) の代わりに呼び出されます。<em>name</em> は属性名で、<em>value</em> はその属性に代入する値です。</p>
<p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> の中でインスタンス属性への代入が必要なら、基底クラスのこれと同じ名前のメソッドを呼び出さなければなりません。例えば、 <code class="docutils literal"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code> とします。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delattr__">
<code class="descclassname">object.</code><code class="descname">__delattr__</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> に似ていますが、代入ではなく値の削除を行います。このメソッドを実装するのは、オブジェクトにとって <code class="docutils literal"><span class="pre">del</span> <span class="pre">obj.name</span></code> が意味がある場合だけにしなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__dir__">
<code class="descclassname">object.</code><code class="descname">__dir__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクトに <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> が呼び出されたときに呼び出されます。シーケンスが返されなければなりません。 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> は返されたシーケンスをリストに変換し、ソートします。</p>
</dd></dl>

<div class="section" id="implementing-descriptors">
<span id="descriptors"></span><h4>3.3.2.1. デスクリプタ (descriptor) の実装<a class="headerlink" href="#implementing-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>以下のメソッドは、このメソッドを持つクラス (いわゆる <em>デスクリプタ(descriptor)</em> クラス) のインスタンスが、 <em>オーナー (owner)</em> クラスに存在するときにのみ適用されます (デスクリプタは、オーナーのクラス辞書か、その親のいずれかのクラス辞書になければなりません)。
以下の例では、&#8221;属性&#8221; とは、名前がオーナークラスの <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> のプロパティ (porperty) のキーであるような属性を指します。</p>
<dl class="method">
<dt id="object.__get__">
<code class="descclassname">object.</code><code class="descname">__get__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>owner</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナクラスの属性を取得する (クラス属性へのアクセス) 際や、オーナクラスのインスタンスの属性を取得する (インスタンス属性へのアクセス) 場合に呼び出されます。 <em>owner</em> は常にオーナクラスです。一方、 <em>instance</em> は属性へのアクセスを仲介するインスタンスか属性が <em>owner</em> を介してアクセスされる場合は <code class="docutils literal"><span class="pre">None</span></code> になります。このメソッドは (計算された) 属性値を返すか、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 例外を送出しなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__set__">
<code class="descclassname">object.</code><code class="descname">__set__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナクラスのインスタンス <em>instance</em> 上の属性を新たな値 <em>value</em> に設定する際に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delete__">
<code class="descclassname">object.</code><code class="descname">__delete__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オーナクラスのインスタンス <em>instance</em> 上の属性を削除する際に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__set_name__">
<code class="descclassname">object.</code><code class="descname">__set_name__</code><span class="sig-paren">(</span><em>self</em>, <em>owner</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Called at the time the owning class <em>owner</em> is created. The
descriptor has been assigned to <em>name</em>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<p><code class="xref py py-attr docutils literal"><span class="pre">__objclass__</span></code> 属性は <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a> モジュールによって解釈され、このオブジェクトが定義されたクラスを特定するのに使われます (この属性を適切に設定しておくと、動的なクラスの属性を実行時に調べる助けになります)。
呼び出される側にとっては、この属性で指定されたクラス (もしくはそのサブクラス) のインスタンスが1番目の位置引数として期待もしくは要求されていることが示せます (例えば、 CPython は束縛されていない C で実行されたメソッドにこの属性を設定します)。</p>
</div>
<div class="section" id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4>3.3.2.2. デスクリプタの呼び出し<a class="headerlink" href="#invoking-descriptors" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>一般にデスクリプタとは、特殊な &#8220;束縛に関する動作 (binding behaviour)&#8221; をもつオブジェクト属性のことです。デスクリプタは、デスクリプタプロトコル (descriptor protocol) のメソッド: <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a>, および <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></code></a> を使って、属性アクセスをオーバライドしているものです。これらのメソッドのいずれかがオブジェクトに対して定義されている場合、オブジェクトはデスクリプタであるといいます。</p>
<p>属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、値を設定したり、削除したりするというものです。例えば、 <code class="docutils literal"><span class="pre">a.x</span></code> による属性の検索では、まず <code class="docutils literal"><span class="pre">a.__dict__['x']</span></code> 、次に <code class="docutils literal"><span class="pre">type(a).__dict__['x']</span></code> 、そして <code class="docutils literal"><span class="pre">type(a)</span></code> の基底クラスでメタクラスでないものに続く、といった具合に連鎖が起こります。</p>
<p>しかし、検索対象の値が、デスクリプタメソッドのいずれかを定義しているオブジェクトであれば、Python はデフォルトの動作をオーバーライドして、代わりにデスクリプタメソッドを呼び出します。先述の連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、どのデスクリプタメソッドが定義されていて、どのように呼び出されたかに依存します。</p>
<p>デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding) 、すなわち <code class="docutils literal"><span class="pre">a.x</span></code> です。引数がどのようにデスクリプタに結合されるかは <code class="docutils literal"><span class="pre">a</span></code> に依存します:</p>
<dl class="docutils">
<dt>直接呼び出し (Direct Call)</dt>
<dd><p class="first last">最も単純で、かつめったに使われない呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し: <code class="docutils literal"><span class="pre">x.__get__(a)</span></code> を行うというものです。</p>
</dd>
<dt>インスタンス束縛 (Instance Binding)</dt>
<dd><p class="first last">オブジェクトインスタンスへ束縛すると、<code class="docutils literal"><span class="pre">a.x</span></code> は呼び出し <code class="docutils literal"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code> に変換されます。</p>
</dd>
<dt>クラス束縛 (Class Binding)</dt>
<dd><p class="first last">クラスへ束縛すると、<code class="docutils literal"><span class="pre">A.x</span></code> は呼び出し <code class="docutils literal"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code> に変換されます。</p>
</dd>
<dt>super 束縛 (Super Binding)</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">a</span></code> が <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal"><span class="pre">super</span></code></a> のインスタンスである場合、束縛 <code class="docutils literal"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code> を行うとまず <code class="docutils literal"><span class="pre">A</span></code> 、続いて <code class="docutils literal"><span class="pre">B</span></code> に対して <code class="docutils literal"><span class="pre">obj.__class_.__mro__</span></code> を検索し、次に呼び出し: <code class="docutils literal"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code> でデスクリプタを呼び出します。</p>
</dd>
</dl>
<p>インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが定義されているかに依存します。データデスクリプタは、 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> と <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> 、 <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></code></a> の任意の組合せを定義することができます。 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> が定義されない場合には、その属性にアクセスすると、そのオブジェクトのインスタンス辞書にその値がある場合を除けば、デスクリプタオブジェクト自身が返ってきます。デスクリプタが <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> と <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal"><span class="pre">__delete__()</span></code></a> またはそのどちらかを定義していれば、データデスクリプタとなります; もし両方とも定義しなければ、非データデスクリプタです。通常、データデスクリプタでは、 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> と <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> を定義し、一方、非データデスクリプタには <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> メソッドしかありません。 <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal"><span class="pre">__set__()</span></code></a> と <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal"><span class="pre">__get__()</span></code></a> を定義したデータデスクリプタは、インスタンス辞書内で属性値が再定義されても、常にこの値をオーバライドします。対照的に、非データデスクリプタの場合には、属性値はインスタンス側でオーバライドされます。</p>
<p>(<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a> や <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> を含む) Python メソッドは、非データデスクリプタとして実装されています。その結果、インスタンスではメソッドを再定義したりオーバライドできます。このことにより、個々のインスタンスが同じクラスの他のインスタンスと互いに異なる動作を獲得することができます。</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal"><span class="pre">property()</span></code></a> 関数はデータデスクリプタとして実装されています。従って、インスタンスはあるプロパティの動作をオーバライドすることができません。</p>
</div>
<div class="section" id="slots">
<span id="id3"></span><h4>3.3.2.3. __slots__<a class="headerlink" href="#slots" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>デフォルトでは、クラスのインスタンスは属性を保存するための辞書を持っています。これは、ほとんどインスタンス変数を持たないオブジェクトでは領域の無駄です。大量のインスタンスを生成するとき、この記憶領域の消費量は深刻になり得ます。</p>
<p>このデフォルトの設定は、クラス定義中で <em>__slots__</em> を定義することでオーバーライドできます。<em>__slots__</em> 宣言はインスタンス変数のシーケンスを取り、各々のインスタンス上には、各変数の値を記憶するのに必要な量だけの記憶領域を確保します。各々のインスタンスに対して <em>__dict__</em> が生成されることがないので、記憶領域が節約されます。</p>
<dl class="data">
<dt id="object.__slots__">
<code class="descclassname">object.</code><code class="descname">__slots__</code><a class="headerlink" href="#object.__slots__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラス変数には、インスタンスが用いる変数名を表す、文字列、イテラブル、または文字列のシーケンスを代入できます。<em>__slots__</em> は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、<em>__dict__</em> と <em>__weakref__</em> が自動的に生成されないようにします。</p>
</dd></dl>

<div class="section" id="notes-on-using-slots">
<h5>3.3.2.3.1. <em>__slots__</em> を利用する際の注意<a class="headerlink" href="#notes-on-using-slots" title="このヘッドラインへのパーマリンク">¶</a></h5>
<ul class="simple">
<li><p class="first"><em>__slots__</em> を持たないクラスから継承する場合、 <em>__dict__</em> 属性は常にアクセス可能なので、サブクラスで <em>__slots__</em> を定義しても意味がありません。</p>
</li>
<li><p class="first"><em>__dict__</em> 変数がない場合、 <em>__slots__</em> に列挙されていない新たな変数をインスタンスに代入することはできません。列挙されていない変数名を使って代入しようとした場合、 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。新たな変数を動的に代入したいのなら、 <em>__slots__</em> を宣言する際に <code class="docutils literal"><span class="pre">'__dict__'</span></code> を変数名のシーケンスに追加してください。</p>
</li>
<li><p class="first"><em>__slots__</em> を定義しているクラスの各インスタンスに <em>__weakref__</em> 変数がない場合、インスタンスに対する弱参照 (weak reference) はサポートされません。弱参照のサポートが必要なら、 <em>__slots__</em> を宣言する際に <code class="docutils literal"><span class="pre">'__weakref__'</span></code> を変数名のシーケンスに追加してください。</p>
</li>
<li><p class="first"><em>__slots__</em> は、クラスのレベルで各変数に対するデスクリプタ (<a class="reference internal" href="#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> を参照) を使って実装されます。その結果、 <em>__slots__</em> に定義されているインスタンス変数のデフォルト値はクラス属性を使って設定できなくなっています; そうしないと、デスクリプタによる代入をクラス属性が上書きしてしまうからです。</p>
</li>
<li><p class="first"><em>__slots__</em> 宣言が動作するのは、定義が行われたクラスだけに限られています。その結果、サブクラスでは、 <em>__slots__</em> を定義しない限り <em>__dict__</em> を持つことになります。</p>
</li>
<li><p class="first">あるクラスで、基底クラスですでに定義されているスロットを定義した場合、基底クラスのスロットで定義されているインスタンス変数は (デスクリプタを基底クラスから直接取得しない限り) アクセスできなくなります。これにより、プログラムの趣意が不定になってしまいます。将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。</p>
</li>
<li><p class="first">空でない <em>__slots__</em> は、 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> や <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> や <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> のような &#8220;可変長の&#8221; 組み込み型から派生したクラスでは動作しません。</p>
</li>
<li><p class="first"><em>__slots__</em> には、文字列でない反復可能オブジェクトを代入することができます。辞書型も使うことができます; しかし将来、辞書の各キーに相当する値に何らかの特殊な意味が割り当てられるかもしれません。</p>
</li>
<li><p class="first"><em>__class__</em> への代入は、両方のクラスが同じ <em>__slots__</em> を持っているときのみ動作します。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="customizing-class-creation">
<span id="class-customization"></span><h3>3.3.3. クラス生成をカスタマイズする<a class="headerlink" href="#customizing-class-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Whenever a class inherits from another class, <em>__init_subclass__</em> is
called on that class. This way, it is possible to write classes which
change the behavior of subclasses. This is closely related to class
decorators, but where class decorators only affect the specific class they&#8217;re
applied to, <code class="docutils literal"><span class="pre">__init_subclass__</span></code> solely applies to future subclasses of the
class defining the method.</p>
<dl class="classmethod">
<dt id="object.__init_subclass__">
<em class="property">classmethod </em><code class="descclassname">object.</code><code class="descname">__init_subclass__</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This method is called whenever the containing class is subclassed.
<em>cls</em> is then the new subclass. If defined as a normal instance method,
this method is implicitly converted to a class method.</p>
<p>Keyword arguments which are given to a new class are passed to
the parent&#8217;s class <code class="docutils literal"><span class="pre">__init_subclass__</span></code>. For compatibility with
other classes using <code class="docutils literal"><span class="pre">__init_subclass__</span></code>, one should take out the
needed keyword arguments and pass the others over to the base
class, as in:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The default implementation <code class="docutils literal"><span class="pre">object.__init_subclass__</span></code> does
nothing, but raises an error if it is called with any arguments.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The metaclass hint <code class="docutils literal"><span class="pre">metaclass</span></code> is consumed by the rest of the type
machinery, and is never passed to <code class="docutils literal"><span class="pre">__init_subclass__</span></code> implementations.
The actual metaclass (rather than the explicit hint) can be accessed as
<code class="docutils literal"><span class="pre">type(cls)</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.6 で追加.</span></p>
</div>
</dd></dl>

<div class="section" id="metaclasses">
<span id="id4"></span><h4>3.3.3.1. Metaclasses<a class="headerlink" href="#metaclasses" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-78">デフォルトでは、クラスは <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> を使って構築されます。 クラス本体は新しい名前空間で実行され、クラス名が <code class="docutils literal"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code> の結果にローカルに束縛されます。</p>
<p>クラス生成プロセスはカスタマイズできます。
そのためにはクラス定義行で <code class="docutils literal"><span class="pre">metaclass</span></code> キーワード引数を渡すか、そのような引数を定義行に含む既存のクラスを継承します。
次の例で <code class="docutils literal"><span class="pre">MyClass</span></code> と <code class="docutils literal"><span class="pre">MySubclass</span></code> は両方とも <code class="docutils literal"><span class="pre">Meta</span></code> のインスタンスです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>クラス定義の中で指定された他のキーワード引数は、後述するすべてのメタクラス操作に渡されます。</p>
<p>クラス定義が実行される際に、以下のステップが生じます:</p>
<ul class="simple">
<li><p class="first">適切なメタクラスが決定される</p>
</li>
<li><p class="first">クラスの名前空間が準備される</p>
</li>
<li><p class="first">クラスの本体が実行される</p>
</li>
<li><p class="first">クラスオブジェクトが作られる</p>
</li>
</ul>
</div>
<div class="section" id="determining-the-appropriate-metaclass">
<h4>3.3.3.2. 適切なメタクラスの決定<a class="headerlink" href="#determining-the-appropriate-metaclass" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-79">クラス定義に対して適切なメタクラスは、以下のように決定されます:</p>
<ul class="simple">
<li><p class="first">ベースクラスも明示的なメタクラスも指定されなかった場合、 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> が使われます</p>
</li>
<li><p class="first">明示的にメタクラスが指定され、それが <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> のインスタンス <em>でない</em> 場合、それが直接メタクラスとして使われます</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a> のインスタンスが明示的にメタクラスとして指定されたり、ベースクラスが定義されている場合、最も派生的なメタクラスが使われます</p>
</li>
</ul>
<p>最も派生的なメタクラスは、(もしあれば) 明示的に指定されたメタクラスと、指定されたすべてのベースクラスのメタクラスから選ばれます。最も派生的なメタクラスは、これらのメタクラス候補のすべてのサブタイプであるようなものです。メタクラス候補のどれもその基準を満たさなければ、クラス定義は <code class="docutils literal"><span class="pre">TypeError</span></code> で失敗します。</p>
</div>
<div class="section" id="preparing-the-class-namespace">
<span id="prepare"></span><h4>3.3.3.3. クラスの名前空間の準備<a class="headerlink" href="#preparing-the-class-namespace" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-80">適切なメタクラスが識別されたら、次にクラスの名前空間が準備されます。メタクラスに <code class="docutils literal"><span class="pre">__prepare__</span></code> 属性がある場合、それは、<code class="docutils literal"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> として呼ばれます (ここで追加のキーワード引数は、もしあればクラス定義から来ます)。</p>
<p>If the metaclass has no <code class="docutils literal"><span class="pre">__prepare__</span></code> attribute, then the class namespace
is initialised as an empty ordered mapping.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-81"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - Metaclasses in Python 3000</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">__prepare__</span></code> 名前空間フックの導入</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="executing-the-class-body">
<h4>3.3.3.4. クラス本体の実行<a class="headerlink" href="#executing-the-class-body" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-82">クラス本体が (大まかには) <code class="docutils literal"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> として実行されます。通常の呼び出しと <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> の重要な違いは、クラス定義が関数内部で行われる場合、レキシカルスコープによってクラス本体 (任意のメソッドを含む) が現在のスコープと外側のスコープから名前を参照できるという点です。</p>
<p>However, even when the class definition occurs inside the function, methods
defined inside the class still cannot see names defined at the class scope.
Class variables must be accessed through the first parameter of instance or
class methods, or through the implicit lexically scoped <code class="docutils literal"><span class="pre">__class__</span></code> reference
described in the next section.</p>
</div>
<div class="section" id="creating-the-class-object">
<span id="class-object-creation"></span><h4>3.3.3.5. クラスオブジェクトの作成<a class="headerlink" href="#creating-the-class-object" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p id="index-83">クラス本体の実行によってクラスの名前空間が初期化されたら、<code class="docutils literal"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> を呼び出すことでクラスオブジェクトが作成されます (ここで渡される追加のキーワードは <code class="docutils literal"><span class="pre">__prepare__</span></code> に渡されるものと同じです)。</p>
<p>このクラスオブジェクトは、 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> の無引数形式によって参照されるものです。 <code class="docutils literal"><span class="pre">__class__</span></code> は、クラス本体中のメソッドが <code class="docutils literal"><span class="pre">__class__</span></code> または <code class="docutils literal"><span class="pre">super</span></code> のいずれかを参照している場合に、コンパイラによって作成される暗黙のクロージャー参照です。これは、メソッドに渡された最初の引数に基づいて現在の呼び出しを行うために使用されるクラスまたはインスタンスが識別される一方、 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> の無引数形式がレキシカルスコープに基づいて定義されているクラスを正確に識別することを可能にします。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> In CPython 3.6 and later, the <code class="docutils literal"><span class="pre">__class__</span></code> cell is passed to the metaclass
as a <code class="docutils literal"><span class="pre">__classcell__</span></code> entry in the class namespace. If present, this must
be propagated up to the <code class="docutils literal"><span class="pre">type.__new__</span></code> call in order for the class to be
initialised correctly.
Failing to do so will result in a <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a> in Python 3.6,
and a <a class="reference internal" href="../library/exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeWarning</span></code></a> in the future.</p>
</div>
<p>When using the default metaclass <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal"><span class="pre">type</span></code></a>, or any metaclass that ultimately
calls <code class="docutils literal"><span class="pre">type.__new__</span></code>, the following additional customisation steps are
invoked after creating the class object:</p>
<ul class="simple">
<li>first, <code class="docutils literal"><span class="pre">type.__new__</span></code> collects all of the descriptors in the class
namespace that define a <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal"><span class="pre">__set_name__()</span></code></a> method;</li>
<li>second, all of these <code class="docutils literal"><span class="pre">__set_name__</span></code> methods are called with the class
being defined and the assigned name of that particular descriptor; and</li>
<li>finally, the <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal"><span class="pre">__init_subclass__()</span></code></a> hook is called on the
immediate parent of the new class in its method resolution order.</li>
</ul>
<p>クラスオブジェクトが作成された後には、クラス定義に含まれているクラスデコレータ (もしあれば) にクラスオブジェクトが渡され、デコレータが返すオブジェクトがここで定義されたクラスとしてローカルの名前空間に束縛されます。</p>
<p>When a new class is created by <code class="docutils literal"><span class="pre">type.__new__</span></code>, the object provided as the
namespace parameter is copied to a new ordered mapping and the original
object is discarded. The new copy is wrapped in a read-only proxy, which
becomes the <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> attribute of the class object.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-84"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a> - New super</dt>
<dd><p class="first last">暗黙の <code class="docutils literal"><span class="pre">__class__</span></code> クロージャ参照について記述しています</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="metaclass-example">
<h4>3.3.3.6. メタクラスの例<a class="headerlink" href="#metaclass-example" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>メタクラスは限りない潜在的利用価値を持っています。これまで試されてきたアイデアには、ログ記録、インタフェースのチェック、自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、そして自動リソースロック／同期といったものがあります。</p>
<p>ここに、 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></code></a> を使い、クラス変数が定義された順序を記憶するメタクラスの例を挙げます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OrderedClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="n">metacls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">namespace</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">members</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">OrderedClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">three</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">four</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">pass</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">members</span>
<span class="p">(</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="s1">&#39;four&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>この <em>A</em> のクラス定義が実行されたとき、処理はメタクラスの <code class="xref py py-meth docutils literal"><span class="pre">__prepare__()</span></code> を呼び出すことから始まり、それは空の <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></code></a> を返します。このマッピングは、 <em>A</em> のメソッドと属性を、クラス文の本体内で定義された順に記録します。一旦この定義が実行されると、順序付き辞書は完全に登録され、メタクラスの <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> メソッドが呼び出されます。このメソッドは新しい型を構築し、順序付き辞書のキーを <code class="docutils literal"><span class="pre">members</span></code> と呼ばれる属性に保存します。</p>
</div>
</div>
<div class="section" id="customizing-instance-and-subclass-checks">
<h3>3.3.4. インスタンスのカスタマイズとサブクラスチェック<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドは組み込み関数 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> のデフォルトの動作を上書きするのに利用します。</p>
<p>特に、 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal"><span class="pre">abc.ABCMeta</span></code></a> メタクラスは、抽象基底クラス (ABCs) を&#8221;仮想基底クラス (virtual base classes)&#8221; として、他の ABC を含む、任意のクラスや (組み込み型を含む) 型に追加するために、これらのメソッドを実装しています。</p>
<dl class="method">
<dt id="class.__instancecheck__">
<code class="descclassname">class.</code><code class="descname">__instancecheck__</code><span class="sig-paren">(</span><em>self</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>instance</em> が (直接、または間接的に) <em>class</em> のインスタンスと考えられる場合に true を返します。定義されていれば、 <code class="docutils literal"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code> の実装のために呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasscheck__">
<code class="descclassname">class.</code><code class="descname">__subclasscheck__</code><span class="sig-paren">(</span><em>self</em>, <em>subclass</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>subclass</em> が (直接、または間接的に) <em>class</em> のサブクラスと考えられる場合に true を返します。定義されていれば、 <code class="docutils literal"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code> の実装のために呼び出されます。</p>
</dd></dl>

<p>なお、これらのメソッドは、クラスの型 (メタクラス) 上で検索されます。実際のクラスにクラスメソッドとして定義することはできません。これは、インスタンスそれ自体がクラスであるこの場合にのみ、インスタンスに呼び出される特殊メソッドの検索と一貫しています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-103"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - 抽象基底クラスの導入</dt>
<dd><p class="first last">抽象基底クラス (<a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal"><span class="pre">abc</span></code></a> モジュールを参照) を言語に追加する文脈においての動機から、 <a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal"><span class="pre">__instancecheck__()</span></code></a> と <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal"><span class="pre">__subclasscheck__()</span></code></a> を通して、 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> に独自の動作をさせるための仕様の記述があります。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="emulating-callable-objects">
<span id="callable-types"></span><h3>3.3.5. 呼び出し可能オブジェクトをエミュレートする<a class="headerlink" href="#emulating-callable-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="method">
<dt id="object.__call__">
<code class="descclassname">object.</code><code class="descname">__call__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-86">インスタンスが関数として &#8220;呼ばれた&#8221; 際に呼び出されます; このメソッドが定義されている場合、 <code class="docutils literal"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> は <code class="docutils literal"><span class="pre">x.__call__(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> を短く書いたものになります。</p>
</dd></dl>

</div>
<div class="section" id="emulating-container-types">
<span id="sequence-types"></span><h3>3.3.6. コンテナをエミュレートする<a class="headerlink" href="#emulating-container-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下に挙げるメソッドを定義することで、コンテナオブジェクトを実装できます。コンテナは通常は (リストやタプルのような) シーケンスや (辞書のような) マッピングですが、他のコンテナも同じように表現することができます。最初のメソッド群はシーケンスもしくはマッピングを模倣するために使われます; 両者の違いは、シーケンスでキーとして使えるのは、 <em>N</em> をシーケンスの長さとして <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">N</span></code> を満たす整数 <em>k</em> 、もしくは要素の範囲を定義するスライスオブジェクトです。マッピングは、 Python の標準の辞書オブジェクトのメソッドと似た振る舞いをするメソッド <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">values()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">items()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">get()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">setdefault()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">update()</span></code> を提供することも推奨されています。 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールは、 <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal"><span class="pre">MutableMapping</span></code></a> 抽象基底クラスを提供し、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> 、 <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a> 、 <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a> 、 <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code> という基礎となるメソッド群から前文で挙げたメソッドを作成するのを助けてくれます。可変シーケンスは、 Python の標準のリストオブジェクトと同じように、メソッド <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">count()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">index()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">extend()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">insert()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code> 、 <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> を提供すべきです。最後に、シーケンス型は (連結を意味する) 加算と (繰り返しを意味する) 乗算を、以下に説明するメソッド <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a> 、 <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal"><span class="pre">__radd__()</span></code></a> 、 <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal"><span class="pre">__iadd__()</span></code></a> 、 <a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal"><span class="pre">__mul__()</span></code></a> 、 <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal"><span class="pre">__rmul__()</span></code></a> 、 <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal"><span class="pre">__imul__()</span></code></a> を定義して実装すべきです; そして、それ以外の数値演算子は定義すべきではありません。マッピングとシーケンスは両方とも、効率の良い <code class="docutils literal"><span class="pre">in</span></code> 演算子が使えるように <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> メソッドを実装すべきです; マッピングでは <code class="docutils literal"><span class="pre">in</span></code> はマッピングのキーを検索すべきです; シーケンスでは値を検索すべきです。マッピングもシーケンスも、コンテナの効率の良い反復処理ができるよう <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> メソッドを実装すべきです; マッピングでは <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> は <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code> と同じであるべきです; シーケンスでは値全体の反復処理を行うべきです。</p>
<dl class="method">
<dt id="object.__len__">
<code class="descclassname">object.</code><code class="descname">__len__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-87">呼び出して組み込み関数 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> を実装します。
オブジェクトの長さを 0 以上の整数で返さなければなりません。
また、 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a>  メソッドを定義しておらず、 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> メソッドが 0 を返すようなオブジェクトは、ブール演算コンテキストでは偽とみなされます。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> In CPython, the length is required to be at most <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a>.
If the length is larger than <code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code> some features (such as
<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a>) may raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a>.  To prevent raising
<code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code> by truth value testing, an object must define a
<a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__length_hint__">
<code class="descclassname">object.</code><code class="descname">__length_hint__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出して <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal"><span class="pre">operator.length_hint()</span></code></a> を実装します。
オブジェクトの推定される長さ (実際のものより長かったり短かったりするかもしれません) を返さなければなりません。
長さは 0 以上の整数でなければなりません。
このメソッドは純粋に最適化であり、正確性のために必要なものではありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>スライシングは、以下の 3 メソッドによって排他的に行われます。次のような呼び出しは</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>次のように翻訳され</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p class="last">以下も同様です。存在しないスライスの要素は <code class="docutils literal"><span class="pre">None</span></code> で埋められます。</p>
</div>
<dl class="method">
<dt id="object.__getitem__">
<code class="descclassname">object.</code><code class="descname">__getitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-88"><code class="docutils literal"><span class="pre">self[key]</span></code> の値評価 (evaluation) を実現するために呼び出されます。シーケンスの場合、キーとして整数とスライスオブジェクトを受理できなければなりません。 (シーケンス型をエミュレートする場合) 負のインデクスの解釈は <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッド次第となります。 <em>key</em> が不適切な型であった場合、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出してもかまいません; (負のインデクス値に対して何らかの解釈を行った上で) <em>key</em> がシーケンスのインデクス集合外の値である場合、 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> を送出しなければなりません。マップ型の場合は、 <em>key</em> に誤りがある場合（コンテナに含まれていない場合）、 <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出しなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループでは、シーケンスの終端を正しく検出できるようにするために、不正なインデクスに対して <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> が送出されるものと期待しています。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__missing__">
<code class="descclassname">object.</code><code class="descname">__missing__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[key]</span></code> の実装において辞書内にキーが存在しなかった場合に、 dict のサブクラスのために <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> によって呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="object.__setitem__">
<code class="descclassname">object.</code><code class="descname">__setitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[key]</span></code> に対する代入を実装するために呼び出されます。 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> と同じ注意事項があてはまります。このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができるシーケンスの場合だけです。不正な <em>key</em> に対しては、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドと同様の例外の送出を行わなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__delitem__">
<code class="descclassname">object.</code><code class="descname">__delitem__</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">self[key]</span></code> の削除を実装するために呼び出されます。 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> と同じ注意事項があてはまります。このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、要素を削除できるシーケンスの場合だけです。不正な <em>key</em> に対しては、 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドと同様の例外の送出を行わなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__iter__">
<code class="descclassname">object.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。このメソッドは、コンテナ内の全てのオブジェクトに渡って反復処理できるような、新たなイテレータオブジェクトを返さなければなりません。マッピングでは、コンテナ内のキーに渡って反復処理しなければなりません。</p>
<p>イテレータオブジェクトでもこのメソッドを実装する必要があります; イテレータの場合、自分自身を返さなければなりません。イテレータオブジェクトに関するより詳細な情報は、 <a class="reference internal" href="../library/stdtypes.html#typeiter"><span class="std std-ref">イテレータ型</span></a> を参照してください。</p>
</dd></dl>

<dl class="method">
<dt id="object.__reversed__">
<code class="descclassname">object.</code><code class="descname">__reversed__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> 組み込み関数が逆方向イテレーションを実装するために、(存在すれば)呼び出します。コンテナ内の全要素を逆順にイテレートする、新しいイテレータを返すべきです。</p>
<p><a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a> メソッドが定義されていない場合、 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> 組込み関数は sequence プロトコル (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> と <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>) を使った方法にフォールバックします。 sequence プロトコルをサポートしたオブジェクトは、 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> よりも効率のいい実装を提供できる場合にのみ <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a> を定義するべきです。</p>
</dd></dl>

<p>帰属テスト演算子 (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> および <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>) は通常、シーケンスに渡る反復処理を使って実装されます。しかし、コンテナオブジェクトで以下の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクトがシーケンスでなくてもよいようにできます。</p>
<dl class="method">
<dt id="object.__contains__">
<code class="descclassname">object.</code><code class="descname">__contains__</code><span class="sig-paren">(</span><em>self</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>帰属テスト演算を実装するために呼び出されます。 <em>item</em> が <em>self</em> 内に存在する場合には真を、そうでない場合には偽を返さなければなりません。マップオブジェクトの場合、値やキーと値の組ではなく、キーに対する帰属テストを考えなければなりません。</p>
<p><a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> を定義しないオブジェクトに対しては、メンバシップテストはまず、 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> を使った反復を試みます、次に古いシーケンス反復プロトコル <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> を使います、 <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">言語レファレンスのこの節</span></a> を参照して下さい。</p>
</dd></dl>

</div>
<div class="section" id="emulating-numeric-types">
<span id="numeric-types"></span><h3>3.3.7. 数値型をエミュレーションする<a class="headerlink" href="#emulating-numeric-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のメソッドを定義して、数値型オブジェクトをエミュレートすることができます。特定の種類の数値型ではサポートされていないような演算に対応するメソッド (非整数の数値に対するビット単位演算など) は、未定義のままにしておかなければなりません。</p>
<dl class="method">
<dt id="object.__add__">
<code class="descclassname">object.</code><code class="descname">__add__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__sub__">
<code class="descclassname">object.</code><code class="descname">__sub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__mul__">
<code class="descclassname">object.</code><code class="descname">__mul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__matmul__">
<code class="descclassname">object.</code><code class="descname">__matmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__truediv__">
<code class="descclassname">object.</code><code class="descname">__truediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__floordiv__">
<code class="descclassname">object.</code><code class="descname">__floordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__mod__">
<code class="descclassname">object.</code><code class="descname">__mod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__divmod__">
<code class="descclassname">object.</code><code class="descname">__divmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__pow__">
<code class="descclassname">object.</code><code class="descname">__pow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__lshift__">
<code class="descclassname">object.</code><code class="descname">__lshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rshift__">
<code class="descclassname">object.</code><code class="descname">__rshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__and__">
<code class="descclassname">object.</code><code class="descname">__and__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__xor__">
<code class="descclassname">object.</code><code class="descname">__xor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__or__">
<code class="descclassname">object.</code><code class="descname">__or__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-89">これらのメソッドを呼んで二項算術演算子 (<code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">&#64;</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">//</span></code>, <code class="docutils literal"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a>, <code class="docutils literal"><span class="pre">**</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">|</span></code>) を実装します。
例えば <em>x</em> が <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a> メソッドのあるクラスのインスタンスである場合、式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> を評価すると <code class="docutils literal"><span class="pre">x.__add__(y)</span></code> が呼ばれます。
<a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal"><span class="pre">__divmod__()</span></code></a> メソッドは <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal"><span class="pre">__floordiv__()</span></code></a> と <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal"><span class="pre">__mod__()</span></code></a> を使用するのと等価でなければなりません。
<a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal"><span class="pre">__truediv__()</span></code></a> と関連してはなりません。
組み込みの <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a> 関数の三項のものがサポートされていなければならない場合、 <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal"><span class="pre">__pow__()</span></code></a> はオプションの第三引数を受け取るものとして定義されなければなりません。</p>
<p>これらのメソッドのいずれかが渡された引数に対する操作を提供していない場合、 <code class="docutils literal"><span class="pre">NotImplemented</span></code> を送出しなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__radd__">
<code class="descclassname">object.</code><code class="descname">__radd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rsub__">
<code class="descclassname">object.</code><code class="descname">__rsub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmul__">
<code class="descclassname">object.</code><code class="descname">__rmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmatmul__">
<code class="descclassname">object.</code><code class="descname">__rmatmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="descclassname">object.</code><code class="descname">__rtruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="descclassname">object.</code><code class="descname">__rfloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rmod__">
<code class="descclassname">object.</code><code class="descname">__rmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="descclassname">object.</code><code class="descname">__rdivmod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rpow__">
<code class="descclassname">object.</code><code class="descname">__rpow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rlshift__">
<code class="descclassname">object.</code><code class="descname">__rlshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rrshift__">
<code class="descclassname">object.</code><code class="descname">__rrshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rand__">
<code class="descclassname">object.</code><code class="descname">__rand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__rxor__">
<code class="descclassname">object.</code><code class="descname">__rxor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ror__">
<code class="descclassname">object.</code><code class="descname">__ror__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-90">These methods are called to implement the binary arithmetic operations
(<code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">&#64;</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">//</span></code>, <code class="docutils literal"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a>,
<a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a>, <code class="docutils literal"><span class="pre">**</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">^</span></code>, <code class="docutils literal"><span class="pre">|</span></code>) with reflected
(swapped) operands.  These functions are only called if the left operand does
not support the corresponding operation <a class="footnote-reference" href="#id10" id="id5">[3]</a> and the operands are of different
types. <a class="footnote-reference" href="#id11" id="id6">[4]</a> For instance, to evaluate the expression <code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, where <em>y</em> is
an instance of a class that has an <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal"><span class="pre">__rsub__()</span></code></a> method, <code class="docutils literal"><span class="pre">y.__rsub__(x)</span></code>
is called if <code class="docutils literal"><span class="pre">x.__sub__(y)</span></code> returns <em>NotImplemented</em>.</p>
<p id="index-91">ただし、三項演算子 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a> が <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal"><span class="pre">__rpow__()</span></code></a> を呼ぶことはないので注意してください (型強制の規則が非常に難解になるからです)。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">右側の被演算子の型が左側の被演算子の型のサブクラスであり、このサブクラスであるメソッドに対する反射メソッドが定義されている場合には、左側の被演算子の非反射メソッドが呼ばれる前に、このメソッドが呼ばれます。この振る舞いにより、サブクラスが親の演算をオーバーライドすることが可能になります。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__iadd__">
<code class="descclassname">object.</code><code class="descname">__iadd__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__isub__">
<code class="descclassname">object.</code><code class="descname">__isub__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imul__">
<code class="descclassname">object.</code><code class="descname">__imul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imatmul__">
<code class="descclassname">object.</code><code class="descname">__imatmul__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__itruediv__">
<code class="descclassname">object.</code><code class="descname">__itruediv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="descclassname">object.</code><code class="descname">__ifloordiv__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__imod__">
<code class="descclassname">object.</code><code class="descname">__imod__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ipow__">
<code class="descclassname">object.</code><code class="descname">__ipow__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="optional">[</span>, <em>modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ilshift__">
<code class="descclassname">object.</code><code class="descname">__ilshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__irshift__">
<code class="descclassname">object.</code><code class="descname">__irshift__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__iand__">
<code class="descclassname">object.</code><code class="descname">__iand__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ixor__">
<code class="descclassname">object.</code><code class="descname">__ixor__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__ior__">
<code class="descclassname">object.</code><code class="descname">__ior__</code><span class="sig-paren">(</span><em>self</em>, <em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>これらのメソッドを呼び出して累算算術代入 (<code class="docutils literal"><span class="pre">+=</span></code>, <code class="docutils literal"><span class="pre">-=</span></code>, <code class="docutils literal"><span class="pre">*=</span></code>, <code class="docutils literal"><span class="pre">&#64;=</span></code>, <code class="docutils literal"><span class="pre">/=</span></code>, <code class="docutils literal"><span class="pre">//=</span></code>, <code class="docutils literal"><span class="pre">%=</span></code>, <code class="docutils literal"><span class="pre">**=</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal"><span class="pre">&amp;=</span></code>, <code class="docutils literal"><span class="pre">^=</span></code>, <code class="docutils literal"><span class="pre">|=</span></code>) を実装します。
これらのメソッドは演算をインプレースで (<em>self</em> を変更する) 行うよう試み、その結果 (その必要はありませんが <em>self</em> でも構いません) を返さなければなりません。
特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッドにフォールバックされます。
例えば <em>x</em> が <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal"><span class="pre">__iadd__()</span></code></a> メソッドを持つクラスのインスタンスである場合、<code class="docutils literal"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code> と等価です。
そうでない場合、<code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> の評価と同様に <code class="docutils literal"><span class="pre">x.__add__(y)</span></code> と <code class="docutils literal"><span class="pre">y.__radd__(x)</span></code> が考慮されます。
特定の状況では、累算代入は予期しないエラーに終わるかもしれません (<a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">なぜ加算はされるのに a_tuple[i] += [&#8216;item&#8217;] は例外を送出するのですか?</span></a> を参照してください) が、この挙動は実際はデータモデルの挙動の一部です。</p>
</dd></dl>

<dl class="method">
<dt id="object.__neg__">
<code class="descclassname">object.</code><code class="descname">__neg__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__pos__">
<code class="descclassname">object.</code><code class="descname">__pos__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__abs__">
<code class="descclassname">object.</code><code class="descname">__abs__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__invert__">
<code class="descclassname">object.</code><code class="descname">__invert__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-92">呼び出して単項算術演算 (<code class="docutils literal"><span class="pre">-</span></code>, <code class="docutils literal"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> および <code class="docutils literal"><span class="pre">~</span></code>) を実装します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__complex__">
<code class="descclassname">object.</code><code class="descname">__complex__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__int__">
<code class="descclassname">object.</code><code class="descname">__int__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__float__">
<code class="descclassname">object.</code><code class="descname">__float__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="この定義へのパーマリンク">¶</a></dt>
<dt id="object.__round__">
<code class="descclassname">object.</code><code class="descname">__round__</code><span class="sig-paren">(</span><em>self</em><span class="optional">[</span>, <em>n</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-93">呼び出して組み込み関数 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a> 、および <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a> を実装します。適切な型の値を返さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__index__">
<code class="descclassname">object.</code><code class="descname">__index__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出して <a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal"><span class="pre">operator.index()</span></code></a> を実装します。
Python が数値オブジェクトを整数オブジェクトに損失なく変換する必要がある場合 (たとえばスライシングや、組み込みの <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal"><span class="pre">bin()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal"><span class="pre">hex()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a> 関数) は常に呼び出されます。
このメソッドがあるとその数値オブジェクトが整数型であることが示唆されます。
整数を返さなければなりません。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">整数型クラスの一貫性を保つため、<a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> が定義された場合、<a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal"><span class="pre">__int__()</span></code></a> もまた定義されるべきであり、どちらも同じ値を返すべきです。</p>
</div>
</dd></dl>

</div>
<div class="section" id="with-statement-context-managers">
<span id="context-managers"></span><h3>3.3.8. with文とコンテキストマネージャ<a class="headerlink" href="#with-statement-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンテキストマネージャ(<em class="dfn">context manager</em>) とは、 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の実行時にランタイムコンテキストを定義するオブジェクトです。コンテキストマネージャは、コードブロックを実行するために必要な入り口および出口の処理を扱います。コンテキストマネージャは通常、 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文（ <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">with 文</span></a> の章を参照）により起動されますが、これらのメソッドを直接呼び出すことで起動することもできます。</p>
<p id="index-94">コンテキストマネージャの代表的な使い方としては、様々なグローバル情報の保存および更新、リソースのロックとアンロック、ファイルのオープンとクローズなどが挙げられます。</p>
<p>コンテキストマネージャについてのさらなる情報については、 <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">コンテキストマネージャ型</span></a> を参照してください。</p>
<dl class="method">
<dt id="object.__enter__">
<code class="descclassname">object.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャのの入り口で実行される処理です。 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文は、文の <a class="reference internal" href="compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節で規定された値を返すこのメソッドを呼び出します。</p>
</dd></dl>

<dl class="method">
<dt id="object.__exit__">
<code class="descclassname">object.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コンテキストマネージャの出口で実行される処理です。パラメータは、コンテキストが終了した原因となった例外について説明しています。コンテキストが例外を送出せず終了した場合は、全ての引き数に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> が設定されます。</p>
<p>もし、例外が送出され、かつメソッドが例外を抑制したい場合（すなわち、例外が伝播されるのを防ぎたい場合）、このメソッドは True を返す必要があります。そうでなければ、このメソッドの終了後、例外は通常通り伝播することになります。</p>
<p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドは受け取った例外を再度送出すべきではありません。これは、呼び出し側の責任でおこなってください。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-104"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &#8220;with&#8221; ステートメント</dt>
<dd><p class="first last">Python の <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文の仕様、背景、および例が記載されています。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="special-method-lookup">
<span id="special-lookup"></span><h3>3.3.9. 特殊メソッド検索<a class="headerlink" href="#special-method-lookup" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>カスタムクラスでは、特殊メソッドの暗黙の呼び出しは、オブジェクトのインスタンス辞書ではなく、オブジェクトの型で定義されているときにのみ正しく動作することが保証されます。この動作のため、以下のコードは例外を送出します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>この動作の背景となる理由は、 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> と <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> といった type オブジェクトを含むすべてのオブジェクトで定義されている特殊メソッドにあります。これらのメソッドの暗黙の検索が通常の検索プロセスを使った場合、 type オブジェクト自体に対して実行されたときに失敗してしまいます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>クラスの非結合メソッドをこのようにして実行しようとすることは、&#8217;metaclass confusion&#8217; と呼ばれることもあり、特殊メソッドを検索するときはインスタンスをバイパスすることで回避されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>正確性のためにインスタンス属性をスキップするのに加えて、特殊メソッド検索はオブジェクトのメタクラスを含めて、 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> メソッドもバイパスします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>このように <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> 機構をバイパスすることで、特殊メソッドの扱いに関するある程度の自由度と引き換えに (特殊メソッドはインタプリタから一貫して実行されるためにクラスオブジェクトに設定 <em>しなければならない</em>)、インタープリタを高速化するための大きな余地が手に入ります。</p>
</div>
</div>
<div class="section" id="coroutines">
<span id="index-96"></span><h2>3.4. コルーチン<a class="headerlink" href="#coroutines" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="awaitable-objects">
<h3>3.4.1. 待機可能オブジェクト (Awaitable Object)<a class="headerlink" href="#awaitable-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトは一般的には <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal"><span class="pre">__await__()</span></code></a> が実装されています。
<a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">def</span></code></a> 関数が返す <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine</span></a> オブジェクトは待機可能です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal"><span class="pre">types.coroutine()</span></code></a> デコレータもしくは <a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal"><span class="pre">asyncio.coroutine()</span></code></a> でデコレータが付けられたジェネレータから返される <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> オブジェクトも待機可能ですが、 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal"><span class="pre">__await__()</span></code></a> は実装されていません。</p>
</div>
<dl class="method">
<dt id="object.__await__">
<code class="descclassname">object.</code><code class="descname">__await__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> を返さなければなりません。
このメソッドは <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトを実装するのに使われるべきです。
簡単のために、 <a class="reference internal" href="../library/asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> にはこのメソッドが実装され、 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal"><span class="pre">await</span></code></a> 式と互換性を持つようになっています。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">待機可能オブジェクトについてより詳しくは <span class="target" id="index-105"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> を参照してください。</p>
</div>
</div>
<div class="section" id="coroutine-objects">
<span id="id7"></span><h3>3.4.2. コルーチンオブジェクト<a class="headerlink" href="#coroutine-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine</span></a> オブジェクトは <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトです。
<a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal"><span class="pre">__await__()</span></code></a> を呼び出し、その返り値に対し反復処理をすることでコルーチンの実行を制御できます。
コルーチンの実行が完了し制御を戻したとき、イテレータは <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を送出し、その例外の <code class="xref py py-attr docutils literal"><span class="pre">value</span></code> 属性に返り値を持たせます。
コルーチンが例外を送出した場合は、イテレータにより伝搬されます。
コルーチンから <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外を外に送出すべきではありません。</p>
<p>コルーチンには以下に挙げるメソッドもあり、これらはジェネレータのメソッドからの類似です (<a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">ジェネレータ-イテレータメソッド</span></a> を参照してください)。
ただし、ジェネレータと違って、コルーチンは反復処理を直接はサポートしていません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5.2 で変更: </span>コルーチンで2回以上待機 (await) すると <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> となります。</p>
</div>
<dl class="method">
<dt id="coroutine.send">
<code class="descclassname">coroutine.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コルーチンの実行を開始したり再開したりします。
<em>value</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合は、 <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal"><span class="pre">__await__()</span></code></a> から返されたイテレータを進めるのと同等です。
<em>value</em> が <code class="docutils literal"><span class="pre">None</span></code> でない場合は、このコルーチンを一時停止させたイテレータの <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> メソッドに処理を委任します。
結果 (返り値か <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> かその他の例外) は、上で解説したような <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal"><span class="pre">__await__()</span></code></a> の返り値に対して反復処理を行ったときと同じです。</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.throw">
<code class="descclassname">coroutine.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コルーチンで指定された例外を送出します。
このメソッドは、イテレータにコルーチンを一時停止する <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal"><span class="pre">throw()</span></code></a> メソッドがある場合に処理を委任します。
そうでない場合には、中断した地点から例外が送出されます。
結果 (返り値か <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> かその他の例外) は、上で解説したような <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal"><span class="pre">__await__()</span></code></a> の返り値に対して反復処理を行ったときと同じです。
例外がコルーチンの中で捕捉されなかった場合、呼び出し元へ伝搬されます。</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.close">
<code class="descclassname">coroutine.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コルーチンが自分自身の後片付けをし終了します。
コルーチンが一時停止している場合は、コルーチンを一時停止させたイテレータに <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> メソッドがあれば、まずはそれに処理を委任します。
そして一時停止した地点から <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> が送出され、ただちにコルーチンが自分自身の後片付けを行います。
最後に、実行が開始されていなかった場合でも、コルーチンに実行が完了した印を付けます。</p>
<p>コルーチンオブジェクトが破棄されるときには、上記の手順を経て自動的に閉じられます。</p>
</dd></dl>

</div>
<div class="section" id="asynchronous-iterators">
<span id="async-iterators"></span><h3>3.4.3. 非同期イテレータ (Asynchronous Iterator)<a class="headerlink" href="#asynchronous-iterators" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>非同期イテラブル</em> の <code class="docutils literal"><span class="pre">__aiter__</span></code> の実装からは非同期のコードが呼べ、 <em>非同期イテレータ</em> の <code class="docutils literal"><span class="pre">__anext__</span></code> メソッドからは非同期のコードが呼べます。</p>
<p>非同期イテレータは <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">for</span></code></a> 文の中で使えます。</p>
<dl class="method">
<dt id="object.__aiter__">
<code class="descclassname">object.</code><code class="descname">__aiter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>非同期イテレータ</em> オブジェクトを返さなくてはなりません。</p>
</dd></dl>

<dl class="method">
<dt id="object.__anext__">
<code class="descclassname">object.</code><code class="descname">__anext__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イテレータの次の値を返す <em>待機可能オブジェクト</em> を返さなければなりません。
反復処理が終了したときには <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopAsyncIteration</span></code></a> エラーを送出すべきです。</p>
</dd></dl>

<p>非同期イテラブルオブジェクトの例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<div class="last versionchanged">
<p><span class="versionmodified">バージョン 3.5.2 で変更: </span>CPython 3.5.2 以降では、 <code class="docutils literal"><span class="pre">__aiter__</span></code> は <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">非同期イテレータ</span></a> を直接返せます。
<a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトを返すと <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">PendingDeprecationWarning</span></code></a> が送出されます。</p>
<p>CPython 3.5.x での後方互換性のあるコードを書くときに推奨される方法は、 <code class="docutils literal"><span class="pre">__aiter__</span></code> から待機可能オブジェクトを返し続けることです。
PendingDeprecationWarning を避け、コードの後方互換性を保ちたい場合は、次のデコレータが使えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">aiter_compat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">aiter_compat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span>
</pre></div>
</div>
<p>以下はプログラム例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncIterator</span><span class="p">:</span>

    <span class="nd">@aiter_compat</span>
    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>CPython 3.6 からは、 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">PendingDeprecationWarning</span></code></a> は <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a> に置き換えられます。
CPython 3.7 では、 <code class="docutils literal"><span class="pre">__aiter__</span></code> から待機可能オブジェクトを返すと <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が送出されます。</p>
</div>
</div>
</div>
<div class="section" id="asynchronous-context-managers">
<h3>3.4.4. 非同期コンテクストマネージャ (Asynchronous Context Manager)<a class="headerlink" href="#asynchronous-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>非同期コンテキストマネージャ</em> は、 <code class="docutils literal"><span class="pre">__aenter__</span></code> メソッドと <code class="docutils literal"><span class="pre">__aexit__</span></code> メソッド内部で実行を一時停止できる <em>コンテキストマネージャ</em> です。</p>
<p>非同期コンテキストマネージャは <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal"><span class="pre">async</span> <span class="pre">with</span></code></a> 文の中で使えます。</p>
<dl class="method">
<dt id="object.__aenter__">
<code class="descclassname">object.</code><code class="descname">__aenter__</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは文法的には <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> に似ていますが、 <em>待機可能オブジェクト</em> を返さなければならないところだけが異なります。</p>
</dd></dl>

<dl class="method">
<dt id="object.__aexit__">
<code class="descclassname">object.</code><code class="descname">__aexit__</code><span class="sig-paren">(</span><em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このメソッドは文法的には <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> に似ていますが、 <em>待機可能オブジェクト</em> を返さなければならないところだけが異なります。</p>
</dd></dl>

<p>非同期コンテキストマネージャクラスの例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first last">特定の条件が満たされた場合、オブジェクトの type を変更することが <em>できます</em> 。これは、正しく扱われなかった場合にとても奇妙な動作を引き起こすので、一般的には良い考えではありません。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>The <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a>, and
<a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> methods have special handling for this; others
will still raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>, but may do so by relying on
the behavior that <code class="docutils literal"><span class="pre">None</span></code> is not callable.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>&#8220;Does not support&#8221; here means that the class has no such method, or
the method returns <code class="docutils literal"><span class="pre">NotImplemented</span></code>.  Do not set the method to
<code class="docutils literal"><span class="pre">None</span></code> if you want to force fallback to the right operand&#8217;s reflected
method—that will instead have the opposite effect of explicitly
<em>blocking</em> such fallback.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td><p class="first last">同じ型の被演算子については、無反転のメソッド (たとえば <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal"><span class="pre">__add__()</span></code></a>) が失敗した場合、その演算はサポートされていないとみなされます。
これは、反射したメソッドが呼び出されないためです。</p>
</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. データモデル</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. オブジェクト、値、および型</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. 標準型の階層</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. 特殊メソッド名</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. 基本的なカスタマイズ</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. 属性値アクセスをカスタマイズする</a><ul>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.1. デスクリプタ (descriptor) の実装</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.2. デスクリプタの呼び出し</a></li>
<li><a class="reference internal" href="#slots">3.3.2.3. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.3.1. <em>__slots__</em> を利用する際の注意</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. クラス生成をカスタマイズする</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclasses</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.2. 適切なメタクラスの決定</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.3. クラスの名前空間の準備</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.4. クラス本体の実行</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.5. クラスオブジェクトの作成</a></li>
<li><a class="reference internal" href="#metaclass-example">3.3.3.6. メタクラスの例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. インスタンスのカスタマイズとサブクラスチェック</a></li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.5. 呼び出し可能オブジェクトをエミュレートする</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.6. コンテナをエミュレートする</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.7. 数値型をエミュレーションする</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.8. with文とコンテキストマネージャ</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.9. 特殊メソッド検索</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. コルーチン</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. 待機可能オブジェクト (Awaitable Object)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. コルーチンオブジェクト</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. 非同期イテレータ (Asynchronous Iterator)</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. 非同期コンテクストマネージャ (Asynchronous Context Manager)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="前の章へ">2. 字句解析</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="次の章へ">4. 実行モデル</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/reference/datamodel.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 実行モデル"
             >次へ</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 字句解析"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 5月 27, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>