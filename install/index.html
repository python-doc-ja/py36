
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Python モジュールのインストール (旧版) &#8212; Python 3.6.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="prev" title="10. API リファレンス" href="../distutils/apiref.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/install/index.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/install/index.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="../distutils/apiref.html" title="10. API リファレンス"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="installing-python-modules-legacy-version">
<span id="install-index"></span><h1>Python モジュールのインストール (旧版)<a class="headerlink" href="#installing-python-modules-legacy-version" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">Greg Ward — 日本語訳: Python ドキュメント翻訳プロジェクト</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../installing/index.html#installing-index"><span class="std std-ref">Python モジュールのインストール</span></a></dt>
<dd>最新のモジュールインストールのドキュメンテーション</dd>
</dl>
</div>
<p>このドキュメントでは、Python モジュール配布ユーティリティ (Python Distribution Utilities, &quot;Distutils&quot;) について、エンドユーザの視点に立ち、サードパーティ製のモジュールや拡張モジュールの構築やインストールによって標準の Python に機能を追加する方法について述べます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このガイドは、Python のバージョンの一部として提供される拡張のビルドと配布についての基礎的なツールについてのみをカバーします。サードパーティによるツールが、容易に使えてもっと安全な代替として使えるでしょう。もっと詳しい情報は <a class="reference external" href="https://packaging.python.org/en/latest/current/">quick recommendations section</a> にある Python パッケージングユーザガイドから得られます。</p>
</div>
<div class="section" id="introduction">
<span id="inst-intro"></span><h2>はじめに<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python の広範な標準ライブラリは、プログラミングにおける多くの要求をカバーしていますが、時には何らかの新たな機能をサードパーティ製モジュールの形で追加する必要に迫られます。自分がプログラムを書くときのサポートとして必要な場合もあるし、自分が使いたいアプリケーションがたまたま Python で書かれていて、そのサポートとして必要な場合もあるでしょう。</p>
<p>以前は、すでにインストール済みの Python に対して、サードパーティ製モジュールを追加するためのサポートはほとんどありませんでした。しかしPython 配布ユーティリティ (Python Distribution Utilities,  略して Distutils) が Python 2.0 から取り入れられ、状況は変わりました。</p>
<p>このドキュメントが主要な対象としているのは、サードパーティモジュールをインストールする必要がある人たち: 単に何らかの Python アプリケーションを稼動させたいだけのエンドユーザやシステム管理者、そしてすでに Python プログラマであって、新たな道具を自分のツールキットに加えたいと思っている人たちです。このドキュメントを読むために、 Python について知っておく必要はありません; インストールしたモジュールを調べるために Python の対話モードにちょっとだけ手を出す必要がありますが、それだけです。自作の Python モジュールを他人が使えるようにするために配布する方法を探しているのなら、 <a class="reference internal" href="../distutils/index.html#distutils-index"><span class="std std-ref">Python モジュールの配布 (レガシーバージョン)</span></a> マニュアルを参照してください。 <a class="reference internal" href="../distutils/setupscript.html#debug-setup-script"><span class="std std-ref">setup スクリプトをデバッグする</span></a> も面白いかもしれません。</p>
<div class="section" id="best-case-trivial-installation">
<span id="inst-trivial-install"></span><h3>もっとも簡単な場合: ありふれたインストール作業<a class="headerlink" href="#best-case-trivial-installation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最も楽なのは、インストールしたいモジュール配布物の特殊なバージョンをインストールしたいプラットフォーム向けに誰かがすでに用意してくれていて、他のアプリケーションと同じようにインストールするだけであるような場合です。例えば Windows ユーザ向けには実行可能形式のインストーラ、RPM ベースの Linux システム (Red Hat, SuSE, Mandrake その他多数)  向けには RPM パッケージ、Debian ベースの Linux システム向けには  Debian パッケージといった具合に、モジュール開発者はビルド済み配布物を作成しているかもしれません。</p>
<p>その場合、自分のプラットフォームに適したインストーラをダウンロードして、例えば RPM なら <code class="docutils literal"><span class="pre">rpm</span> <span class="pre">--install</span></code> などの方法でインストーラを実行します。Python や setup スクリプトを実行する必要も、何かをコンパイルする必要もありません。— 何らかの手順書を一切読まずにインストールすることも可能でしょう (常に読んだほうが良いですが)。</p>
<p>もちろん、いつもこう簡単とは限りません。自分のプラットフォーム向けのお手軽なインストーラがないモジュール配布物に興味を持つこともあるでしょう。そんな場合には、モジュールの作者やメンテナがリリースしているソース配布物から作業をはじめねばなりません。ソース配布物からのインストールは、モジュールが標準的な方法でパッケージ化されている限りさほど大変ではありません。このドキュメントの大部分は、標準的なソース配布物からのビルドとインストールに関するものです。</p>
</div>
<div class="section" id="the-new-standard-distutils">
<span id="inst-new-standard"></span><h3>新しい標準: Distutils<a class="headerlink" href="#the-new-standard-distutils" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>モジュールのソースコード配布物をダウンロードしたら、配布物が標準のやり方、すなわち Distutils のやり方に従ってパッケージされて 配布されているかどうかすぐに分かります。Distutils の場合、まず配布物の名前とバージョン番号が、例えば <code class="file docutils literal"><span class="pre">foo-1.0.tar.gz</span></code> や <code class="file docutils literal"><span class="pre">widget-0.9.7.zip</span></code> のように、ダウンロードされたアーカイブファイルの 名前にはっきりと反映されます。次に、アーカイブは同様の名前のディレクトリ、例えば <code class="file docutils literal"><span class="pre">foo-1.0</span></code> や <code class="file docutils literal"><span class="pre">widget-0.9.7</span></code> に展開されます。さらに、配布物には setup スクリプト <code class="file docutils literal"><span class="pre">setup.py</span></code> が入っています。また、 <code class="file docutils literal"><span class="pre">README.txt</span></code> 場合によっては <code class="file docutils literal"><span class="pre">README</span></code> という名前のファイルも入っていて、そこには、モジュール配布物の構築とインストールは簡単で、このようにするだけだ、とするだけだ、という説明が書かれているはずです</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install
</pre></div>
</div>
<p>Windows ではこのコマンドは、コマンドプロンプトのウィンドウを開いて (<span class="menuselection">スタート ‣ アクセサリ</span>)、このように実行するのに違いありません</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>setup.py install
</pre></div>
</div>
<p>上記の全てが当てはまるなら、ダウンロードしたものをビルドしてインストールする方法はすでに知っていることになります: 上記のコマンドを実行するだけです。非標準の方法でインストールを行ったり、ビルドプロセスをカスタマイズ行いたいのでない限り、このマニュアルは必要ありません。別の言葉で言えば、上のコマンドこそが、このマニュアルから習得すべき全てということになります。</p>
</div>
</div>
<div class="section" id="standard-build-and-install">
<span id="inst-standard-install"></span><h2>標準的なビルド・インストール作業<a class="headerlink" href="#standard-build-and-install" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#inst-new-standard"><span class="std std-ref">新しい標準: Distutils</span></a> 節で述べたように、 Distutils を使ったモジュール配布物のビルドとインストールは、通常は端末からの単純な以下コマンドで行います:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install
</pre></div>
</div>
<div class="section" id="platform-variations">
<span id="inst-platform-variations"></span><h3>プラットフォームによる違い<a class="headerlink" href="#platform-variations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>setup コマンドは常に配布物ルートディレクトリ、すなわちモジュールのソース配布物を展開した際のトップレベルのサブディレクトリ内で実行しなければなりません。例えば、あるモジュールのソース配布物 <code class="file docutils literal"><span class="pre">foo-1.0.tar.gz</span></code> を Unix システム上にダウンロードしたなら、通常は以下の操作を行います:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
cd foo-1.0
python setup.py install
</pre></div>
</div>
<p>Windows では、おそらく <code class="file docutils literal"><span class="pre">foo-1.0.zip</span></code> をダウンロードしているでしょう。アーカイブファイルを <code class="file docutils literal"><span class="pre">C:\Temp</span></code> にダウンロードしたのなら、(WinZip のような) グラフィカルユーザインタフェースつきのアーカイブ操作ソフトや、 (<strong class="program">unzip</strong> や <strong class="program">pkunzip</strong> のような) コマンドラインツールを使ってアーカイブを <code class="file docutils literal"><span class="pre">C:\Temp\foo-1.0</span></code> に展開します。次に、コマンドプロンプトウィンドウを開いて、以下を実行します:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>cd c:\Temp\foo-1.0
python setup.py install
</pre></div>
</div>
</div>
<div class="section" id="splitting-the-job-up">
<span id="inst-splitting-up"></span><h3>ビルド作業とインストール作業を分割する<a class="headerlink" href="#splitting-the-job-up" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">setup.py</span> <span class="pre">install</span></code> を実行すると、一度の実行で全てのモジュールをビルドしてインストールします。段階的に作業をしたい場合 — ビルドプロセスをカスタマイズしたり、作業がうまくいかない場合に特に便利です — には、setup スクリプトに一度に一つづつ作業を行わせるようにできます。この機能は、ビルドとインストールを異なるユーザで行う場合にも便利です — 例えば、モジュール配布物をビルドしておいてシステム管理者に渡して (または、自分でスーパユーザになって)、インストールしたくなるかもしれません.</p>
<p>最初のステップでは全てをビルドしておき、次のステップで全てをインストールするには、setup スクリプトを二度起動します:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py build
python setup.py install
</pre></div>
</div>
<p>この作業を行ってみれば、 <strong class="command">install</strong> コマンドを実行するとまず <strong class="command">build</strong> コマンドを実行し、さらに — この場合には — <code class="file docutils literal"><span class="pre">build</span></code> ディレクトリの中が全て最新の状態になっているので、 <strong class="command">build</strong> は何も行わなくてよいと判断していることがわかるでしょう。</p>
<p>インターネットからダウンロードしたモジュールをインストールしたいだけなら、上のように作業を分割する機能は必要ないかもしれませんが、この機能はより進んだ使い方をする際にはとても便利です。自作の Python モジュールや拡張モジュールを配布することになれば、個々の Distutils コマンドを自分で何度も実行することになるでしょう。</p>
</div>
<div class="section" id="how-building-works">
<span id="inst-how-build-works"></span><h3>ビルドの仕組み<a class="headerlink" href="#how-building-works" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上で示唆したように、 <strong class="command">build</strong> コマンドは、インストールすべきファイルを <em>ビルドディレクトリ</em> に置く働きがあります。デフォルトでは、ビルドディレクトリは配布物ルート下の  <code class="file docutils literal"><span class="pre">build</span></code> になります; システムの処理速度に強いこだわりがあったり、ソースツリーに指一本触れたくないのなら、 <code class="xref std std-option docutils literal"><span class="pre">--build-base</span></code> オプションを使ってビルドディレクトリを変更できます。例えば:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py build --build-base=/path/to/pybuild/foo-1.0
</pre></div>
</div>
<p>(あるいは、システム全体向け、あるいは個人用の Distutils 設定ファイルにディレクティブを書いて、永続的に設定を変えられます; <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 設定ファイル</span></a> 節を参照してください。)  通常は必要ない作業です。</p>
<p>ビルドツリーのデフォルトのレイアウトは以下のようになっています:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>--- build/ --- lib/
or
--- build/ --- lib.&lt;plat&gt;/
               temp.&lt;plat&gt;/
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&lt;plat&gt;</span></code> は、現在の OS/ハードウェアプラットフォームと Python のバージョンを記述する短い文字列に展開されます。第一の <code class="file docutils literal"><span class="pre">lib</span></code> ディレクトリだけの形式は、 &quot;pure モジュール配布物&quot; — すなわち、pure Python モジュールだけの入ったモジュール配布物 — の場合に使われます。モジュール配布物に何らかの拡張モジュール (C/C++ で書かれたモジュール) が入っている場合、第二の <code class="docutils literal"><span class="pre">&lt;plat&gt;</span></code> 付きディレクトリが二つある形式が使われます。この場合、  <code class="file docutils literal"><span class="pre">temp.</span><em><span class="pre">plat</span></em></code> ディレクトリには、コンパイル/リンク過程で生成され、実際にはインストールされない一時ファイルが収められます。どちらの場合にも、 <code class="file docutils literal"><span class="pre">lib</span></code> (または <code class="file docutils literal"><span class="pre">lib.</span><em><span class="pre">plat</span></em></code>)  ディレクトリには、最終的にインストールされることになる全ての Python  モジュール (pure Python モジュールおよび拡張モジュール) が入ります。</p>
<p>今後、Python スクリプト、ドキュメント、バイナリ実行可能形式、その他 Python モジュールやアプリケーションのインストール作業に必要なディレクトリが追加されるかもしれません。</p>
</div>
<div class="section" id="how-installation-works">
<span id="inst-how-install-works"></span><h3>インストールの仕組み<a class="headerlink" href="#how-installation-works" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><strong class="command">build</strong> コマンドを実行した後 (明示的に実行した場合も、 <strong class="command">install</strong> コマンドが代わりに実行してくれた場合も) は、 <strong class="command">install</strong> コマンドの仕事は比較的単純なもの: <code class="file docutils literal"><span class="pre">build/lib</span></code> (または <code class="file docutils literal"><span class="pre">build/lib.</span><em><span class="pre">plat</span></em></code>) の下にあるもの全ての指定したインストールディレクトリへのコピー、になります。</p>
<p>インストールディレクトリを選ばなかった場合 — すなわち、 <code class="docutils literal"><span class="pre">setup.py</span> <span class="pre">install</span></code> を実行しただけの場合 — には、 <strong class="command">install</strong> コマンドはサードパーティ製 Python モジュールを置くための標準の場所にインストールを行います。この場所は、プラットフォームや、Python 自体をどのようにビルド/インストールしたかで変わります。 Unix (と、Unix をベースとしたMac OS X) では、インストールしようとするモジュール配布物が pure Python なのか、拡張モジュールを含む (&quot;非 pure&quot;) のかによっても異なります:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="42%" />
<col width="39%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">プラットフォーム</th>
<th class="head">標準のインストール場所</th>
<th class="head">デフォルト値</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Unix (pure)</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></td>
<td><code class="file docutils literal"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td>Unix (非 pure)</td>
<td><code class="file docutils literal"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></td>
<td><code class="file docutils literal"><span class="pre">/usr/local/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td>Windows</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\site-packages</span></code></td>
<td><code class="file docutils literal"><span class="pre">C:\Python</span><em><span class="pre">XY</span></em><span class="pre">\Lib\site-packages</span></code></td>
<td>(2)</td>
</tr>
</tbody>
</table>
<p>注釈:</p>
<ol class="arabic simple">
<li>ほとんどの Linux ディストリビューションには、システムの標準インストール物として Python が入っているので、 Linux では普通、 <code class="file docutils literal"><em><span class="pre">prefix</span></em></code> や <code class="file docutils literal"><em><span class="pre">exec-prefix</span></em></code> はどちらも <code class="file docutils literal"><span class="pre">/usr</span></code>  になります。 Linux (または Unixライクなシステム) 上で自分で Python  をビルドした場合、デフォルトの <code class="file docutils literal"><em><span class="pre">prefix</span></em></code> および <code class="file docutils literal"><em><span class="pre">exec-prefix</span></em></code> は <code class="file docutils literal"><span class="pre">/usr/local</span></code> になります。</li>
<li>Windows での Python のデフォルトインストールディレクトリは、 Python 1.6a1、 1.5.2、およびそれ以前のバージョンでは <code class="file docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></code> です。</li>
</ol>
<p><code class="file docutils literal"><em><span class="pre">prefix</span></em></code> および <code class="file docutils literal"><em><span class="pre">exec-prefix</span></em></code> は、 Python がインストールされているディレクトリと、実行時にライブラリを探しにいく場所を表します。これらのディレクトリは、Windows では常に同じで、 Unixと Mac OS X でもほぼ常に同じです。自分の Python がどんな <code class="file docutils literal"><em><span class="pre">prefix</span></em></code> や <code class="file docutils literal"><em><span class="pre">exec-prefix</span></em></code> を使っているかは、Python を対話モードで起動して、単純なコマンドをいくつか入力すればわかります。 Windows では、 <span class="menuselection">スタート ‣ (すべての) プログラム ‣  Python X.Y ‣ Python (command line)</span> を選びます。Unix では、シェルプロンプトで単に <code class="docutils literal"><span class="pre">python</span></code> と入力します。インタプリタを起動すると、プロンプトに Python コードを入力できます。例えば、著者の使っている Linux システムで、三つの Python 文を以下のように入力すると、出力から著者のシステムの <code class="file docutils literal"><em><span class="pre">prefix</span></em></code> と <code class="file docutils literal"><em><span class="pre">exec-prefix</span></em></code> を得られます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Python 2.4 (#26, Aug  7 2004, 17:19:02)
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.prefix
&#39;/usr&#39;
&gt;&gt;&gt; sys.exec_prefix
&#39;/usr&#39;
</pre></div>
</div>
<p>このドキュメントではほかにちょっとだけプレースホルダを使います:  <code class="file docutils literal"><em><span class="pre">X.Y</span></em></code> は Python のバージョンを表し、例えば <code class="docutils literal"><span class="pre">3.2</span></code> です; <code class="file docutils literal"><em><span class="pre">abiflags</span></em></code> は <a class="reference internal" href="../library/sys.html#sys.abiflags" title="sys.abiflags"><code class="xref py py-data docutils literal"><span class="pre">sys.abiflags</span></code></a> の値に置き換えられるか、プラットフォームが ABI フラグを定義しない場合、空文字列に置き換えられます; <code class="file docutils literal"><em><span class="pre">distname</span></em></code> はインストールしようとしているモジュール配布物の名前に置き換えられます。ドットとキャピタライズはパス内で重要です; 例えば UNIX では <code class="docutils literal"><span class="pre">python3.2</span></code> が使われる値が、Windows では普通 <code class="docutils literal"><span class="pre">Python32</span></code> を使います。</p>
<p>モジュールを標準の場所にインストールしたくない場合や、標準の場所にインストールするためのファイル権限を持っていない場合、 <a class="reference internal" href="#inst-alt-install"><span class="std std-ref">別の場所へのインストール</span></a> 節にある、別の場所へのインストール方法の説明を読んでください。インストール先のディレクトリを大幅にカスタマイズしければ、 <a class="reference internal" href="#inst-custom-install"><span class="std std-ref">カスタムのインストール</span></a> 節のカスタムインストールに関する説明を読んでください。</p>
</div>
</div>
<div class="section" id="alternate-installation">
<span id="inst-alt-install"></span><h2>別の場所へのインストール<a class="headerlink" href="#alternate-installation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>しばしば、サードパーティ製 Python モジュールをインストールするための標準の場所以外にモジュールをインストールしなければならなかったり、単にそうしたくなるときがあります。例えばUnix システムでは、標準のサードパーティ製モジュールディレクトリに対する書き込み権限を持っていないかもしれません。または、あるモジュールを、ローカルで使っている Python に標準のモジュールの一部として組み込む前にテストしてみたいと思うかもしれません。既存の配布物をアップグレードする際には特にそうでしょう: 実際にアップグレードする前に、既存のスクリプトの基本となる部分が新たなバージョンでも動作するか確認したいはずです。</p>
<p>Distutils の <strong class="command">install</strong> コマンドは、別の場所へ配布物をインストールする作業を単純で苦労のない作業にするように設計されています。基本的なアイデアは、インストール先のベースディレクトリを指定しておき、 <strong class="command">install</strong> コマンドがそのベースディレクトリ下にファイル群をインストールするための一連のディレクトリ (<em>インストールスキーム : installation scheme</em>) を作成するというものです。詳細はプラットフォームによって異なるので、以下の節から自分のプラットフォームに当てはまるものを読んでください。</p>
<p>色々な代替インストールスキームは相互に排他的であることに注意してください: <code class="docutils literal"><span class="pre">--user</span></code>, または <code class="docutils literal"><span class="pre">--home</span></code>, または <code class="docutils literal"><span class="pre">--prefix</span></code> と <code class="docutils literal"><span class="pre">--exec-prefix</span></code>, または <code class="docutils literal"><span class="pre">--install-base</span></code> と <code class="docutils literal"><span class="pre">--install-platbase</span></code> を指定できますが、それらグループを混ぜこぜには使えません。</p>
<div class="section" id="alternate-installation-the-user-scheme">
<span id="inst-alt-install-user"></span><h3>別の場所へのインストール: user スキーム<a class="headerlink" href="#alternate-installation-the-user-scheme" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>このスキームはグローバルな site-packages ディレクトリへの書き込み権限を持たないユーザあるいはそこにインストールしたくないユーザに最も便利な解法となるようデザインされています。簡単なオプションでこれが可能です:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --user
</pre></div>
</div>
<p>ファイルは <a class="reference internal" href="../library/site.html#site.USER_BASE" title="site.USER_BASE"><code class="xref py py-data docutils literal"><span class="pre">site.USER_BASE</span></code></a> (以降 <code class="file docutils literal"><em><span class="pre">userbase</span></em></code> と書きます) のサブディレクトリにインストールされます。このスキームでは pure Python モジュールと拡張モジュールは(<a class="reference internal" href="../library/site.html#site.USER_SITE" title="site.USER_SITE"><code class="xref py py-data docutils literal"><span class="pre">site.USER_SITE</span></code></a> としても知られる)同じ場所にインストールされます。Mac OS X を含む UNIX の場合は下表の通りです:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">インストールディレクトリ</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>モジュール</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></td>
</tr>
<tr class="row-odd"><td>スクリプト</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/bin</span></code></td>
</tr>
<tr class="row-even"><td>データ</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em></code></td>
</tr>
<tr class="row-odd"><td>C ヘッダー</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/include/python</span><em><span class="pre">X.Y</span></em><em><span class="pre">abiflags</span></em><span class="pre">/</span><em><span class="pre">distname</span></em></code></td>
</tr>
</tbody>
</table>
<p>Windows の場合は以下の通り:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">インストールディレクトリ</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>モジュール</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\site-packages</span></code></td>
</tr>
<tr class="row-odd"><td>スクリプト</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\Scripts</span></code></td>
</tr>
<tr class="row-even"><td>データ</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em></code></td>
</tr>
<tr class="row-odd"><td>C ヘッダー</td>
<td><code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">\Python</span><em><span class="pre">XY</span></em><span class="pre">\Include\</span><em><span class="pre">distname</span></em></code></td>
</tr>
</tbody>
</table>
<p>このスキームが前述してきたほかのものと比較して有利なのは、ユーザの site-packages ディレクトリが常に <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> に含まれる普通の状態にある(詳細は <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> 参照)ということで、つまり <code class="file docutils literal"><span class="pre">setup.py</span></code> スクリプト後にインストールを完成させるための特別なステップが不要ということです。</p>
<p>さらに、コンパイラがヘッダファイルを検索するための <code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/include</span></code> 、ライブラリを検索するための <code class="file docutils literal"><em><span class="pre">userbase</span></em><span class="pre">/lib</span></code> 、ランタイムの共有ライブラリを探すためのパス(rpath)を追加するために、 <strong class="command">build_ext</strong> コマンドには <code class="docutils literal"><span class="pre">--user</span></code> オプションがあります。</p>
</div>
<div class="section" id="alternate-installation-the-home-scheme">
<span id="inst-alt-install-home"></span><h3>別の場所へのインストール: home スキーム<a class="headerlink" href="#alternate-installation-the-home-scheme" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>&quot;home スキーム&quot; の背後にある考え方は、Python モジュールを個人用のモジュール置き場でビルドし、維持するというものです。このスキームの名前は Unixの「ホーム」ディレクトリの概念からとりました。というのも、 Unixのユーザにとって、自分のホームディレクトリを <code class="file docutils literal"><span class="pre">/usr/</span></code> や <code class="file docutils literal"><span class="pre">/usr/local/</span></code> のようにレイアウトするのはよくあることだからです。とはいえ、このスキームはどのオペレーティングシステムのユーザでも使えます。</p>
<p>新たなモジュールのインストールは単純で</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --home=&lt;dir&gt;
</pre></div>
</div>
<p>のようにします。このとき、 <code class="xref std std-option docutils literal"><span class="pre">--home</span></code> オプションを使ってディレクトリを指定します。
Unix では、面倒臭がりの人は単にチルダ (<code class="docutils literal"><span class="pre">~</span></code>) をタイプするだけでかまいません;  <strong class="command">install</strong> コマンドがチルダをホームディレクトリに展開してくれます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --home=~
</pre></div>
</div>
<p>このスキームでインストールされた配布物を Python が見つけられるようにするために、 <a class="reference internal" href="#inst-search-path"><span class="std std-ref">Python サーチパスの変更</span></a> をするか、 <code class="xref py py-mod docutils literal"><span class="pre">sitecustomize</span></code> (<a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> 参照) を編集して <a class="reference internal" href="../library/site.html#site.addsitedir" title="site.addsitedir"><code class="xref py py-func docutils literal"><span class="pre">site.addsitedir()</span></code></a> を呼び出すか、 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> を編集するかしないといけないかもしれません。</p>
<p><code class="xref std std-option docutils literal"><span class="pre">--home</span></code> オプションは、インストールのベースディレクトリを指定します。
ファイルはインストールベース下の以下のディレクトリに保存されます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">インストールディレクトリ</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>モジュール</td>
<td><code class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/lib/python</span></code></td>
</tr>
<tr class="row-odd"><td>スクリプト</td>
<td><code class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/bin</span></code></td>
</tr>
<tr class="row-even"><td>データ</td>
<td><code class="file docutils literal"><em><span class="pre">home</span></em></code></td>
</tr>
<tr class="row-odd"><td>C ヘッダー</td>
<td><code class="file docutils literal"><em><span class="pre">home</span></em><span class="pre">/include/python/</span><em><span class="pre">distname</span></em></code></td>
</tr>
</tbody>
</table>
<p>(Windows の場合はスラッシュをバックスラッシュに脳内変換)</p>
</div>
<div class="section" id="alternate-installation-unix-the-prefix-scheme">
<span id="inst-alt-install-prefix-unix"></span><h3>別の場所へのインストール: Unix (prefix スキーム)<a class="headerlink" href="#alternate-installation-unix-the-prefix-scheme" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>あるインストール済みの Python を使ってモジュールのビルド/インストールを (例えば setup スクリプトを実行して) 行いたいけれども、 別のインストール済みの Python のサードパーティ製モジュール置き場 (あるいは、そう見えるようなディレクトリ構造) に、ビルドされた モジュールをインストールしたい場合には、&quot;prefix スキーム&quot; が便利です。そんな作業はまったくありえそうにない、と思うなら、確かにその通りです — &quot;home スキーム&quot; を先に説明したのもそのためです。とはいえ、prefix スキームが有用なケースは少なくとも二つあります。</p>
<p>まず、多くの Linux ディストリビューションは、 Python を <code class="file docutils literal"><span class="pre">/usr/local</span></code> ではなく <code class="file docutils literal"><span class="pre">/usr</span></code> に置いていることを考えてください。この場合は、 Python はローカルの計算機ごとのアドオン (add-on) ではなく、&quot;システム&quot; の一部となっているので、 <code class="file docutils literal"><span class="pre">/usr</span></code> に置くのは全く正当なことです。しかしながら、 Python モジュールをソースコードからインストールしていると、モジュールを <code class="file docutils literal"><span class="pre">/usr/lib/python2.</span><em><span class="pre">X</span></em></code> ではなく <code class="file docutils literal"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></code> に置きたいと思うかもしれません。これを行うには、以下のように指定します</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/usr/bin/python setup.py install --prefix=/usr/local
</pre></div>
</div>
<p>もう一つありえるのは、ネットワークファイルシステムにおいて、遠隔のディレクトリに対する読み出しと書き込みの際に違う名前を使う場合です。例えば、 <code class="file docutils literal"><span class="pre">/usr/local/bin/python</span></code> でアクセスするような Python  インタプリタは、 <code class="file docutils literal"><span class="pre">/usr/local/lib/python2.</span><em><span class="pre">X</span></em></code> からモジュールを探すでしょうが、モジュールは別の場所、例えば <code class="file docutils literal"><span class="pre">/mnt/</span><em><span class="pre">&#64;server</span></em><span class="pre">/export/lib/python2.</span><em><span class="pre">X</span></em></code> にインストールしなければならないかもしれません。この場合には、以下のようにします</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/usr/local/bin/python setup.py install --prefix=/mnt/@server/export
</pre></div>
</div>
<p>どちらの場合も、 <code class="xref std std-option docutils literal"><span class="pre">--prefix</span></code> オプションでインストール先のベースディレクトリが決まり、 <code class="xref std std-option docutils literal"><span class="pre">--exec-prefix</span></code> でプラットフォーム固有のファイルのための、プラットフォーム固有となるインストール先のベースディレクトリが決まります。
(プラットフォーム固有のファイルとは、現状では単に非 pure モジュール配布物のことを意味しますが、 C ライブラリやバイナリ実行可能形式などに拡張されるかもしれません。)
<code class="xref std std-option docutils literal"><span class="pre">--exec-prefix</span></code>  が指定されていなければ、デフォルトの <code class="xref std std-option docutils literal"><span class="pre">--prefix</span></code> になります。
ファイルは以下のようにインストールされます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">インストールディレクトリ</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pure Python モジュール</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></td>
</tr>
<tr class="row-odd"><td>拡張モジュール</td>
<td><code class="file docutils literal"><em><span class="pre">exec-prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">X.Y</span></em><span class="pre">/site-packages</span></code></td>
</tr>
<tr class="row-even"><td>スクリプト</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/bin</span></code></td>
</tr>
<tr class="row-odd"><td>データ</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em></code></td>
</tr>
<tr class="row-even"><td>C ヘッダー</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/include/python</span><em><span class="pre">X.Y</span></em><em><span class="pre">abiflags</span></em><span class="pre">/</span><em><span class="pre">distname</span></em></code></td>
</tr>
</tbody>
</table>
<p><code class="xref std std-option docutils literal"><span class="pre">--prefix</span></code> や <code class="xref std std-option docutils literal"><span class="pre">--exec-prefix</span></code> が実際に他のインストール済み Python の場所を指している必要はありません; 上に挙げたディレクトリがまだ存在しなければ、インストール時に作成されます。</p>
<p>ちなみに、prefix スキームが重要な本当の理由は、単に標準の Unix  インストールが prefix スキームを使っているからです。
ただし、そのときには、 <code class="xref std std-option docutils literal"><span class="pre">--prefix</span></code> や <code class="xref std std-option docutils literal"><span class="pre">--exec-prefix</span></code>  は Python 自体が <code class="docutils literal"><span class="pre">sys.prefix</span></code> や <code class="docutils literal"><span class="pre">sys.exec_prefix</span></code> を使って決めます。
というわけで、読者は prefix スキームを決して使うことはあるまいと思っているかもしれませんが、 <code class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code>  をオプションを何もつけずに実行していれば、常に prefix スキームを使っていることになるのです。</p>
<p>拡張モジュールを別のインストール済み Python にインストールしても、拡張モジュールのビルド方法による影響を受けることはありません: 特に、拡張モジュールをコンパイルする際には、 setup スクリプトを実行する際に使う Python インタプリタと一緒にインストールされている Python ヘッダファイル (<code class="file docutils literal"><span class="pre">Python.h</span></code>  とその仲間たち) を使います。上で述べてきたやり方でインストールされた拡張モジュールを実行するインタプリタと、インタプリタをビルドする際に用いた別のインタプリタとの互換性を保証するのはユーザの責任です。これを行うには、二つのインタプリタが同じバージョンの Python  (ビルドが違っていたり、同じビルドのコピーということもあり得ます) であるかどうかを確かめます。(もちろん、 <code class="xref std std-option docutils literal"><span class="pre">--prefix</span></code> や  <code class="xref std std-option docutils literal"><span class="pre">--exec-prefix</span></code> が別のインストール済み Python の場所すら指していなければどうにもなりません。)</p>
</div>
<div class="section" id="alternate-installation-windows-the-prefix-scheme">
<span id="inst-alt-install-prefix-windows"></span><h3>別の場所へのインストール (prefix を使う方法): Windows<a class="headerlink" href="#alternate-installation-windows-the-prefix-scheme" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Windows はユーザのホームディレクトリという概念がなく、 Windows 環境下で標準的にインストールされた Python は Unixよりも単純な構成をしているので、 Windows で追加のパッケージを別の場所に入れる場合には、伝統的に <code class="xref std std-option docutils literal"><span class="pre">--prefix</span></code> が使われてきました。</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --prefix=&quot;\Temp\Python&quot;
</pre></div>
</div>
<p>とすると、モジュールを現在のドライブの <code class="file docutils literal"><span class="pre">\Temp\Python</span></code> ディレクトリにインストールします。</p>
<p>インストールベースディレクトリは、 <code class="xref std std-option docutils literal"><span class="pre">--prefix</span></code> オプションだけで決まります; <code class="xref std std-option docutils literal"><span class="pre">--exec-prefix</span></code> オプションは、Windows ではサポートされていません。pure モジュールと拡張モジュールは同じ場所にインストールされます。ファイルは以下のような構成でインストールされます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">インストールディレクトリ</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>モジュール</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\site-packages</span></code></td>
</tr>
<tr class="row-odd"><td>スクリプト</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Scripts</span></code></td>
</tr>
<tr class="row-even"><td>データ</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em></code></td>
</tr>
<tr class="row-odd"><td>C ヘッダー</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Include\</span><em><span class="pre">distname</span></em></code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="custom-installation">
<span id="inst-custom-install"></span><h2>カスタムのインストール<a class="headerlink" href="#custom-installation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>たまに、 <a class="reference internal" href="#inst-alt-install"><span class="std std-ref">別の場所へのインストール</span></a> 節で述べたような別の場所へのインストールスキームが、自分のやりたいインストール方法と違うことがあります。もしかすると、同じベースディレクトリ下にあるディレクトリのうち、一つか二つだけをいじりたかったり、インストールスキームを完全に再定義したいと思うかもしれません。どちらの場合にせよ、こうした操作では <em>カスタムのインストールスキーム</em> を作成することになります。</p>
<p>カスタムインストールのためには、スキームの中のひとつから始めて、ファイルのタイプごとに使われるインストールディレクトリを以下オプションで上書きします:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">上書きオプション</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pure Python モジュール</td>
<td><code class="docutils literal"><span class="pre">--install-purelib</span></code></td>
</tr>
<tr class="row-odd"><td>拡張モジュール</td>
<td><code class="docutils literal"><span class="pre">--install-platlib</span></code></td>
</tr>
<tr class="row-even"><td>全てのモジュール</td>
<td><code class="docutils literal"><span class="pre">--install-lib</span></code></td>
</tr>
<tr class="row-odd"><td>スクリプト</td>
<td><code class="docutils literal"><span class="pre">--install-scripts</span></code></td>
</tr>
<tr class="row-even"><td>データ</td>
<td><code class="docutils literal"><span class="pre">--install-data</span></code></td>
</tr>
<tr class="row-odd"><td>C ヘッダー</td>
<td><code class="docutils literal"><span class="pre">--install-headers</span></code></td>
</tr>
</tbody>
</table>
<p>これらの上書きオプションには、相対パス、絶対パス、あるいはインストールのベースディレクトリの一つに関して明示的に定義されたものを指定できます。(2つのインストールのベースディレクトリがあり、普通それらは同じです — それらは Unix &quot;prefix scheme&quot; を使い、 <code class="docutils literal"><span class="pre">--prefix</span></code> と <code class="docutils literal"><span class="pre">--exec-prefix</span></code> に異なる値を与えた場合にのみ違ってきます; <code class="docutils literal"><span class="pre">--install-lib</span></code> を使うと、計算されたものあるいは <code class="docutils literal"><span class="pre">--install-purelib</span></code> と <code class="docutils literal"><span class="pre">--install-platlib</span></code> で与えられるものを上書きしますので、pure モジュールと拡張モジュールでの違いのないスキームではお奨めです。)</p>
<p>例えば、 Unix環境でモジュール配布物をホームディレクトリにインストールしたい — とはいえ、スクリプトは <code class="file docutils literal"><span class="pre">~/bin</span></code> ではなく <code class="file docutils literal"><span class="pre">~/scripts</span></code> に置きたい — とします。ご想像の通り、スクリプトを置くディレクトリは、 <code class="xref std std-option docutils literal"><span class="pre">--install-scripts</span></code> オプションで上書きできます; この場合は相対パスで指定もでき、インストールベースディレクトリ (この場合にはホームディレクトリ) からの相対パスとして解釈されます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --home=~ --install-scripts=scripts
</pre></div>
</div>
<p>Unix 環境での例をもう一つ紹介します: インストール済みの Python が、 <code class="file docutils literal"><span class="pre">/usr/local/python</span></code> を prefix にしてビルドされ、インストールされていて、標準のインストールスクリプトは <code class="file docutils literal"><span class="pre">/usr/local/python/bin</span></code> に入るようになっているとします。 <code class="file docutils literal"><span class="pre">/usr/local/bin</span></code> に入るようにしたければ、絶対パスを <code class="xref std std-option docutils literal"><span class="pre">--install-scripts</span></code> オプションに与えて上書きすることになるでしょう:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --install-scripts=/usr/local/bin
</pre></div>
</div>
<p>(この操作を行うと、 &quot;prefix スキーム&quot; を使ったインストールになり、 prefix は Python インタプリタがインストールされている場所 — この場合には <code class="file docutils literal"><span class="pre">/usr/local/python</span></code> になります。)</p>
<p>Windows 用の Python を管理しているのなら、サードパーティ製モジュールを <code class="file docutils literal"><em><span class="pre">prefix</span></em></code> そのものの下ではなく、 <code class="file docutils literal"><em><span class="pre">prefix</span></em></code> の下にあるサブディレクトリに置きたいと考えるかもしれません。この作業は、インストールディレクトリのカスタマイズとほぼ同じくらい簡単です — 覚えておかねばならないのは、モジュールには二つのタイプ、 pure モジュールと拡張モジュールがあるということです。ともにひとつのオプションで簡単にコントロール出来ます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --install-lib=Site
</pre></div>
</div>
<p>指定したインストール先ディレクトリは、 <code class="file docutils literal"><em><span class="pre">prefix</span></em></code> からの相対です。もちろん、 このディレクトリを <code class="file docutils literal"><span class="pre">.pth</span></code> ファイルに入れるなどして(<a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> 参照)、Python のモジュール検索パス内に入るようにしなければなりません。Python のモジュール検索パスを修正する方法は、  <a class="reference internal" href="#inst-search-path"><span class="std std-ref">Python サーチパスの変更</span></a> 節を参照してください。</p>
<p>インストールスキーム全体を定義したいのなら、全てのインストールディレクトリオプションを指定しなければなりません。この作業には、相対パスを使った指定を勧めます; 例えば、全ての Python モジュール関連ファイルをホームディレクトリ下の <code class="file docutils literal"><span class="pre">python</span></code> ディレクトリの下に置き、そのホームディレクトリをマウントしている各プラットフォームごとに別のディレクトリを置きたければ、以下のようにインストールスキームを定義します:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --home=~ \
                        --install-purelib=python/lib \
                        --install-platlib=python/lib.$PLAT \
                        --install-scripts=python/scripts
                        --install-data=python/data
</pre></div>
</div>
<p>また、以下のようにも指定できます、</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --home=~/python \
                        --install-purelib=lib \
                        --install-platlib=&#39;lib.$PLAT&#39; \
                        --install-scripts=scripts
                        --install-data=data
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">$PLAT</span></code> は、(必ずしも) 環境変数ではありません — この表記は、Distutils がコマンドラインオプションの解釈と同じやり方で展開します。設定ファイルを解釈する際と同じです。</p>
<p>言うまでもないことですが、毎回新たなモジュール配布物をインストールする度にインストールスキーム全体の指定を行っていては面倒です。そこで、オプションは Distutils 設定ファイル (<a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 設定ファイル</span></a> 参照) にも指定できます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>[install]
install-base=$HOME
install-purelib=python/lib
install-platlib=python/lib.$PLAT
install-scripts=python/scripts
install-data=python/data
</pre></div>
</div>
<p>また、以下のようにも指定できます、</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>[install]
install-base=$HOME/python
install-purelib=lib
install-platlib=lib.$PLAT
install-scripts=scripts
install-data=data
</pre></div>
</div>
<p>これら二つは、setup スクリプトを異なるインストールベースディレクトリから実行した場合には同じには <em>ならない</em> ので注意してください。例えば、</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py install --install-base=/tmp
</pre></div>
</div>
<p>とすると、最初の書き方では pure モジュールが <code class="file docutils literal"><span class="pre">/tmp/python/lib</span></code>  に入り、二番目の書き方では <code class="file docutils literal"><span class="pre">/tmp/lib</span></code> に入ります。(二番目のケースでは、インストールベースを <code class="file docutils literal"><span class="pre">/tmp/python</span></code> に指定しようと考えるでしょう。)</p>
<p>読者は、設定ファイル例で、入力値に <code class="docutils literal"><span class="pre">$HOME</span></code> や <code class="docutils literal"><span class="pre">$PLAT</span></code> を使っていることに気づいているかもしれませんね。これらは Distutils の設定変数で、環境変数を彷彿とさせます。実際、この表記が使えるプラットフォーム上では、設定ファイル中に環境変数を入れられますが、 Distutils は他にも、例えば <code class="docutils literal"><span class="pre">$PLAT</span></code> のようにおそらくユーザの環境中にないような変数をいくつか持っています。(そしてもちろん、 Mac OS 9 のような環境変数のないシステムでは、設定ファイル中で使える変数は Distutils が提供しているものだけです。) 詳細は <a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 設定ファイル</span></a> を参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="../library/venv.html#venv-def"><span class="std std-ref">virtual environment</span></a> 下にいる場合、仮想環境の外に不注意でプロジェクトをインストールしてしまうことを避けるために、インストールパスを変更するあらゆるオプションは distutils の全ての設定ファイルによって無視されます。</p>
</div>
<div class="section" id="modifying-python-s-search-path">
<span id="inst-search-path"></span><h3>Python サーチパスの変更<a class="headerlink" href="#modifying-python-s-search-path" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python インタプリタが <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文を実行するとき、インタプリタは Python コードや拡張モジュールをモジュール検索パス中から探します。検索パスのデフォルト値は、インタプリタをビルドする際に Python のバイナリ内に設定されます。検索パスは、 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> を import して、 <code class="docutils literal"><span class="pre">sys.path</span></code> を出力すればわかります。</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ python
Python 2.2 (#11, Oct  3 2002, 13:31:27)
[GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#39;&#39;, &#39;/usr/local/lib/python2.3&#39;, &#39;/usr/local/lib/python2.3/plat-linux2&#39;,
 &#39;/usr/local/lib/python2.3/lib-tk&#39;, &#39;/usr/local/lib/python2.3/lib-dynload&#39;,
 &#39;/usr/local/lib/python2.3/site-packages&#39;]
&gt;&gt;&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sys.path</span></code> 内の空文字列は、現在の作業ディレクトリを表します。</p>
<p>ローカルでインストールされるパッケージは、 <code class="file docutils literal"><em><span class="pre">…</span></em><span class="pre">/site-packages/</span></code> ディレクトリに入るのが決まりですが、ユーザはどこか任意のディレクトリに Python モジュールをインストールしたいと思うかもしれません。例えば、自分のサイトでは、 web サーバに関連する全てのソフトウェアを <code class="file docutils literal"><span class="pre">/www</span></code> に置くという決まりがあるかもしれません。そこで、アドオンの Python モジュールが <code class="file docutils literal"><span class="pre">/www/python</span></code> 置かれることになると、モジュールを import するためにはディレクトリを <code class="docutils literal"><span class="pre">sys.path</span></code> に追加せねばなりません。ディレクトリを検索パスに追加するには、いくつかの異なる方法が存在します。</p>
<p>最も手軽な方法は、パス設定ファイルをすでに Python の検索パスに含まれるディレクトリ、通常は <code class="file docutils literal"><span class="pre">.../site-packages/</span></code> ディレクトリに置くというものです。パス設定ファイルは拡張子が <code class="file docutils literal"><span class="pre">.pth</span></code> で、ファイルには <code class="docutils literal"><span class="pre">sys.path</span></code> に追加するパスを一行に一つづつ記述しなければなりません。 (新たなパスは今の <code class="docutils literal"><span class="pre">sys.path</span></code> の後ろに追加されるので、追加されたディレクトリ内にあるモジュールが標準のモジュールセットを上書きすることはありません。つまり、このメカニズムを使って、標準モジュールに対する修正版のインストールはできないということです。)</p>
<p>パスは絶対パスでも相対パスでもよく、相対パスの場合には <code class="file docutils literal"><span class="pre">.pth</span></code> ファイルのあるパスからの相対になります。詳しくは <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> モジュールを参照してください。</p>
<p>やや便利さには欠けますが、Python の標準ライブラリ中にある  <code class="file docutils literal"><span class="pre">site.py</span></code> ファイルを編集することでも、 <code class="docutils literal"><span class="pre">sys.path</span></code> を変更できます。 <code class="file docutils literal"><span class="pre">site.py</span></code> は、 <a class="reference internal" href="../using/cmdline.html#id3"><code class="xref std std-option docutils literal"><span class="pre">-S</span></code></a> スイッチを与えて抑制しないかぎり、Python インタプリタが実行される際に自動的に import  されます。ただし、設定するには、単に <code class="file docutils literal"><span class="pre">site.py</span></code> を編集して、例えば以下のような二行を加えます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>import sys
sys.path.append(&#39;/www/python/&#39;)
</pre></div>
</div>
<p>しかしながら、(例えば 2.2 から 2.2.2 にアップグレードするときのように) 同じメジャーバージョンの Python を再インストールすると、 <code class="file docutils literal"><span class="pre">site.py</span></code> は手持ちのバージョンで上書きされてしまいます。ファイルが変更されていることを覚えておき、インストールを行う前にコピーを忘れずとっておかねばなりません。</p>
<p>また、 <code class="docutils literal"><span class="pre">sys.path</span></code> を修正できる二つの環境変数があります。 <span class="target" id="index-23"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></code></a> を使うと、インストールされている Python のプレフィクスを別の値に設定できます。例えば、 <span class="target" id="index-24"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONHOME</span></code></a> を <code class="docutils literal"><span class="pre">/www/python</span></code> に設定すると、検索パスは <code class="docutils literal"><span class="pre">['',</span> <span class="pre">'/www/python/lib/pythonX.Y/',</span> <span class="pre">'/www/python/lib/pythonX.Y/plat-linux2',</span> <span class="pre">...]</span></code> といった具合になります。</p>
<p><span class="target" id="index-25"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></code></a> を使うと、 <code class="docutils literal"><span class="pre">sys.path</span></code> の先頭に一連のパスを追加できます。例えば、 <span class="target" id="index-26"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONPATH</span></code></a> を <code class="docutils literal"><span class="pre">/www/python:/opt/py</span></code> に設定すると、検索パスは <code class="docutils literal"><span class="pre">['/www/python',</span> <span class="pre">'/opt/py']</span></code> から始まります。  (<code class="docutils literal"><span class="pre">sys.path</span></code> にディレクトリを追加するには、そのディレクトリが実在しなければなりません; <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal"><span class="pre">site</span></code></a> は実在しないディレクトリを除去します。)</p>
<p>最後に、<code class="docutils literal"><span class="pre">sys.path</span></code> はただの普通の Python のリストなので、どんな Python アプリケーションもエントリを追加したり除去したりといった修正を行えます。</p>
</div>
</div>
<div class="section" id="distutils-configuration-files">
<span id="inst-config-files"></span><h2>Distutils 設定ファイル<a class="headerlink" href="#distutils-configuration-files" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>上で述べたように、Distutils 設定ファイルを使えば、任意の  Distutils オプションに対して個人的な設定やサイト全体の設定を記録できます。すなわち、任意のコマンドの任意のオプションを二つか三つ (プラットフォームによって異なります) の設定ファイルに保存でき、コマンドラインを解釈する前にオプションを問い合わせさせるようにできます。つまり、設定ファイルはデフォルトの値を上書きし、さらにコマンドライン上で与えた値が設定ファイルの内容を上書きするわけです。さらに、複数の設定ファイルが適用されると、&quot;先に&quot; 適用されたファイルに指定されていた値は &quot;後に&quot; 適用されたファイル内の値で上書きされます。</p>
<div class="section" id="location-and-names-of-config-files">
<span id="inst-config-filenames"></span><h3>設定ファイルの場所と名前<a class="headerlink" href="#location-and-names-of-config-files" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>設定ファイルの名前と場所は、非常にわずかですがプラットフォーム間で異なります。Unix と Mac OS X では、三種類の設定ファイルは以下のようになります (処理される順に並んでいます):</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="73%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">場所とファイル名</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>system</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python</span><em><span class="pre">ver</span></em><span class="pre">/distutils/distutils.cfg</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td>personal</td>
<td><code class="file docutils literal"><span class="pre">$HOME/.pydistutils.cfg</span></code></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td>local</td>
<td><code class="file docutils literal"><span class="pre">setup.cfg</span></code></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p>Windows では設定ファイルは以下のようになります:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="70%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ファイルのタイプ</th>
<th class="head">場所とファイル名</th>
<th class="head">注釈</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>system</td>
<td><code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">\Lib\distutils\distutils.cfg</span></code></td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td>personal</td>
<td><code class="file docutils literal"><span class="pre">%HOME%\pydistutils.cfg</span></code></td>
<td>(5)</td>
</tr>
<tr class="row-even"><td>local</td>
<td><code class="file docutils literal"><span class="pre">setup.cfg</span></code></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p>全てのプラットフォームにおいて、&quot;個人の&quot; ファイルは <cite>–no-user-cfg</cite> オプションを使って一時的に無効にすることができます。</p>
<p>注釈:</p>
<ol class="arabic simple">
<li>厳密に言えば、システム全体向けの設定ファイルは、 Distutils がインストールされているディレクトリになります; Unixの Python 1.6 以降では、表の通りの場所になります。 Python 1.5.2 では、 Distutils は通常 <code class="file docutils literal"><em><span class="pre">prefix</span></em><span class="pre">/lib/python1.5/site-packages/distutils</span></code> にインストールされるため、 Python 1.5.2 では設定ファイルをそこに置かなければなりません。</li>
<li>Unixでは、環境変数 <span class="target" id="index-27"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOME</span></code> が定義されていない場合、標準モジュール <a class="reference internal" href="../library/pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">pwd</span></code></a> の <code class="xref py py-func docutils literal"><span class="pre">getpwuid()</span></code> 関数を使ってユーザのホームディレクトリを決定します。このとき同時に Distutils によって <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></code></a> が実行されます。</li>
<li>現在のディレクトリ (通常は setup スクリプトがある場所) です。</li>
<li>(注記 (1) も参照してください)  Python 1.6 およびそれ以降のバージョンでは、 Python のデフォルトの &quot;インストールプレフィクス&quot; は <code class="file docutils literal"><span class="pre">C:\Python</span></code> なので、システム設定ファイルは通常 <code class="file docutils literal"><span class="pre">C:\Python\Lib\distutils\distutils.cfg</span></code> になります。Python 1.5.2 ではデフォルトのプレフィクスは <code class="file docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python</span></code> であり、Distutils は標準ライブラリの一部ではありません — 従って、システム設定ファイルは、 Windows 用の標準の Python 1.5.2 では <code class="file docutils literal"><span class="pre">C:\Program</span> <span class="pre">Files\Python\distutils\distutils.cfg</span></code> になります。</li>
<li>Windows では、環境変数 <span class="target" id="index-28"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOME</span></code> が設定されていない場合、 <span class="target" id="index-29"></span><code class="xref std std-envvar docutils literal"><span class="pre">USERPROFILE</span></code> 、 <span class="target" id="index-30"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOMEDRIVE</span></code> 、 <span class="target" id="index-31"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOMEPATH</span></code> を順々に試します。このとき同時に Distutils によって <a class="reference internal" href="../library/os.path.html#os.path.expanduser" title="os.path.expanduser"><code class="xref py py-func docutils literal"><span class="pre">os.path.expanduser()</span></code></a> が実行されます。</li>
</ol>
</div>
<div class="section" id="syntax-of-config-files">
<span id="inst-config-syntax"></span><h3>設定ファイルの構文<a class="headerlink" href="#syntax-of-config-files" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Distutils 設定ファイルは、全て同じ構文をしています。設定ファイルはセクションでグループ分けされています。各 Distutils コマンドごとにセクションがあり、それに加えて全てのコマンドに影響するグローバルオプションを設定するための <code class="docutils literal"><span class="pre">global</span></code> セクションがあります。各セクションには <code class="docutils literal"><span class="pre">option=value</span></code> の形で、一行あたり一つのオプションを指定します。</p>
<p>例えば、以下は全てのコマンドに対してデフォルトでメッセージを出さないよう強制するための完全な設定ファイルです:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>[global]
verbose=0
</pre></div>
</div>
<p>この内容のファイルがシステム全体用の設定ファイルとしてインストールされていれば、そのシステムの全てのユーザによる全ての Python モジュール配布物に対する処理に影響します。ファイルが (個人用の設定をサポートしているシステムで) 個人用の設定ファイルとしてインストールされていれば、そのユーザが処理するモジュール配布物にのみ影響します。この内容を特定のモジュール配布物の <code class="file docutils literal"><span class="pre">setup.cfg</span></code> として使えば、その配布物だけに影響します。</p>
<p>以下のようにして、デフォルトの &quot;ビルドベース&quot; ディレクトリをオーバライドしたり、 <strong class="command">build*</strong> コマンドが常に強制的にリビルドを行うようにもできます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>[build]
build-base=blib
force=1
</pre></div>
</div>
<p>この設定は、コマンドライン引数の</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py build --build-base=blib --force
</pre></div>
</div>
<p>に対応します。ただし、後者ではコマンドライン上で <strong class="command">build</strong>  コマンドを含めて、そのコマンドを実行するよう意味しているところが違います。特定のコマンドに対するオプションを設定ファイルに含めると、このような関連付けの必要はなくなります; あるコマンドが実行されると、そのコマンドに対するオプションが適用されます。 (また、設定ファイル内からオプションを取得するような他のコマンドを実行した場合、それらのコマンドもまた設定ファイル内の対応するオプションの値を使います。)</p>
<p>あるコマンドに対するオプションの完全なリストは、例えば以下のように、 <code class="xref std std-option docutils literal"><span class="pre">--help</span></code> を使って調べます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py build --help
</pre></div>
</div>
<p>グローバルオプションの完全なリストを得るには、コマンドを指定せずに <code class="xref std std-option docutils literal"><span class="pre">--help</span></code> オプションを使います:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py --help
</pre></div>
</div>
<p>&quot;Python モジュールの配布&quot; マニュアルの、&quot;リファレンスマニュアル&quot; の節も参照してください。</p>
</div>
</div>
<div class="section" id="building-extensions-tips-and-tricks">
<span id="inst-building-ext"></span><h2>拡張モジュールのビルド: 小技と豆知識<a class="headerlink" href="#building-extensions-tips-and-tricks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Distutils は、可能なときにはいつでも、 <code class="file docutils literal"><span class="pre">setup.py</span></code> スクリプトを実行する Python インタプリタが提供する設定情報を使おうとします。例えば、拡張モジュールをコンパイルする際には、コンパイラやリンカのフラグには Python をコンパイルした際と同じものが使われます。通常、この設定はうまくいきますが、状況が複雑になると不適切な設定になることもあります。この節では、通常の Distutils の動作をオーバライドする方法について議論します。</p>
<div class="section" id="tweaking-compiler-linker-flags">
<span id="inst-tweak-flags"></span><h3>コンパイラ/リンカのフラグをいじるには<a class="headerlink" href="#tweaking-compiler-linker-flags" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>C や C++ で書かれた Python 拡張をコンパイルする際、しばしば特定のライブラリを使ったり、特定の種類のオブジェクトコードを生成したりする上で、コンパイラやリンカに与えるフラグをカスタマイズする必要があります。ある拡張モジュールが自分のプラットフォームではテストされていなかったり、クロスコンパイルを行わねばならない場合にはこれが当てはまります。</p>
<p>最も一般的なケースでは、拡張モジュールの作者はすでに拡張モジュールのコンパイルが複雑になることを見越していて、 <code class="file docutils literal"><span class="pre">Setup</span></code> ファイルを提供して編集できるようにしています。 <code class="file docutils literal"><span class="pre">Setup</span></code> ファイルの編集は、モジュール配布物に多くの個別の拡張モジュールがあったり、コンパイラに拡張モジュールをコンパイルさせるために細かくフラグをセットする必要があるような場合にのみ行うことになるでしょう。</p>
<p><code class="file docutils literal"><span class="pre">Setup</span></code> ファイルが存在する場合、ビルドするべき拡張モジュールのリストを得るために解釈されます。 <code class="file docutils literal"><span class="pre">Setup</span></code> ファイルの各行には単一のモジュールを書きます。各行は以下のような構造をとります:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>module ... [sourcefile ...] [cpparg ...] [library ...]
</pre></div>
</div>
<p>次に、各フィールドについて見てみましょう。</p>
<ul class="simple">
<li><em>module</em> はビルドする拡張モジュールの名前で、Python の識別子名として有効でなければなりません。モジュールの名前変更は、このフィールドを変えるだけではできない (ソースコードの編集も必要です)  ので、このフィールドに手を加えるべきではありません。</li>
<li><em>sourcefile</em> は、少なくともファイル名から何の言語で書かれているかがわかるようになっているソースコードファイル名です。 <code class="file docutils literal"><span class="pre">.c</span></code> で終わるファイルは C で書かれているとみなされ、 <code class="file docutils literal"><span class="pre">.C</span></code> 、 <code class="file docutils literal"><span class="pre">.cc</span></code> 、および <code class="file docutils literal"><span class="pre">.c++</span></code> で終わるファイルは C++ で書かれているとみなされます。 <code class="file docutils literal"><span class="pre">.m</span></code> や <code class="file docutils literal"><span class="pre">.mm</span></code> で終わるファイルは Objective C で書かれているとみなされます。</li>
<li><em>cpparg</em> は C プリプロセッサへの引数で、 <code class="xref std std-option docutils literal"><span class="pre">-I</span></code> 、 <code class="xref std std-option docutils literal"><span class="pre">-D</span></code> 、 <code class="xref std std-option docutils literal"><span class="pre">-U</span></code> または <code class="xref std std-option docutils literal"><span class="pre">-C</span></code> のいずれかから始まる文字列です。</li>
<li><em>library</em> は <code class="file docutils literal"><span class="pre">.a</span></code> で終わるか、 <code class="xref std std-option docutils literal"><span class="pre">-l</span></code> または <code class="xref std std-option docutils literal"><span class="pre">-L</span></code> のいずれかから始まる文字列です。</li>
</ul>
<p>特定のプラットフォームにおいて、プラットフォーム上の特殊なライブラリが必要な場合、 <code class="file docutils literal"><span class="pre">Setup</span></code> ファイルを編集して <code class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">build</span></code> を実行すればライブラリを追加できます。例えば、以下の行</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>foo foomodule.c
</pre></div>
</div>
<p>で定義されたモジュールを、自分のプラットフォーム上の数学ライブラリ <code class="file docutils literal"><span class="pre">libm.a</span></code> とリンクしなければならない場合、 <code class="file docutils literal"><span class="pre">Setup</span></code> 内の行に <code class="xref std std-option docutils literal"><span class="pre">-lm</span></code> を追加するだけです:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>foo foomodule.c -lm
</pre></div>
</div>
<p>コンパイラやリンカ向けの任意のスイッチオプションは、 <code class="xref std std-option docutils literal"><span class="pre">-Xcompiler</span></code> <em>arg</em> や <code class="xref std std-option docutils literal"><span class="pre">-Xlinker</span></code> <em>arg</em> オプションで与えます:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm
</pre></div>
</div>
<p><code class="xref std std-option docutils literal"><span class="pre">-Xcompiler</span></code> および <code class="xref std std-option docutils literal"><span class="pre">-Xlinker</span></code> の後にくるオプションは、それぞれ適切なコマンドラインに追加されます。従って、上の例では、コンパイラには <code class="xref std std-option docutils literal"><span class="pre">-o32</span></code> オプションが渡され、リンカには <code class="xref std std-option docutils literal"><span class="pre">-shared</span></code> が渡されます。コンパイラオプションに引数が必要な場合、複数の <code class="xref std std-option docutils literal"><span class="pre">-Xcompiler</span></code>  オプションを与えます; 例えば、 <code class="docutils literal"><span class="pre">-x</span> <span class="pre">c++</span></code> を渡すには、 <code class="file docutils literal"><span class="pre">Setup</span></code> ファイルには <code class="docutils literal"><span class="pre">-Xcompiler</span> <span class="pre">-x</span> <span class="pre">-Xcompiler</span> <span class="pre">c++</span></code> を渡さねばなりません。</p>
<p>コンパイラフラグは、環境変数 <span class="target" id="index-32"></span><code class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></code> の設定でも与えられます。 <span class="target" id="index-33"></span><code class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></code> が設定されていれば、 <code class="file docutils literal"><span class="pre">Setup</span></code> ファイル内で指定されているコンパイラフラグに <span class="target" id="index-34"></span><code class="xref std std-envvar docutils literal"><span class="pre">CFLAGS</span></code> の内容が追加されます。</p>
</div>
<div class="section" id="using-non-microsoft-compilers-on-windows">
<span id="inst-non-ms-compilers"></span><h3>Windows で非 Microsoft コンパイラを使ってビルドするには<a class="headerlink" href="#using-non-microsoft-compilers-on-windows" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="borland-codegear-c">
<h4>Borland/CodeGear C++<a class="headerlink" href="#borland-codegear-c" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この小節では、 Borland C++ コンパイラのバージョン 5.5 で Distutils を使うために必要な手順について述べています。  まず、 Borland のオブジェクトファイル形式 (OMF) は、Python 公式サイトや ActiveState の Web サイトからダウンロードできるバージョンの Python が使っている形式とは違うことを知っておかねばなりません (Python は通常、 Microsoft Visual C++ でビルドされています。Microsoft Visual C++ は COFF をオブジェクトファイル形式に使います。) このため、以下のようにして、 Python のライブラリ <code class="file docutils literal"><span class="pre">python25.lib</span></code>  を Borland の形式に変換する必要があります:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>coff2omf python25.lib python25_bcpp.lib
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">coff2omf</span></code> プログラムは、 Borland コンパイラに付属しています。 <code class="file docutils literal"><span class="pre">python25.lib</span></code> は Python インストールディレクトリの <code class="file docutils literal"><span class="pre">Libs</span></code>  ディレクトリ内にあります。拡張モジュールで他のライブラリ (zlib, …) を使っている場合、それらのライブラリも変換しなければなりません。</p>
<p>変換されたファイルは、通常のライブラリと同じディレクトリに置かねばなりません。</p>
<p>さて、 Distutils は異なる名前を持つこれらのライブラリをどのように扱うのでしょうか? 拡張モジュールで (例えば <code class="file docutils literal"><span class="pre">foo</span></code> という名の) ライブラリが必要な場合、 Distutils はまず <code class="file docutils literal"><span class="pre">_bcpp</span></code> が後ろに付いたライブラリ (例えば <code class="file docutils literal"><span class="pre">foo_bcpp.lib</span></code>) が見つかるかどうか調べ、あればそのライブラリを使います。該当するライブラリがなければ、デフォルトの名前 (<code class="file docutils literal"><span class="pre">foo.lib</span></code>) を使います。 <a class="footnote-reference" href="#id4" id="id1">[1]</a></p>
<p>Borland C++ を使って Distutils に拡張モジュールをコンパイルさせるには、以下のように入力します:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py build --compiler=bcpp
</pre></div>
</div>
<p>Borland C++ コンパイラをデフォルトにしたいなら、自分用、またはシステム全体向けに、 Distutils の設定ファイルを書くことを検討した方がよいでしょう (<a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 設定ファイル</span></a> 節を参照してください)。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="https://www.embarcadero.com/products">C++Builder Compiler</a></dt>
<dd>Borland によるフリーの C++ コンパイラに関する情報で、コンパイラのダウンロードページへのリンクもあります。</dd>
<dt><a class="reference external" href="http://www.cyberus.ca/~g_will/pyExtenDL.shtml">Creating Python Extensions Using Borland’s Free Compiler</a></dt>
<dd>Borland 製のフリーのコマンドライン C++ を使って Python をビルドする方法について述べたドキュメントです。</dd>
</dl>
</div>
</div>
<div class="section" id="gnu-c-cygwin-mingw">
<h4>GNU C / Cygwin / MinGW<a class="headerlink" href="#gnu-c-cygwin-mingw" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この節では、Cygwin や MinGW <a class="footnote-reference" href="#id5" id="id2">[2]</a> 配布物中の GNU C/C++ コンパイラで Distutils を使うために必要な手順について述べます。Cygwin 向けにビルドされている Python インタプリタを使っているなら、以下の手順をとらなくても Distutils はまったく問題なく動作します。</p>
<p>全ての拡張ライブラリが MinGW や Cygwin でビルドできるわけではありませんが、多くの場合はビルドできます。ビルドできない拡張ライブラリは、大抵C++を利用していたり Microsoft Visual Cの拡張に依存していたりします。</p>
<p>distutils に Cygwin を使って拡張をコンパイルさせるには次のようにタイプします:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py build --compiler=cygwin
</pre></div>
</div>
<p>Cygwin を no-cygwin モード <a class="footnote-reference" href="#id6" id="id3">[3]</a> で使うときや MinGW を使うときは次のようにします:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>python setup.py build --compiler=mingw32
</pre></div>
</div>
<p>これらのオプションやコンパイラをデフォルトにしたい場合、 Distutils の個人用あるいはシステム全体用の設定ファイルを書くことを検討するべきです。 (<a class="reference internal" href="#inst-config-files"><span class="std std-ref">Distutils 設定ファイル</span></a> を参照してください)</p>
<div class="section" id="older-versions-of-python-and-mingw">
<h5>古いバージョンの Python と MinGW<a class="headerlink" href="#older-versions-of-python-and-mingw" title="このヘッドラインへのパーマリンク">¶</a></h5>
<p>以下の手順は Python 2.4.1 以前と MinGW 3.0.0 (binutils-2.13.90-20030111-1) 以前を利用しているときのものです。</p>
<p>上記のコンパイラは、いくつかの特殊なライブラリを必要とします。この作業は Borland の C++ よりもやや複雑です。というのは、ライブラリを変換するためのプログラムが存在しないからです。  まず、 Python DLL が公開している全てのシンボルからなるリストを作成しなければなりません。 (この作業むけの良いプログラムは、 <a class="reference external" href="https://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/">https://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/</a> から入手できます。)</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>pexports python25.dll &gt;python25.def
</pre></div>
</div>
<p>インストールされた <code class="file docutils literal"><span class="pre">python25.dll</span></code> の位置はインストールオプションと、 Windowsのバージョンと言語に依存します。&quot;自分だけのため&quot;のインストールの場合には、インストールディレクトリのルートに配置されます。共有インストールの場合にはシステムディレクトリに配置されます。</p>
<p>これで、上で得られた情報をもとに、gcc 用の import ライブラリを作成できます。</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/cygwin/bin/dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a
</pre></div>
</div>
<p>出来上がったライブラリは、 <code class="file docutils literal"><span class="pre">python25.lib</span></code> と同じディレクトリに置かなければなりません。 (Python インストールディレクトリの <code class="file docutils literal"><span class="pre">libs</span></code> ディレクトリになるはずです。)</p>
<p>拡張モジュールが他のライブラリ (zlib, …) を必要とする場合、それらのライブラリも変換しなければなりません。変換されたファイルは、それぞれ通常のライブラリが置かれているのと同じディレクトリに置かねばなりません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://old.zope.org/Members/als/tips/win32_mingw_modules">Building Python modules on MS Windows platform with MinGW</a></dt>
<dd>MinGW 環境で必要なライブラリのビルドに関する情報があります。</dd>
</dl>
</div>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>つまり、全ての既存の COFF ライブラリを同名の OMF ライブラリに置き換えてもかまわないということです。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>詳しくは <a class="reference external" href="https://www.sourceware.org/cygwin/">https://www.sourceware.org/cygwin/</a> や <a class="reference external" href="http://www.mingw.org/">http://www.mingw.org/</a> を参照してください</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>このモードでは POSIX エミュレーションを利用できませんが、 <code class="file docutils literal"><span class="pre">cygwin1.dll</span></code> も必要なくなります。</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python モジュールのインストール (旧版)</a><ul>
<li><a class="reference internal" href="#introduction">はじめに</a><ul>
<li><a class="reference internal" href="#best-case-trivial-installation">もっとも簡単な場合: ありふれたインストール作業</a></li>
<li><a class="reference internal" href="#the-new-standard-distutils">新しい標準: Distutils</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standard-build-and-install">標準的なビルド・インストール作業</a><ul>
<li><a class="reference internal" href="#platform-variations">プラットフォームによる違い</a></li>
<li><a class="reference internal" href="#splitting-the-job-up">ビルド作業とインストール作業を分割する</a></li>
<li><a class="reference internal" href="#how-building-works">ビルドの仕組み</a></li>
<li><a class="reference internal" href="#how-installation-works">インストールの仕組み</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternate-installation">別の場所へのインストール</a><ul>
<li><a class="reference internal" href="#alternate-installation-the-user-scheme">別の場所へのインストール: user スキーム</a></li>
<li><a class="reference internal" href="#alternate-installation-the-home-scheme">別の場所へのインストール: home スキーム</a></li>
<li><a class="reference internal" href="#alternate-installation-unix-the-prefix-scheme">別の場所へのインストール: Unix (prefix スキーム)</a></li>
<li><a class="reference internal" href="#alternate-installation-windows-the-prefix-scheme">別の場所へのインストール (prefix を使う方法): Windows</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-installation">カスタムのインストール</a><ul>
<li><a class="reference internal" href="#modifying-python-s-search-path">Python サーチパスの変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="#distutils-configuration-files">Distutils 設定ファイル</a><ul>
<li><a class="reference internal" href="#location-and-names-of-config-files">設定ファイルの場所と名前</a></li>
<li><a class="reference internal" href="#syntax-of-config-files">設定ファイルの構文</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-extensions-tips-and-tricks">拡張モジュールのビルド: 小技と豆知識</a><ul>
<li><a class="reference internal" href="#tweaking-compiler-linker-flags">コンパイラ/リンカのフラグをいじるには</a></li>
<li><a class="reference internal" href="#using-non-microsoft-compilers-on-windows">Windows で非 Microsoft コンパイラを使ってビルドするには</a><ul>
<li><a class="reference internal" href="#borland-codegear-c">Borland/CodeGear C++</a></li>
<li><a class="reference internal" href="#gnu-c-cygwin-mingw">GNU C / Cygwin / MinGW</a><ul>
<li><a class="reference internal" href="#older-versions-of-python-and-mingw">古いバージョンの Python と MinGW</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="../distutils/apiref.html"
                        title="前の章へ">10. API リファレンス</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/install/index.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="../distutils/apiref.html" title="10. API リファレンス"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 2月 09, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>