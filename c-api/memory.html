
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>メモリ管理 &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="オブジェクト実装サポート (object implementation support)" href="objimpl.html" />
    <link rel="prev" title="初期化 (initialization)、終了処理 (finalization)、スレッド" href="init.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/c-api/memory.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/c-api/memory.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="オブジェクト実装サポート (object implementation support)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="init.html" title="初期化 (initialization)、終了処理 (finalization)、スレッド"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python/C API リファレンスマニュアル</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="memory-management">
<span id="memory"></span><h1>メモリ管理<a class="headerlink" href="#memory-management" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="overview">
<span id="memoryoverview"></span><h2>概要<a class="headerlink" href="#overview" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python におけるメモリ管理には、全ての Python オブジェクトとデータ構造が入ったプライベートヒープ (private heap) が必須です。プライベートヒープの管理は、内部的には <em>Python メモリマネージャ (Python memory manager)</em> が確実に行います。Python メモリマネージャには、共有 (sharing)、セグメント分割 (segmentation)、事前割り当て (preallocation)、キャッシュ化 (caching) といった、様々な動的記憶管理の側面を扱うために、個別のコンポーネントがあります。</p>
<p>最低水準層では、素のメモリ操作関数 (raw memory allocator) がオペレーティングシステムのメモリ管理機構とやりとりして、プライベートヒープ内にPython 関連の全てのデータを記憶するのに十分な空きがあるかどうか確認します。素のメモリ操作関数の上には、いくつかのオブジェクト固有のメモリ操作関数があります。これらは同じヒープを操作し、各オブジェクト型固有の事情に合ったメモリ管理ポリシを実装しています。例えば、整数オブジェクトは文字列やタプル、辞書とは違ったやり方でヒープ内で管理されます。というのも、整数には値を記憶する上で特別な要件があり、速度/容量のトレードオフが存在するからです。このように、Python メモリマネジャは作業のいくつかをオブジェクト固有のメモリ操作関数に委譲しますが、これらの関数がプライベートヒープからはみ出してメモリ管理を行わないようにしています。</p>
<p>重要なのは、たとえユーザがいつもヒープ内のメモリブロックを指すようなオブジェクトポインタを操作しているとしても、Python 用ヒープの管理はインタプリタ自体が行うもので、ユーザがそれを制御する余地はないと理解することです。Python オブジェクトや内部使用されるバッファを入れるためのヒープ空間のメモリ確保は、必要に応じて、Python メモリマネージャがこのドキュメント内で列挙しているPython/C API 関数群を介して行います。</p>
<p id="index-0">メモリ管理の崩壊を避けるため、拡張モジュールの作者は決して Python  オブジェクトを C ライブラリが公開している関数: <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">calloc()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">realloc()</span></code> および <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> で操作しようとしてはなりません。こうした関数を使うと、C のメモリ操作関数と Python メモリマネージャとの間で関数呼び出しが交錯します。 C のメモリ操作関数とPython メモリマネージャは異なるアルゴリズムで実装されていて、異なるヒープを操作するため、呼び出しの交錯は致命的な結果を招きます。とはいえ、個別の目的のためなら、 C ライブラリのメモリ操作関数を使って安全にメモリを確保したり解放したりできます。例えば、以下がそのような例です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="p">...</span><span class="n">Do</span> <span class="n">some</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="n">involving</span> <span class="n">buf</span><span class="p">...</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* malloc&#39;ed */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>この例では、I/O バッファに対するメモリ要求は C ライブラリのメモリ操作関数を使っています。Python メモリマネージャーは戻り値として返される文字列オブジェクトを確保する時にだけ必要です。</p>
<p>とはいえ、ほとんどの状況では、メモリの操作は Python ヒープに固定して行うよう勧めます。なぜなら、Python ヒープは Python メモリマネジャの管理下にあるからです。例えば、インタプリタを C で書かれた新たなオブジェクト型で拡張する際には、ヒープでのメモリ管理が必要です。Python ヒープを使った方がよいもう一つの理由として、拡張モジュールが必要としているメモリについて Python メモリマネージャに <em>情報を提供</em> してほしいということがあります。たとえ必要なメモリが内部的かつ非常に特化した用途に対して排他的に用いられるものだとしても、全てのメモリ操作要求を Python メモリマネージャに委譲すれば、インタプリタはより正確なメモリフットプリントの全体像を把握できます。その結果、特定の状況では、Python メモリマネージャがガベージコレクションやメモリのコンパクト化、その他何らかの予防措置といった、適切な動作をトリガできることがあります。上の例で示したように C ライブラリのメモリ操作関数を使うと、I/O バッファ用に確保したメモリは Python メモリマネージャの管理から完全に外れることに注意してください。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p>環境変数 <span class="target" id="index-6"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONMALLOC</span></code></a> を使用して Python が利用するメモリアロケータを制御することができます。</p>
<p class="last">環境変数 <span class="target" id="index-7"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOCSTATS"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONMALLOCSTATS</span></code></a> を使用して、新たなオブジェクトアリーナが生成される時と、シャットダウン時に <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc メモリアロケータ</span></a> の統計情報を表示できます。</p>
</div>
</div>
<div class="section" id="raw-memory-interface">
<h2>生メモリインタフェース<a class="headerlink" href="#raw-memory-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数群はシステムのアロケータをラップします。
これらの関数はスレッドセーフで、 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> を保持していなくても呼び出すことができます。</p>
<p>デフォルトの生メモリブロックアロケーターは次の関数を利用します: <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">realloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">free()</span></code>
0バイトを要求されたときには <code class="docutils literal"><span class="pre">malloc(1)</span></code> (あるいは <code class="docutils literal"><span class="pre">calloc(1,</span> <span class="pre">1)</span></code>) を呼びます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<dl class="function">
<dt id="c.PyMem_RawMalloc">
void* <code class="descname">PyMem_RawMalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawMalloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>n</em> バイトを割り当て、そのメモリを指す <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> 型のポインタを返します。要求が失敗した場合 <em>NULL</em> を返します。</p>
<p>0バイトを要求すると、 <code class="docutils literal"><span class="pre">PyMem_RawMalloc(1)</span></code> が呼ばれたときと同じように、可能なら <em>NULL</em> でないユニークなポインタを返します。確保されたメモリーにはいかなる初期化も行われません。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawCalloc">
void* <code class="descname">PyMem_RawCalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;nelem</em>, size_t<em>&nbsp;elsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawCalloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>各要素が <em>elsize</em> バイトの要素 <em>nelem</em> 個分のメモリーを確保し、そのメモリーを指す <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> 型のポインタを返します。アロケートに失敗した場合は <em>NULL</em> を返します。確保されたメモリー領域はゼロで初期化されます。</p>
<p>要素数か要素のサイズが0バイトの要求に対しては、可能なら <code class="docutils literal"><span class="pre">PyMem_RawCalloc(1,</span> <span class="pre">1)</span></code> が呼ばれたのと同じように、ユニークな <em>NULL</em> でないポインタを返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawRealloc">
void* <code class="descname">PyMem_RawRealloc</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawRealloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>p</em> が指すメモリブロックを <em>n</em> バイトにリサイズします。古いサイズと新しいサイズの小さい方までの内容は変更されません。</p>
<p><em>p</em> が <em>NULL</em> の場合呼び出しは <code class="docutils literal"><span class="pre">PyMem_RawMalloc(n)</span></code> と等価です。そうでなく、 <em>n</em> がゼロに等しい場合、メモリブロックはリサイズされますが解放されません。返されたポインタは非 <em>NULL</em> です。</p>
<p><em>p</em> が <em>NULL</em> でない限り、<em>p</em> はそれより前の <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawCalloc()</span></code></a> の呼び出しにより返されなければなりません。</p>
<p>要求が失敗した場合 <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a> は <em>NULL</em> を返し、 <em>p</em> は前のメモリエリアをさす有効なポインタのままです。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawFree">
void <code class="descname">PyMem_RawFree</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawFree" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Frees the memory block pointed to by <em>p</em>, which must have been returned by a
previous call to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a> or
<a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawCalloc()</span></code></a>.  Otherwise, or if <code class="docutils literal"><span class="pre">PyMem_RawFree(p)</span></code> has been
called before, undefined behavior occurs.</p>
<p><em>p</em> が <em>NULL</em> の場合何もしません。</p>
</dd></dl>

</div>
<div class="section" id="memory-interface">
<span id="memoryinterface"></span><h2>メモリインタフェース<a class="headerlink" href="#memory-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数群が利用して Python ヒープに対してメモリを確保したり解放したり出来ます。これらの関数は ANSI C 標準に従ってモデル化されていますが、0 バイトを要求した際の動作についても定義しています:</p>
<p>デフォルトではこれらの関数は <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc メモリアロケータ</span></a> を利用します。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">これらの関数を呼ぶときには、 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> を保持しておく必要があります。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>デフォルトのアロケータがシステムの <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> から pymalloc になりました。</p>
</div>
<dl class="function">
<dt id="c.PyMem_Malloc">
void* <code class="descname">PyMem_Malloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Malloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>n</em> バイトを割り当て、そのメモリを指す <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> 型のポインタを返します。要求が失敗した場合 <em>NULL</em> を返します。</p>
<p>0バイトを要求すると、 <code class="docutils literal"><span class="pre">PyMem_Malloc(1)</span></code> が呼ばれたときと同じように、可能なら <em>NULL</em> でないユニークなポインタを返します。
確保されたメモリーにはいかなる初期化も行われません。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Calloc">
void* <code class="descname">PyMem_Calloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;nelem</em>, size_t<em>&nbsp;elsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Calloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>各要素が <em>elsize</em> バイトの要素 <em>nelem</em> 個分のメモリーを確保し、そのメモリーを指す <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> 型のポインタを返します。アロケートに失敗した場合は <em>NULL</em> を返します。確保されたメモリー領域はゼロで初期化されます。</p>
<p>要素数か要素のサイズが0バイトの要求に対しては、可能なら <code class="docutils literal"><span class="pre">PyMem_Calloc(1,</span> <span class="pre">1)</span></code> が呼ばれたのと同じように、ユニークな <em>NULL</em> でないポインタを返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Realloc">
void* <code class="descname">PyMem_Realloc</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Realloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>p</em> が指すメモリブロックを <em>n</em> バイトにリサイズします。古いサイズと新しいサイズの小さい方までの内容は変更されません。</p>
<p><em>p</em> が <em>NULL</em> の場合呼び出しは <code class="docutils literal"><span class="pre">PyMem_Malloc(n)</span></code> と等価です。そうでなく、 <em>n</em> がゼロに等しい場合、メモリブロックはリサイズされますが解放されません。返されたポインタは非 <em>NULL</em> です。</p>
<p><em>p</em> が <em>NULL</em> でない限り、<em>p</em> はそれより前の <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> または <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Calloc()</span></code></a> の呼び出しにより返されなければなりません。</p>
<p>要求が失敗した場合 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> は <em>NULL</em> を返し、 <em>p</em> は前のメモリエリアをさす有効なポインタのままです。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Free">
void <code class="descname">PyMem_Free</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Free" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>p</em> が指すメモリブロックを解放します。 <em>p</em> は以前呼び出した <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>、 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a>、または <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Calloc()</span></code></a> の返した値でなければなりません。それ以外の場合や <code class="docutils literal"><span class="pre">PyMem_Free(p)</span></code> を呼び出した後だった場合、未定義の動作になります。</p>
<p><em>p</em> が <em>NULL</em> の場合何もしません。</p>
</dd></dl>

<p>以下に挙げる型対象のマクロは利便性のために提供されているものです。<em>TYPE</em> は任意の C の型を表します。</p>
<dl class="function">
<dt id="c.PyMem_New">
TYPE* <code class="descname">PyMem_New</code><span class="sig-paren">(</span>TYPE, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_New" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a> と同じですが、 <code class="docutils literal"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> バイトのメモリを確保します。 <code class="xref c c-type docutils literal"><span class="pre">TYPE*</span></code> に型キャストされたポインタを返します。メモリには何の初期化も行われていません。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Resize">
TYPE* <code class="descname">PyMem_Resize</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em>, TYPE, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Resize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> と同じですが、 <code class="docutils literal"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> バイトにサイズ変更されたメモリを確保します。
<code class="xref c c-type docutils literal"><span class="pre">TYPE*</span></code> に型キャストされたポインタを返します。
関数が終わったとき、 <em>p</em> は新しいメモリ領域のポインタか、失敗した場合は <em>NULL</em> になります。</p>
<p>これは C プリプロセッサマクロです。<em>p</em> は常に再代入されます。エラー処理時にメモリを失うのを避けるには <em>p</em> の元の値を保存してください。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Del">
void <code class="descname">PyMem_Del</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Del" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a> と同じです。</p>
</dd></dl>

<p>上記に加えて、C API 関数を介することなく Python メモリ操作関数を直接呼び出すための以下のマクロセットが提供されています。ただし、これらのマクロは Python バージョン間でのバイナリ互換性を保てず、それゆえに拡張モジュールでは撤廃されているので注意してください。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">PyMem_MALLOC(size)</span></code></li>
<li><code class="docutils literal"><span class="pre">PyMem_NEW(type,</span> <span class="pre">size)</span></code></li>
<li><code class="docutils literal"><span class="pre">PyMem_REALLOC(ptr,</span> <span class="pre">size)</span></code></li>
<li><code class="docutils literal"><span class="pre">PyMem_RESIZE(ptr,</span> <span class="pre">type,</span> <span class="pre">size)</span></code></li>
<li><code class="docutils literal"><span class="pre">PyMem_FREE(ptr)</span></code></li>
<li><code class="docutils literal"><span class="pre">PyMem_DEL(ptr)</span></code></li>
</ul>
</div>
<div class="section" id="object-allocators">
<h2>Object allocators<a class="headerlink" href="#object-allocators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の関数群が利用して Python ヒープに対してメモリを確保したり解放したり出来ます。これらの関数は ANSI C 標準に従ってモデル化されていますが、0 バイトを要求した際の動作についても定義しています:</p>
<p>デフォルトではこれらの関数は <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc メモリアロケータ</span></a> を利用します。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">これらの関数を呼ぶときには、 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> を保持しておく必要があります。</p>
</div>
<dl class="function">
<dt id="c.PyObject_Malloc">
void* <code class="descname">PyObject_Malloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Malloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>n</em> バイトを割り当て、そのメモリを指す <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> 型のポインタを返します。要求が失敗した場合 <em>NULL</em> を返します。</p>
<p>Requesting zero bytes returns a distinct non-<em>NULL</em> pointer if possible, as
if <code class="docutils literal"><span class="pre">PyObject_Malloc(1)</span></code> had been called instead. The memory will not have
been initialized in any way.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Calloc">
void* <code class="descname">PyObject_Calloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;nelem</em>, size_t<em>&nbsp;elsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Calloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>各要素が <em>elsize</em> バイトの要素 <em>nelem</em> 個分のメモリーを確保し、そのメモリーを指す <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> 型のポインタを返します。アロケートに失敗した場合は <em>NULL</em> を返します。確保されたメモリー領域はゼロで初期化されます。</p>
<p>Requesting zero elements or elements of size zero bytes returns a distinct
non-<em>NULL</em> pointer if possible, as if <code class="docutils literal"><span class="pre">PyObject_Calloc(1,</span> <span class="pre">1)</span></code> had been called
instead.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.5 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Realloc">
void* <code class="descname">PyObject_Realloc</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Realloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>p</em> が指すメモリブロックを <em>n</em> バイトにリサイズします。古いサイズと新しいサイズの小さい方までの内容は変更されません。</p>
<p>If <em>p</em> is <em>NULL</em>, the call is equivalent to <code class="docutils literal"><span class="pre">PyObject_Malloc(n)</span></code>; else if <em>n</em>
is equal to zero, the memory block is resized but is not freed, and the
returned pointer is non-<em>NULL</em>.</p>
<p>Unless <em>p</em> is <em>NULL</em>, it must have been returned by a previous call to
<a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Realloc()</span></code></a> or <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Calloc()</span></code></a>.</p>
<p>If the request fails, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Realloc()</span></code></a> returns <em>NULL</em> and <em>p</em> remains
a valid pointer to the previous memory area.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Free">
void <code class="descname">PyObject_Free</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Free" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Frees the memory block pointed to by <em>p</em>, which must have been returned by a
previous call to <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Realloc()</span></code></a> or
<a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Calloc()</span></code></a>.  Otherwise, or if <code class="docutils literal"><span class="pre">PyObject_Free(p)</span></code> has been called
before, undefined behavior occurs.</p>
<p><em>p</em> が <em>NULL</em> の場合何もしません。</p>
</dd></dl>

</div>
<div class="section" id="customize-memory-allocators">
<h2>メモリアロケータをカスタマイズする<a class="headerlink" href="#customize-memory-allocators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<dl class="type">
<dt id="c.PyMemAllocatorEx">
<code class="descname">PyMemAllocatorEx</code><a class="headerlink" href="#c.PyMemAllocatorEx" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>メモリブロックアロケータを記述するための構造体です。4つのフィールドを持ちます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">フィールド</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">*ctx</span></code></td>
<td>第一引数として渡されるユーザコンテクスト</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">void*</span> <span class="pre">malloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></td>
<td>メモリブロックを割り当てます</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void*</span> <span class="pre">calloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">nelem,</span> <span class="pre">size_t</span> <span class="pre">elsize)</span></code></td>
<td>0で初期化されたメモリブロックを割り当てます</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">void*</span> <span class="pre">realloc(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">size_t</span> <span class="pre">new_size)</span></code></td>
<td>メモリブロックを割り当てるかリサイズします</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></td>
<td>メモリブロックを解放する</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.5 で変更: </span><code class="xref c c-type docutils literal"><span class="pre">PyMemAllocator</span></code> 構造体が <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><code class="xref c c-type docutils literal"><span class="pre">PyMemAllocatorEx</span></code></a> にリネームされた上で <code class="docutils literal"><span class="pre">calloc</span></code> フィールドが追加されました。</p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.PyMemAllocatorDomain">
<code class="descname">PyMemAllocatorDomain</code><a class="headerlink" href="#c.PyMemAllocatorDomain" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アロケータドメインを同定するための列挙型です。ドメインは:</p>
<dl class="var">
<dt id="c.PYMEM_DOMAIN_RAW">
<code class="descname">PYMEM_DOMAIN_RAW</code><a class="headerlink" href="#c.PYMEM_DOMAIN_RAW" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawCalloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawFree()</span></code></a></li>
</ul>
</dd></dl>

<dl class="var">
<dt id="c.PYMEM_DOMAIN_MEM">
<code class="descname">PYMEM_DOMAIN_MEM</code><a class="headerlink" href="#c.PYMEM_DOMAIN_MEM" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>,</li>
<li><a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Calloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a></li>
</ul>
</dd></dl>

<dl class="var">
<dt id="c.PYMEM_DOMAIN_OBJ">
<code class="descname">PYMEM_DOMAIN_OBJ</code><a class="headerlink" href="#c.PYMEM_DOMAIN_OBJ" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>関数:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Realloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Calloc()</span></code></a></li>
<li><a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Free()</span></code></a></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="c.PyMem_GetAllocator">
void <code class="descname">PyMem_GetAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain">PyMemAllocatorDomain</a><em>&nbsp;domain</em>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx">PyMemAllocatorEx</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_GetAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたドメインのメモリブロックアロケータを取得します。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_SetAllocator">
void <code class="descname">PyMem_SetAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain">PyMemAllocatorDomain</a><em>&nbsp;domain</em>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx">PyMemAllocatorEx</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたドメインのメモリブロックアロケータを設定します。</p>
<p>新しいアロケータは、0バイトを要求されたときユニークな NULL でないポインタを返さなければなりません。</p>
<p><a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_RAW</span></code></a> ドメインでは、アロケータはスレッドセーフでなければなりません: アロケータが呼び出されたとき <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> は保持されていません。</p>
<p>新しいアロケータがフックでない (1つ前のアロケータを呼び出さない) 場合、 <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> 関数を呼び出して、新しいアロケータの上にデバッグフックを再度設置しなければなりません。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_SetupDebugHooks">
void <code class="descname">PyMem_SetupDebugHooks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetupDebugHooks" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python メモリアロケータ関数のバグを検出するためのフックを設定します。</p>
<p>新たに割り当てられたメモリはバイト <code class="docutils literal"><span class="pre">0xCB</span></code> で埋められ、解放されたメモリはバイト <code class="docutils literal"><span class="pre">0xDB</span></code> で埋められます。</p>
<p>実行時チェック:</p>
<ul class="simple">
<li>API 違反を検出します。例: <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a> が割り当てたバッファに対して <a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Free()</span></code></a> を呼びだした。</li>
<li>バッファの開始前の書き込み (バッファアンダーフロー) を検出します</li>
<li>バッファ終了後の書き込み (バッファオーバーフロー) を検出します</li>
<li>Check that the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> is held when
allocator functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (ex:
<a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code></a>) and <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (ex:
<a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>) domains are called</li>
</ul>
<p>On error, the debug hooks use the <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal"><span class="pre">tracemalloc</span></code></a> module to get the
traceback where a memory block was allocated. The traceback is only
displayed if <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal"><span class="pre">tracemalloc</span></code></a> is tracing Python memory allocations and the
memory block was traced.</p>
<p>These hooks are installed by default if Python is compiled in debug
mode. The <span class="target" id="index-3"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONMALLOC</span></code></a> environment variable can be used to install
debug hooks on a Python compiled in release mode.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.6 で変更: </span>This function now also works on Python compiled in release mode.
On error, the debug hooks now use <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal"><span class="pre">tracemalloc</span></code></a> to get the traceback
where a memory block was allocated. The debug hooks now also check
if the GIL is held when functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> and
<a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> domains are called.</p>
</div>
</dd></dl>

</div>
<div class="section" id="the-pymalloc-allocator">
<span id="pymalloc"></span><h2>pymalloc アロケータ<a class="headerlink" href="#the-pymalloc-allocator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python には、寿命の短いの小さな(512バイト以下の)オブジェクトに最適化された <em>pymalloc</em> アロケータがあります。 <em>pymalloc</em> は、256 KBの固定サイズの &quot;アリーナ&quot; と呼びれるメモリマッピングを使います。512バイトよりも大きな割り当てでは、 <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a> と <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a> にフォールバックします。</p>
<p><em>pymalloc</em> is the default allocator of the <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (ex:
<a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>) and <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (ex:
<a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code></a>) domains.</p>
<p>アリーナアロケータは、次の関数を使います:</p>
<ul class="simple">
<li>Windows では <code class="xref c c-func docutils literal"><span class="pre">VirtualAlloc()</span></code> と <code class="xref c c-func docutils literal"><span class="pre">VirtualFree()</span></code>、</li>
<li>利用できる場合、<code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> と <code class="xref c c-func docutils literal"><span class="pre">munmap()</span></code>、</li>
<li>それ以外の場合は <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> と <code class="xref c c-func docutils literal"><span class="pre">free()</span></code>。</li>
</ul>
<div class="section" id="customize-pymalloc-arena-allocator">
<h3>pymalloc アリーナアロケータのカスタマイズ<a class="headerlink" href="#customize-pymalloc-arena-allocator" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<dl class="type">
<dt id="c.PyObjectArenaAllocator">
<code class="descname">PyObjectArenaAllocator</code><a class="headerlink" href="#c.PyObjectArenaAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アリーナアロケータを記述するための構造体です。3つのフィールドを持ちます:</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">フィールド</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">*ctx</span></code></td>
<td>第一引数として渡されるユーザコンテクスト</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">void*</span> <span class="pre">alloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></td>
<td>size バイトのアリーナを割り当てます</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></td>
<td>アリーナを解放します</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GetArenaAllocator">
<code class="descname">PyObject_GetArenaAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator">PyObjectArenaAllocator</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GetArenaAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アリーナアロケータを取得します。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_SetArenaAllocator">
<code class="descname">PyObject_SetArenaAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator">PyObjectArenaAllocator</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_SetArenaAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>アリーナアロケータを設定します。</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples">
<span id="memoryexamples"></span><h2>使用例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>最初に述べた関数セットを使って、 <a class="reference internal" href="#memoryoverview"><span class="std std-ref">概要</span></a> 節の例を Python ヒープに I/O バッファをメモリ確保するように書き換えたものを以下に示します:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* allocated with PyMem_Malloc */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>同じコードを型対象の関数セットで書いたものを以下に示します:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* allocated with PyMem_New */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>上の二つの例では、バッファを常に同じ関数セットに属する関数で操作していることに注意してください。実際、あるメモリブロックに対する操作は、異なるメモリ操作機構を混用する危険を減らすために、同じメモリ API ファミリを使って行うことが必要です。以下のコードには二つのエラーがあり、そのうちの一つには異なるヒープを操作する別のメモリ操作関数を混用しているので <em>致命的 (Fatal)</em> とラベルづけをしています。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">buf1</span> <span class="o">=</span> <span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf3</span><span class="p">);</span>  <span class="cm">/* Wrong -- should be PyMem_Free() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>       <span class="cm">/* Right -- allocated via malloc() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>       <span class="cm">/* Fatal -- should be PyMem_Del()  */</span>
</pre></div>
</div>
<p>素のメモリブロックを Python ヒープ上で操作する関数に加え、 <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_New()</span></code></a> 、 <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal"><span class="pre">PyObject_NewVar()</span></code></a> 、および <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Del()</span></code></a> を使うと、 Python におけるオブジェクトをメモリ確保したり解放したりできます。</p>
<p>これらの関数については、次章の C による新しいオブジェクト型の定義や実装に関する記述の中で説明します。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">メモリ管理</a><ul>
<li><a class="reference internal" href="#overview">概要</a></li>
<li><a class="reference internal" href="#raw-memory-interface">生メモリインタフェース</a></li>
<li><a class="reference internal" href="#memory-interface">メモリインタフェース</a></li>
<li><a class="reference internal" href="#object-allocators">Object allocators</a></li>
<li><a class="reference internal" href="#customize-memory-allocators">メモリアロケータをカスタマイズする</a></li>
<li><a class="reference internal" href="#the-pymalloc-allocator">pymalloc アロケータ</a><ul>
<li><a class="reference internal" href="#customize-pymalloc-arena-allocator">pymalloc アリーナアロケータのカスタマイズ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">使用例</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="init.html"
                        title="前の章へ">初期化 (initialization)、終了処理 (finalization)、スレッド</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="objimpl.html"
                        title="次の章へ">オブジェクト実装サポート (object implementation support)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/c-api/memory.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="オブジェクト実装サポート (object implementation support)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="init.html" title="初期化 (initialization)、終了処理 (finalization)、スレッド"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API リファレンスマニュアル</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 4月 30, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>