<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>What’s New in Python 2.6 &#8212; Python 3.6.1 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.1 ドキュメント" href="../contents.html" />
    <link rel="up" title="What’s New in Python" href="index.html" />
    <link rel="next" title="What’s New in Python 2.5" href="2.5.html" />
    <link rel="prev" title="What’s New in Python 2.7" href="2.7.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/whatsnew/2.6.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/whatsnew/2.6.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="What’s New in Python 2.5"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="What’s New in Python 2.7"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What&#8217;s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-2-6">
<span id="whats-new-in-2-6"></span><h1>What&#8217;s New in Python 2.6<a class="headerlink" href="#what-s-new-in-python-2-6" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">A.M. Kuchling (amk at amk.ca)</td>
</tr>
</tbody>
</table>
<p>この文書は Python 2.6 の新機能について解説します。 Python 2.6 は 2008 年 10 月 1 日にリリースされました。リリーススケジュールは <span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0361"><strong>PEP 361</strong></a> に記述されています。</p>
<p>The major theme of Python 2.6 is preparing the migration path to
Python 3.0, a major redesign of the language.  Whenever possible,
Python 2.6 incorporates new features and syntax from 3.0 while
remaining compatible with existing code by not removing older features
or syntax.  When it&#8217;s not possible to do that, Python 2.6 tries to do
what it can, adding compatibility functions in a
<code class="xref py py-mod docutils literal"><span class="pre">future_builtins</span></code> module and a <code class="xref std std-option docutils literal"><span class="pre">-3</span></code> switch to warn about
usages that will become unsupported in 3.0.</p>
<p><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> や <a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a> といった、いくつか重要な新しいパッケージが標準ライブラリに追加されましたが、Python 3.0 に何らかも関係しない新機能はあまり多くはありません。</p>
<p>Python 2.6 ではさらに、たくさんの改善とバグフィックスがソースコードのありとあらゆる場所に見られます。Python 2.5 から 2.6 の変更ログを手繰ってみると、低く見積もっても、適用されたパッチは 259、フィックスされたバグは 612 にのぼります。</p>
<p>このドキュメントは新機能の完全な詳細を提供するのではなくて、簡易な概要を提供することを目的にしています。完全な詳細が知りたければ、 Python 2.6 のドキュメントを参照してください。設計と実装の根拠を理解したい場合は、新機能に関する PEP を参照してください。可能な限り、 &#8220;What’s New in Python&#8221; は各変更の bug や patch に対してリンクしています。</p>
<div class="section" id="python-3-0">
<h2>Python 3.0<a class="headerlink" href="#python-3-0" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.6 と 3.0 の開発サイクルは同期していました。両バージョンのアルファ、ベータリリースは同じ日にリリースされています。3.0 の開発は 2.6 の多くの機能に影響を与えました。</p>
<p>Python 3.0 は、2.x シリーズとの互換性を破壊する、広範囲な再設計です。これは、Python 3.0 で動作させるためには既存のコードに何らかの変換が必要なことを意味しています。しかしながら、必ずしも全ての 3.0 での変更が互換性を破壊するわけではありません。新機能が既存のコードの破壊を引き起こさないケースにおいては、それらは 2.6 にバックポートされました。これらについてはこのドキュメントの適切な場所に記載しています。3.0 由来の機能の一部としては以下があります:</p>
<ul class="simple">
<li><p class="first">オブジェクトを複素数(虚数)に変換する <a class="reference internal" href="../reference/datamodel.html#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal"><span class="pre">__complex__()</span></code></a> メソッド。</p>
</li>
<li><p class="first">例外の捕捉の、これまでとは別の文法の追加: <code class="docutils literal"><span class="pre">except</span> <span class="pre">TypeError</span> <span class="pre">as</span> <span class="pre">exc</span></code> 。</p>
</li>
<li><p class="first">組み込み関数 <code class="xref py py-func docutils literal"><span class="pre">reduce()</span></code> への別名としての <a class="reference internal" href="../library/functools.html#functools.reduce" title="functools.reduce"><code class="xref py py-func docutils literal"><span class="pre">functools.reduce()</span></code></a> の追加。</p>
</li>
</ul>
<p>Python 3.0 はいくつかの新しい組み込み関数を追加し、また、いくつかの既存の組み込み関数では意味を変更しています。Python 3.0 での新しい組み込み関数、例えば <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal"><span class="pre">bin()</span></code></a> などは単純に 2.6 に追加されましたが、既存のものはそうせずに、代わりに <code class="xref py py-mod docutils literal"><span class="pre">future_builtins</span></code> モジュールに 3.0 版のものを追加しています。3.0 と互換性を持ちたいコードでは、必要に応じて <code class="docutils literal"><span class="pre">from</span> <span class="pre">future_builtins</span> <span class="pre">import</span> <span class="pre">hex,</span> <span class="pre">map</span></code> などとすることが出来ます。</p>
<p>A new command-line switch, <code class="xref std std-option docutils literal"><span class="pre">-3</span></code>, enables warnings
about features that will be removed in Python 3.0.  You can run code
with this switch to see how much work will be necessary to port
code to 3.0.  The value of this switch is available
to Python code as the boolean variable <code class="xref py py-data docutils literal"><span class="pre">sys.py3kwarning</span></code>,
and to C extension code as <code class="xref c c-data docutils literal"><span class="pre">Py_Py3kWarningFlag</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">Python 3.0 についての提案を含む PEP は 3xxx シリーズにあります。 <span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3000"><strong>PEP 3000</strong></a> は Python 3.0 の開発プロセスについて記述しています。Python 3.0 の全般的な目標について記述している <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3100"><strong>PEP 3100</strong></a> から始めて、個別の機能についての提案のこれより番号が高い PEP を探索してみてください。</p>
</div>
</div>
<div class="section" id="changes-to-the-development-process">
<h2>開発プロセスに関する変更<a class="headerlink" href="#changes-to-the-development-process" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>2.6 の開発の間で、Python 開発プロセスは 2 つの重要な変更を経験しました: SourceForge の課題トラッカーから、カスタイマイズした Roundup インストレーションに乗り換えました。また、ドキュメントは LaTeX から reStructuredText に変換しました。</p>
<div class="section" id="new-issue-tracker-roundup">
<h3>新しい課題トラッカー: Roundup<a class="headerlink" href="#new-issue-tracker-roundup" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もう随分長いこと Python 開発者たちは、SourceForge のバグトラッカーにイライラを高め続けてきました。SourceForge がホストするソリューションには全くカスタマイズの余地がなく、たとえば課題のライフサイクルをカスタマイズ出来ませんでした。</p>
<p>そのようなわけで、Python Software Foundation のインフラ委員会はボランティアたちに課題トラッカーについて、異なるプロダクトのセットアップをし、SourceForge からバグ報告とパッチのインポートをする依頼の呼び掛けをしました。4 つのトラッカーが試されました: <a class="reference external" href="https://www.atlassian.com/software/jira/">Jira</a>, <a class="reference external" href="https://launchpad.net">Launchpad</a>, <a class="reference external" href="http://roundup.sourceforge.net/">Roundup</a>, <a class="reference external" href="https://trac.edgewall.org/">Trac</a> です。委員会は結果として Jira と Roundup の 2 つを候補に据えました。Jira はフリーソフトウェアプロジェクトの無償でのホストが可能な商用製品です; Roundup はそれを運営するボランティアとそれをホストするサーバが必要なオープンソースプロダクトです。</p>
<p>ボランティアへの呼び掛けののち、新しい Roundup インストレーションが <a class="reference external" href="https://bugs.python.org">https://bugs.python.org</a> にセットアップされました。Roundup の一つのインストレーションは複数のトラッカーをホスト出来るため、このサーバは今では Jython と Python ウェブサイトのための課題トラッカーもホストしています。間違いなく将来はほかのものもホストするでしょう。可能な場所では、&#8221;What&#8217;s New in Python&#8221; のこのエディションでは、それぞれの変更についてのバグ/パッチの Roundup アイテムにリンクします。</p>
<p>Python バグトラッカーのホスティングは、南アフリカの Stellenbosch による <a class="reference external" href="http://www.upfrontsystems.co.za/">Upfront Systems</a> が快く提供してくれています。Martin von Löwis が SourceForge からバグ報告とパッチをインポートするのに多大な労力を払いました; 彼によるこのインポート操作のためのスクリプトは <a class="reference external" href="http://svn.python.org/view/tracker/importer/">http://svn.python.org/view/tracker/importer/</a> にあります。これは SourceForge から Roundup へ移行したいと考えているほかのプロジェクトにも役に立つでしょう。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="https://bugs.python.org">https://bugs.python.org</a></dt>
<dd><p class="first last">Python のバグトラッカー。</p>
</dd>
<dt><a class="reference external" href="http://bugs.jython.org">http://bugs.jython.org</a>:</dt>
<dd><p class="first last">Jython のバグトラッカー。</p>
</dd>
<dt><a class="reference external" href="http://roundup.sourceforge.net/">http://roundup.sourceforge.net/</a></dt>
<dd><p class="first last">Roundup のダウンロードとドキュメント。</p>
</dd>
<dt><a class="reference external" href="http://svn.python.org/view/tracker/importer/">http://svn.python.org/view/tracker/importer/</a></dt>
<dd><p class="first last">Martin von Löwis の変換スクリプト。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="new-documentation-format-restructuredtext-using-sphinx">
<h3>新しいドキュメンテーションフォーマット: Sphinx を使っての reStructuredText<a class="headerlink" href="#new-documentation-format-restructuredtext-using-sphinx" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のドキュメンテーションは、そのプロジェクトの開始した 1989 年頃より LaTeX を使って書かれてきました。1980 年代と 1990 年代初期は、ほとんどのドキュメンテーションはあとで学習するために印刷されるもので、オンラインで見るものではありませんでした。LaTeX はとても魅惑的な印刷をしてくれるものですから、非常に大変広く広く使われていましたが、一方では、学んだマークアップの基礎的なルールで直裁的に、書いたらそれっきり、というものでもありました。</p>
<p>こんにちにおいてもなお、印刷を命題とする出版において LaTeX は健在といえど、プログラミングの道具立ての風景は変わりました。わたしたちはもはやドキュメンテーションの紙束をプリントアウトはしません。代わりにオンラインでブラウズします。ですから HTML は、サポートすべき最も重要なフォーマットになりました。悲しいかな、 LaTeX から HTML への変換は気が狂うほどに複雑で、Fred L. Drake Jr.、彼は長らく Python ドキュメンテーションのエディターを務めていますが、彼はその変換処理の保守に多大な時間を浪費していたのです。ときおり人々はドキュメンテーションを SGML に変換して、それから XML にすればいいでしょ、と持ちかけるのですが、良い変換を達成することにとらわれて、誰一人として仕事を完遂させようと時間を捧げることはしませんでした。</p>
<p>2.6 の開発サイクルの期間に、Georg Brandl はドキュメンテーションの処理のための新たなツールチェインの構築に多大な労力を払いました。
その成果であるパッケージは Sphinx と呼ばれ、 <a class="reference external" href="http://sphinx-doc.org/">http://sphinx-doc.org/</a> で入手出来ます。</p>
<p>Sphinx は HTML 出力に集中し、人を惹きつけるスタイルでモダンな HTML を生成します。印刷出力は LaTeX への変換を経由することで健在です。入力のフォーマットは reStructuredText です。これはカスタムな拡張とディレクティブをサポートしているマークアップ文法で、Python コミュニティでは広く使われています。</p>
<p>Sphinx は執筆に使えるスタンドアロンのパッケージです。そして 2 ダースに届かんばかりのプロジェクトが(<a class="reference external" href="http://sphinx-doc.org/examples.html">Sphinx ウェブサイトのリスト</a>)、ドキュメンテーションツールとして Sphinx を採用しました。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="https://docs.python.org/devguide/documenting.html">Documenting Python</a></dt>
<dd><p class="first last">Python ドキュメントの書き方について書いています。</p>
</dd>
<dt><a class="reference external" href="http://sphinx-doc.org/">Sphinx</a></dt>
<dd><p class="first last">Sphinx ツールチェインのドキュメントとコードです。</p>
</dd>
<dt><a class="reference external" href="http://docutils.sourceforge.net">Docutils</a></dt>
<dd><p class="first last">縁の下の力持ちになっている reStructuredText のパーサとツールセットです。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="pep-343-the-with-statement">
<span id="pep-0343"></span><h2>PEP 343: &#8220;with&#8221; ステートメント<a class="headerlink" href="#pep-343-the-with-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.5 では、  &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; 文が <code class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">with_statement</span></code> ディレクティブで有効に出来るオプションの機能として追加されました。2.6 では &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; 文は特別に有効化する必要なく、もういつでもそこにあります。このセクションの残りの部分は &#8220;What&#8217;s New in Python 2.5&#8221; の対応するセクションからの丸々コピーですので、2.5 で既に馴染みならば読み飛ばしてもらって結構です。</p>
<p>&#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントは、以前なら後片付けが実行されるのを確実にするために <code class="docutils literal"><span class="pre">try...finally</span></code> ブロックを使ったであろうようなコードを、より単純明快にします。このセクションでは、このステートメントの普通の使い方を説明します。続くセクションでは実装の詳細を調べ、このステートメントとともに使うためにオブジェクトをどうやって書けば良いかをお見せします。</p>
<p>&#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントは基本構造が以下となる制御フロー構造です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">expression</span> <span class="p">[</span><span class="k">as</span> <span class="n">variable</span><span class="p">]:</span>
    <span class="k">with</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p>expression は評価されて結果がコンテキスト管理プロトコルをサポートするオブジェクトにならなければなりません (具体的にはメソッド <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> を持つオブジェクト)。 ( 訳注: Python ドキュメント全体で context manager protocol と context management protocol とで不統一。同じものです。 )</p>
<p><em>with-block</em> が呼び出される前に、 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> が呼ばれるので、セットアップコードをそこで実行出来ます。それは <em>variable</em> 名(与えられた場合)に束縛されることになる値も返します(注意深く読んで下さい、つまり <em>variable</em> には <em>expression</em> の結果が代入される <em>のではない</em> のです)。</p>
<p><em>with-block</em> ブロックの実行が終了後、ブロックが例外を送出する場合であろうとオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> が呼び出されますので、ここで後片付けコードを実行出来ます。</p>
<p>いくつかの Python 標準オブジェクトが既にコンテキスト管理プロトコルをサポートしていて、 &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; とともに使えます。ファイルオブジェクトがその一例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span>
        <span class="o">...</span> <span class="n">more</span> <span class="n">processing</span> <span class="n">code</span> <span class="o">...</span>
</pre></div>
</div>
<p>このステートメントが実行し終わったあかつきには、 <em>f</em> のファイルオブジェクトは、たとえ <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループが道半ばにして例外と成り果てても、自動的にクローズされます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このケースでは、 <em>f</em> は <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> が作ったオブジェクトと同じです。これはファイルオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">file.__enter__()</span></code> が <em>self</em> を返しているからです。</p>
</div>
<p><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールのロック・条件変数でも &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントの恩恵にあずかれます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># Critical section of code</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>ブロックが実行される前にロックが獲得されて、ブロックが完了するやいなや必ず解放されます。</p>
<p><a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュール内の <code class="xref py py-func docutils literal"><span class="pre">localcontext()</span></code> 関数は現在の decimal のコンテキスト (計算の望みの精度と丸め特性をカプセル化しています) を保存しておいてあとで元に戻すのを簡単にしてくれます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">localcontext</span>

<span class="c1"># Displays with default precision of 28 digits</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;578&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">16</span><span class="p">)):</span>
    <span class="c1"># All code in this block uses a precision of 16 digits.</span>
    <span class="c1"># The original context is restored on exiting the block.</span>
    <span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="writing-context-managers">
<span id="new-26-context-managers"></span><h3>コンテキストマネージャを書く<a class="headerlink" href="#writing-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>中身を紐解いてみれば、 &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントはけっこう入り組んでいます。ほとんどの人にとっては、既存のオブジェクトを &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; とともに使うだけのことでその詳細は知らなくても良いので、そうしたいならこのセクションの残りの部分は読み飛ばして結構です。新しいオブジェクトの作者は基礎となる実装の詳細について知る必要があります。このまま読み進めるべきです。</p>
<p>コンテキスト管理プロトコルの高度な説明はこんなです:</p>
<ul class="simple">
<li><p class="first">expression は評価されて、 &#8220;コンテキストマネージャ(context manager)&#8221;  にならなければなりません。コンテキストマネージャは <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドと <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドを持っていなければなりません。</p>
</li>
<li><p class="first">コンテキストマネージャの <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドが呼び出されます。これの戻り値は <em>VAR</em> に代入されます。 <code class="docutils literal"><span class="pre">as</span> <span class="pre">VAR</span></code> 節がない場合は、この値は単に捨てられます。</p>
</li>
<li><p class="first"><em>BLOCK</em> 内のコードが実行されます。</p>
</li>
<li><p class="first"><em>BLOCK</em> が例外を起こした場合、コンテキストマネージャの <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドが 3 つの引数とともに呼び出されます。これは例外の詳細です (<code class="docutils literal"><span class="pre">type,</span> <span class="pre">value,</span> <span class="pre">traceback</span></code>, これは <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> が返す値と同じで、例外が起こらなければ <code class="docutils literal"><span class="pre">None</span></code> です)。そのメソッドの戻り値は例外を再送出するかどうかを制御します: 全ての偽の値ではその例外が再送出され、 <code class="docutils literal"><span class="pre">True</span></code> では揉み消します。例外を揉み消すなど滅多なことでは欲しいと思わないでしょう。もしそうしてしまったら、 &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントを含んだコードの作者は何か間違ったことが起こったことに決して気付かないですから。</p>
</li>
<li><p class="first"><em>BLOCK</em> が例外を起こさなかった場合も <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドが呼び出されます。ただし <em>type</em>, <em>value</em>, <em>traceback</em> は全て <code class="docutils literal"><span class="pre">None</span></code> です。</p>
</li>
</ul>
<p>例を通じて考えましょう。枝葉末節を含んだ完璧なコードを提示しようとは思いませんが、データベースのためにトランザクションをサポートするのに必要となるメソッドの書き方についてスケッチしてみようと思います。</p>
<p>(データベース用語に不慣れな方へ:データベースへの変更のセットは、トランザクションという単位でグループ化されています。トランザクションは「コミット」される、その意味は、全ての変更がデータベースに書き込まれることです、もしくは「ロールバック」される、この場合全ての変更が捨てられてデータベースが変更されません、この 2 つのいずれかになりえます。詳しくはなにかデータベースの著述を読んで下さい。)</p>
<p>データベース接続を表現するオブジェクトがあると仮定しましょう。私たちの目標は、そのオブジェクトのユーザがこのように書けるようになることです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">db_connection</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_connection</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into ...&#39;</span><span class="p">)</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;delete from ...&#39;</span><span class="p">)</span>
    <span class="c1"># ... more operations ...</span>
</pre></div>
</div>
<p>トランザクションはブロック内のコードがつつがなく終了すればコミットし、例外が発生すればロールバックすべきです。私が思い描いている <code class="xref py py-class docutils literal"><span class="pre">DatabaseConnection</span></code> の基本的なインターフェイスはこんなです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="c1"># Database interface</span>
    <span class="k">def</span> <span class="nf">cursor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns a cursor object and starts a new transaction&quot;</span>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Commits current transaction&quot;</span>
    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Rolls back current transaction&quot;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドはとっても簡単で、トランザクションを開始する必要があるだけです。このアプリケーションでは、カーソルオブジェクトを結果とすることが有用なので、メソッドはそれを返しましょう。ユーザはこれにより <code class="docutils literal"><span class="pre">as</span> <span class="pre">cursor</span></code> をその &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントにつけて、そのカーソルを変数名に束縛できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Code to start a new transaction</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cursor</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドはそれがほとんどの仕事をしなければならない場所なので、もっと複雑です。メソッドは例外が起こったのかどうかをチェックし、例外が起こっていなければトランザクションをコミットし、例外があればロールバックしなければいけません。</p>
<p>下記のコード内では実行がメソッドの末尾まで落ちていって、なのでデフォルトの <code class="docutils literal"><span class="pre">None</span></code> 返却になります。 <code class="docutils literal"><span class="pre">None</span></code> は偽なので、例外は自動的に再送出されます。望むならもっと明示的に、コメントでマークした部分で <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文を書いてもよろしいです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No exception, so commit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Exception occurred, so rollback.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="c1"># return False</span>
</pre></div>
</div>
</div>
<div class="section" id="the-contextlib-module">
<span id="new-module-contextlib"></span><h3>contextlib モジュール<a class="headerlink" href="#the-contextlib-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールは、 &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントで使えるオブジェクトを書く際に便利ないくつかの関数とデコレータを提供しています。</p>
<p>デコレータは <code class="xref py py-func docutils literal"><span class="pre">contextmanager()</span></code> という名前で、新たにクラスを書く代わりに一つジェネレータを書けば済むようにするものです。そのジェネレータは正確に一つの値を yield しなければなりません。 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> より上の部分のコードが <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドとして実行されます。yield した値は <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドの戻り値となって、 &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントの <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節があれば、その変数に束縛されます。 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> に続くコードが <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッド内で実行されます。ブロック内では任意の例外が <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> ステートメントによって引き起こされます。</p>
<p>このデコレータを使って、前セクションの私たちのデータベースの例はこのように書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">db_transaction</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cursor</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールには <code class="docutils literal"><span class="pre">nested(mgr1,</span> <span class="pre">mgr2,</span> <span class="pre">...)</span></code> 関数もあって、これはたくさんのコンテキストマネージャを組み合わせることが出来るので、入れ子の &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; を書く必要性をなくしてくれます。この例では、単一の &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; でデータベーストランザクション開始とスレッドのロック獲得の両方をやってのけています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">nested</span> <span class="p">(</span><span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">),</span> <span class="n">lock</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">locked</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>最後になりますが、 <code class="xref py py-func docutils literal"><span class="pre">closing()</span></code> 関数はその与えた引数をそのまま返して変数に束縛出来るようにし、かつブロックの終了で、与えた引数が持つ <code class="docutils literal"><span class="pre">.close()</span></code> を呼び出します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">closing</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.yahoo.com&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="docutils">
<dt><span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &#8220;with&#8221; ステートメント</dt>
<dd><p class="first last">PEP は Guido van Rossum と Nick Coghlan によって書かれ、Mike Bland、 Guido van Rossum、Neal Norwitz により実装されました。この PEP は &#8216;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>&#8216; ステートメントによって生成されるコードを見せてくれるので、このステートメントがどうやって動作するのかを知るのに役立ちます。</p>
</dd>
</dl>
<p class="last"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールについてのドキュメント。</p>
</div>
</div>
</div>
<div class="section" id="pep-366-explicit-relative-imports-from-a-main-module">
<span id="pep-0366"></span><h2>PEP 366: メインモジュールからの明示的相対インポート<a class="headerlink" href="#pep-366-explicit-relative-imports-from-a-main-module" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のオプション <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> で、モジュールをスクリプトとして実行出来ます。パッケージ内のモジュールを実行する際に、相対インポートが正しく動作していませんでした。</p>
<p>Python 2.6 でのそれについてのフィックスは、モジュールに <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> 属性を追加するというものです。この属性がある場合は相対インポートは <a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a> 属性の代わりにこの属性の値からの相対でインポートします。</p>
<p>PEP 302 スタイルのインポーターはその結果 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> を必要に応じて設定出来ます。 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> スイッチを実装している <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal"><span class="pre">runpy</span></code></a> モジュールは今はこれをするので、パッケージ内のモジュール実行内の相対インポートは、今では正しく動作します。(&#8212; 訳注: このセクションの言いたいことの結論がわからない方はいないと思いますが、細かいところでこの翻訳を行っている 2015 年ではわからなくなっているところがあるので補足しておきます。 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> 属性のくだりですが、現在となっては「2.5 ではこれを設定していなかった」のかどうか簡単には確認は出来ないですが、言語リファレンスによればローダが <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> をセットするのはオプションだがセットすべき、と書かれています。2.6 で行われたのは、おそらく <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> の用法が <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal"><span class="pre">runpy</span></code></a> きっかけで整理された、ということではないかと思います。&#8212;)</p>
</div>
<div class="section" id="pep-370-per-user-site-packages-directory">
<span id="pep-0370"></span><h2>PEP 370: ユーザごとの <code class="docutils literal"><span class="pre">site-packages</span></code> ディレクトリ<a class="headerlink" href="#pep-370-per-user-site-packages-directory" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python を実行すると、モジュール検索パス <code class="docutils literal"><span class="pre">sys.path</span></code> にはパスが  <code class="docutils literal"><span class="pre">&quot;site-packages&quot;</span></code> で終わるディレクトリが普通含まれます。このディレクトリは、ローカルにインストールされる機器を使う全てのユーザが使えるパッケージあるいは固有のサイトインストレーションを持つ場所として意図されています。</p>
<p>Python 2.6 ではユーザ固有のサイトディレクトリのための決まりを導入しました。ディレクトリはプラットフォームに依存して変わります。</p>
<ul class="simple">
<li><p class="first">Unix と Mac OS X: <code class="file docutils literal"><span class="pre">~/.local/</span></code></p>
</li>
<li>Windows: <code class="file docutils literal"><span class="pre">%APPDATA%/Python</span></code></li>
</ul>
<p>このディレクトリ内にはバージョン固有のサブディレクトリが入ります。Unix/Mac OS では  <code class="file docutils literal"><span class="pre">lib/python2.6/site-packages</span></code>  のように、Windows では <code class="file docutils literal"><span class="pre">Python26/site-packages</span></code>  のように。</p>
<p>このデフォルトディレクトリが好きでないなら、この機能をサポートする全ての Python バージョンが使う環境変数 <span class="target" id="index-56"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONUSERBASE"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONUSERBASE</span></code></a> にルートディレクトリを指定することで上書き出来ます。Windows ではアプリケーション固有データの場所を環境変数 <span class="target" id="index-57"></span><code class="xref std std-envvar docutils literal"><span class="pre">APPDATA</span></code> で変更出来ます。また、あなたの Python インストレーションについての <code class="file docutils literal"><span class="pre">site.py</span></code> ファイルを修正することでも出来ます。</p>
<p>この機能は Python 起動時に <a class="reference internal" href="../using/cmdline.html#cmdoption-s"><code class="xref std std-option docutils literal"><span class="pre">-s</span></code></a> オプションを付けるか、環境変数 <span class="target" id="index-58"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNOUSERSITE"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONNOUSERSITE</span></code></a> をセットすることで完全に無効に出来ます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0370"><strong>PEP 370</strong></a> - ユーザごとの <code class="docutils literal"><span class="pre">site-packages</span></code> ディレクトリ</dt>
<dd><p class="first last">PEP 著と実装 Christian Heimes.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-371-the-multiprocessing-package">
<span id="pep-0371"></span><h2>PEP 371: <code class="docutils literal"><span class="pre">multiprocessing</span></code> パッケージ<a class="headerlink" href="#pep-371-the-multiprocessing-package" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新しい <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> により、Python プログラムが新たなプロセスを作成して何か計算を実行させて結果を返させることが出来ます。親と子のプロセスはキューとパイプを使って通信し、ロックとセマフォを使って同期し、単純なデータの配列を共有出来ます。</p>
<p><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールは、 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールがスレッドの代わりにプロセスを使ようになるだけのような、完全な模倣となるよう開始されました。その目標は Python 2.6 へ向かう道のりを経て捨て去られはしましたが、モジュールの一般的なアプローチはそれでも似ています。基礎的なクラスは <code class="xref py py-class docutils literal"><span class="pre">Process</span></code> です。これには呼び出し可能オブジェクトと引数のコレクションを渡します。その <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code> メソッドが渡された呼び出し可能オブジェクトをサブプロセスで実行するので、 <code class="xref py py-meth docutils literal"><span class="pre">is_alive()</span></code> メソッドを呼び出せばサブプロセスが実行中かを知ることが出来、 <code class="xref py py-meth docutils literal"><span class="pre">join()</span></code> メソッドでそのプロセスが終了するのを待つことが出来ます。</p>
<p>ここに、サブプロセスが階乗を計算する例を示します。その計算をする関数はヘンテコリンに書かれていて、入力が 4 の倍数だととっても時間がかかるように仕組んであります。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>


<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="s2">&quot;Compute a factorial.&quot;</span>
    <span class="c1"># If N is a multiple of 4, this function will take much longer.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="o">.</span><span class="mi">05</span> <span class="o">*</span> <span class="n">N</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Calculate the result</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="mi">1</span><span class="n">L</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">i</span>

    <span class="c1"># Put the result on the queue</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">factorial</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="nb">print</span> <span class="s1">&#39;Factorial&#39;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">result</span>
</pre></div>
</div>
<p>A <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> is used to communicate the result of the factorial.
The <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> object is stored in a global variable.
The child process will use the value of the variable when the child
was created; because it&#8217;s a <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a>, parent and child can use
the object to communicate.  (If the parent were to change the value of
the global variable, the child&#8217;s value would be unaffected, and vice
versa.)</p>
<p>2 つのほかのクラス <code class="xref py py-class docutils literal"><span class="pre">Pool</span></code> と <code class="xref py py-class docutils literal"><span class="pre">Manager</span></code> はハイレベルインターフェイスです。 <code class="xref py py-class docutils literal"><span class="pre">Pool</span></code> では固定数のワーカープロセスを作ってワーカープロセスにリクエストを配ることが出来ます。 <code class="xref py py-meth docutils literal"><span class="pre">apply()</span></code> または <code class="xref py py-meth docutils literal"><span class="pre">apply_async()</span></code> メソッドで単体のリクエストを追加出来、 <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-meth docutils literal"><span class="pre">map()</span></code></a> または <code class="xref py py-meth docutils literal"><span class="pre">map_async()</span></code> メソッドでたくさんのリクエストを追加出来ます。以下のコードでは <code class="xref py py-class docutils literal"><span class="pre">Pool</span></code> を使って 5 つのワーカープロセスにリクエストをばら撒き、結果のリストを回収します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
    <span class="s2">&quot;Compute a factorial.&quot;</span>
    <span class="o">...</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">v</span>
</pre></div>
</div>
<p>これは以下のような出力をします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">39916800</span>
<span class="mi">51090942171709440000</span>
<span class="mi">8222838654177922817725562880000000</span>
<span class="mi">33452526613163807108170062053440751665152000000000</span>
<span class="o">...</span>
</pre></div>
</div>
<p>もう一方の方のハイレベルインターフェイス <code class="xref py py-class docutils literal"><span class="pre">Manager</span></code> クラスは、Python データ構造のマスターコピーを保持出来る、独立したひとつのサーバプロセスを作ります。ほかのプロセスたちは、これらデータ構造の読み書きと修正をプロキシオブジェクトを使って行えます。続く例では、 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-meth docutils literal"><span class="pre">dict()</span></code></a> メソッドを呼ぶことにより共有辞書を作ります; ワーカープロセスはその辞書へ挿入します。(ロックは自動的には行われませんがこの例では問題ではありません。 <code class="xref py py-class docutils literal"><span class="pre">Manager</span></code> のメソッドには <code class="xref py py-meth docutils literal"><span class="pre">Lock()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">RLock()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">Semaphore()</span></code> メソッドも含まれていて、共有ロックを作るのに使えます。)</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Manager</span>

<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
    <span class="s2">&quot;Compute a factorial.&quot;</span>
    <span class="c1"># Calculate the result</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="mi">1</span><span class="n">L</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">i</span>

    <span class="c1"># Store result in dictionary</span>
    <span class="n">dictionary</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">fact</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">mgr</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>         <span class="c1"># Create shared dictionary</span>

    <span class="c1"># Run tasks using the pool</span>
    <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>

    <span class="c1"># Mark pool as closed -- no more tasks can be added.</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Wait for tasks to exit</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="c1"># Output results</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="nb">print</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
</pre></div>
</div>
<p>これはこんな出力をするでしょう:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">1</span>
<span class="mi">11</span> <span class="mi">39916800</span>
<span class="mi">21</span> <span class="mi">51090942171709440000</span>
<span class="mi">31</span> <span class="mi">8222838654177922817725562880000000</span>
<span class="mi">41</span> <span class="mi">33452526613163807108170062053440751665152000000000</span>
<span class="mi">51</span> <span class="mf">15511187532873822802242430164693032110632597200169861120000.</span><span class="o">..</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> モジュールについてのドキュメント。</p>
<dl class="last docutils">
<dt><span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0371"><strong>PEP 371</strong></a> - multiprocessing パッケージの追加</dt>
<dd><p class="first last">PEP 著 Jesse Noller と Richard Oudkerk; 実装 Richard Oudkerk と Jesse Noller.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3101-advanced-string-formatting">
<span id="pep-3101"></span><h2><span class="target" id="index-35"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3101"><strong>PEP 3101</strong></a>: 進化版文字列フォーマッティング<a class="headerlink" href="#pep-3101-advanced-string-formatting" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 3.0 では <cite>%</cite> 演算子を補う、より強力な文字列フォーマッティングメソッドの <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-meth docutils literal"><span class="pre">format()</span></code></a> が作られました。これをサポートする <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> メソッドが Python 2.6 にバックポートされています。</p>
<p>2.6 では 8 ビット文字列と Unicode 文字列の両方が <cite>.format()</cite> メソッドを持ち、文字列をテンプレートとみなして、フォーマットに使われるべき引数を受け取ります。フォーマッティングのテンプレートには波括弧 (<cite>{</cite>, <cite>}</cite>) が特殊文字として使われます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Substitute positional argument 0 into the string.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;User ID: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
<span class="go">&#39;User ID: root&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use the named keyword arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;User ID: </span><span class="si">{uid}</span><span class="s2">   Last seen: </span><span class="si">{last_login}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">uid</span><span class="o">=</span><span class="s2">&quot;root&quot;</span><span class="p">,</span>
<span class="gp">... </span>   <span class="n">last_login</span> <span class="o">=</span> <span class="s2">&quot;5 Mar 2008 07:20&quot;</span><span class="p">)</span>
<span class="go">&#39;User ID: root   Last seen: 5 Mar 2008 07:20&#39;</span>
</pre></div>
</div>
<p>波括弧自身は二重に書くことでエスケープ出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;Empty dict: {{}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
<span class="go">&quot;Empty dict: {}&quot;</span>
</pre></div>
</div>
<p>フィールド名は、位置引数に対応する整数による <code class="docutils literal"><span class="pre">{0}</span></code>, <code class="docutils literal"><span class="pre">{1}</span></code>, …、またはキーワード引数に対応する名前です。属性を読み出したり辞書のキーにアクセスするような合成フィールド名(compound field names)も与えることが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s1">&#39;Platform: </span><span class="si">{0.platform}</span><span class="se">\n</span><span class="s1">Python version: </span><span class="si">{0.version}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
<span class="go">Platform: darwin</span>
<span class="go">Python version: 2.6a1+ (trunk:61261M, Mar  5 2008, 20:29:41)</span>
<span class="go">[GCC 4.0.1 (Apple Computer, Inc. build 5367)]&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mimetypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Content-type: </span><span class="si">{0[.mp4]}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mimetypes</span><span class="o">.</span><span class="n">types_map</span><span class="p">)</span>
<span class="go">&#39;Content-type: video/mp4&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">[.mp4]</span></code> のように辞書スタイルの記法を使う際は文字列の周りを引用符で囲む必要はありません; <code class="docutils literal"><span class="pre">.mp4</span></code> をキーに値のルックアップされます。数値で始まる文字列は整数に変換されます。フォーマット文字列内でこれ以上複雑な表現は書けません。</p>
<p>ここまでは、結果文字列に置き換えられるフィールドを指定する方法について見てきました。フォーマッティングではさらに、コロンに続けて書式指定子を追加することでコントロール可能です。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Field 0: left justify, pad to 15 characters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Field 1: right justify, pad to 6 characters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:15}</span><span class="s1"> $</span><span class="si">{1:&gt;6}</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Registration&#39;</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="go">&#39;Registration    $    35&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Tutorial&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">&#39;Tutorial        $    50&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Banquet&#39;</span><span class="p">,</span> <span class="mi">125</span><span class="p">)</span>
<span class="go">&#39;Banquet         $   125&#39;</span>
</pre></div>
</div>
<p>書式指定子として、ネストによる他フィールド参照が使えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;{0:</span><span class="si">{1}</span><span class="s1">}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Invoice #1234&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
<span class="go">&#39;Invoice #1234  &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span> <span class="o">=</span> <span class="mi">35</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Invoice #1234&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
<span class="go">&#39;Invoice #1234                      &#39;</span>
</pre></div>
</div>
<p>望みの幅内でのフィールドの整列を指定可能です:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">文字</p>
</th>
<th class="head"><p class="first last">効果</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><p class="first last">&lt; (デフォルト)</p>
</td>
<td><p class="first last">左寄せ</p>
</td>
</tr>
<tr class="row-odd"><td>&gt;</td>
<td><p class="first last">右寄せ</p>
</td>
</tr>
<tr class="row-even"><td>^</td>
<td><p class="first last">中央寄せ</p>
</td>
</tr>
<tr class="row-odd"><td>=</td>
<td><p class="first last">(数値型についてのみ) 符号のあとにパディング</p>
</td>
</tr>
</tbody>
</table>
<p>書式指定子には体裁のタイプも含めることが出来ます。値をどのようにフォーマットするかです。たとえば浮動小数点数は普通の数値に、あるいは指数形式でフォーマット出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{0:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">3.75</span><span class="p">)</span>
<span class="go">&#39;3.75&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{0:e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">3.75</span><span class="p">)</span>
<span class="go">&#39;3.750000e+00&#39;</span>
</pre></div>
</div>
<p>たくさんの体裁のタイプを利用出来ます。2.6 ドキュメントの <a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">complete list</span></a> を調べてみてください。以下はその一部です:</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">b</span></code></td>
<td><p class="first last">2進数。出力される数値は2を基数とします。</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">c</span></code></td>
<td><p class="first last">文字。数値を対応するユニコード文字に変換します。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">d</span></code></td>
<td><p class="first last">10進数。出力される数値は10を基数とします。</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">o</span></code></td>
<td><p class="first last">8進数。出力される数値は8を基数とします。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span></code></td>
<td><p class="first last">16進数。出力される数値は16を基数とします。 10進で9を超える数字には小文字が使われます。</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">e</span></code></td>
<td><p class="first last">指数表現です。指数を示す &#8216;e&#8217;  を使った科学的記数法で表示します。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">g</span></code></td>
<td><p class="first last">汎用フォーマット。数値が大き過ぎない限りは固定小数点表現をしますが、大きい値では &#8216;e&#8217; 指数表現に切り替えます。</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">n</span></code></td>
<td><p class="first last">数値です。現在のロケールに合わせて、数値分割文字が挿入されることを除き、 <code class="docutils literal"><span class="pre">'g'</span></code> (浮動小数点数の場合) または &#8216;d&#8217; (整数の場合) と同じです。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">%</span></code></td>
<td><p class="first last">パーセンテージです。数値は 100 倍され、固定小数点数フォーマット (<code class="docutils literal"><span class="pre">'f'</span></code>) でパーセント記号付きで表示されます。</p>
</td>
</tr>
</tbody>
</table>
<p>クラスと型は、自身がどのように書式化されるかをコントロールするために <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal"><span class="pre">__format__()</span></code></a> メソッドを定義出来ます。単一の引数として書式指定子を受け取ります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format_spec</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">unicode</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>ビルトインの <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a> もあって、単一の値をフォーマット出来ます。これは型の <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal"><span class="pre">__format__()</span></code></a> メソッドを与えられた指定子とともに呼び出します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mf">75.6564</span><span class="p">,</span> <span class="s1">&#39;.2f&#39;</span><span class="p">)</span>
<span class="go">&#39;75.66&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">書式指定文字列の文法</span></a></dt>
<dd><p class="first last">リファレンスドキュメント。</p>
</dd>
<dt><span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3101"><strong>PEP 3101</strong></a>: 進化版文字列フォーマッティング</dt>
<dd><p class="first last">PEP 著 Talin; 実装 Eric Smith。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3105-print-as-a-function">
<span id="pep-3105"></span><h2>PEP 3105: <code class="docutils literal"><span class="pre">print</span></code> を関数にする<a class="headerlink" href="#pep-3105-print-as-a-function" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal"><span class="pre">print</span></code> 文は Python 3.0 では <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数になります。 <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> が関数になることで、 <code class="docutils literal"><span class="pre">def</span> <span class="pre">print(...)</span></code> やなにかほかの場所からの新しい関数をインポートするなどの方法で置き換え可能になります。</p>
<p>Python 2.6 では <code class="docutils literal"><span class="pre">__future__</span></code> インポートで 言語構文としての <code class="docutils literal"><span class="pre">print</span></code> を取り除き、関数形式のものを代わりに使えるように出来ます。たとえば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;# of entries&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictionary</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</pre></div>
</div>
<p>この新しい関数のシグネチャは以下の通りです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>パラメータは以下のとおりです:</p>
<blockquote>
<div><ul class="simple">
<li><p class="first"><em>args</em>: 出力される値を指定する位置引数リスト。</p>
</li>
<li><p class="first"><em>sep</em>: 引数リスト <em>args</em> を出力するのに使われる区切り文字。</p>
</li>
<li><p class="first"><em>end</em>: 引数リスト <em>args</em>  を全て出力したあとに出力するテキスト。</p>
</li>
<li><p class="first"><em>file</em>: 出力が送られるファイルオブジェクト。</p>
</li>
</ul>
</div></blockquote>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-62"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3105"><strong>PEP 3105</strong></a> - print を関数にする</dt>
<dd><p class="first last">Georg Brandl 著の PEP。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3110-exception-handling-changes">
<span id="pep-3110"></span><h2>PEP 3110: 例外処理の変更<a class="headerlink" href="#pep-3110-exception-handling-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python プログラマが時折やらかしてしまう誤りの一つにこんなのがあります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># Wrong!</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>このコードの作者はきっと <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外と <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外の両方とっつかまえてやろうと思ったのでしょうが、このコードは実際にはちょっと違ったことをします: <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を捕捉したらこれを <code class="docutils literal"><span class="pre">&quot;ValueError&quot;</span></code> というローカル名の例外オブジェクトに束縛します…。 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外は決して捕捉されません。正しくは、例外のタプルで指定します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>こんなことが起こってしまうのは、ここではカンマの使用が曖昧だからです: それ、解析木内で 2 つのノードを示すのかな、タプルな単一ノードかしら?</p>
<p>Python 3.0 はカンマからワード &#8220;as&#8221; に置き換えてこの曖昧さをなくします。例外を捕捉して例外オブジェクトを <code class="docutils literal"><span class="pre">exc</span></code> に記憶するには、こう書かなければなりません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Python 3.0 は &#8220;as&#8221; の使用のみをサポートするようになるので、最初の例は 2 つの異なる例外を捕捉するものとして翻訳されます。Python 2.6 ではカンマも &#8220;as&#8221; もサポートするので、既存のコードはそのまま動作します。新たに 2.6 で実行される Python コードを書くならば、 &#8220;as&#8221; の使用を勧めます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3110"><strong>PEP 3110</strong></a> - Python 3000 での例外の捕捉</dt>
<dd><p class="first last">PEP 著と実装 Collin Winter.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3112-byte-literals">
<span id="pep-3112"></span><h2>PEP 3112: バイトリテラル<a class="headerlink" href="#pep-3112-byte-literals" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 3.0 は Unicode を言語の基本文字列型として採用し、8 ビットリテラルは異なった記法で指示します。それには <code class="docutils literal"><span class="pre">b'string'</span></code> とするか、 <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> のコンストラクタを用います。前方互換のために、Python 2.6 は <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 型に対する別名として <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> を追加のうえで、 <code class="docutils literal"><span class="pre">b''</span></code> 記法もサポートします。</p>
<p>2.6 の <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 型は 3.0 の <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 型とは色んな意味で違います; 一番顕著なのは、コンストラクタがまったく異なることです。3.0 での <code class="docutils literal"><span class="pre">bytes([65,</span> <span class="pre">66,</span> <span class="pre">67])</span></code> は 3 つのバイトで <code class="docutils literal"><span class="pre">ABC</span></code> を構築しますが、2.6 での <code class="docutils literal"><span class="pre">bytes([65,</span> <span class="pre">66,</span> <span class="pre">67])</span></code> は引数のリストを <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> で文字列化した 12 バイト文字列を返します。</p>
<p>2.6 での <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> の主な使いみちはオブジェクトの型のテストに <code class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">bytes)</span></code> とすることでしょう。またこれは、 2.x コードが文字列として ASCII 文字と 8 ビットバイトのどちらを意図しているのか知ることが出来ない 2to3 コンバータの助けになります; あなたは今や <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> と <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> の区別を、あなたの意図を正確に表現するのに使えます。そして結果のコードは Python 3.0 で正しいものに修正されるでしょう。</p>
<p>全ての文字列リテラルを Unicode 文字列としてしまう <code class="docutils literal"><span class="pre">__future__</span></code> インポートもあります。これは Unicode 文字を含むのに <code class="docutils literal"><span class="pre">\u</span></code> エスケープシーケンスを使えることを意味します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>

<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\u751f\u3080\u304e\u3000\u751f\u3054</span><span class="s1">&#39;</span>
     <span class="s1">&#39;</span><span class="se">\u3081\u3000\u751f\u305f\u307e\u3054</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="nb">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>               <span class="c1"># 12 Unicode characters</span>
</pre></div>
</div>
<p>C API のレベルでは、Python 3.0 は既存の 8 ビット文字列型の名前を変えます。Python 2.x での <code class="xref c c-type docutils literal"><span class="pre">PyStringObject</span></code> は <a class="reference internal" href="../c-api/bytes.html#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-type docutils literal"><span class="pre">PyBytesObject</span></code></a> になります。Python 2.6 では <a class="reference internal" href="../c-api/bytes.html#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-func docutils literal"><span class="pre">PyBytesObject()</span></code></a>, <a class="reference internal" href="../c-api/bytes.html#c.PyBytes_Check" title="PyBytes_Check"><code class="xref c c-func docutils literal"><span class="pre">PyBytes_Check()</span></code></a>, <a class="reference internal" href="../c-api/bytes.html#c.PyBytes_FromStringAndSize" title="PyBytes_FromStringAndSize"><code class="xref c c-func docutils literal"><span class="pre">PyBytes_FromStringAndSize()</span></code></a> をはじめとする全ての文字列関数とマクロを <code class="docutils literal"><span class="pre">#define</span></code> を使ってサポートしています(訳注: pure Python レベルと同じく単なる PyString_* の別名として)。</p>
<p><a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 型のインスタンスは単に文字列と同じで <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> です。 <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 型が、バイト列を <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> シーケンスとして格納するものとして新しく追加されました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">([</span><span class="mi">65</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">67</span><span class="p">])</span>
<span class="go">bytearray(b&#39;ABC&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u21ef\u3244</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;\xe2\x87\xaf\xe3\x89\x84&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\xe3</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;\xe3\x87\xaf\xe3\x89\x84&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unicode</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">u&#39;\u31ef \u3244&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> は <code class="xref py py-meth docutils literal"><span class="pre">startswith()</span></code>/<code class="xref py py-meth docutils literal"><span class="pre">endswith()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">find()</span></code>/<code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code> のような文字列型のほとんどのメソッド、 <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code> のようなリストのいくつかのメソッドをサポートします。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="s1">&#39;ABC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;ABCde&#39;)</span>
</pre></div>
</div>
<p>対応する C API もあります。 <a class="reference internal" href="../c-api/bytearray.html#c.PyByteArray_FromObject" title="PyByteArray_FromObject"><code class="xref c c-func docutils literal"><span class="pre">PyByteArray_FromObject()</span></code></a>, <a class="reference internal" href="../c-api/bytearray.html#c.PyByteArray_FromStringAndSize" title="PyByteArray_FromStringAndSize"><code class="xref c c-func docutils literal"><span class="pre">PyByteArray_FromStringAndSize()</span></code></a> や色々その他関数です。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-64"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3112"><strong>PEP 3112</strong></a> - Python 3000 でのバイトリテラル</dt>
<dd><p class="first last">PEP 著 Jason Orendorff; 2.6 へのバックポート Christian Heimes.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3116-new-i-o-library">
<span id="pep-3116"></span><h2>PEP 3116: 新しい I/O ライブラリ<a class="headerlink" href="#pep-3116-new-i-o-library" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python ビルトインのファイルオブジェクトはたくさんのメソッドをサポートしていますが、ファイルライクなオブジェクトは必ずしもそのすべてをサポートする必要はありません。ファイルのまねごとをするオブジェクトは大抵 <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> をサポートしますが、 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> はサポートしないかもしれません、例えば。Python 3.0 は <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> モジュールに、階層化された I/O ライブラリを導入しています。それは基礎的な読み書き操作からバッファリング機能とテキスト処理を分離しています。</p>
<p><a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> モジュールによって提供される抽象基底クラスには 3 つのレベルがあります:</p>
<ul>
<li><p class="first"><code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code> は剥き身の I/O 操作を定義します: <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">readinto()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">tell()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">truncate()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> 。このクラスのほとんどのメソッドが多くの場合単一のシステムコールに対応するでしょう。 <code class="xref py py-meth docutils literal"><span class="pre">readable()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">writable()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">seekable()</span></code> メソッドも利用可能で、オブジェクトでどの操作が許されるのかを知るのに使えます。</p>
<p>Python 3.0 はこのクラスのファイルとソケットに対する具象実装を持っていますが、Python 2.6 はファイル、ソケットオブジェクトのこの方法での再構築はしていません。</p>
</li>
<li><p class="first"><code class="xref py py-class docutils literal"><span class="pre">BufferedIOBase</span></code> はデータをメモリにバッファすることでシステムコール使用回数を減らし、I/O 処理をより効率的に行うための抽象基底クラスです。 <code class="xref py py-class docutils literal"><span class="pre">RawIOBase</span></code> の全てのメソッドをサポートし、追加で基底の剥き身のオブジェクトを保持する <code class="xref py py-attr docutils literal"><span class="pre">raw</span></code> 属性を持ちます。</p>
<p>5 つの具象クラスがこの ABC を実装しています。 <code class="xref py py-class docutils literal"><span class="pre">BufferedWriter</span></code> と <code class="xref py py-class docutils literal"><span class="pre">BufferedReader</span></code> はランダムアクセスのための <code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code> を持ち、書き込みオンリーまたは読み込みオンリーの用途をサポートするオブジェクトのためのものです。 <code class="xref py py-class docutils literal"><span class="pre">BufferedRandom</span></code> オブジェクトはこれらと同じ前提のストリームでの読み書きアクセスをサポートし、 <code class="xref py py-class docutils literal"><span class="pre">BufferedRWPair</span></code> は、TTY のような、連続していないデータのストリームの上で読み書き操作両方を演じるオブジェクトのためのものです。 <code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code> クラスはインメモリのバッファ上での読み、書き、シークをサポートします。</p>
</li>
<li id="index-13"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code>: 文字列 (忘れないで、Python 3.0 では文字列は Unicode になります) の読み書き関数を提供し、 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> をサポートします。 <code class="xref py py-class docutils literal"><span class="pre">TextIOBase</span></code> は <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> メソッドをサポートし、また、オブジェクトを渡るイテレーションをサポートします。</p>
<p>2 つの具象実装があります。 <code class="xref py py-class docutils literal"><span class="pre">TextIOWrapper</span></code> はバッファ化 I/O オブジェクトをラップし、テキスト I/O の全てのメソッドをサポートし、追加で元となるオブジェクトへのアクセスのための <code class="xref py py-attr docutils literal"><span class="pre">buffer</span></code> 属性を持ちます。 <code class="xref py py-class docutils literal"><span class="pre">StringIO</span></code> はディスクへの一切の書き込みをせずに単純にメモリ内に全てをバッファします。</p>
<p>(Python 2.6 では <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> は pure Python で書かれているので、かなり遅いです。ですから今のところは既存の <code class="xref py py-mod docutils literal"><span class="pre">StringIO</span></code> モジュール か <code class="xref py py-mod docutils literal"><span class="pre">cStringIO</span></code> モジュールに留まっておくべきです。Python 3.0 の <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> モジュールは、ある時点で速度のために C に書き直されます。そしておそらくその実装は 2.x リリースにバックポートされます ( <strong>訳注: 2.7 で実現</strong> ) 。)</p>
</li>
</ul>
<p>Python 2.6 では根底にある実装が <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> モジュールのクラスの上に組み立てられるようには再構築されていません (訳注: Python HowTo の移植ガイドにも触れられている通り、2.7 も同じです)。このモジュールは 3.0 への前方互換のコードを書くのを容易にするために、また、開発者たちがバッファリング I/O とテキスト I/O を自身で書く労力を省くために提供されています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3116"><strong>PEP 3116</strong></a> - 新しい I/O</dt>
<dd><p class="first last">PEP 著: Daniel Stutzbach, Mike Verdone, Guido van Rossum. 実装: Guido van Rossum, Georg Brandl, Walter Doerwald, Jeremy Hylton, Martin von Loewis, Tony Löwis, ほか.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3118-revised-buffer-protocol">
<span id="pep-3118"></span><h2>PEP 3118: 改訂版バッファプロトコル<a class="headerlink" href="#pep-3118-revised-buffer-protocol" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>バッファプロトコルは Python 型にその内部表現へのポインタをやりとりさせる、C レベル API です。例えば、メモリマップドファイルは文字のバッファとして見ることが出来ます。そしてこれは <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> のようなほかのモジュールが、それを文字列として扱って検索するようなことを許します。</p>
<p>バッファプロトコルの主なユーザは NumPy のような数値演算パッケージで、それらは呼び出し元がより遅い API を経由することなく直接的に行列にデータを書き込むことが出来るように、行列の内部表現を曝しています。この PEP は NumPy 開発の経験を踏まえてバッファプロトコルを更新するもので、行列の形状を表明したり、メモリ領域をロックしたりするような多数の新機能を追加します。</p>
<p>最重要の新規 C API 関数は <code class="docutils literal"><span class="pre">PyObject_GetBuffer(PyObject</span> <span class="pre">*obj,</span> <span class="pre">Py_buffer</span> <span class="pre">*view,</span> <span class="pre">int</span> <span class="pre">flags)</span></code> で、これはオブジェクトを受け取って、フラグをセットし、 <code class="docutils literal"><span class="pre">Py_buffer</span></code> 構造体にオブジェクトのメモリ表現についての情報を埋めます。オブジェクトはこの操作を、外部の呼び出し元がその内容を修正している間所定のメモリをロックするのに使えます。ですので対応する操作 <code class="docutils literal"><span class="pre">PyBuffer_Release(Py_buffer</span> <span class="pre">*view)</span></code> があり、これで外部呼出し元が処理を終えたことを表明します。</p>
<p><a class="reference internal" href="../c-api/buffer.html#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></code></a> への <em>flags</em> 引数は返されるメモリについての制約条件を指定します。いくつかの例として:</p>
<blockquote>
<div><ul class="simple">
<li><p class="first"><code class="xref py py-const docutils literal"><span class="pre">PyBUF_WRITABLE</span></code> はメモリが書き込み可能でなければならないことを指示します。</p>
</li>
<li><p class="first"><code class="xref py py-const docutils literal"><span class="pre">PyBUF_LOCK</span></code> は読み取り専用もしくはメモリの排他ロックを要求します。</p>
</li>
<li><p class="first"><code class="xref py py-const docutils literal"><span class="pre">PyBUF_C_CONTIGUOUS</span></code> と <code class="xref py py-const docutils literal"><span class="pre">PyBUF_F_CONTIGUOUS</span></code> は C-contiguous (最後の次元が最初に動きます) または Fortran-contiguous (最初の次元が最初に動きます) の行列レイアウトを要求します。 (訳注: 日本でも馴染みのある用語ではいわゆる column-major order (列優先)、 row-major order (行優先) です。)</p>
</li>
</ul>
</div></blockquote>
<p><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> のための 2 つの新しい書式化コード <code class="docutils literal"><span class="pre">s*</span></code> と <code class="docutils literal"><span class="pre">z*</span></code> は、パラメータとしてロックされたバッファオブジェクトを返します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> - 改訂版バッファプロトコル</dt>
<dd><p class="first last">PEP 著: Travis Oliphant, Carl Banks; 実装: Travis Oliphant.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3119-abstract-base-classes">
<span id="pep-3119"></span><h2>PEP 3119: 抽象基底クラス<a class="headerlink" href="#pep-3119-abstract-base-classes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ある種のオブジェクト指向言語、たとえば Java などは、クラスが持つメソッドの集合やサポートするアクセスプロトコルを宣言するための「インターフェイス」をサポートしています。抽象基底クラス (ABCs=Abstract Base Classes)は Python でのこれと等価な機能です。ABC サポートは、 <code class="xref py py-class docutils literal"><span class="pre">ABCMeta</span></code> と呼ばれるメタクラスを含む <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal"><span class="pre">abc</span></code></a> モジュール、ビルトイン <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal"><span class="pre">issubclass()</span></code></a> のそのメタクラスについての特殊処理、それに Python 開発者が広範囲にわたって使えると考えた基礎的な ABCs のコレクションから成ります。たぶん将来のバージョンの Python ではもっとたくさんの ABCs が追加されると思います。</p>
<p>あなたがなにか特別なクラスを持っていて、辞書スタイルのアクセスをサポートするのか知りたいとしましょう。「辞書スタイル」ってなんでしょうね、それにしても。たぶんアイテムにアクセスするのに <code class="docutils literal"><span class="pre">obj[1]</span></code> が使えるでしょう。それは <code class="docutils literal"><span class="pre">obj[2]</span> <span class="pre">=</span> <span class="pre">value</span></code> のように値をセットするのも含まれるでしょうね? あるいは <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">items()</span></code> メソッドを持ちますかね? <code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code> みたいな列挙系はいかがでしょう? <a class="reference internal" href="../library/copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a> と <code class="xref py py-meth docutils literal"><span class="pre">update()</span></code> は? オブジェクトを巡回するのに <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal"><span class="pre">iter()</span></code></a> で出来ます?</p>
<p>Python 2.6 の <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールには、この手の区別を表現出来るたくさんの ABCs が含まれています。 <code class="xref py py-class docutils literal"><span class="pre">Iterable</span></code> は <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> を定義したクラスを示し、 <code class="xref py py-class docutils literal"><span class="pre">Container</span></code> は <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> メソッドを定義していて、なので <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 式をサポートしていることを意味します。アイテム取得、アイテムセット、 <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">items()</span></code> という品揃えの基礎的な辞書インターフェイスは <code class="xref py py-class docutils literal"><span class="pre">MutableMapping</span></code> ABC で定義されています。</p>
<p>あなた自身のクラスを特定の ABC から派生して、ABC のインターフェイスをサポートすることを示せます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>

<span class="k">class</span> <span class="nc">Storage</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>別の方法としては、望みの ABC から派生するのではなく、その ABC の <code class="xref py py-meth docutils literal"><span class="pre">register()</span></code>  メソッドを呼び出して登録することでも出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>

<span class="k">class</span> <span class="nc">Storage</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Storage</span><span class="p">)</span>
</pre></div>
</div>
<p>あなたが書くクラスでは ABC から派生するのが、たぶん綺麗で良いと思います。既存の型やクラスを記述出来る新しい ABC が書けた場合や、なにかサードパーティのクラスが実装する ABC を宣言したい場合などには <code class="xref py py-meth docutils literal"><span class="pre">register()</span></code> メソッドが有用です。例えば、 <code class="xref py py-class docutils literal"><span class="pre">PrintableType</span></code> ABC を定義したのなら、今がそのとき、です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Register Python&#39;s types</span>
<span class="n">PrintableType</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">PrintableType</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="n">PrintableType</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<p>クラスは ABC が規定するセマンティクスに従うべきですが、Python はそれをチェックは出来ません；その ABC の要求を理解してコードを適切に実装するのはクラスの作者任せです。</p>
<p>オブジェクトが特定のインターフェイスをサポートするかどうかをチェックするのには、今やこう書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mapping object expected, not </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>これからはたくさんのこのようなチェックをしなければならないのだ、この例のように、などとは思わないように。Python は至極ダックタイピングな流儀なのであって明示的な型チェックは決してされませんし、コードは単純にオブジェクトのメソッドを、それらメソッドがそこにあるはずで、なければ例外になるのを信じて呼ぶだけです。ABC についてのチェックには分別を持ち、それが絶対的に必要な場合にだけそうするようにしましょう。</p>
<p>あなた自身の ABCs を書くには、クラス定義内のメタクラスとして <code class="docutils literal"><span class="pre">abc.ABCMeta</span></code> を使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="k">class</span> <span class="nc">Drawable</span><span class="p">():</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">draw_doubled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Drawable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>上の <code class="xref py py-class docutils literal"><span class="pre">Drawable</span></code> ABC では、 <code class="xref py py-meth docutils literal"><span class="pre">draw_doubled()</span></code> メソッドがオブジェクトをその 2 倍のサイズで描画しますが、 <code class="xref py py-class docutils literal"><span class="pre">Drawable</span></code> で示されたほかのメソッドのやり方で実現されるのでしょう。この ABC を実装するクラスは <code class="xref py py-meth docutils literal"><span class="pre">draw_doubled()</span></code> のそれ自身の実装を提供する必要はないわけですが、実装しても良いです。一方 <code class="xref py py-meth docutils literal"><span class="pre">draw()</span></code> の実装は必要です。その ABC が役に立つ汎用的な実装が提供出来ていないので。</p>
<p><code class="xref py py-meth docutils literal"><span class="pre">draw()</span></code> のような、実装が必須のメソッドに対して <code class="docutils literal"><span class="pre">&#64;abstractmethod</span></code> デコレータを適用することが出来ます; Python はそのメソッドを実装しないクラスに例外を喰らわせます。サブクラスにそのメソッドが欠けていたとしても、インスタンスを実際に作ろうと試みてはじめて例外となることに注意しましょう:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">Drawable</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Can&#39;t instantiate abstract class Circle with abstract methods draw</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>抽象データ属性を <code class="docutils literal"><span class="pre">&#64;abstractproperty</span></code> を使って宣言出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">abstractproperty</span>
<span class="o">...</span>

<span class="nd">@abstractproperty</span>
<span class="k">def</span> <span class="nf">readonly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>この場合サブクラスは <code class="xref py py-meth docutils literal"><span class="pre">readonly()</span></code> プロパティを定義することが必須です。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - 抽象基底クラスの導入</dt>
<dd><p class="first last">PEP は Guido van Rossum と Talin によって著され、Guido van Rossum により実装されています。Python 2.6 へのバックポートは Benjamin Aranguren と Alex Martelli により行われました。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3127-integer-literal-support-and-syntax">
<span id="pep-3127"></span><h2>PEP 3127: 整数リテラルのサポートと文法<a class="headerlink" href="#pep-3127-integer-literal-support-and-syntax" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 3.0 は octal (基数 8: 8 進数) 整数リテラルの構文を変更し、先行するゼロの代わりに &#8220;0o&#8221; または &#8220;0O&#8221; (「ゼロオー」)としています。また、 binary (基数 2: 2 進数) 整数リテラルのサポートを追加し、これは &#8220;0b&#8221; または &#8220;0B&#8221; で指示します。</p>
<p>Python 2.6 は先行するゼロの形式での 8 進数サポートをやめませんが、 &#8220;0o&#8221; と &#8220;0b&#8221; は追加サポートします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mo">0o21</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">(17, 17)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mb">0b101111</span>
<span class="go">47</span>
</pre></div>
</div>
<p>ビルトイン関数 <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a> はまだ先行ゼロ形式での表現を返します。新しいビルトイン関数 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal"><span class="pre">bin()</span></code></a> は数値の 2 進数表現を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;052&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">future_builtins</span><span class="o">.</span><span class="n">oct</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;0o52&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">173</span><span class="p">)</span>
<span class="go">&#39;0b10101101&#39;</span>
</pre></div>
</div>
<p>ビルトイン <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>, <code class="xref py py-func docutils literal"><span class="pre">long()</span></code> が、基数 8 か 0 を要求された場合の &#8220;0o&#8221; プレフィクス、基数 2 か 0 を要求された場合の &#8220;0b&#8221; プレフィクスをそれぞれ許容するようになりました(基数 <em>base</em> = 0 は文字列から基数を決めるべきであることを指示します):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span> <span class="p">(</span><span class="s1">&#39;0o52&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;1101&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;0b1101&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;0b1101&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">13</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3127"><strong>PEP 3127</strong></a> - 整数リテラルのサポートと文法</dt>
<dd><p class="first last">PEP 著 Patrick Maupin、2.6 へのバックポートは Eric Smith による。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3129-class-decorators">
<span id="pep-3129"></span><h2>PEP 3129: クラスデコレータ<a class="headerlink" href="#pep-3129-class-decorators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>デコレータが拡張されて関数だけでなクラスにも使えるようになりました。今やこのように書くのは合法です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nd">@foo</span>
<span class="nd">@bar</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
  <span class="k">pass</span>
</pre></div>
</div>
<p>これは次と等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
  <span class="k">pass</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3129"><strong>PEP 3129</strong></a> - クラスデコレータ</dt>
<dd><p class="first last">PEP 著 Collin Winter.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-3141-a-type-hierarchy-for-numbers">
<span id="pep-3141"></span><h2>PEP 3141: 数値の型階層<a class="headerlink" href="#pep-3141-a-type-hierarchy-for-numbers" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 3.0 では Scheme の numeric tower に触発された、いくつかの数値型のための抽象基底クラスを追加しています。これらのクラスは <a class="reference internal" href="../library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal"><span class="pre">numbers</span></code></a> モジュール として 2.6 にバックポートされています。</p>
<p>一番てっぺんの汎用 ABC が <code class="xref py py-class docutils literal"><span class="pre">Number</span></code> です。これには何の演算も含まれず、オブジェクトがなんらか数値であることをチェックするためだけにあります。 <code class="docutils literal"><span class="pre">isinstance(obj,</span> <span class="pre">Number)</span></code> として使えます。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Complex</span></code> は <code class="xref py py-class docutils literal"><span class="pre">Number</span></code> のサブクラスです。複素数は基礎的な追加の演算の加算、減算、積算、除算、累乗に耐えるとともに、実数部と虚数部の抽出と共役数の取得が出来ます。Python のビルトインの complex 型は <code class="xref py py-class docutils literal"><span class="pre">Complex</span></code> を実装しています。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Real</span></code> は <code class="xref py py-class docutils literal"><span class="pre">Complex</span></code> から更に派生し、実数のみで動作する演算を追加しています: <code class="xref py py-func docutils literal"><span class="pre">floor()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">trunc()</span></code>, 丸め, divmod, floor division, 比較、です。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Rational</span></code> 数は <code class="xref py py-class docutils literal"><span class="pre">Real</span></code> からの派生で、プロパティ <code class="xref py py-attr docutils literal"><span class="pre">numerator</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">denominator</span></code> を持ち、浮動小数点数への変換が出来ます。Python 2.6 は単純な有理数クラス <code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code> を <a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> モジュールに追加しています。(<code class="xref py py-class docutils literal"><span class="pre">Rational</span></code> ではなく <code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code> なのは、 <a class="reference internal" href="../library/numbers.html#numbers.Rational" title="numbers.Rational"><code class="xref py py-class docutils literal"><span class="pre">numbers.Rational</span></code></a> と名前が衝突するのを避けるためです。)</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code> 数は <code class="xref py py-class docutils literal"><span class="pre">Rational</span></code> からの派生で、シフト演算 <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code> が出来て、 <code class="docutils literal"><span class="pre">&amp;</span></code> や <code class="docutils literal"><span class="pre">|</span></code> のようなビット演算で混ぜ合わせることができて、また、配列のインデクスとスライスの境界として使えます。</p>
<p>Python 3.0 では、その PEP は少し既存のビルトイン <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor()</span></code></a>, <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil()</span></code></a> を再定義していて、また、Python 2.6 にバックポートされている新しい <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc()</span></code></a> を追加しています。 <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc()</span></code></a> はゼロに向かう方向の丸めで、引数とゼロの間で一番近い <code class="xref py py-class docutils literal"><span class="pre">Integral</span></code> を返します。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="docutils">
<dt><span class="target" id="index-70"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3141"><strong>PEP 3141</strong></a> - 数値の型階層</dt>
<dd><p class="first last">PEP 著: Jeffrey Yasskin.</p>
</dd>
</dl>
<p>Guile マニュアルの <a class="reference external" href="https://www.gnu.org/software/guile/manual/html_node/Numerical-Tower.html#Numerical-Tower">Scheme&#8217;s numerical tower</a> 。</p>
<p class="last">R5RS Scheme 仕様の <a class="reference external" href="http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2">Scheme&#8217;s number datatypes</a> 。</p>
</div>
<div class="section" id="the-fractions-module">
<h3><a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> モジュール<a class="headerlink" href="#the-fractions-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>数値型階層を埋めるべく、 <a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> モジュールが有理数クラスを提供しています。有理数は分子(numerator)と分母(denominator)で構成される分数としてその値を格納し、浮動小数点数では近似しか出来ない <code class="docutils literal"><span class="pre">2/3</span></code> のような数を正確に表現出来ます。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code> のコンストラクタは 2 つの <code class="xref py py-class docutils literal"><span class="pre">Integral</span></code> 値を取り、それらはそれぞれ結果の分数の分子と分母になります。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(0.66666666666666663, 0.40000000000000002)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="go">Fraction(16, 15)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
<span class="go">Fraction(5, 3)</span>
</pre></div>
</div>
<p>浮動小数点数を有理数に変換するのに、浮動小数点数型に <code class="xref py py-meth docutils literal"><span class="pre">as_integer_ratio()</span></code> メソッドが追加されています。これはそれを評価して分数の分子と分母を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span> <span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(5, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.1415</span><span class="p">)</span> <span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(7074029114692207L, 2251799813685248L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(6004799503160661L, 18014398509481984L)</span>
</pre></div>
</div>
<p>1./3 のような浮動小数点数で近似にしかならない値は、近似して単純化されたりはしないことに注意してください; その分数は浮動小数点数に <strong>正確に</strong> 合うように試みられます。</p>
<p><a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> モジュールは、ずっと長い間 Python の <code class="file docutils literal"><span class="pre">Demo/classes/</span></code> ディレクトリにいた Sjoerd Mullender による実装に基いています。この実装が Jeffrey Yasskin によって大幅に更新されました。</p>
</div>
</div>
<div class="section" id="other-language-changes">
<h2>その他の言語変更<a class="headerlink" href="#other-language-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 言語コアに小さな変更がいくつか行われました:</p>
<ul>
<li><p class="first"><code class="file docutils literal"><span class="pre">__main__.py</span></code> を含んだディレクトリ名と zip アーカイブ名をインタプリタに渡して直接実行出来るようになりました。そのディレクトリと zip アーカイブは自動的に sys.path エントリの先頭に追加されます。(Suggestion and initial patch by Andy Chu, subsequently revised by Phillip J. Eby and Nick Coghlan; <a class="reference external" href="https://bugs.python.org/issue1739468">bpo-1739468</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal"><span class="pre">hasattr()</span></code></a> 関数は <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドが例外を起こすと何か失敗したのだと仮定して、全て捕捉して無視して <code class="docutils literal"><span class="pre">False</span></code> を返していました。ですがそのロジックは <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> と <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a> まで捕まえるべきではなかったのです。Python 2.6 では <a class="reference internal" href="../library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal"><span class="pre">hasattr()</span></code></a> はもはやそれら例外に出会ってもそれを捨てません。 (Fixed by Benjamin Peterson; <a class="reference external" href="https://bugs.python.org/issue2196">bpo-2196</a>.)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">**</span></code> 構文を使ってキーワード引数を許容する関数を呼び出すのに、もう Python 辞書を使う必要はありません; 任意のマッピングプロトコルをサポートするオブジェクトで今では動作します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ud</span><span class="o">=</span><span class="n">UserDict</span><span class="o">.</span><span class="n">UserDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ud</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ud</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="o">**</span><span class="n">ud</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>(Contributed by Alexander Belopolsky; <a class="reference external" href="https://bugs.python.org/issue1686487">bpo-1686487</a>.)</p>
<p>同時に、 <code class="docutils literal"><span class="pre">*args</span></code> 引数のあとでキーワード引数を与える関数呼び出しも今では合法です。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">args</span><span class="p">,</span> <span class="n">kw</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">keyword</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="go">(1, 2, 3, 4, 5, 6) {&#39;keyword&#39;: 13}</span>
</pre></div>
</div>
<p>以前はこれは構文エラーになっていました。 (Contributed by Amaury Forgeot d&#8217;Arc; <a class="reference external" href="https://bugs.python.org/issue3473">bpo-3473</a>.)</p>
</li>
<li><p class="first">新しいビルトイン <code class="docutils literal"><span class="pre">next(iterator,</span> <span class="pre">[default])</span></code> は指定したイテレータより次のアイテムを返します。 <em>iterator</em> が使い果たされている場合、 <em>default</em> 引数が与えられていれがこれを、そうでなければ <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外を起こします。 (Backported in <a class="reference external" href="https://bugs.python.org/issue2719">bpo-2719</a>.)</p>
</li>
<li><p class="first">タプルがリストと同じく <code class="xref py py-meth docutils literal"><span class="pre">index()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">count()</span></code> メソッドを持つようになっています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger)</p>
</li>
<li><p class="first">ビルトイン型が拡張スライス構文をサポートするために改善されています。色々な <code class="docutils literal"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 組み合わせを受け付けます。以前はこれのサポートは限定的で、ものによっては動作しませんでした。 (Implemented by Thomas Wouters.)</p>
</li>
<li><p class="first">property に <code class="xref py py-attr docutils literal"><span class="pre">getter</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">setter</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">deleter</span></code> が追加されています。取得関数(getter)、設定関数(setter)、削除関数(deleter)を既存のプロパティに追加するための便利なショートカットとして使えるデコレータです。これらはこのように使えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="nd">@C</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
</li>
<li><p class="first">ビルトインの set 型のいくつかのメソッドが複数イテラブルを受け付けるようになっています: <code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">intersection_update()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">union()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">update()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">difference()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">difference_update()</span></code> です。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="s1">&#39;1234567890&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="s1">&#39;abc123&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf246&#39;</span><span class="p">)</span>  <span class="c1"># Intersection between all inputs</span>
<span class="go">set([&#39;2&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="s1">&#39;246&#39;</span><span class="p">,</span> <span class="s1">&#39;789&#39;</span><span class="p">)</span>
<span class="go">set([&#39;1&#39;, &#39;0&#39;, &#39;3&#39;, &#39;5&#39;])</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">たくさんの浮動小数点数機能が追加されました。 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a> 関数は文字列 <code class="docutils literal"><span class="pre">nan</span></code> を IEEE 754 非数 (Not A Number) 値に変換し、 <code class="docutils literal"><span class="pre">+inf</span></code> と <code class="docutils literal"><span class="pre">-inf</span></code> は正あるいは負の無限大に変換します。これは IEEE 754 セマンティクスのあらゆるプラットフォームで動作します。 (Contributed by Christian Heimes; <a class="reference external" href="https://bugs.python.org/issue1635">bpo-1635</a>.)</p>
<p>ほか <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> モジュールに <code class="xref py py-func docutils literal"><span class="pre">isinf()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">isnan()</span></code> が追加されています; 浮動小数点数が、前者は無限大ならば、後者は非数ならばそれぞれ真を返します。 (<a class="reference external" href="https://bugs.python.org/issue1640">bpo-1640</a>)</p>
<p>浮動小数点数を 16 進表記文字列に変換する変換関数が追加されています (<a class="reference external" href="https://bugs.python.org/issue3008">bpo-3008</a>)。これら関数は 10 進と 2 進との間の変換で起こる丸め誤差を持ち込まずに浮動小数点数と文字列表現の相互変換をします。浮動小数点数は文字列表現を返す <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-meth docutils literal"><span class="pre">hex()</span></code></a> メソッドを持ち、また、 <code class="docutils literal"><span class="pre">float.fromhex()</span></code> メソッドが文字列から浮動小数点数に戻します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">3.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;0x1.e000000000000p+1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x1.e000000000000p+1&#39;</span><span class="p">)</span>
<span class="go">3.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;0x1.5555555555555p-2&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first">数に関する繊細さ: 符号付ゼロ (-0 と +0) をサポートするシステムで 2 つの浮動小数点数から複素数を作る際に、 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a> コンストラクタがゼロの符号を維持するようになりました。 (Fixed by Mark T. Dickinson; <a class="reference external" href="https://bugs.python.org/issue1507">bpo-1507</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドを親クラスから継承するクラスは、ハッシュ出来ないことを示すのに <code class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> をセット出来ます。これにより <code class="docutils literal"><span class="pre">hash(obj)</span></code> は <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を起こし、そのクラスは <code class="xref py py-class docutils literal"><span class="pre">Hashable</span></code> ABC を実装していないことを示します。</p>
<p><code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> か <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> を定義するのにその比較にオブジェクトの身元ではなくその値を使ったならば、あなたはこれをすべきです。全てのオブジェクトはその値として <code class="docutils literal"><span class="pre">id(obj)</span></code> を使うデフォルトのハッシュ化メソッドを持っています。親クラスから継承した <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> を削除する整理された方法はありません。ですのでオーバライドとしての <code class="docutils literal"><span class="pre">None</span></code> の代入が実装されました。 C API のレベルでは、拡張は <code class="docutils literal"><span class="pre">tp_hash</span></code> に <a class="reference internal" href="../c-api/object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal"><span class="pre">PyObject_HashNotImplemented()</span></code></a> をセット出来ます。 (Fixed by Nick Coghlan and Amaury Forgeot d&#8217;Arc; <a class="reference external" href="https://bugs.python.org/issue2235">bpo-2235</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> 例外が <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a> ではなく <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a> のサブクラスになっています。 <code class="docutils literal"><span class="pre">except</span> <span class="pre">Exception:</span></code> をする例外ハンドラが意図せず <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> 捕捉してしまうことがなくなります。 (Contributed by Chad Austin; <a class="reference external" href="https://bugs.python.org/issue1537">bpo-1537</a>.)</p>
</li>
<li><p class="first">ジェネレータオブジェクトが、そのジェネレータを返すオリジナルのコードオブジェクトを参照する <code class="xref py py-attr docutils literal"><span class="pre">gi_code</span></code> 属性を持つようになりました。 (Contributed by Collin Winter; <a class="reference external" href="https://bugs.python.org/issue1473257">bpo-1473257</a>.)</p>
</li>
<li><p class="first">ビルトイン関数 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> が位置引数だけでなくキーワード引数も受け付けるようになりました。  (Contributed by Thomas Wouters; <a class="reference external" href="https://bugs.python.org/issue1444529">bpo-1444529</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a> コンストラクタが括弧で囲まれた複素数表現文字列を受け付けるようになっています。 <code class="docutils literal"><span class="pre">complex(repr(cplx))</span></code> で元に戻せるということです。例えば <code class="docutils literal"><span class="pre">complex('(3+4j)')</span></code> は今では値 <code class="docutils literal"><span class="pre">(3+4j)</span></code> を返します。 (<a class="reference external" href="https://bugs.python.org/issue1491866">bpo-1491866</a>)</p>
</li>
<li><p class="first">文字列の <code class="xref py py-meth docutils literal"><span class="pre">translate()</span></code> メソッドが変形テーブルパラメータとして <code class="docutils literal"><span class="pre">None</span></code> を受け付けるようになりました。そのまま同じものを返す変形として扱われます。これにより文字を削除する操作を実行するのが簡単になります。 (Contributed by Bengt Richter and implemented by Raymond Hettinger; <a class="reference external" href="https://bugs.python.org/issue1193128">bpo-1193128</a>.)</p>
</li>
<li><p class="first">ビルトインの <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> 関数が、受け取ったオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal"><span class="pre">__dir__()</span></code></a> メソッドをチェックするようになりました。このメソッドはそのオブジェクトで妥当な属性名を含む文字列のリストを返さなければなりません。これにより <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> が生成する値を制御出来ます。 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> や <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal"><span class="pre">__getattribute__()</span></code></a> メソッドを使うオブジェクトはこれを使うことで、約束するつもりの擬似属性を公表出来ます。 (<a class="reference external" href="https://bugs.python.org/issue1591665">bpo-1591665</a>)</p>
</li>
<li><p class="first">インスタンスメソッドオブジェクトが、そのメソッドを包含するオブジェクトと関数のための新たな属性を持つようになっています; <code class="xref py py-attr docutils literal"><span class="pre">im_self</span></code> への新しい別名が <code class="xref py py-attr docutils literal"><span class="pre">__self__</span></code> です。また <code class="xref py py-attr docutils literal"><span class="pre">im_func</span></code> も <code class="xref py py-attr docutils literal"><span class="pre">__func__</span></code> として利用可能です。古い名前は Python 2.6 で引き続きサポートされますが、3.0 ではいなくなります。</p>
</li>
<li><p class="first">目立たない変更: <a class="reference internal" href="../library/functions.html#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> 関数を <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> ステートメント内で使う際、結果の辞書はもはや自由変数を返しません。(この場合、自由変数は <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> ステートメント内で参照される変数で、クラスの属性ではありません。)</p>
</li>
</ul>
<div class="section" id="optimizations">
<h3>最適化<a class="headerlink" href="#optimizations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul>
<li><p class="first"><a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> モジュールが C で書き直されました。これにより警告をパーサから発行出来、また、インタプリタの起動が高速化しています。 (Contributed by Neal Norwitz and Brett Cannon; <a class="reference external" href="https://bugs.python.org/issue1631171">bpo-1631171</a>.)</p>
</li>
<li><p class="first">型オブジェクトがメソッドのキャッシュを持つようになっています。これは個別のクラスについての正しいメソッド実装を見つけるのに必要な仕事を減らします。いったんキャッシュされれば、インタプリタは呼び出さなければならない正しいメソッドを知るために基底クラス群を横断しなくてもよくなります。基底クラスやクラス自身が修正されれば、Python の動的な振る舞いの面においても正しくあり続けなければならないので、キャッシュはクリアされます。 (Original optimization implemented by Armin Rigo, updated for Python 2.6 by Kevin Jacobs; <a class="reference external" href="https://bugs.python.org/issue1700288">bpo-1700288</a>.)</p>
<p>デフォルトではこの変更は、Python コアに含まれる型のみに適用されます。拡張モジュールは必ずしもこのキャッシュに互換ではなく、拡張モジュールはメソッドキャッシュを有効にするために、モジュールの <code class="docutils literal"><span class="pre">tp_flags</span></code> フィールドに明示的に <code class="xref c c-macro docutils literal"><span class="pre">Py_TPFLAGS_HAVE_VERSION_TAG</span></code> を追加しなければなりません。(このメソッドキャッシュに対して互換であるためには、拡張モジュールのコードは、それが実装するどんな型についても <code class="docutils literal"><span class="pre">tp_dict</span></code> メンバに直接アクセスしたり修正したりしてはなりません。ほとんどのモジュールはこれをしていませんが、Python インタプリタがそれを検知することは出来ません。 <a class="reference external" href="https://bugs.python.org/issue1878">bpo-1878</a> にいくらかの議論がありますので参照してください。)</p>
</li>
<li><p class="first">キーワード引数を使う関数呼び出しが、素早くポインタで比較することで顕著に高速化しています。これは常に文字列丸ごとを比較する時間を省きます。 (Contributed by Raymond Hettinger, after an initial implementation by Antoine Pitrou; <a class="reference external" href="https://bugs.python.org/issue1819">bpo-1819</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールの全ての関数が C で書き換えられました。「Need For Speed スプリント」での作業の成果です。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">いくつかの標準ビルトイン型が、その型オブジェクトにビットをセットするようになりました。これは、オブジェクトがそれら型のサブクラスの一つであるかどうかのチェックするのを高速化します。 (Contributed by Neal Norwitz.)</p>
</li>
<li><p class="first">Unicode 文字列が、空白文字と改行を検出するためのコードにより高速な実装を使うようになりました; <code class="xref py py-meth docutils literal"><span class="pre">split()</span></code> メソッドでおよそ 25% の速度向上、 <code class="xref py py-meth docutils literal"><span class="pre">splitlines()</span></code> メソッドでは 35% です。(Contributed by Antoine Pitrou.) Unicode 文字列データのために pymalloc を使うことでメモリ使用が減りました。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">with</span></code> ステートメントが <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドをスタック上に保存するようになり、ちょっとだけ高速化しました。 (Implemented by Jeffrey Yasskin.)</p>
</li>
<li><p class="first">メモリ使用を減らすために、一番作られたオブジェクトをガーベージコレクトする際に、ガーベージコレクタが内部のフリーリストをクリアするようになりました。これはオペレーティングシステムにすぐに返されます。</p>
</li>
</ul>
</div>
<div class="section" id="interpreter-changes">
<span id="new-26-interpreter"></span><h3>インタプリタの変更<a class="headerlink" href="#interpreter-changes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のほかの実装で使うために、2 つのコマンドラインオプションが予約されました。 <a class="reference internal" href="../using/cmdline.html#cmdoption-J"><code class="xref std std-option docutils literal"><span class="pre">-J</span></code></a> スイッチは Jython 固有のオプションのために予約されました。前提となる JVM に渡すスイッチなどに使います。 <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal"><span class="pre">-X</span></code></a> スイッチは個別の Python 実装、たとえば CPython、Jython や IronPython のために予約されました。Python 2.6 でどちらかのオプションが使われると、インタプリタはそのオプションは現在使われていないことを報告します。</p>
<p>Python インタプリタに <a class="reference internal" href="../using/cmdline.html#cmdoption-B"><code class="xref std std-option docutils literal"><span class="pre">-B</span></code></a> スイッチを渡すか、インタプリタ実行前に環境変数 <span class="target" id="index-71"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> をセットするかのどちらかで、 <code class="file docutils literal"><span class="pre">.pyc</span></code> や <code class="file docutils literal"><span class="pre">.pyo</span></code> が作られないようにすることが出来るようになりました。この設定は Python プログラムから <code class="docutils literal"><span class="pre">sys.dont_write_bytecode</span></code> 変数として利用可能で、Python コードはこの変数を変更してインタプリタの振る舞いを変えることが出来ます。 (Contributed by Neal Norwitz and Georg Brandl.)</p>
<p>標準入力、標準出力、標準エラー出力に使うエンコーディングを、インタプリタ起動前に環境変数 <span class="target" id="index-72"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONIOENCODING</span></code></a> を設定することで指定出来るようになりました。値は <code class="docutils literal"><span class="pre">&lt;encoding&gt;</span></code> または <code class="docutils literal"><span class="pre">&lt;encoding&gt;:&lt;errorhandler&gt;</span></code> 形式の文字列でなければなりません。 <em>encoding</em> 部分はエンコーディングの名前で、例えば <code class="docutils literal"><span class="pre">utf-8</span></code> や <code class="docutils literal"><span class="pre">latin-1</span></code> です; 省略可能な <em>errorhandler</em> 部分はエンコーディングによって処理出来ない文字に対して何をするのかを指定するもので、 &#8220;error&#8221;, &#8220;ignore&#8221;, &#8220;replace&#8221; のどれかです。 (Contributed by Martin von Löwis.)</p>
</div>
</div>
<div class="section" id="new-and-improved-modules">
<h2>新しいモジュールと改良されたモジュール<a class="headerlink" href="#new-and-improved-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>全てのリリースに置いて、 Python の標準ライブラリはたくさんの改良とバグ修正がされてきました。ここでは一部の注目に値する変更を、モジュール名で辞書順ソートしてリストアップしています。もっと完全な変更リストが見たければ、ソースツリー内の <code class="file docutils literal"><span class="pre">Misc/NEWS</span></code> ファイルか、全ての完全な詳細が入っている Subversion のログを参照してください。</p>
<ul>
<li><p class="first"><a class="reference internal" href="../library/asyncore.html#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code class="xref py py-mod docutils literal"><span class="pre">asyncore</span></code></a> と <a class="reference internal" href="../library/asynchat.html#module-asynchat" title="asynchat: Support for asynchronous command/response protocols."><code class="xref py py-mod docutils literal"><span class="pre">asynchat</span></code></a> モジュールが再び活発に保守され、多数のパッチとバグ修正が適用されました。 (Maintained by Josiah Carlson; see <a class="reference external" href="https://bugs.python.org/issue1736190">bpo-1736190</a> for one patch.)</p>
</li>
<li><p class="first">The <code class="xref py py-mod docutils literal"><span class="pre">bsddb</span></code> module also has a new maintainer, Jesús Cea Avión, and the package
is now available as a standalone package.  The web page for the package is
<a class="reference external" href="https://www.jcea.es/programacion/pybsddb.htm">www.jcea.es/programacion/pybsddb.htm</a>.
The plan is to remove the package from the standard library
in Python 3.0, because its pace of releases is much more frequent than
Python&#8217;s.</p>
<p><code class="xref py py-mod docutils literal"><span class="pre">bsddb.dbshelve</span></code> モジュールは pickle 化で、プロトコル 1 に制限するのではなく利用出来る一番高いプロトコルバージョンを使うようになりました。(Contributed by W. Barnes.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/cgi.html#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface."><code class="xref py py-mod docutils literal"><span class="pre">cgi</span></code></a> モジュールが HTTP POST リクエストのクエリ文字列を読み取るようになりました。これにより URL に &#8220;/cgi-bin/add.py?category=1&#8221; のようにクエリ文字列を含む form アクションに使えるようになります。 (Contributed by Alexandre Fiori and Nubis; <a class="reference external" href="https://bugs.python.org/issue1817">bpo-1817</a>.)</p>
<p><code class="xref py py-func docutils literal"><span class="pre">parse_qs()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">parse_qsl()</span></code> 関数を <a class="reference internal" href="../library/cgi.html#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface."><code class="xref py py-mod docutils literal"><span class="pre">cgi</span></code></a> モジュールから <code class="xref py py-mod docutils literal"><span class="pre">urlparse</span></code> モジュールに移動しました。もとのバージョンは <a class="reference internal" href="../library/cgi.html#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface."><code class="xref py py-mod docutils literal"><span class="pre">cgi</span></code></a> モジュールにまだいて、2.6 では呼び出すと <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal"><span class="pre">PendingDeprecationWarning</span></code></a> メッセージが報告されます。 (<a class="reference external" href="https://bugs.python.org/issue600362">bpo-600362</a>).</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> モジュールに大掛かりな改訂が行われました。Mark Dickinson と Christian Heimes による貢献です。5 つの新しい関数が追加されました:</p>
<ul class="simple">
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">polar()</span></code> は複素数を極形式 (polar form) に変換し、複素数の絶対値 (modulus) と偏角 (argument) を返します。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">rect()</span></code> はその逆で、絶対値と偏角から対応する複素数に戻します。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">phase()</span></code> は複素数の偏角 (angle とも呼ばれています) を返します。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">isnan()</span></code> はその引数の実数部か虚数部のどちらかが NaN であれば真を返します。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">isinf()</span></code> はその引数の実数部か虚数部のどちらかが無限大であれば真を返します。</p>
</li>
</ul>
<p>その改訂では、 <a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> モジュールの数値的安定性も改善されました。全ての関数で、結果の実数部、虚数部は最小精度単位で少しの範囲内で、可能な限り正確です。詳細は <a class="reference external" href="https://bugs.python.org/issue1381">bpo-1381</a> を見てください。 <code class="xref py py-func docutils literal"><span class="pre">asinh()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">atanh()</span></code>:, <code class="xref py py-func docutils literal"><span class="pre">atan()</span></code> に対する分岐截線 (branch cut) も修正されています。(&#8212; 訳注: units of least precision に対する枯れた訳語はないようなので最小精度単位としていますが仮数部の最下位ビットのことです。ので、within a few ulps は下位数ビットという意味。分岐截線 (branch cut) は一般的な訳語かどうかはわかりませんが、wikipedia から採りました。&#8212;)</p>
<p>そのモジュールのテストは大変拡大しました; およそ 2000 の新たなテストケースが数学関数群を鍛え上げます。</p>
<p>IEEE 754 プラットフォームでは <a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> モジュールは、IEEE 754 の特殊値と浮動小数点例外を、C99 標準の付録 &#8216;G&#8217; での一貫性のある方法で処理するようになりました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールに新しいデータ型が追加されています: <code class="xref py py-class docutils literal"><span class="pre">namedtuple(typename,</span> <span class="pre">fieldnames)</span></code> は、添え字だけでなく名前でもアクセス出来るフィールドを持った標準タプルのサブクラスを作るファクトリ関数です。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var_type</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;variable&#39;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="s1">&#39;id name type size&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Names are separated by spaces or commas.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &#39;id, name, type, size&#39; would also work.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var_type</span><span class="o">.</span><span class="n">_fields</span>
<span class="go">(&#39;id&#39;, &#39;name&#39;, &#39;type&#39;, &#39;size&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">var_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">var</span><span class="o">.</span><span class="n">id</span>    <span class="c1"># Equivalent</span>
<span class="go">1 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">var</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span>  <span class="c1"># Equivalent</span>
<span class="go">int int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
<span class="go">{&#39;size&#39;: 4, &#39;type&#39;: &#39;int&#39;, &#39;id&#39;: 1, &#39;name&#39;: &#39;frequency&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span>
<span class="go">variable(id=1, name=&#39;amplitude&#39;, type=&#39;int&#39;, size=4)</span>
</pre></div>
</div>
<p>標準ライブラリのいくつかの箇所で <code class="xref py py-class docutils literal"><span class="pre">namedtuple</span></code> インスタンスを返すように修正されています。例えば <code class="xref py py-meth docutils literal"><span class="pre">Decimal.as_tuple()</span></code> メソッドは <code class="xref py py-attr docutils literal"><span class="pre">sign</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">digits</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">exponent</span></code> フィールドを持った名前付きタプルを返すようになりました。</p>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールのもう一つの変更は、 <code class="xref py py-class docutils literal"><span class="pre">deque</span></code> 型が省略可能な <em>maxlen</em> パラメータをサポートするようになったことです; 与えられると、 deque のサイズが要素数 <em>maxlen</em> を超えないように制限されます。お腹いっぱいの deque にさらに要素を追加すると、古いものから捨てられます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span><span class="o">=</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span>
<span class="go">deque([], maxlen=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span>
<span class="go">deque([1, 2, 3], maxlen=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span>
<span class="go">deque([2, 3, 4], maxlen=3)</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">Cookie</span></code> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Morsel</span></code> オブジェクトが <code class="xref py py-attr docutils literal"><span class="pre">httponly</span></code> 属性をサポートするようになりました。いくつかのブラウザでは、この属性を付けたクッキーは JavaScript コードからアクセスや操作が出来ません。 (Contributed by Arvin Schnell; <a class="reference external" href="https://bugs.python.org/issue1638033">bpo-1638033</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">curses</span></code></a> モジュールの新しい window メソッド <code class="xref py py-meth docutils literal"><span class="pre">chgat()</span></code> は、一行での指定数ぶん文字の表示属性を変更します。 (Contributed by Fabian Kreutz.)</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Boldface text starting at y=0,x=21</span>
<span class="c1"># and affecting the rest of the line.</span>
<span class="n">stdscr</span><span class="o">.</span><span class="n">chgat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="n">curses</span><span class="o">.</span><span class="n">A_BOLD</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/curses.html#module-curses.textpad" title="curses.textpad: Emacs-like input editing in a curses window."><code class="xref py py-mod docutils literal"><span class="pre">curses.textpad</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Textbox</span></code> クラスが上書きモードのほかに挿入モード編集をサポートするようになりました。挿入モードは <code class="xref py py-class docutils literal"><span class="pre">Textbox</span></code> インスタンス構築時に <em>insert_mode</em> パラメータを真にすることで有効になります。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal"><span class="pre">datetime</span></code></a> モジュールの <code class="xref py py-meth docutils literal"><span class="pre">strftime()</span></code> メソッドが <code class="docutils literal"><span class="pre">%f</span></code> 書式化コードをサポートするようになりました。これはオブジェクトのマイクロ秒をミリ秒としてゼロ埋めで 6 桁で展開します。 (&#8212;訳注: 言葉だけだとどうしても伝わりにくいですが、フィールドとしてミリ秒を持たずにマイクロ秒を持っている datetime で「秒.ミリ秒」という表記をするのにマイクロ秒精度まで表示するのが目的です。ですので 654 ミリ秒が「654000」と書式化されますし、32 ミリ秒は「032000」です。&#8212;) (Contributed by Skip Montanaro; <a class="reference external" href="https://bugs.python.org/issue1158">bpo-1158</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールが <a class="reference external" href="http://speleotrove.com/decimal/decarith.html">the General Decimal Specification</a> のバージョン 1.55 に更新されました。新しい機能には <code class="xref py py-meth docutils literal"><span class="pre">exp()</span></code> や <code class="xref py py-meth docutils literal"><span class="pre">log10()</span></code> のようないくつかの基礎的な数学関数が含まれます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&quot;2.718281828459045235360287471&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;2.7182818&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&quot;0.9999999895305022877376682436&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&quot;3&quot;)</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> クラスの <code class="xref py py-meth docutils literal"><span class="pre">as_tuple()</span></code> メソッドが <code class="xref py py-attr docutils literal"><span class="pre">sign</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">digits</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">exponent</span></code> フィールドを持った名前付きタプルを返すようになりました。</p>
<p>(Implemented by Facundo Batista and Mark Dickinson.  Named tuple
support added by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal"><span class="pre">difflib</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">SequenceMatcher</span></code> クラスが、マッチを <code class="xref py py-attr docutils literal"><span class="pre">a</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">b</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">size</span></code> 属性を持つ名前付きタプルで返すようになりました。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/ftplib.html#ftplib.FTP" title="ftplib.FTP"><code class="xref py py-class docutils literal"><span class="pre">ftplib.FTP</span></code></a> クラスのコンストラクタと <code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code> メソッドに省略可能 <code class="docutils literal"><span class="pre">timeout</span></code> パラメータが追加されました。タイムアウトを秒で指定します。(Added by Facundo Batista.) また、 <code class="xref py py-class docutils literal"><span class="pre">FTP</span></code> クラスの <code class="xref py py-meth docutils literal"><span class="pre">storbinary()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">storlines()</span></code> メソッドが <em>callback</em> パラメータを新たに受け取ります。これはデータが送信されたあとでデータの各ブロックごとに呼び出されます。 (Contributed by Phil Schwartz; <a class="reference external" href="https://bugs.python.org/issue1221598">bpo-1221598</a>.)</p>
</li>
<li><p class="first">ビルトイン関数の <code class="xref py py-func docutils literal"><span class="pre">reduce()</span></code> が <a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal"><span class="pre">functools</span></code></a> モジュールでも利用可能です。Python 3.0 ではビルトイン関数は削除されて <a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal"><span class="pre">functools</span></code></a> のものだけが使えます; 現在のところ 2.x シリーズでビルトイン版を削除する計画はありません。 (Patched by Christian Heimes; <a class="reference external" href="https://bugs.python.org/issue1739906">bpo-1739906</a>.) (&#8212;訳注: 2.7 でも削除されていません。使用を検出するには <code class="xref std std-option docutils literal"><span class="pre">-3</span></code> オプションなどで警告をチェックしてください。 &#8212;)</p>
</li>
<li><p class="first">可能な場合には、 <a class="reference internal" href="../library/getpass.html#module-getpass" title="getpass: Portable reading of passwords and retrieval of the userid."><code class="xref py py-mod docutils literal"><span class="pre">getpass</span></code></a> モジュールはプロンプトメッセージ出力とパスワードの読み取りに <code class="file docutils literal"><span class="pre">/dev/tty</span></code> を使うようになりました。利用出来ない場合は標準エラー出力と標準入力が使われます。端末に入力パスワードがエコーされるかもしれない場合、プロンプト表示の前に警告が出力されます。 (Contributed by Gregory P. Smith.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/glob.html#glob.glob" title="glob.glob"><code class="xref py py-func docutils literal"><span class="pre">glob.glob()</span></code></a> 関数が、Unicode パスが使われるかディレクトリ内に Unicode ファイル名がマッチすると Unicode ファイル名を返すようになりました。 (<a class="reference external" href="https://bugs.python.org/issue1001604">bpo-1001604</a>)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal"><span class="pre">heapq</span></code></a> モジュールの新しい関数 <code class="docutils literal"><span class="pre">merge(iter1,</span> <span class="pre">iter2,</span> <span class="pre">...)</span></code> は、任意の数のソートされたデータを返すイテラブルを取り、全てのイテラブルの内容をソートされた順に返す新しいジェネレータを返します (&#8212;訳注: 誤解を招く表現なので補足しておきますが、入力のイテレータはソート済みであることを「仮定」し、出力のジェネレータは「入力が主張している」順序に従うだけです。入力がソートされていなくても並べ替えられるわけではありません。リファレンスにはここはきちんと書かれています。&#8212;)。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">]))</span>
<span class="go">[1, 2, 3, 5, 8, 9, 16]</span>
</pre></div>
</div>
<p>もう一つの新たな関数 <code class="docutils literal"><span class="pre">heappushpop(heap,</span> <span class="pre">item)</span></code> は、 <em>item</em> を <em>heap</em> に push した後、pop を行って <em>heap</em> から最初の要素を返します。この一続きの動作を <code class="xref py py-func docutils literal"><span class="pre">heappush()</span></code> に引き続いて <code class="xref py py-func docutils literal"><span class="pre">heappop()</span></code> を別々に呼び出すよりも効率的に実行します。</p>
<p><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal"><span class="pre">heapq</span></code></a> は以前使っていた「以下(<code class="docutils literal"><span class="pre">&lt;=</span></code>)」比較ではなく「より小さい(<code class="docutils literal"><span class="pre">&lt;</span></code>)」比較だけを使って実装されています。これにより <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal"><span class="pre">heapq</span></code></a> に格納する型の要件が <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> メソッドに合致します。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">省略可能パラメータ <code class="docutils literal"><span class="pre">timeout</span></code> が <code class="xref py py-class docutils literal"><span class="pre">httplib.HTTPConnection</span></code> と <code class="xref py py-class docutils literal"><span class="pre">HTTPSConnection</span></code> クラスのコンストラクタに追加されました。タイムアウトを秒で指定します。 (Added by Facundo Batista.)</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">getmoduleinfo()</span></code> や <code class="xref py py-func docutils literal"><span class="pre">getargs()</span></code> のようなほとんどの <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a> モジュール関数が、名前付きタプルを返すようになりました。タプルのように振る舞うだけでなく、属性でアクセスすることも出来ます。 (Contributed by Raymond Hettinger.)</p>
<p>モジュールには <code class="xref py py-func docutils literal"><span class="pre">isgenerator()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">isgeneratorfunction()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">isabstract()</span></code> を含むいくつかの新しい関数が追加されています。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> モジュールにいくつかの関数が追加されています。</p>
<p><code class="docutils literal"><span class="pre">izip_longest(iter1,</span> <span class="pre">iter2,</span> <span class="pre">...[,</span> <span class="pre">fillvalue])</span></code> はそれぞれの要素群からタプルを生成します; イテラブルの要素数がほかのものより短ければ欠落値として <em>fillvalue</em> が埋められます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">izip_longest</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>
<span class="go">((1, 1), (2, 2), (3, 3), (None, 4), (None, 5))</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">product(iter1,</span> <span class="pre">iter2,</span> <span class="pre">...,</span> <span class="pre">[repeat=N])</span></code> は与えたイテラブルの直積 (Cartesian product)、つまりそれぞれのイテラブルから返るその要素たちの全てのありうる組み合わせを含むタプルの集合を返します。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]))</span>
<span class="go">[(1, 4), (1, 5), (1, 6),</span>
<span class="go"> (2, 4), (2, 5), (2, 6),</span>
<span class="go"> (3, 4), (3, 5), (3, 6)]</span>
</pre></div>
</div>
<p>省略可能 <em>repeat</em> キーワード引数が与えられると、イテラブルが一つであればこれが <em>N</em> 個、複数あればそのセットが <em>N</em> 回与えられたとみなします。単一のイテラブルに対しては <em>N</em> 要素タプルのリストで返ります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2),</span>
<span class="go"> (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)]</span>
</pre></div>
</div>
<p>2 つのイテラブルであれば <em>2N</em> 要素タプルのリストで返ります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 3, 1, 3), (1, 3, 1, 4), (1, 3, 2, 3), (1, 3, 2, 4),</span>
<span class="go"> (1, 4, 1, 3), (1, 4, 1, 4), (1, 4, 2, 3), (1, 4, 2, 4),</span>
<span class="go"> (2, 3, 1, 3), (2, 3, 1, 4), (2, 3, 2, 3), (2, 3, 2, 4),</span>
<span class="go"> (2, 4, 1, 3), (2, 4, 1, 4), (2, 4, 2, 3), (2, 4, 2, 4)]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">combinations(iterable,</span> <span class="pre">r)</span></code>  は、入力 <em>iterable</em> の要素からなる長さ <em>r</em> の部分列を返します (&#8212;訳注: 数学の初等組み合わせ論の「組合せ (combination)」 &#8212;):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;), (&#39;1&#39;, &#39;3&#39;), (&#39;2&#39;, &#39;3&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="s1">&#39;1234&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;), (&#39;1&#39;, &#39;2&#39;, &#39;4&#39;),</span>
<span class="go"> (&#39;1&#39;, &#39;3&#39;, &#39;4&#39;), (&#39;2&#39;, &#39;3&#39;, &#39;4&#39;)]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">permutations(iter[,</span> <span class="pre">r])</span></code> は入力 <em>iterable</em> の長さ <em>r</em> の順列を返します。 <em>r</em> が指定されなければ、イテラブルが生成する全要素数がデフォルトで使われます (&#8212;訳注: 数学の初等組み合わせ論の「順列 (sequence without repetition)」または群論や組合せ論の「置換 (permutation)」。リファレンスでは訳出で置換も順列も両方出てきていますが、高校教育で習う用語で「順列」が伝わりやすいのでここでは「順列」としています。 &#8212;):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 3), (1, 4),</span>
<span class="go"> (2, 1), (2, 3), (2, 4),</span>
<span class="go"> (3, 1), (3, 2), (3, 4),</span>
<span class="go"> (4, 1), (4, 2), (4, 3)]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">itertools.chain(*iterables)</span></code> は <a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> に元々いたものですが、新しい構築方法が出来ました。Python 2.6 では、 <code class="docutils literal"><span class="pre">itertools.chain.from_iterable(iterable)</span></code> でほかのイテラブルを返す単一のイテラブルを取り、 <code class="xref py py-func docutils literal"><span class="pre">chain()</span></code> は、最初のイテラブルからの全要素、次のイテラブルからの全要素、…、のように返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="go">[1, 2, 3, 4, 5, 6]</span>
</pre></div>
</div>
<p>(All contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">FileHandler</span></code> クラスとそのサブクラスの <code class="xref py py-class docutils literal"><span class="pre">WatchedFileHandler</span></code>, <code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code>, <code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code> がそのコンストラクタで省略可能 <em>delay</em> パラメータを受け取るようになりました。 <em>delay</em> が真の場合、ログファイルのオープンは最初の <code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code> が呼び出されるまで延期されます。 (Contributed by Vinay Sajip.)</p>
<p><code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code> ではコンストラクタに <em>utc</em> パラメータも取るようになっています。これが真の場合、 <code class="docutils literal"><span class="pre">when='midnight'</span></code> などの切り替え時刻判定とその生成ファイル名に UTC が使われます。</p>
</li>
<li><p class="first">いくつかの新しい関数が <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> モジュールに追加されました:</p>
<ul class="simple">
<li><p class="first"><a class="reference internal" href="../library/math.html#math.isinf" title="math.isinf"><code class="xref py py-func docutils literal"><span class="pre">isinf()</span></code></a> と <a class="reference internal" href="../library/math.html#math.isnan" title="math.isnan"><code class="xref py py-func docutils literal"><span class="pre">isnan()</span></code></a> は与えられた浮動小数点数が、順に、(正または負の) 無限大であるかどうか、非数 (NaN=Not a Number) であるかどうかを返します。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/math.html#math.copysign" title="math.copysign"><code class="xref py py-func docutils literal"><span class="pre">copysign()</span></code></a> は IEEE 754 数の符号ビットをコピーします。 <em>x</em> の絶対値と <em>y</em> の符号ビットを組み合わせたものを返します。例えば <code class="docutils literal"><span class="pre">math.copysign(1,</span> <span class="pre">-0.0)</span></code> は -1.0 を返します。 (Contributed by Christian Heimes.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/math.html#math.factorial" title="math.factorial"><code class="xref py py-func docutils literal"><span class="pre">factorial()</span></code></a> は階乗を計算します。 (Contributed by Raymond Hettinger; <a class="reference external" href="https://bugs.python.org/issue2138">bpo-2138</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal"><span class="pre">fsum()</span></code></a> はイテラブルからの数列を、部分和の計算を通じて精度の損失を避けながら積み上げた合計の計算をします。 (Contributed by Jean Brouwers, Raymond Hettinger, and Mark Dickinson; <a class="reference external" href="https://bugs.python.org/issue2819">bpo-2819</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/math.html#math.acosh" title="math.acosh"><code class="xref py py-func docutils literal"><span class="pre">acosh()</span></code></a>, <a class="reference internal" href="../library/math.html#math.asinh" title="math.asinh"><code class="xref py py-func docutils literal"><span class="pre">asinh()</span></code></a>, <a class="reference internal" href="../library/math.html#math.atanh" title="math.atanh"><code class="xref py py-func docutils literal"><span class="pre">atanh()</span></code></a> は逆双曲線関数を計算します。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/math.html#math.log1p" title="math.log1p"><code class="xref py py-func docutils literal"><span class="pre">log1p()</span></code></a> は <em>1+x</em>  の自然対数 (底 <em>e</em> の対数) を返します。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">trunc()</span></code> はゼロに向かう方向に丸めを行い、与えられた引数とゼロに最も近い <code class="xref py py-class docutils literal"><span class="pre">Integral</span></code> を返します。これは <a class="reference external" href="#pep-3141">PEP 3141: 数値の型階層</a> のバックポートの一部として追加されました。</p>
</li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> モジュールは、特に浮動小数点例外と IEEE 754 の特殊値の処理において、プラットフォーム間に渡る振る舞いの一貫性をさらに高めるように改善されました。</p>
<p>可能な場合にはいつでもこのモジュールは 754 の特殊値について、C99 標準の勧告に従います。例えば、 <code class="docutils literal"><span class="pre">sqrt(-1.)</span></code> は今ではほとんど全てのプラットフォームで <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> となるはずで、 <code class="docutils literal"><span class="pre">sqrt(float('NaN'))</span></code> は全ての IEEE 754 プラットフォームで NaN を返すはずです。C99 標準の付録 &#8216;F&#8217; で &#8216;divide-by-zero&#8217; または &#8216;invalid&#8217; を伝えることを勧告している箇所では Python は <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を投げます。C99 標準の付録 &#8216;F&#8217; で &#8216;overflow&#8217; を伝えることを勧告している箇所では Python は <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> を投げます。 (See <a class="reference external" href="https://bugs.python.org/issue711019">bpo-711019</a> and <a class="reference external" href="https://bugs.python.org/issue1640">bpo-1640</a>.)</p>
<p>(Contributed by Christian Heimes and Mark Dickinson.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/mmap.html#mmap.mmap" title="mmap.mmap"><code class="xref py py-class docutils literal"><span class="pre">mmap</span></code></a> オブジェクトに <code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code> メソッドが追加されています。部分文字列の検索を、末尾から後ろ向きに検索します。 <code class="xref py py-meth docutils literal"><span class="pre">find()</span></code> には新しい引数 <em>end</em> パラメータが追加されていて、検索対象の終了位置を指定することが出来ます。 (Contributed by John Lenton.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal"><span class="pre">operator</span></code></a> モジュールに <code class="xref py py-func docutils literal"><span class="pre">methodcaller()</span></code> 関数が追加されています。名前と省略可能な引数を与えると、渡したその任意の引数でその名前の関数を呼び出す呼び出し可能オブジェクトを返します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Equivalent to lambda s: s.replace(&#39;old&#39;, &#39;new&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">replacer</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="s1">&#39;old&#39;</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">replacer</span><span class="p">(</span><span class="s1">&#39;old wine in old bottles&#39;</span><span class="p">)</span>
<span class="go">&#39;new wine in new bottles&#39;</span>
</pre></div>
</div>
<p>(Contributed by Georg Brandl, after a suggestion by Gregory Petrosyan.)</p>
<p><code class="xref py py-func docutils literal"><span class="pre">attrgetter()</span></code> 関数がドット付きの名前を受け付け、対応する属性ルックアップをするようになりました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inst_name</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span>
<span class="gp">... </span>       <span class="s1">&#39;__class__.__name__&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inst_name</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">&#39;str&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inst_name</span><span class="p">(</span><span class="n">help</span><span class="p">)</span>
<span class="go">&#39;_Helper&#39;</span>
</pre></div>
</div>
<p>(Contributed by Georg Brandl, after a suggestion by Barry Warsaw.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> モジュールがいくつか新しくシステムコールをラップしています。開いたファイルについて、 <code class="docutils literal"><span class="pre">fchmod(fd,</span> <span class="pre">mode)</span></code> はモードを変更し、 <code class="docutils literal"><span class="pre">fchown(fd,</span> <span class="pre">uid,</span> <span class="pre">gid)</span></code> は所有権を変更し、 <code class="docutils literal"><span class="pre">lchmod(path,</span> <span class="pre">mode)</span></code> はシンボリックリンクのモードを変更します。 (Contributed by Georg Brandl and Christian Heimes.)</p>
<p><code class="xref py py-func docutils literal"><span class="pre">chflags()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">lchflags()</span></code> は対応するシステムコール (利用可能であれば) へのラッパーで、ファイルのフラグを変更します。そのフラグ値についての定数が <a class="reference internal" href="../library/stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a> モジュールに定義されています; いくつかの取りうる値には、ファイルが変更されるべきではないことを伝える <code class="xref py py-const docutils literal"><span class="pre">UF_IMMUTABLE</span></code> 、ファイルにはデータの追記のみが可能であることを伝える <code class="xref py py-const docutils literal"><span class="pre">UF_APPEND</span></code> 、があります。 (Contributed by M. Levinson.)</p>
<p><code class="docutils literal"><span class="pre">os.closerange(low,</span> <span class="pre">high)</span></code> は効率よく全ての <em>low</em> から <em>high</em> のファイルデスクリプタをクローズします。全てのエラーは無視されます。それと <em>high</em> はクローズ対象ではないです。この関数は既に <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> モジュールがプロセスを開始するのを高速化するために使われています。 (Contributed by Georg Brandl; <a class="reference external" href="https://bugs.python.org/issue1663329">bpo-1663329</a>.)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">os.environ</span></code> オブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> メソッドが、オブジェクトのキーから取り除くだけでなく <a class="reference internal" href="../library/os.html#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">os.unsetenv()</span></code></a> を使って環境変数を未設定にするようになりました。  (Contributed by Martin Horcicka; <a class="reference external" href="https://bugs.python.org/issue1181">bpo-1181</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.html#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">os.walk()</span></code></a> 関数に <code class="docutils literal"><span class="pre">followlinks</span></code> パラメータが追加されています。これを真にすると、シンボリックリンクが指す相手のディレクトリを渡り歩くようになります。後方互換のためにこのパラメータのデフォルトは偽です。なお、親ディレクトリを指すシンボリックリンクなど参照が循環していると、無限再帰に陥りますので注意してください。 (<a class="reference external" href="https://bugs.python.org/issue1273829">bpo-1273829</a>)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a> モジュールの <code class="xref py py-func docutils literal"><span class="pre">splitext()</span></code> 関数が、先行するピリオドで分割しないように変更されています。これにより Unix のドットファイルの処理結果がよくなります。例えば <code class="docutils literal"><span class="pre">os.path.splitext('.ipython')</span></code> は <code class="docutils literal"><span class="pre">('',</span> <span class="pre">'.ipython')</span></code> ではなく <code class="docutils literal"><span class="pre">('.ipython',</span> <span class="pre">'')</span></code> を返すようになっています。 (<a class="reference external" href="https://bugs.python.org/issue1115886">bpo-1115886</a>)</p>
<p>新規関数 <code class="docutils literal"><span class="pre">os.path.relpath(path,</span> <span class="pre">start='.')</span></code> は、与えられれば <code class="docutils literal"><span class="pre">start</span></code> からの、与えられなければカレントディレクトリからの、目的地 <code class="docutils literal"><span class="pre">path</span></code> への相対パスを返します。 (Contributed by Richard Barran; <a class="reference external" href="https://bugs.python.org/issue1339796">bpo-1339796</a>.)</p>
<p>Windows において、 <a class="reference internal" href="../library/os.path.html#os.path.expandvars" title="os.path.expandvars"><code class="xref py py-func docutils literal"><span class="pre">os.path.expandvars()</span></code></a> が &#8220;%var%&#8221; 形式の記述に環境変数を展開し、 &#8220;~user&#8221; にユーザのホームディレクトリのパスを展開するようになりました。 (Contributed by Josiah Carlson; <a class="reference external" href="https://bugs.python.org/issue957650">bpo-957650</a>.) (&#8212;訳注: &#8220;~user&#8221; は実在した仕様かわかりません。2.7 に該当する実装もコメントも docstring もリファレンスもありませんし、当然この振る舞いは現在実在していません。&#8212;)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal"><span class="pre">pdb</span></code></a> モジュールで提供される Python デバッガに新たなコマンドが追加されました: &#8220;run&#8221; はデバッグ対象の Python プログラムを再起動します。またオプションとして、対象プログラムに与えるコマンドライン引数を渡せます。 (Contributed by Rocky Bernstein; <a class="reference external" href="https://bugs.python.org/issue1393667">bpo-1393667</a>.)</p>
</li>
<li><p class="first">トレースバックのデバッグを開始するのに使われる <a class="reference internal" href="../library/pdb.html#pdb.post_mortem" title="pdb.post_mortem"><code class="xref py py-func docutils literal"><span class="pre">pdb.post_mortem()</span></code></a> が、トレースバックが与えられない場合に <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> からの戻り値のトレースバックを使うようになりました。 (Contributed by Facundo Batista; <a class="reference external" href="https://bugs.python.org/issue1106316">bpo-1106316</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal"><span class="pre">pickletools</span></code></a> モジュールに <code class="xref py py-func docutils literal"><span class="pre">optimize()</span></code> 関数が追加されました。これは pickle を含んだ文字列を受け取って、未使用 opcode を削除の上で同じデータ構造を含んだより小さい pickle を返します。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/pkgutil.html#module-pkgutil" title="pkgutil: Utilities for the import system."><code class="xref py py-mod docutils literal"><span class="pre">pkgutil</span></code></a> モジュールに <code class="xref py py-func docutils literal"><span class="pre">get_data()</span></code> 関数が追加されました。これはインストールされている Python パッケージに含まれるリソースファイルの内容を返します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pkgutil</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">pkgutil</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="s1">&#39;exception_hierarchy.txt&#39;</span><span class="p">)</span>
<span class="go">BaseException</span>
<span class="go"> +-- SystemExit</span>
<span class="go"> +-- KeyboardInterrupt</span>
<span class="go"> +-- GeneratorExit</span>
<span class="go"> +-- Exception</span>
<span class="go">      +-- StopIteration</span>
<span class="go">      +-- StandardError</span>
<span class="go"> ...</span>
</pre></div>
</div>
<p>(Contributed by Paul Moore; <a class="reference external" href="https://bugs.python.org/issue2439">bpo-2439</a>.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">pyexpat</span></code> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Parser</span></code> オブジェクトで、 <code class="xref py py-attr docutils literal"><span class="pre">buffer_size</span></code> 属性の設定により文字データの保持に使うバッファのサイズを変更出来るようになりました。 (Contributed by Achim Gaedke; <a class="reference external" href="https://bugs.python.org/issue1137">bpo-1137</a>.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">Queue</span></code> モジュールが、エントリを違った順序で取り出すような queue の変種をサポートするようになっています。 <code class="xref py py-class docutils literal"><span class="pre">PriorityQueue</span></code> クラスはキューアイテムをヒープで格納し、それを優先順で取り出します。 <code class="xref py py-class docutils literal"><span class="pre">LifoQueue</span></code> クラスは、最後にエントリに追加されたものを最初に取り出します。つまり stack のように振舞うということです。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal"><span class="pre">random</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Random</span></code> が、今では 32 ビットシステムで pickle 出来、64 ビットシステムで unpickle 出来、逆も出来ます。残念ながらこの変更は Python 2.6 の <code class="xref py py-class docutils literal"><span class="pre">Random</span></code> オブジェクトを以前の Python で正しく unpickle 出来ないことを意味します。 (Contributed by Shawn Ligocki; <a class="reference external" href="https://bugs.python.org/issue1727780">bpo-1727780</a>.)</p>
<p>新たな <code class="docutils literal"><span class="pre">triangular(low,</span> <span class="pre">high,</span> <span class="pre">mode)</span></code> は、三角分布 (triangular distribution) に従う乱数を生成します。 <em>mode</em> は分布内の最頻値で、返却値は <em>high</em> を含まない <em>low</em> と <em>high</em> の間です。 (Contributed by Wladmir van der Laan and Raymond Hettinger; <a class="reference external" href="https://bugs.python.org/issue1681432">bpo-1681432</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールによって実行される長い正規表現検索が届けられるシグナルをチェックするようになり、これにより多大な時間を要する検索を中断出来るようになります。 (Contributed by Josh Hoyt and Ralf Schmitt; <a class="reference external" href="https://bugs.python.org/issue846388">bpo-846388</a>.) (&#8212;訳注: 原文を忠実に訳すとわかりにくいですが、単に C のレベルでシグナルハンドラを仕掛けたので Python が割り込める、というのがここで言っていることです。本質的には「長い」や「時間のかかる」はあまり関係ないです。&#8212;)</p>
<p>正規表現モジュールは、小さな正規表現固有仮想マシン用のバイトコードをコンパイルすることで実装されています。信頼出来ないコードにより、悪意あるバイトコード文字列を直接作って破滅させることが出来ます。ですので、2.6 では正規表現バイトコードの検証をするようにしてあります。(Contributed by Guido van Rossum from work for Google App Engine; <a class="reference external" href="https://bugs.python.org/issue3487">bpo-3487</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/rlcompleter.html#module-rlcompleter" title="rlcompleter: Python identifier completion, suitable for the GNU readline library."><code class="xref py py-mod docutils literal"><span class="pre">rlcompleter</span></code></a> モジュールの <code class="xref py py-meth docutils literal"><span class="pre">Completer.complete()</span></code> メソッドが名前の評価時に引き起こされた例外を無視するようになりました。 (Fixed by Lorenz Quack; <a class="reference external" href="https://bugs.python.org/issue2250">bpo-2250</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/sched.html#module-sched" title="sched: General purpose event scheduler."><code class="xref py py-mod docutils literal"><span class="pre">sched</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">scheduler</span></code> インスタンスが読み取り専用の <a class="reference internal" href="../library/queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-attr docutils literal"><span class="pre">queue</span></code></a> 属性を持つようになりました。これはスケジューラのキュー内容を名前付きタプル <code class="docutils literal"><span class="pre">(time,</span> <span class="pre">priority,</span> <span class="pre">action,</span> <span class="pre">argument)</span></code> で返します。 (Contributed by Raymond Hettinger; <a class="reference external" href="https://bugs.python.org/issue1861">bpo-1861</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal"><span class="pre">select</span></code></a> モジュールに新たに Linux システムコール <code class="xref c c-func docutils literal"><span class="pre">epoll()</span></code> と BSD システムコール <code class="xref c c-func docutils literal"><span class="pre">kqueue()</span></code> へのラッパー関数が追加されました。既存の <code class="xref py py-class docutils literal"><span class="pre">poll</span></code> オブジェクトには新たに <code class="xref py py-meth docutils literal"><span class="pre">modify()</span></code> メソッドが追加されています。 <code class="docutils literal"><span class="pre">pollobj.modify(fd,</span> <span class="pre">eventmask)</span></code> はファイルデスクリプタかファイルオブジェクトとイベントマスクを取り、そのファイルの記録イベントのマスクを修正します。(Contributed by Christian Heimes; <a class="reference external" href="https://bugs.python.org/issue1657">bpo-1657</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal"><span class="pre">shutil.copytree()</span></code></a> が省略可能引数 <em>ignore</em> を取るようになっています。呼び出し可能オブジェクトを渡します。この呼び出し可能オブジェクトはそれぞれのディレクトリパスとその内容リストを受け取って、コピーせずに無視したい名前のリストを返します。</p>
<p><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a> モジュールでは同時に、この新たなパラメータのために使える <code class="xref py py-func docutils literal"><span class="pre">ignore_patterns()</span></code> も提供しています。 <code class="xref py py-func docutils literal"><span class="pre">ignore_patterns()</span></code> は任意の数の glob スタイルのパターンを取り、これらパターンに合致する任意のファイルとディレクトリを無視する呼び出し可能オブジェクトを返します。以下は、 <code class="file docutils literal"><span class="pre">.svn</span></code> ディレクトリと &#8216;~&#8217; で終わるファイル名を持つ Emacs のバックアップファイルをスキップしてディレクトリコピーをする例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="s1">&#39;Doc/library&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/library&#39;</span><span class="p">,</span>
                <span class="n">ignore</span><span class="o">=</span><span class="n">shutil</span><span class="o">.</span><span class="n">ignore_patterns</span><span class="p">(</span><span class="s1">&#39;*~&#39;</span><span class="p">,</span> <span class="s1">&#39;.svn&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>(Contributed by Tarek Ziadé; <a class="reference external" href="https://bugs.python.org/issue2663">bpo-2663</a>.)</p>
</li>
<li><p class="first">Tkinter や GTK+ などのような場所で、シグナルハンドリングと GUI 処理のイベントループを組み合わせることは、長い間悩みの種でした; ほとんどのソフトウェアはポーリングを行って、わずかばかりの時間で起き上がっては GUI イベントが起きていないかチェックするハメになっています。 <a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a> モジュールが、これをより効率的に行えるようにしました。 <code class="docutils literal"><span class="pre">signal.set_wakeup_fd(fd)</span></code> でファイルデスクリプタをセットすると、イベント受信時にファイルデスクリプタにバイトが書き込まれます。 C レベルの関数 <a class="reference internal" href="../c-api/exceptions.html#c.PySignal_SetWakeupFd" title="PySignal_SetWakeupFd"><code class="xref c c-func docutils literal"><span class="pre">PySignal_SetWakeupFd()</span></code></a> もあります。同じくファイルデスクリプタを渡します。</p>
<p>イベントループはこれを、読み込み用と書き込み用の 2 つのデスクリプタを作るパイプをオープンして使うことになるでしょう。書き込み用デスクリプタは <code class="xref py py-func docutils literal"><span class="pre">set_wakeup_fd()</span></code> に渡し、読み込み用デスクリプタはイベントループから <code class="xref c c-func docutils literal"><span class="pre">select()</span></code> や <code class="xref c c-func docutils literal"><span class="pre">poll()</span></code> で監視するデスクリプタのリストに追加すれば良いでしょう。シグナル受信時にはバイトが書き込まれてメインのイベントループが起き上がるので、ポーリングは必要なくなります。</p>
<p>(Contributed by Adam Olsen; <a class="reference external" href="https://bugs.python.org/issue1583">bpo-1583</a>.)</p>
<p><code class="xref py py-func docutils literal"><span class="pre">siginterrupt()</span></code> 関数が Python コードから利用可能になりました。対象シグナルがシステムコールを中断出来るかどうかを変更出来ます。 (Contributed by Ralf Schmitt.)</p>
<p><code class="xref py py-func docutils literal"><span class="pre">setitimer()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">getitimer()</span></code> 関数も追加されています (利用可能であれば)。 <code class="xref py py-func docutils literal"><span class="pre">setitimer()</span></code> は、指定時間経過後に処理にシグナルを届けます。時間は「壁時計時間 (wall-clock time)」(訳注: リファレンスでは「実時間」と表現している)、「プロセスの実行時間 (consumed process time)」、またはプロセス + システム時間の組合せで指定します。(Contributed by Guilherme Polo; <a class="reference external" href="https://bugs.python.org/issue2240">bpo-2240</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">smtplib</span></code></a> モジュールが、 <code class="xref py py-class docutils literal"><span class="pre">SMTP_SSL</span></code> クラスの追加によって SMTP over SSL をサポートするようになっています。このクラスは既存の <code class="xref py py-class docutils literal"><span class="pre">SMTP</span></code> と同じインターフェイスです。(Contributed by Monty Taylor.)   両方のクラスのコンストラクタでは新たに省略可能な <code class="docutils literal"><span class="pre">timeout</span></code> パラメータを取ります。最初に接続を試みる際のタイムアウト値を秒で指定します。(Contributed by Facundo Batista.)</p>
<p>LMTP プロトコル (<span class="target" id="index-73"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2033.html"><strong>RFC 2033</strong></a>) 実装もモジュールに追加されています。LMTP はメールキューを管理しないエージェント間で e-mail を転送する際に、SMTP の代わりに使われます。(LMTP implemented by Leif Hedstrom; <a class="reference external" href="https://bugs.python.org/issue957003">bpo-957003</a>.)</p>
<p><code class="xref py py-meth docutils literal"><span class="pre">SMTP.starttls()</span></code> は今や <span class="target" id="index-74"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3207.html"><strong>RFC 3207</strong></a> 遵守であり、TLS ネゴシエーション自身で得たのでないサーバから得られるいかなる知識も記憶しません。(Patch contributed by Bill Fenner; <a class="reference external" href="https://bugs.python.org/issue829951">bpo-829951</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールが TIPC (<a class="reference external" href="http://tipc.sourceforge.net/">http://tipc.sourceforge.net/</a>) をサポートするようになりました。これは高性能な非 IP ベースのプロトコルで、クラスタ環境で使われるように設計されたものです。TIPC のアドレスは 4 または 5 要素のタプルです。 (Contributed by Alberto Bertogli; <a class="reference external" href="https://bugs.python.org/issue1646">bpo-1646</a>.)</p>
<p>新規の <code class="xref py py-func docutils literal"><span class="pre">create_connection()</span></code> 関数はアドレスを取り、省略可能なタイムアウト値を使って接続を行い、接続されたソケットオブジェクトを返します。この関数は同時に、アドレスのタイプを調べて IPv4 と IPv6 の相応しい方を使って接続します。あなたのコードが <code class="docutils literal"><span class="pre">socket(socket.AF_INET,</span> <span class="pre">...)</span></code> を使う代わりに <code class="xref py py-func docutils literal"><span class="pre">create_connection()</span></code> に乗り換えることは、それが IPv6 対応で必要なこと全て、となるでしょう。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">SocketServer</span></code> モジュール内の基底クラスが、 <code class="xref py py-attr docutils literal"><span class="pre">timeout</span></code> 属性で指定の無応答時間経過後に <code class="xref py py-meth docutils literal"><span class="pre">handle_timeout()</span></code> メソッドを呼び出すようになっています。 (Contributed by Michael Pomraning.)  <code class="xref py py-meth docutils literal"><span class="pre">serve_forever()</span></code> メソッドは、オプションの秒指定のポーリング間隔を取るようになりました。これは、サーバがシャットダウン要求のチェックをどの程度の頻度で行えばよいのかを制御します。 (Contributed by Pedro Werneck and Jeffrey Yasskin; <a class="reference external" href="https://bugs.python.org/issue742598">bpo-742598</a>, <a class="reference external" href="https://bugs.python.org/issue1193577">bpo-1193577</a>.)</p>
</li>
<li><p class="first">Gerhard Häring により保守されている <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal"><span class="pre">sqlite3</span></code></a> モジュールが、Python 2.5 時のバージョン 2.3.2 からバージョン 2.4.1 に更新されました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> モジュールが C99 の <code class="xref c c-type docutils literal"><span class="pre">_Bool</span></code> 型をフォーマット文字 <code class="docutils literal"><span class="pre">'?'</span></code> でサポートするようになりました。 (Contributed by David Remahl.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Popen</span></code> オブジェクトに <code class="xref py py-meth docutils literal"><span class="pre">terminate()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">kill()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">send_signal()</span></code> メソッドが追加されました。Windows では <code class="xref py py-meth docutils literal"><span class="pre">send_signal()</span></code> は <code class="xref py py-const docutils literal"><span class="pre">SIGTERM</span></code> シグナルのみがサポートされ、またこれら全てのメソッドは Win32 API 関数の <code class="xref c c-func docutils literal"><span class="pre">TerminateProcess()</span></code> の別名になっています。 (Contributed by Christian Heimes.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> モジュールに新たに追加された変数 <code class="xref py py-attr docutils literal"><span class="pre">float_info</span></code> は、 <code class="file docutils literal"><span class="pre">float.h</span></code> に由来するプラットフォームの浮動小数点数サポートについての情報を含んだオブジェクトです。このオブジェクトの属性としては、 <code class="xref py py-attr docutils literal"><span class="pre">mant_dig</span></code> (仮数部の桁数)、 <code class="xref py py-attr docutils literal"><span class="pre">epsilon</span></code> (1.0 と、それより大きい表現可能な最小値との差)などがあります。 (Contributed by Christian Heimes; <a class="reference external" href="https://bugs.python.org/issue1534">bpo-1534</a>.)</p>
<p>もう一つの新たな変数 <code class="xref py py-attr docutils literal"><span class="pre">dont_write_bytecode</span></code> は Python がモジュールインポート時に <code class="file docutils literal"><span class="pre">.pyc</span></code> や <code class="file docutils literal"><span class="pre">.pyo</span></code> を作るかどうかを制御します。この変数が真ならば、コンパイル済みファイルは作られません。この変数は Python インタプリタを <a class="reference internal" href="../using/cmdline.html#cmdoption-B"><code class="xref std std-option docutils literal"><span class="pre">-B</span></code></a> スイッチ付きで起動するか環境変数 <span class="target" id="index-75"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> をセットすることで初期設定されます。Python コードはこのあとでこの変数の値を変更することで、バイトコードファイルを作るかどうかを制御出来ます。 (Contributed by Neal Norwitz and Georg Brandl.)</p>
<p>Python インタプリタに与えられたコマンドライン引数についての情報を、 <code class="docutils literal"><span class="pre">sys.flags</span></code> として利用可能な名前付きタプルで知ることが出来ます。例えば Python が冗長モードで起動された場合は <code class="xref py py-attr docutils literal"><span class="pre">verbose</span></code> 属性は真となり、デバッグモードでは <code class="xref py py-attr docutils literal"><span class="pre">debug</span></code> 属性が真、などです。これら属性は全て読み取り専用です。 (Contributed by Christian Heimes.)</p>
<p>新しい関数 <code class="xref py py-func docutils literal"><span class="pre">getsizeof()</span></code> が追加されました。 Python オブジェクトを受け取り、そのオブジェクトが利用しているメモリサイズをバイト単位で返します。
ビルトインオブジェクトは正確な結果を返しますが、サードパーティの拡張は正確な値を返さないかもしれません。
その場合 <code class="xref py py-meth docutils literal"><span class="pre">__sizeof__()</span></code> メソッドを定義してオブジェクトのサイズを返すことができます。 (Robert Schuppenies による貢献. <a class="reference external" href="https://bugs.python.org/issue2898">bpo-2898</a>)</p>
<p>現在動作中のプロファイラとトレーサーを、 <a class="reference internal" href="../library/sys.html#sys.getprofile" title="sys.getprofile"><code class="xref py py-func docutils literal"><span class="pre">sys.getprofile()</span></code></a> と <a class="reference internal" href="../library/sys.html#sys.gettrace" title="sys.gettrace"><code class="xref py py-func docutils literal"><span class="pre">sys.gettrace()</span></code></a> で知ることが出来るようになりました。 (Contributed by Georg Brandl; <a class="reference external" href="https://bugs.python.org/issue1648">bpo-1648</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal"><span class="pre">tarfile</span></code></a> モジュールが、既にサポートされている POSIX.1-1988 (ustar) と GNU tar フォーマットに加えて、POSIX.1-2001 (pax) をサポートするようになりました。デフォルトは GNU tar です; これと違うフォーマットでファイルを開くには <code class="docutils literal"><span class="pre">format</span></code> パラメータで指定します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">tar</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;output.tar&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
                   <span class="nb">format</span><span class="o">=</span><span class="n">tarfile</span><span class="o">.</span><span class="n">PAX_FORMAT</span><span class="p">)</span>
</pre></div>
</div>
<p>新しい <code class="docutils literal"><span class="pre">encoding</span></code> と <code class="docutils literal"><span class="pre">errors</span></code> パラメータはエンコーディングと文字変換のエラー処理方法を指定します。 <code class="docutils literal"><span class="pre">'strict'</span></code>, <code class="docutils literal"><span class="pre">'ignore'</span></code>,  <code class="docutils literal"><span class="pre">'replace'</span></code> は Python の 3 つの標準エラー処理です; <code class="docutils literal"><span class="pre">'utf-8'</span></code> は特殊で、不正な文字を、それの UTF-8 表現に置き換えます。(文字変換は、PAX フォーマットが Unicode ファイル名をサポートするために現れ、デフォルトは UTF-8 エンコーディングです。)</p>
<p><code class="xref py py-meth docutils literal"><span class="pre">TarFile.add()</span></code> メソッドが新たに <code class="docutils literal"><span class="pre">exclude</span></code> 引数を受け付けます。これはアーカイブから特定のファイル名を除外するために呼び出される呼び出し可能オブジェクトです。ファイル名を受け取って、除外すべきファイルの場合に真、そうでなければ偽を返してください。この呼び出し可能オブジェクトは <code class="xref py py-meth docutils literal"><span class="pre">add()</span></code> に最初に追加される名前と再帰的に追加されるディレクトリの名前の両方に適用されます。</p>
<p>(All changes contributed by Lars Gustäbel).</p>
</li>
<li><p class="first">省略可能パラメータ <code class="docutils literal"><span class="pre">timeout</span></code> が <a class="reference internal" href="../library/telnetlib.html#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal"><span class="pre">telnetlib.Telnet</span></code></a> クラスのコンストラクタに追加されました。タイムアウトを秒で指定します。 (Added by Facundo Batista.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/tempfile.html#tempfile.NamedTemporaryFile" title="tempfile.NamedTemporaryFile"><code class="xref py py-class docutils literal"><span class="pre">tempfile.NamedTemporaryFile</span></code></a> クラスは普通はこれが作った一時ファイルを、ファイルクローズ時に削除します。この振る舞いを、コンストラクタのパラメータに <code class="docutils literal"><span class="pre">delete=False</span></code> を渡すことで変更出来るようになりました。 (Contributed by Damien Miller; <a class="reference external" href="https://bugs.python.org/issue1537850">bpo-1537850</a>.)</p>
<p>新しいクラス <code class="xref py py-class docutils literal"><span class="pre">SpooledTemporaryFile</span></code> は一時ファイルのように振舞いますが、そのデータは最大サイズを超えるまではメモリ内に格納されます。その制限を超えると、その内容がディスク上の一時ファイルに書き込まれます。 (Contributed by Dustin J. Mitchell.)</p>
<p><code class="xref py py-class docutils literal"><span class="pre">NamedTemporaryFile</span></code> と <code class="xref py py-class docutils literal"><span class="pre">SpooledTemporaryFile</span></code> のともにコンテキストマネージャとして動作しますので、 <code class="docutils literal"><span class="pre">with</span> <span class="pre">tempfile.NamedTemporaryFile()</span> <span class="pre">as</span> <span class="pre">tmp:</span> <span class="pre">...</span></code> のように書くことが出来ます。 (Contributed by Alexander Belopolsky; <a class="reference external" href="https://bugs.python.org/issue2021">bpo-2021</a>.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">test.test_support</span></code> に、テストを書くのに便利な多くのコンテキストマネージャが追加されています。 <code class="xref py py-func docutils literal"><span class="pre">EnvironmentVarGuard()</span></code> は環境変数を一時的に変更して自動的に元に戻すコンテキストマネージャです。</p>
<p>もう一つのコンテキストマネージャ <code class="xref py py-class docutils literal"><span class="pre">TransientResource</span></code> は、利用出来るかもしれないし出来ないかもしれないリソースの呼び出しを包むことが出来ます; 指定した例外リストを捕捉して無視します(&#8212;訳注: この紹介、良くないと思うのと、多分著者が誤解してます。確かに属性名/属性値を特定してこれに一致する場合にだけ例外を受け取るためのものなので、一致しないものは無視、という事実には反しませんが、「狙った例外は受け取る(ResourceDenied)」でもあるはずです。「期待した例外が発生する」ことをテストしたいでしょう、「期待しない例外はテストには関係ない」であるとともに。それとリファレンスと docstring によれば「指定した例外と属性に合致する場合に ResourceDenied」と言っているので、やはり事実とは反しています。&#8212;)。例えば、ネットワークのテストでは外部のウェブサイトとの接続時の特定の失敗を無視するでしょう:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">test_support</span><span class="o">.</span><span class="n">TransientResource</span><span class="p">(</span><span class="ne">IOError</span><span class="p">,</span>
                                <span class="n">errno</span><span class="o">=</span><span class="n">errno</span><span class="o">.</span><span class="n">ETIMEDOUT</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;https://sf.net&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>最後に、 <code class="xref py py-func docutils literal"><span class="pre">check_warnings()</span></code> は <code class="xref py py-mod docutils literal"><span class="pre">warning</span></code> モジュールの警告フィルタをリセットして、全ての引き起こされる警告メッセージを記録するオブジェクトを返します (<a class="reference external" href="https://bugs.python.org/issue3781">bpo-3781</a>):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">test_support</span><span class="o">.</span><span class="n">check_warnings</span><span class="p">()</span> <span class="k">as</span> <span class="n">wrec</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
    <span class="c1"># ... code that triggers a warning ...</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">wrec</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;function is outdated&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrec</span><span class="o">.</span><span class="n">warnings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Multiple warnings raised&quot;</span>
</pre></div>
</div>
<p>(Contributed by Brett Cannon.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/textwrap.html#module-textwrap" title="textwrap: Text wrapping and filling"><code class="xref py py-mod docutils literal"><span class="pre">textwrap</span></code></a> モジュールで、行頭と新たに作る行の末尾にもともと含まれている空白文字を保ったままにすることが出来るようになりました。 <code class="docutils literal"><span class="pre">drop_whitespace=False</span></code> を指定します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;This  sentence  has a bunch   of</span>
<span class="gp">... </span><span class="s2">  extra   whitespace.&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go">This  sentence</span>
<span class="go">has a bunch</span>
<span class="go">of    extra</span>
<span class="go">whitespace.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">drop_whitespace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go">This  sentence</span>
<span class="go">  has a bunch</span>
<span class="go">   of    extra</span>
<span class="go">   whitespace.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>(Contributed by Dwayne Bailey; <a class="reference external" href="https://bugs.python.org/issue1581073">bpo-1581073</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールの API が、 <code class="xref py py-meth docutils literal"><span class="pre">setDaemon()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">isDaemon()</span></code> メソッドではなく <code class="xref py py-attr docutils literal"><span class="pre">daemon</span></code> のようにプロパティを使うように変更中です。また、いくつかのメソッドはキャメルケースではなくアンダースコアスタイルに名前変更されています; 例えば <code class="xref py py-meth docutils literal"><span class="pre">activeCount()</span></code> メソッドは <code class="xref py py-meth docutils literal"><span class="pre">active_count()</span></code> にリネームされます。2.6 と 3.0 の両バージョンのモジュールは同じプロパティとリネームされたメソッドをサポートしますが、古いメソッドは削除されません。古い API が Python 3.x で撤廃するのがいつになるのかは未定です; 2.x バージョンでは削除されないでしょう。 (Carried out by several people, most notably Benjamin Peterson.) (&#8212; 訳注: 3.5 でもこの状態は続いたままです。今でもキャメルケーススタイルのメソッドが使えます。ですが、もちろん新しい名前を使うべきです。&#8212;)</p>
<p><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Thread</span></code> オブジェクトに <code class="xref py py-attr docutils literal"><span class="pre">ident</span></code> プロパティが追加されています。スレッドの識別子を非ゼロの整数で返します。 (Contributed by Gregory P. Smith; <a class="reference external" href="https://bugs.python.org/issue2871">bpo-2871</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal"><span class="pre">timeit</span></code></a> モジュールが、計測されるステートメントとセットアップコードとして、文字列だけでなく呼び出し可能オブジェクトを渡せるようになりました。 <code class="xref py py-class docutils literal"><span class="pre">Timer</span></code> インスタンスを作成する 2 つの便利関数が追加されています: <code class="docutils literal"><span class="pre">repeat(stmt,</span> <span class="pre">setup,</span> <span class="pre">time,</span> <span class="pre">repeat,</span> <span class="pre">number)</span></code> と <code class="docutils literal"><span class="pre">timeit(stmt,</span> <span class="pre">setup,</span> <span class="pre">time,</span> <span class="pre">number)</span></code> で、インスタンスを作成して対応するメソッドを呼びます。 (Contributed by Erik Demaine; <a class="reference external" href="https://bugs.python.org/issue1533909">bpo-1533909</a>.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">Tkinter</span></code> モジュールが、オプションとしてリストとタプルを受け付けるようになっています。Tcl/Tk へは空白区切りの文字列にして渡されます。 (Contributed by Guilherme Polo; <a class="reference external" href="https://bugs.python.org/issue2906">bpo-2906</a>.)</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal"><span class="pre">turtle</span></code></a> module for turtle graphics was greatly enhanced by
Gregor Lingl.  New features in the module include:</p>
<ul class="simple">
<li><p class="first">亀の移動と回転のアニメーションの改善。</p>
</li>
<li>Control over turtle movement using the new <code class="xref py py-meth docutils literal"><span class="pre">delay()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">tracer()</span></code>, and <code class="xref py py-meth docutils literal"><span class="pre">speed()</span></code> methods.</li>
<li>The ability to set new shapes for the turtle, and to
define a new coordinate system.</li>
<li><p class="first">亀に、動作を巻き戻せる <code class="xref py py-meth docutils literal"><span class="pre">undo()</span></code> メソッドが増えました。</p>
</li>
<li>Simple support for reacting to input events such as mouse and keyboard
activity, making it possible to write simple games.</li>
<li>A <code class="file docutils literal"><span class="pre">turtle.cfg</span></code> file can be used to customize the starting appearance
of the turtle&#8217;s screen.</li>
<li>The module&#8217;s docstrings can be replaced by new docstrings that have been
translated into another language.</li>
</ul>
<p>(<a class="reference external" href="https://bugs.python.org/issue1513695">bpo-1513695</a>)</p>
</li>
<li><p class="first">省略可能パラメータ <code class="docutils literal"><span class="pre">timeout</span></code> が <code class="xref py py-func docutils literal"><span class="pre">urllib.urlopen()</span></code> 関数と <code class="xref py py-class docutils literal"><span class="pre">urllib.ftpwrapper</span></code> クラスのコンストラクタ、 <code class="xref py py-func docutils literal"><span class="pre">urllib2.urlopen()</span></code> 関数に追加されました。タイムアウトを秒で指定します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://slow.example.com&quot;</span><span class="p">,</span>
<span class="go">                        timeout=3)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">urllib2.URLError</span>: <span class="n">&lt;urlopen error timed out&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>(Added by Facundo Batista.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal"><span class="pre">unicodedata</span></code></a> モジュールで提供される Unicode データベースが、バージョン 5.1.0 に更新されました。 (Updated by Martin von Löwis; <a class="reference external" href="https://bugs.python.org/issue3811">bpo-3811</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> モジュールの <code class="xref py py-func docutils literal"><span class="pre">formatwarning()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">showwarning()</span></code> に省略可能な <em>line</em> 引数が追加されました。ソースコードの行番号を与えることが出来ます。 (Added as part of <a class="reference external" href="https://bugs.python.org/issue1631171">bpo-1631171</a>, which re-implemented part of the <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> module in C code.)</p>
<p>新しい関数 <code class="xref py py-func docutils literal"><span class="pre">catch_warnings()</span></code> はコンテキストマネージャで、テスト目的で警告フィルタを一時的に変更して元に戻すのに使えます。 (<a class="reference external" href="https://bugs.python.org/issue3781">bpo-3781</a>).</p>
</li>
<li><p class="first">XML-RPC の <code class="xref py py-class docutils literal"><span class="pre">SimpleXMLRPCServer</span></code> と <code class="xref py py-class docutils literal"><span class="pre">DocXMLRPCServer</span></code> では、コンストラクタパラメータ <code class="docutils literal"><span class="pre">bind_and_activate</span></code> を変更することで、そのソケットが即座にバインドしてアクティベートするのを避けることが出来るようになりました。これは <code class="xref py py-meth docutils literal"><span class="pre">server_bind()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">server_activate()</span></code> メソッドを呼び出す前にインスタンスの <code class="xref py py-attr docutils literal"><span class="pre">allow_reuse_address</span></code> 属性を変更するのに使えます。(&#8212;訳注: この一節、原文は間違っています。原文では <code class="docutils literal"><span class="pre">bind_and_activate=True</span></code> とすると opening and binding するのを防ぐ、となっていますが逆です。また、open して bind、open して listen、というふうに用語使いも間違っています。  <code class="docutils literal"><span class="pre">bind_and_activate=False</span></code> しない限り「bind, listen」がコンストラクタで行われる、のです。False ならばあとから自分で「bind, listen」するのです。&#8212;) (Contributed by Peter Parente; <a class="reference external" href="https://bugs.python.org/issue1599845">bpo-1599845</a>.)</p>
<p><code class="xref py py-class docutils literal"><span class="pre">SimpleXMLRPCServer</span></code> はさらに <code class="xref py py-attr docutils literal"><span class="pre">_send_traceback_header</span></code> 属性を持つようになりました。真の場合、例外とフォーマットされたトレースバックが HTTP ヘッダ &#8220;X-Exception&#8221; と &#8220;X-Traceback&#8221; として返ります。この機能はデバッグのみに使い、製品のサーバには使ってはなりません。トレースバックには剥き出しのパスワードが含まれるかもしれず、あるいはほかの何か企業秘密だったり国家秘密だったりするような繊細な情報満載かもしれないのです。 (Contributed by Alan McIntyre as part of his project for Google&#8217;s Summer of Code 2007.)</p>
</li>
<li><p class="first">The <code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code> module no longer automatically converts
<a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal"><span class="pre">datetime.date</span></code></a> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal"><span class="pre">datetime.time</span></code></a> to the
<code class="xref py py-class docutils literal"><span class="pre">xmlrpclib.DateTime</span></code> type; the conversion semantics were
not necessarily correct for all applications.  Code using
<code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code> should convert <code class="xref py py-class docutils literal"><span class="pre">date</span></code> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal"><span class="pre">time</span></code></a>
instances. (<a class="reference external" href="https://bugs.python.org/issue1330538">bpo-1330538</a>)  The code can also handle
dates before 1900 (contributed by Ralf Schmitt; <a class="reference external" href="https://bugs.python.org/issue2014">bpo-2014</a>)
and 64-bit integers represented by using <code class="docutils literal"><span class="pre">&lt;i8&gt;</span></code> in XML-RPC responses
(contributed by Riku Lindblad; <a class="reference external" href="https://bugs.python.org/issue2985">bpo-2985</a>).</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal"><span class="pre">zipfile</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">ZipFile</span></code> クラスに <code class="xref py py-meth docutils literal"><span class="pre">extract()</span></code> メソッドと <code class="xref py py-meth docutils literal"><span class="pre">extractall()</span></code> メソッドが追加されました。アーカイブ内の、それぞれ単一ファイル、全てのファイルを、カレントディレクトリか指定のディレクトリに展開します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="s1">&#39;python-251.zip&#39;</span><span class="p">)</span>

<span class="c1"># Unpack a single file, writing it relative</span>
<span class="c1"># to the /tmp directory.</span>
<span class="n">z</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s1">&#39;Python/sysmodule.c&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp&#39;</span><span class="p">)</span>

<span class="c1"># Unpack all the files in the archive.</span>
<span class="n">z</span><span class="o">.</span><span class="n">extractall</span><span class="p">()</span>
</pre></div>
</div>
<p>(Contributed by Alan McIntyre; <a class="reference external" href="https://bugs.python.org/issue467924">bpo-467924</a>.)</p>
<p><a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-meth docutils literal"><span class="pre">open()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">extract()</span></code> メソッドはファイル名か <code class="xref py py-class docutils literal"><span class="pre">ZipInfo</span></code> オブジェクトのどちらかを受け取れるようになっています。これは誤って重複したファイル名を含んでいるアーカイブで有用でしょう。 (Contributed by Graham Horler; <a class="reference external" href="https://bugs.python.org/issue1775025">bpo-1775025</a>.)</p>
<p>最後に、 <a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal"><span class="pre">zipfile</span></code></a> がアーカイブするファイルのファイル名として Unicode の使用をサポートするようになりました。  (Contributed by Alexey Borzenkov; <a class="reference external" href="https://bugs.python.org/issue1734346">bpo-1734346</a>.)  (&#8212;訳注: リファレンスに注意事項として書かれていますが、zip ファイルのファイル名標準は存在しないのでこれは問題を起こすことがあります。&#8212;)</p>
</li>
</ul>
<div class="section" id="the-ast-module">
<h3><a class="reference internal" href="../library/ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal"><span class="pre">ast</span></code></a> モジュール<a class="headerlink" href="#the-ast-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="../library/ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal"><span class="pre">ast</span></code></a> モジュールは Python コードの抽象構文木 (Abstract Syntax Tree) 表現を提供します。また、Armin Ronacher は共通タスクを実行するさまざまなヘルパー関数を寄稿しました。これらは HTML テンプレートパッケージであるとか、コードアナライザ、などなどの、Python コードを処理するツールで有用となるでしょう。</p>
<p><code class="xref py py-func docutils literal"><span class="pre">parse()</span></code> 関数は式を受け取り AST を返します。 <code class="xref py py-func docutils literal"><span class="pre">dump()</span></code> 関数はツリー表現をデバッギングに相応しい出力をします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ast</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">d = </span><span class="si">{}</span><span class="s2"></span>
<span class="s2">for i in &#39;abcdefghijklm&#39;:</span>
<span class="s2">    d[i + i] = ord(i) - ord(&#39;a&#39;) + 1</span>
<span class="s2">print d</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>これの出力は深くネストされたツリーです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Module</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="p">[</span>
  <span class="n">Assign</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span>
    <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Store</span><span class="p">())</span>
   <span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="n">Dict</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="p">[],</span> <span class="n">values</span><span class="o">=</span><span class="p">[]))</span>
  <span class="n">For</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Store</span><span class="p">()),</span>
      <span class="nb">iter</span><span class="o">=</span><span class="n">Str</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;abcdefghijklm&#39;</span><span class="p">),</span> <span class="n">body</span><span class="o">=</span><span class="p">[</span>
    <span class="n">Assign</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span>
      <span class="n">Subscript</span><span class="p">(</span><span class="n">value</span><span class="o">=</span>
        <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
          <span class="nb">slice</span><span class="o">=</span>
          <span class="n">Index</span><span class="p">(</span><span class="n">value</span><span class="o">=</span>
            <span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">op</span><span class="o">=</span><span class="n">Add</span><span class="p">(),</span>
             <span class="n">right</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()))),</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Store</span><span class="p">())</span>
     <span class="p">],</span> <span class="n">value</span><span class="o">=</span>
     <span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span>
      <span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span>
       <span class="n">Call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span>
        <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;ord&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span>
          <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">())</span>
         <span class="p">],</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[],</span> <span class="n">starargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
       <span class="n">op</span><span class="o">=</span><span class="n">Sub</span><span class="p">(),</span> <span class="n">right</span><span class="o">=</span><span class="n">Call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span>
        <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;ord&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span>
          <span class="n">Str</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
         <span class="p">],</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[],</span> <span class="n">starargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">)),</span>
       <span class="n">op</span><span class="o">=</span><span class="n">Add</span><span class="p">(),</span> <span class="n">right</span><span class="o">=</span><span class="n">Num</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="p">],</span> <span class="n">orelse</span><span class="o">=</span><span class="p">[])</span>
   <span class="n">Print</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span>
     <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">())</span>
   <span class="p">],</span> <span class="n">nl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
 <span class="p">])</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">literal_eval()</span></code> メソッドは、文字列またはリテラル式を表現する AST を受け取り解析と評価を行い、結果の値を返します。リテラル式は、文字列、数値、辞書などのみを含む Python 式で、文や関数呼び出しを含みません。もしもあなたに式を評価する必要があって、だけれども <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> を呼び出すことによるセキュリティリスクを許容出来ないということであれば、 <code class="xref py py-func docutils literal"><span class="pre">literal_eval()</span></code> がそれを安全に処理してくれます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">literal</span> <span class="o">=</span> <span class="s1">&#39;(&quot;a&quot;, &quot;b&quot;, {2:4, 3:8, 1:2})&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;, {1: 2, 2: 4, 3: 8})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="s1">&#39;&quot;a&quot; + &quot;b&quot;&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">malformed string</span>
</pre></div>
</div>
<p>モジュールには、AST を横断し、修正するための <code class="xref py py-class docutils literal"><span class="pre">NodeVisitor</span></code> と <code class="xref py py-class docutils literal"><span class="pre">NodeTransformer</span></code> クラス、例えば行番号の変更などの共通的な変形を行う関数群が含まれています。</p>
</div>
<div class="section" id="the-future-builtins-module">
<h3><code class="xref py py-mod docutils literal"><span class="pre">future_builtins</span></code> モジュール<a class="headerlink" href="#the-future-builtins-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 3.0 はビルトイン関数のレポジトリにたくさんの変更を加えていて、そのほとんどが互換性を破壊するため Python 2.x シリーズには導入出来ません。 <code class="xref py py-mod docutils literal"><span class="pre">future_builtins</span></code> モジュールは 3.0 互換コードを書くのにインポート出来る 3.0 互換関数セットです。</p>
<p>このモジュールに今のところ含まれるのは:</p>
<ul class="simple">
<li><p class="first"><code class="docutils literal"><span class="pre">ascii(obj)</span></code>: 2.x の <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> と同じことをします。Python 3.0 では <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> は Unicode 文字列を返すようになっていて、一方 <a class="reference internal" href="../library/functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal"><span class="pre">ascii()</span></code></a> は純粋な ASCII バイト文字列を返します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">filter(predicate,</span> <span class="pre">iterable)</span></code>, <code class="docutils literal"><span class="pre">map(func,</span> <span class="pre">iterable1,</span> <span class="pre">...)</span></code>: 3.0 と同じようにイテレータを返し、これは 2.x のビルトインがリストで返すのとは違っています。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">hex(value)</span></code>, <code class="docutils literal"><span class="pre">oct(value)</span></code>: <code class="xref py py-meth docutils literal"><span class="pre">__hex__()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">__oct__()</span></code> メソッドを呼び出すのではなく、 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> メソッドを呼び出した結果を hexadecimal または octal に変換します。こちらのバージョンの <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a> は新しい <code class="docutils literal"><span class="pre">0o</span></code> 記法で返却します。</p>
</li>
</ul>
</div>
<div class="section" id="the-json-module-javascript-object-notation">
<h3><a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a> モジュール: JavaScript オブジェクト記法<a class="headerlink" href="#the-json-module-javascript-object-notation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新しい <a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a> モジュールは、JSON (Javascript Object Notation) と Python 型のエンコーディング、デコーディングをサポートします。JSON は軽量なデータ交換フォーマットで、頻繁にウェブアプリケーションで使われます。JSON の詳細情報は <a class="reference external" href="http://www.json.org">http://www.json.org</a> にあります。</p>
<p><a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a> モジュールはほとんどのビルトイン型のデコーディングとエンコーディングサポートを備えています。以下の例は辞書のエンコードとデコードをしています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;spam&quot;</span><span class="p">:</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;parrot&quot;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># Encode the data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_json</span>
<span class="go">&#39;{&quot;parrot&quot;: 42, &quot;spam&quot;: &quot;foo&quot;}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">in_json</span><span class="p">)</span> <span class="c1"># Decode into a Python object</span>
<span class="go">{&quot;spam&quot;: &quot;foo&quot;, &quot;parrot&quot;: 42}</span>
</pre></div>
</div>
<p>ほかの何か型をサポートするのに独自のエンコーダ、デコーダを書くことも出来ます。JSON 文字列の pretty-printing もサポートされています。</p>
<p><a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal"><span class="pre">json</span></code></a> (もともと simplejson と呼ばれていました) は Bob Ippolito によって書かれました。</p>
</div>
<div class="section" id="the-plistlib-module-a-property-list-parser">
<h3><a class="reference internal" href="../library/plistlib.html#module-plistlib" title="plistlib: Generate and parse Mac OS X plist files."><code class="xref py py-mod docutils literal"><span class="pre">plistlib</span></code></a> モジュール: プロパティリストパーサ<a class="headerlink" href="#the-plistlib-module-a-property-list-parser" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">.plist</span></code> フォーマットは Mac OS X で一般的に使われ、基本的なデータ型(数値、文字列、リスト、辞書)を XML ベースのフォーマットにシリアライズして格納します。データ型の XML-RPC シリアライズに似ています。</p>
<p>Mac OS X で主に使われるとはいえ、そのフォーマットはまったく Mac 固有ではなくその Python 実装は Python がサポートするあらゆるプラットフォームで動作するので、<a class="reference internal" href="../library/plistlib.html#module-plistlib" title="plistlib: Generate and parse Mac OS X plist files."><code class="xref py py-mod docutils literal"><span class="pre">plistlib</span></code></a> は標準ライブラリに昇格しました。</p>
<p>モジュールを使うのは単純です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">plistlib</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="c1"># Create data structure</span>
<span class="n">data_struct</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lastAccessed</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span>
                   <span class="n">version</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">categories</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Personal&#39;</span><span class="p">,</span><span class="s1">&#39;Shared&#39;</span><span class="p">,</span><span class="s1">&#39;Private&#39;</span><span class="p">))</span>

<span class="c1"># Create string containing XML.</span>
<span class="n">plist_str</span> <span class="o">=</span> <span class="n">plistlib</span><span class="o">.</span><span class="n">writePlistToString</span><span class="p">(</span><span class="n">data_struct</span><span class="p">)</span>
<span class="n">new_struct</span> <span class="o">=</span> <span class="n">plistlib</span><span class="o">.</span><span class="n">readPlistFromString</span><span class="p">(</span><span class="n">plist_str</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">data_struct</span>
<span class="nb">print</span> <span class="n">new_struct</span>

<span class="c1"># Write data structure to a file and read it back.</span>
<span class="n">plistlib</span><span class="o">.</span><span class="n">writePlist</span><span class="p">(</span><span class="n">data_struct</span><span class="p">,</span> <span class="s1">&#39;/tmp/customizations.plist&#39;</span><span class="p">)</span>
<span class="n">new_struct</span> <span class="o">=</span> <span class="n">plistlib</span><span class="o">.</span><span class="n">readPlist</span><span class="p">(</span><span class="s1">&#39;/tmp/customizations.plist&#39;</span><span class="p">)</span>

<span class="c1"># read/writePlist accepts file-like objects as well as paths.</span>
<span class="n">plistlib</span><span class="o">.</span><span class="n">writePlist</span><span class="p">(</span><span class="n">data_struct</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ctypes-enhancements">
<h3>ctypes の強化<a class="headerlink" href="#ctypes-enhancements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Thomas Heller は <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> モジュールの保守と拡張を続けました。</p>
<p><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> は今では C99 <code class="docutils literal"><span class="pre">bool</span></code> 型を表す <code class="xref py py-class docutils literal"><span class="pre">c_bool</span></code> データ型をサポートします。  (Contributed by David Remahl; <a class="reference external" href="https://bugs.python.org/issue1649190">bpo-1649190</a>.)</p>
<p><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> の string, buffer, array 型が拡張スライスインデクス構文をサポートするように改善され、 <code class="docutils literal"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> の色々な組み合わせが使えます。 (Implemented by Thomas Wouters.)</p>
<p>全ての <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> データ型が <code class="xref py py-meth docutils literal"><span class="pre">from_buffer()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">from_buffer_copy()</span></code> メソッドをサポートするようになりました。これは与えられた buffer オブジェクトに基く ctypes インスタンスを作ります。 <code class="xref py py-meth docutils literal"><span class="pre">from_buffer_copy()</span></code> はそのオブジェクトの内容をコピーし、 <code class="xref py py-meth docutils literal"><span class="pre">from_buffer()</span></code> はその同じメモリ領域を共有します。</p>
<p>新しい呼び出しの慣例は、 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> にそれぞれのラップされた呼び出しの発生時に <code class="docutils literal"><span class="pre">errno</span></code> あるいは Win32 LastError 変数をクリアすることを伝えることです。 (Implemented by Thomas Heller; <a class="reference external" href="https://bugs.python.org/issue1798">bpo-1798</a>.)</p>
<p>Unix <code class="docutils literal"><span class="pre">errno</span></code> 変数を関数呼び出し後に抽出できるようになっています。ラップされた関数を作る際、 <code class="docutils literal"><span class="pre">use_errno=True</span></code> を <code class="xref py py-func docutils literal"><span class="pre">DLL()</span></code> 関数へのキーワード引数として渡すことが出来、それによりモジュールレベル関数の <code class="xref py py-meth docutils literal"><span class="pre">set_errno()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">get_errno()</span></code> を、 errno 値を設定・取得するのに呼び出せます。</p>
<p>Win32 LastError は <code class="xref py py-func docutils literal"><span class="pre">DLL()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">OleDLL()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">WinDLL()</span></code> 関数で同じようにサポートされています。同じように <code class="docutils literal"><span class="pre">use_last_error=True</span></code> を与え、モジュールレベル関数 <code class="xref py py-meth docutils literal"><span class="pre">set_last_error()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">get_last_error()</span></code> を使います。</p>
<p>ctypes インスタンスへのポインタを抽出にするのに使われる <code class="xref py py-func docutils literal"><span class="pre">byref()</span></code> 関数が、省略可能な <em>offset</em> パラメータを受け取るようになりました。これは返されるポインタに追加されるバイト数です。</p>
</div>
<div class="section" id="improved-ssl-support">
<h3>SSL サポートの改善<a class="headerlink" href="#improved-ssl-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Bill Janssen made extensive improvements to Python 2.6&#8217;s support for
the Secure Sockets Layer by adding a new module, <a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a>, that&#8217;s
built atop the <a class="reference external" href="https://www.openssl.org/">OpenSSL</a> library.
This new module provides more control over the protocol negotiated,
the X.509 certificates used, and has better support for writing SSL
servers (as opposed to clients) in Python.  The existing SSL support
in the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> module hasn&#8217;t been removed and continues to work,
though it will be removed in Python 3.0.</p>
<p>この新たなモジュールを使うには、まず最初にいつものやり方で TCP コネクションを作らなければなりません。そしてその上でそれを <a class="reference internal" href="../library/ssl.html#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">ssl.wrap_socket()</span></code></a> 関数に渡します (&#8212;訳注: 2.7.9 ではさらに進化した <code class="docutils literal"><span class="pre">SSLContext.wrap_socket</span></code> が使えます &#8212;)。証明書が必要かどうかを指定することが出来、証明書の情報を <code class="xref py py-meth docutils literal"><span class="pre">getpeercert()</span></code> メソッドで取得することも出来ます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a> モジュールについてのドキュメント。</p>
</div>
</div>
</div>
<div class="section" id="deprecations-and-removals">
<h2>非推奨と削除<a class="headerlink" href="#deprecations-and-removals" title="このヘッドラインへのパーマリンク">¶</a></h2>
<ul>
<li><p class="first">文字列を例外として送出することは出来なくなりました。これをすると <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を起こします。</p>
</li>
<li><p class="first"><span class="target" id="index-76"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0352"><strong>PEP 352</strong></a> で指示される <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></a> インターフェイスの変更が続けられています。 2.6 では、 <code class="xref py py-attr docutils literal"><span class="pre">args</span></code> 属性を採用するので <code class="xref py py-attr docutils literal"><span class="pre">message</span></code> 属性が非推奨となります。</p>
</li>
<li><p class="first">(3.0 警告モード) Python 3.0 はたくさんの時代遅れのモジュールを削除し、ほかのものも名前変更するような標準ライブラリの再編成が特色となります。Python 2.6 を 3.0 警告モードで動かすと、それらがインポートされる際に警告が励起されます。</p>
<p>非推奨モジュールのリストです: <code class="xref py py-mod docutils literal"><span class="pre">audiodev</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">bgenlocations</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">buildtools</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">bundlebuilder</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">Canvas</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">compiler</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">dircache</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">dl</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">fpformat</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">gensuitemodule</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">ihooks</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">imageop</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">imgfile</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">linuxaudiodev</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">mhlib</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">mimetools</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">multifile</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">new</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">pure</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">statvfs</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">sunaudiodev</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">test.testall</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">toaiff</span></code>.</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">gopherlib</span></code> モジュールは削除されました。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">MimeWriter</span></code> モジュールと <code class="xref py py-mod docutils literal"><span class="pre">mimify</span></code> モジュール は非推奨となっています。代わりに  <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal"><span class="pre">email</span></code></a> パッケージを使ってください。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">md5</span></code> モジュールは非推奨となりました。代わりに <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal"><span class="pre">hashlib</span></code></a> モジュールを使ってください。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">posixfile</span></code> モジュールは非推奨となりました。  <a class="reference internal" href="../library/fcntl.html#fcntl.lockf" title="fcntl.lockf"><code class="xref py py-func docutils literal"><span class="pre">fcntl.lockf()</span></code></a> がより良いロッキングを提供しています。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">popen2</span></code> モジュールは非推奨となっています。  <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> モジュールを使ってください。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">rgbimg</span></code> モジュールは削除されました。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">sets</span></code> モジュールは非推奨となりました。代わりにビルトインの  <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 型を使ってください。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">sha</span></code> モジュールは非推奨となりました。代わりに <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal"><span class="pre">hashlib</span></code></a> モジュールを使ってください。</p>
</li>
</ul>
</div>
<div class="section" id="build-and-c-api-changes">
<h2>ビルドならびに C API の変更<a class="headerlink" href="#build-and-c-api-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のビルド過程と C API の変更は以下の通りです:</p>
<ul>
<li><p class="first">Python はもはや、 C89 コンパイラでコンパイルされなければなりません (19 年も経ってる!)。ですので Python ソースツリーからは、 <code class="xref c c-func docutils literal"><span class="pre">memmove()</span></code> と <code class="xref c c-func docutils literal"><span class="pre">strerror()</span></code> の手前実装が削除されています。C89 標準ライブラリにあるものですから。</p>
</li>
<li><p class="first">Python 2.6 は Microsoft Visual Studio 2008 (version 9.0) でビルド出来ます。そしてこれが新しいデフォルトコンパイラです。 <code class="file docutils literal"><span class="pre">PCbuild</span></code> ディレクトリのビルドファイルを参照して下さい。 (Implemented by Christian Heimes.)</p>
</li>
<li><p class="first">On Mac OS X, Python 2.6 can be compiled as a 4-way universal build.
The <strong class="program">configure</strong> script
can take a <code class="xref std std-option docutils literal"><span class="pre">--with-universal-archs=[32-bit|64-bit|all]</span></code>
switch, controlling whether the binaries are built for 32-bit
architectures (x86, PowerPC), 64-bit (x86-64 and PPC-64), or both.
(Contributed by Ronald Oussoren.)</p>
</li>
<li><p class="first">BerkeleyDB モジュールが C API オブジェクトを公開しています。 <code class="docutils literal"><span class="pre">bsddb.db.api</span></code> として利用可能です。このモジュールは <code class="xref py py-mod docutils literal"><span class="pre">bsddb</span></code> モジュールを自身の独自の目的で使いたいほかの C 拡張で使えます。 (Contributed by Duncan Grisby.)</p>
</li>
<li><p class="first"><a class="reference external" href="#pep-3118-revised-buffer-protocol">PEP 3118 改訂版バッファプロトコル</a> で前述の新しいバッファインターフェイスのために、 <a class="reference internal" href="../c-api/buffer.html#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GetBuffer()</span></code></a> と <a class="reference internal" href="../c-api/buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></code></a> とほか少しの関数が追加されました。</p>
</li>
<li><p class="first">Python の C stdio ライブラリの使用は今では、スレッドセーフ、もしくは、最低でも基底のライブラリと同じ程度にはスレッドセーフです。ファイルをあるスレッドが別スレッドで読み書き最中にクローズするとマズイことが起こるのは、もう長いこと居座り続けた潜在的なバグでした。2.6 ではファイルオブジェクトが参照カウントを持っていて、 <code class="xref c c-func docutils literal"><span class="pre">PyFile_IncUseCount()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">PyFile_DecUseCount()</span></code> 関数で操作します。ファイルオブジェクトは参照カウントがゼロにならない限りクローズ出来ません。GIL が獲得されている間に <code class="docutils literal"><span class="pre">FILE</span> <span class="pre">*</span></code> ポインタを使った I/O 操作を実行する前に <code class="xref c c-func docutils literal"><span class="pre">PyFile_IncUseCount()</span></code> が呼び出されなければなりません。また、GIL の再獲得後に即座に <code class="xref c c-func docutils literal"><span class="pre">PyFile_DecUseCount()</span></code> が呼び出されなければなりません。(&#8212;訳注: 伝わりづらいので別の言い方で言い直すと「Inc してから GIL 解放して FILE* を弄び、済んだら GIL 再獲得して Dec する」。リファレンスのコード例ですぐにわかります。&#8212;) (Contributed by Antoine Pitrou and Gregory P. Smith.)</p>
</li>
<li><p class="first">異なるスレッドから同時にモジュールをインポートすることでデッドロックが発生することはなくなりました; 今では <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> になります。新たな API 関数 <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModuleNoBlock" title="PyImport_ImportModuleNoBlock"><code class="xref c c-func docutils literal"><span class="pre">PyImport_ImportModuleNoBlock()</span></code></a> は最初に <code class="docutils literal"><span class="pre">sys.modules</span></code> を探し、インポートロック獲得後にインポートしようと試みます。インポートロックが他のスレッドにより獲得されていれば <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> が発生します。(Contributed by Christian Heimes.)</p>
</li>
<li><p class="first">いくつかの関数が、プラットフォームの浮動小数点サポートについての情報を返します。 <a class="reference internal" href="../c-api/float.html#c.PyFloat_GetMax" title="PyFloat_GetMax"><code class="xref c c-func docutils literal"><span class="pre">PyFloat_GetMax()</span></code></a> は浮動小数点数で表現出来る最大値を返し、 <a class="reference internal" href="../c-api/float.html#c.PyFloat_GetMin" title="PyFloat_GetMin"><code class="xref c c-func docutils literal"><span class="pre">PyFloat_GetMin()</span></code></a> は正の最小値を返します。 <a class="reference internal" href="../c-api/float.html#c.PyFloat_GetInfo" title="PyFloat_GetInfo"><code class="xref c c-func docutils literal"><span class="pre">PyFloat_GetInfo()</span></code></a> は <code class="file docutils literal"><span class="pre">float.h</span></code> からの情報を含むオブジェクトを返し、これには <code class="docutils literal"><span class="pre">&quot;mant_dig&quot;</span></code> (仮数部桁数)、 <code class="docutils literal"><span class="pre">&quot;epsilon&quot;</span></code> (1.0 とそれより大きい表現可能な最小値との差)やほかのいくつかの情報を含みます。 (Contributed by Christian Heimes; <a class="reference external" href="https://bugs.python.org/issue1534">bpo-1534</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../c-api/complex.html#c.PyComplex_AsCComplex" title="PyComplex_AsCComplex"><code class="xref c c-func docutils literal"><span class="pre">PyComplex_AsCComplex()</span></code></a> を使う C 関数とメソッドが <a class="reference internal" href="../reference/datamodel.html#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal"><span class="pre">__complex__()</span></code></a> メソッドを持つ引数を受け付けるようになっています。特に、 <a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> モジュールにある関数は、このメソッドを持つオブジェクトを受け付けます。これは Python 3.0 での変更のバックポートです。 (Contributed by Mark Dickinson; <a class="reference external" href="https://bugs.python.org/issue1675423">bpo-1675423</a>.)</p>
</li>
<li><p class="first">Python C API に 2 つの大文字小文字を区別しない文字列比較関数 <code class="docutils literal"><span class="pre">PyOS_stricmp(char*,</span> <span class="pre">char*)</span></code> と <code class="docutils literal"><span class="pre">PyOS_strnicmp(char*,</span> <span class="pre">char*,</span> <span class="pre">Py_ssize_t)</span></code> が追加されました。 (Contributed by Christian Heimes; <a class="reference external" href="https://bugs.python.org/issue1635">bpo-1635</a>.)</p>
</li>
<li><p class="first">多くの C 拡張が、 <code class="docutils literal"><span class="pre">init*</span></code> 関数内でモジュール辞書に整数と文字列定数を追加するために独自の小さなマクロを定義しています。 Python 2.6 ではついにモジュールに値を追加する標準マクロを定義しました。 <a class="reference internal" href="../c-api/module.html#c.PyModule_AddStringMacro" title="PyModule_AddStringMacro"><code class="xref c c-macro docutils literal"><span class="pre">PyModule_AddStringMacro</span></code></a> と <code class="xref c c-macro docutils literal"><span class="pre">PyModule_AddIntMacro()</span></code> です。 (Contributed by Christian Heimes.)</p>
</li>
<li><p class="first">いくつかのマクロが 3.0 と 2.6 の両方でリネームされました。それが関数ではなくマクロであることを明確にするためです。 <code class="xref c c-macro docutils literal"><span class="pre">Py_Size()</span></code> は <code class="xref c c-macro docutils literal"><span class="pre">Py_SIZE()</span></code> となり、 <code class="xref c c-macro docutils literal"><span class="pre">Py_Type()</span></code> は <code class="xref c c-macro docutils literal"><span class="pre">Py_TYPE()</span></code> に、そして <code class="xref c c-macro docutils literal"><span class="pre">Py_Refcnt()</span></code> が <code class="xref c c-macro docutils literal"><span class="pre">Py_REFCNT()</span></code> になっています。元の大小文字混在版は後方互換のために Python 2.6 では利用可能なままです。 (<a class="reference external" href="https://bugs.python.org/issue1629">bpo-1629</a>)</p>
</li>
<li><p class="first">Distutils は C 拡張を、デバッグバージョンの Python 実行時に別のディレクトリにビルドするようになりました。 (Contributed by Collin Winter; <a class="reference external" href="https://bugs.python.org/issue1530959">bpo-1530959</a>.)</p>
</li>
<li><p class="first">いくつかの基本データ型、例えば数値や文字列型は、あとで再利用されるオブジェクトのフリーリスト(&#8212;訳注: メモリ管理での alloc/free の free。&#8212;)を内部的に管理しています。それらデータ構造はこのフリーリストに関して、命名規約に従うようにしました; その変数名は常に <code class="docutils literal"><span class="pre">free_list</span></code> 、カウンタは常に <code class="docutils literal"><span class="pre">numfree</span></code> 、そしてマクロ <code class="docutils literal"><span class="pre">Py&lt;typename&gt;_MAXFREELIST</span></code> が必ず定義されます。</p>
</li>
<li><p class="first">新たに追加された Makefile のターゲット &#8220;make patchcheck&#8221; は、Python ソースツリーに対してパッチを作る準備をします: 修正された <code class="docutils literal"><span class="pre">.py</span></code> ファイル全てに含まれる末尾の余分な空白を取り除き、ドキュメンテーションが変更されているかをチェックし、そして <code class="file docutils literal"><span class="pre">Misc/ACKS</span></code> と <code class="file docutils literal"><span class="pre">Misc/NEWS</span></code> が更新されているかどうかを報告します。 (Contributed by Brett Cannon.)</p>
<p>もう一つの新しいターゲット &#8220;make profile-opt&#8221; は、GCC の profile-guided 最適化を使った Python バイナリをビルドします。これは Python をプロファイリングを有効にしてビルドし、プロファイル結果のセットを得るためのテストスイートを実施し、そして最適化のためにそれら結果を使ってビルドします。 (Contributed by Gregory P. Smith.)</p>
</li>
</ul>
<div class="section" id="port-specific-changes-windows">
<h3>ポート特有の変更: Windows<a class="headerlink" href="#port-specific-changes-windows" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul>
<li><p class="first">Windows 95, 98, ME, NT4 のサポートはとりやめられました。 Python 2.6 は最低でも Windows 2000 SP4 が必要です。</p>
</li>
<li><p class="first">Windows での新しいデフォルトコンパイラが Visual Studio 2008 (version 9.0) になっています。Visual Studio 2003 (version 7.1) と 2005 (version 8.0) のビルドディレクトリは PC/ に移動しました。新しい <code class="file docutils literal"><span class="pre">PCbuild</span></code> ディレクトリは X64, デバッグビルド、Profile Guided Optimization (PGO) をサポートしています。PGO ビルドは通常ビルドに較べておよそ 10% 高速化になります。 (Contributed by Christian Heimes with help from Amaury Forgeot d&#8217;Arc and Martin von Löwis.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/msvcrt.html#module-msvcrt" title="msvcrt: Miscellaneous useful routines from the MS VC++ runtime. (Windows)"><code class="xref py py-mod docutils literal"><span class="pre">msvcrt</span></code></a> モジュールはいまでは通常文字系とワイド文字系の両方のコンソール I/O API をサポートします。 <code class="xref py py-func docutils literal"><span class="pre">getwch()</span></code> 関数と <code class="xref py py-func docutils literal"><span class="pre">getwche()</span></code> 関数は打鍵を読み取り、Unicode 値を返します。 <code class="xref py py-func docutils literal"><span class="pre">putwch()</span></code> 関数は Unicode 文字を受け取り、コンソールに書き出します。 (Contributed by Christian Heimes.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.path.html#os.path.expandvars" title="os.path.expandvars"><code class="xref py py-func docutils literal"><span class="pre">os.path.expandvars()</span></code></a> は &#8220;%var%&#8221; 形式を環境変数で置換し、 &#8220;~user&#8221; をユーザのホームディレクトリパスに置換します(&#8212;訳注: 上のほうの訳注参照。&#8212;)。 (Contributed by Josiah Carlson; <a class="reference external" href="https://bugs.python.org/issue957650">bpo-957650</a>.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールのソケットオブジェクトが <code class="xref py py-meth docutils literal"><span class="pre">ioctl()</span></code> メソッドを持つようになりました。 <code class="xref c c-func docutils literal"><span class="pre">WSAIoctl()</span></code> インターフェイスへの限定的なインターフェイスを提供します。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">_winreg</span></code> モジュールに新しい関数 <code class="xref py py-func docutils literal"><span class="pre">ExpandEnvironmentStrings()</span></code> が追加されています。これは入力文字列が <code class="docutils literal"><span class="pre">%NAME%</span></code> のように参照されている場合に環境変数を展開します。このモジュールで提供されるハンドルオブジェクトはコンテキスト管理プロトコルをサポートするようになったので、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> ステートメントで使えます。 (Contributed by Christian Heimes.)</p>
<p><code class="xref py py-mod docutils literal"><span class="pre">_winreg</span></code> は x64 システムのためのより良いサポートが追加されています。 64 ビットシステムで動作する 32 ビットプロセスでレジストリリフレクションを有無効化をする <code class="xref py py-func docutils literal"><span class="pre">DisableReflectionKey()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">EnableReflectionKey()</span></code>,  <code class="xref py py-func docutils literal"><span class="pre">QueryReflectionKey()</span></code> 関数を公開しています。 (<a class="reference external" href="https://bugs.python.org/issue1753245">bpo-1753245</a>)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/msilib.html#module-msilib" title="msilib: Creation of Microsoft Installer files, and CAB files. (Windows)"><code class="xref py py-mod docutils literal"><span class="pre">msilib</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Record</span></code> オブジェクトに <code class="xref py py-meth docutils literal"><span class="pre">GetInteger()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">GetString()</span></code> メソッドが追加されました。フィールド値をそれぞれ数値として、または文字列として返します。 (Contributed by Floris Bruynooghe; <a class="reference external" href="https://bugs.python.org/issue2125">bpo-2125</a>.)</p>
</li>
</ul>
</div>
<div class="section" id="port-specific-changes-mac-os-x">
<h3>ポート特有の変更: Mac OS X<a class="headerlink" href="#port-specific-changes-mac-os-x" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>When compiling a framework build of Python, you can now specify the
framework name to be used by providing the
<code class="xref std std-option docutils literal"><span class="pre">--with-framework-name=</span></code> option to the
<strong class="program">configure</strong> script.</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">macfs</span></code> モジュールは削除されました。これは同様に <code class="xref py py-func docutils literal"><span class="pre">macostools.touched()</span></code> 関数の削除を必要としました。それが  <code class="xref py py-mod docutils literal"><span class="pre">macfs</span></code> モジュールに依存していたので。  (<a class="reference external" href="https://bugs.python.org/issue1490190">bpo-1490190</a>)</p>
</li>
<li>Many other Mac OS modules have been deprecated and will be removed in
Python 3.0:
<code class="xref py py-mod docutils literal"><span class="pre">_builtinSuites</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">aepack</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">aetools</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">aetypes</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">applesingle</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">appletrawmain</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">appletrunner</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">argvemulator</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">Audio_mac</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">autoGIL</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">Carbon</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">cfmfile</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">CodeWarrior</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">ColorPicker</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">EasyDialogs</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">Explorer</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">Finder</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">FrameWork</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">findertools</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">ic</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">icglue</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">icopen</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">macerrors</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">MacOS</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">macfs</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">macostools</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">macresource</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">MiniAEFrame</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">Nav</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">Netscape</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">OSATerminology</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">pimp</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">PixMapWrapper</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">StdSuites</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">SystemEvents</span></code>,
<code class="xref py py-mod docutils literal"><span class="pre">Terminal</span></code>, and
<code class="xref py py-mod docutils literal"><span class="pre">terminalcommand</span></code>.</li>
</ul>
</div>
<div class="section" id="port-specific-changes-irix">
<h3>ポート特有の変更: IRIX<a class="headerlink" href="#port-specific-changes-irix" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>たくさんの古い IRIX 固有のモジュールが非推奨となり、Python 3.0 では削除されます: <code class="xref py py-mod docutils literal"><span class="pre">al</span></code> と <code class="xref py py-mod docutils literal"><span class="pre">AL</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">cd</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">cddb</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">cdplayer</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">CL</span></code> と <code class="xref py py-mod docutils literal"><span class="pre">cl</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">DEVICE</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">ERRNO</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">FILE</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">FL</span></code> と <code class="xref py py-mod docutils literal"><span class="pre">fl</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">flp</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">fm</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">GET</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">GLWS</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">GL</span></code> と <code class="xref py py-mod docutils literal"><span class="pre">gl</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">IN</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">IOCTL</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">jpeg</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">panelparser</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">readcd</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">SV</span></code> と <code class="xref py py-mod docutils literal"><span class="pre">sv</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">torgb</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">videoreader</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">WAIT</span></code> 。</p>
</div>
</div>
<div class="section" id="porting-to-python-2-6">
<h2>Python 2.6 への移植<a class="headerlink" href="#porting-to-python-2-6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションでは前述の変更とバグフィックスにより必要となるかもしれないコードの変更を列挙します:</p>
<ul>
<li><p class="first">ハッシュ化をサポートしないクラスはその定義内でその事実を示すために、  <code class="docutils literal"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> をセットすべきです。</p>
</li>
<li><p class="first">文字列を例外として送出することは出来なくなりました。これをすると <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を起こします。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal"><span class="pre">collections.deque</span></code></a> の <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドが、イテラブルから要素を追加する前に全ての deque の既存の内容をクリアするようになっています。この変更は <code class="docutils literal"><span class="pre">list.__init__()</span></code> の振る舞いと一致します(&#8212;訳注: 当たり前のことにしか思えないのですが詳細がわかりません。これ以前のバージョンでは deque はシングルトンのように振舞っていたのでしょうか。&#8212;)。</p>
</li>
<li><p class="first"><a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">object.__init__()</span></code></a> は以前は任意の引数とキーワード引数を受け取り、そして無視していました。Python 2.6 ではもうこれは許されません。 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を起こします。これは結果的に <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> の対応するメソッドを呼ぶ(おそらく <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> を介して) <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドに影響します。 <a class="reference external" href="https://bugs.python.org/issue1683368">bpo-1683368</a> の議論を参照して下さい。</p>
</li>
<li><p class="first"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> のコンストラクタは今では先頭と末尾の空白が含まれる文字列を許容します。以前は <code class="xref py py-exc docutils literal"><span class="pre">InvalidOperation</span></code> となっていました。他方で、 <code class="xref py py-class docutils literal"><span class="pre">Context</span></code> オブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">create_decimal()</span></code> メソッドは余分な空白を明示的に拒絶するようになり、 <code class="xref py py-exc docutils literal"><span class="pre">ConversionSyntax</span></code> を投げます。</p>
</li>
<li><p class="first">実装上の誤り(事故)で、ビルトインの <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 関数にファイルパスを渡すと指定したファイルをインポート出来ていました。しかしながらこれは決して意図した振る舞いではありませんでした。実装は今ではこのケースを明示的にチェックし、 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を起こします。</p>
</li>
<li><p class="first">C API: <a class="reference internal" href="../c-api/import.html#c.PyImport_Import" title="PyImport_Import"><code class="xref c c-func docutils literal"><span class="pre">PyImport_Import()</span></code></a> と <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal"><span class="pre">PyImport_ImportModule()</span></code></a> 関数がデフォルトで、相対インポートではなく絶対インポートをするようになっています。これはほかのモジュールをインポートする C 拡張に影響します。</p>
</li>
<li><p class="first">C API: ハッシュされるべきではない拡張データ型は、 <code class="docutils literal"><span class="pre">tp_hash</span></code> スロットを <a class="reference internal" href="../c-api/object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal"><span class="pre">PyObject_HashNotImplemented()</span></code></a> と定義すべきです。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールの例外 <a class="reference internal" href="../library/socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a> が <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> 派生になっています。以前は <code class="xref py py-exc docutils literal"><span class="pre">StandardError</span></code> のサブクラスではありませんでしたが今は <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> を通じてそれのサブクラスです。 (Implemented by Gregory P. Smith; <a class="reference external" href="https://bugs.python.org/issue1706815">bpo-1706815</a>.)</p>
</li>
<li><p class="first">The <code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code> module no longer automatically converts
<a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal"><span class="pre">datetime.date</span></code></a> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal"><span class="pre">datetime.time</span></code></a> to the
<code class="xref py py-class docutils literal"><span class="pre">xmlrpclib.DateTime</span></code> type; the conversion semantics were
not necessarily correct for all applications.  Code using
<code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code> should convert <code class="xref py py-class docutils literal"><span class="pre">date</span></code> and <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal"><span class="pre">time</span></code></a>
instances. (<a class="reference external" href="https://bugs.python.org/issue1330538">bpo-1330538</a>)</p>
</li>
<li><p class="first">(3.0 警告モード) <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></a> クラスはスライスやインデクスアクセスで警告を出します; <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></a> のタプルのような振る舞いはのちに取り除かれます。</p>
</li>
<li><p class="first">(3.0 警告モード) 2 つの辞書や 2 つの比較メソッドを実装しないオブジェクトの不等号比較は警告されます。 <code class="docutils literal"><span class="pre">dict1</span> <span class="pre">==</span> <span class="pre">dict2</span></code> はまだ動作しますが、 <code class="docutils literal"><span class="pre">dict1</span> <span class="pre">&lt;</span> <span class="pre">dict2</span></code> はのちに取り除かれます。</p>
<p>Python のスコープルールの実装の詳細であるセル間の比較も、警告を引き起こします。なぜならこれは、3.0 ではそのような比較は完全に禁止されているからです。</p>
</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<span id="acks"></span><h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します:  Georg Brandl, Steve Brown, Nick Coghlan, Ralph Corderoy, Jim Jewett, Kent Johnson, Chris Lambacher, Martin Michlmayr, Antoine Pitrou, Brian Warner.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">What&#8217;s New in Python 2.6</a><ul>
<li><a class="reference internal" href="#python-3-0">Python 3.0</a></li>
<li><a class="reference internal" href="#changes-to-the-development-process">開発プロセスに関する変更</a><ul>
<li><a class="reference internal" href="#new-issue-tracker-roundup">新しい課題トラッカー: Roundup</a></li>
<li><a class="reference internal" href="#new-documentation-format-restructuredtext-using-sphinx">新しいドキュメンテーションフォーマット: Sphinx を使っての reStructuredText</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: &#8220;with&#8221; ステートメント</a><ul>
<li><a class="reference internal" href="#writing-context-managers">コンテキストマネージャを書く</a></li>
<li><a class="reference internal" href="#the-contextlib-module">contextlib モジュール</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-366-explicit-relative-imports-from-a-main-module">PEP 366: メインモジュールからの明示的相対インポート</a></li>
<li><a class="reference internal" href="#pep-370-per-user-site-packages-directory">PEP 370: ユーザごとの <code class="docutils literal"><span class="pre">site-packages</span></code> ディレクトリ</a></li>
<li><a class="reference internal" href="#pep-371-the-multiprocessing-package">PEP 371: <code class="docutils literal"><span class="pre">multiprocessing</span></code> パッケージ</a></li>
<li><a class="reference internal" href="#pep-3101-advanced-string-formatting"><strong>PEP 3101</strong>: 進化版文字列フォーマッティング</a></li>
<li><a class="reference internal" href="#pep-3105-print-as-a-function">PEP 3105: <code class="docutils literal"><span class="pre">print</span></code> を関数にする</a></li>
<li><a class="reference internal" href="#pep-3110-exception-handling-changes">PEP 3110: 例外処理の変更</a></li>
<li><a class="reference internal" href="#pep-3112-byte-literals">PEP 3112: バイトリテラル</a></li>
<li><a class="reference internal" href="#pep-3116-new-i-o-library">PEP 3116: 新しい I/O ライブラリ</a></li>
<li><a class="reference internal" href="#pep-3118-revised-buffer-protocol">PEP 3118: 改訂版バッファプロトコル</a></li>
<li><a class="reference internal" href="#pep-3119-abstract-base-classes">PEP 3119: 抽象基底クラス</a></li>
<li><a class="reference internal" href="#pep-3127-integer-literal-support-and-syntax">PEP 3127: 整数リテラルのサポートと文法</a></li>
<li><a class="reference internal" href="#pep-3129-class-decorators">PEP 3129: クラスデコレータ</a></li>
<li><a class="reference internal" href="#pep-3141-a-type-hierarchy-for-numbers">PEP 3141: 数値の型階層</a><ul>
<li><a class="reference internal" href="#the-fractions-module"><code class="docutils literal"><span class="pre">fractions</span></code> モジュール</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-language-changes">その他の言語変更</a><ul>
<li><a class="reference internal" href="#optimizations">最適化</a></li>
<li><a class="reference internal" href="#interpreter-changes">インタプリタの変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-and-improved-modules">新しいモジュールと改良されたモジュール</a><ul>
<li><a class="reference internal" href="#the-ast-module"><code class="docutils literal"><span class="pre">ast</span></code> モジュール</a></li>
<li><a class="reference internal" href="#the-future-builtins-module"><code class="docutils literal"><span class="pre">future_builtins</span></code> モジュール</a></li>
<li><a class="reference internal" href="#the-json-module-javascript-object-notation"><code class="docutils literal"><span class="pre">json</span></code> モジュール: JavaScript オブジェクト記法</a></li>
<li><a class="reference internal" href="#the-plistlib-module-a-property-list-parser"><code class="docutils literal"><span class="pre">plistlib</span></code> モジュール: プロパティリストパーサ</a></li>
<li><a class="reference internal" href="#ctypes-enhancements">ctypes の強化</a></li>
<li><a class="reference internal" href="#improved-ssl-support">SSL サポートの改善</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecations-and-removals">非推奨と削除</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">ビルドならびに C API の変更</a><ul>
<li><a class="reference internal" href="#port-specific-changes-windows">ポート特有の変更: Windows</a></li>
<li><a class="reference internal" href="#port-specific-changes-mac-os-x">ポート特有の変更: Mac OS X</a></li>
<li><a class="reference internal" href="#port-specific-changes-irix">ポート特有の変更: IRIX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-6">Python 2.6 への移植</a></li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="2.7.html"
                        title="前の章へ">What&#8217;s New in Python 2.7</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2.5.html"
                        title="次の章へ">What&#8217;s New in Python 2.5</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/whatsnew/2.6.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="What’s New in Python 2.5"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="What’s New in Python 2.7"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What&#8217;s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 9月 02, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>