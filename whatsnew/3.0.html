<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>What’s New In Python 3.0 &#8212; Python 3.6.1 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.1 ドキュメント" href="../contents.html" />
    <link rel="up" title="What’s New in Python" href="index.html" />
    <link rel="next" title="What’s New in Python 2.7" href="2.7.html" />
    <link rel="prev" title="What’s New In Python 3.1" href="3.1.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/whatsnew/3.0.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/whatsnew/3.0.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="What’s New in Python 2.7"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="3.1.html" title="What’s New In Python 3.1"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What&#8217;s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-3-0">
<h1>What&#8217;s New In Python 3.0<a class="headerlink" href="#what-s-new-in-python-3-0" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum</td>
</tr>
</tbody>
</table>
<p>この記事では 2.6 と比較した Python 3.0 での新機能を解説します。
Python 3.0、あるいは &#8220;Python 3000&#8221;、 &#8220;Py3K&#8221; は初めて <em>意図的に後方非互換にした</em> Python のリリースです。
通常のリリースよりも多くの変更があり、全ての Python ユーザにとって重要です。
しかし、変更について理解したら Python に実際にはそれほど変更がないことが分かるでしょう。
全体的に見れば、よく知られた悩みの種が概ね解決され、昔の粗雑なものが取り除かれています。</p>
<p>この記事は全ての新機能を完璧な仕様を示そうとはしませんが、便利な概要については説明しようとしています。
全詳細については Python 3.0 のドキュメントや、本編で引かれている多くの PEP を参照してください。
特定の機能の実装や設計原理について完全に理解したいなら、通常のドキュメントよりも詳しいことが書いてある PEP を見るとよいでしょう。
しかし、一旦機能が完全に実装されると、普通 PEP は最新の状態に保たれないことに注意してください。</p>
<p>この文書で全項目に触れるべきなのですが、時間の制約のためそうではありません。
いつもの新リリースのように、 ソース配布の <cite>Misc/NEWS</cite> には些細な変更についても詳細な情報があります。</p>
<div class="section" id="common-stumbling-blocks">
<h2>よくある悩みの種<a class="headerlink" href="#common-stumbling-blocks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションは Python 2.5 に慣れていたら躓いてしまいそうな少数の変更の一覧です。</p>
<div class="section" id="print-is-a-function">
<h3>print関数<a class="headerlink" href="#print-is-a-function" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">print</span></code> 文は <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数に置き換えられ、古い <code class="docutils literal"><span class="pre">print</span></code> 文の特殊な文法の殆どがキーワード引数で置き換えられています (<span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3105"><strong>PEP 3105</strong></a>)。 例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;The answer is&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The answer is&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="n">x</span><span class="p">,</span>           <span class="c1"># Trailing comma suppresses newline</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>  <span class="c1"># Appends a space instead of a newline</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span>              <span class="c1"># Prints a newline</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">()</span>            <span class="c1"># You must call the function!</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;fatal error&quot;</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fatal error&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>       <span class="c1"># prints repr((x, y))</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>      <span class="c1"># Not the same as print(x, y)!</span>
</pre></div>
</div>
<p>項目間の区切りをカスタマイズすることもできます。例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are &lt;&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;&gt; possibilities!&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>which produces:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>There are &lt;4294967296&gt; possibilities!
</pre></div>
</div>
<p>注釈:</p>
<ul class="simple">
<li><p class="first"><a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数は、古い <code class="docutils literal"><span class="pre">print</span></code> 文の &#8220;ソフトスペース&#8221; 機能をサポートしません。例えば Python 2.x では、 <code class="docutils literal"><span class="pre">print</span> <span class="pre">&quot;A\n&quot;,</span> <span class="pre">&quot;B&quot;</span></code> は <code class="docutils literal"><span class="pre">&quot;A\nB\n&quot;</span></code> を出力していましたが、 Python 3.0 では、 <code class="docutils literal"><span class="pre">print(&quot;A\n&quot;,</span> <span class="pre">&quot;B&quot;)</span></code> は <code class="docutils literal"><span class="pre">&quot;A\n</span> <span class="pre">B\n&quot;</span></code> を出力します。</p>
</li>
<li><p class="first">最初は、対話モードで古い <code class="docutils literal"><span class="pre">print</span> <span class="pre">x</span></code> を何回もタイプしてしまうでしょう。代わりに <code class="docutils literal"><span class="pre">print(x)</span></code> とタイプするよう再教育してください。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">2to3</span></code> ソース変換ツールを使うと、すべての <code class="docutils literal"><span class="pre">print</span></code> 文が <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数呼び出しに自動的に置換されるので、大きなプロジェクトでもさほど問題にならないでしょう。</p>
</li>
</ul>
</div>
<div class="section" id="views-and-iterators-instead-of-lists">
<h3>リストからビューおよびイテレータへ<a class="headerlink" href="#views-and-iterators-instead-of-lists" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>いくつかの良く使われている API はもはやリストを返しません:</p>
<ul>
<li><p class="first"><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> の <a class="reference internal" href="../library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> そして <a class="reference internal" href="../library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal"><span class="pre">dict.values()</span></code></a> メソッドはリストの代わりに &#8220;views&#8221; を返します。 例えば: <code class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">d.keys();</span> <span class="pre">k.sort()</span></code> は上手く動きません。 代わりに <code class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">sorted(d)</span></code> を使ってください (これは Python 2.5 でも動作し、効率的です)。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">dict.iterkeys()</span></code>、 <code class="xref py py-meth docutils literal"><span class="pre">dict.iteritems()</span></code>、 <code class="xref py py-meth docutils literal"><span class="pre">dict.itervalues()</span></code> メソッドはもうサポートされません。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> と <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal"><span class="pre">filter()</span></code></a> はイテレータを返します。もしも本物のリストが必要で、全ての入力シーケンスが同じ長さの場合であれば、簡単に直すなら <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> を <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal"><span class="pre">list()</span></code></a> で包みます。例えば <code class="docutils literal"><span class="pre">list(map(...))</span></code> という具合。ですがより良いのは、大抵はリスト内包を使うことです (特に元々のコードが <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> を使っている場合)。あるいはコードを、リストを全く必要としないように書き換えましょう。とりわけトリッキーなのは、関数に副作用を起こさせるために呼び出される <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> です; この場合確実な変換は普通に <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループを使うことです (そもそもリストを作ること自体が無駄遣いでしょう)。</p>
<p>入力シーケンスの長さが同じとは限らないならば、 <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> は最も短いシーケンスが消費されつくすと処理をやめます。Python 2.x での <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> 用法と全く互換にするにはシーケンスを <a class="reference internal" href="../library/itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal"><span class="pre">itertools.zip_longest()</span></code></a> で包んでください。例えば <code class="docutils literal"><span class="pre">map(func,</span> <span class="pre">*sequences)</span></code> を <code class="docutils literal"><span class="pre">list(map(func,</span> <span class="pre">itertools.zip_longest(*sequences)))</span></code> とします。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal"><span class="pre">range()</span></code></a> は <code class="xref py py-func docutils literal"><span class="pre">xrange()</span></code> のように振る舞います。ただし、任意のサイズの値で動作します。 <code class="xref py py-func docutils literal"><span class="pre">xrange()</span></code> は削除されました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> はイテレータを返します。</p>
</li>
</ul>
</div>
<div class="section" id="ordering-comparisons">
<h3>順序比較<a class="headerlink" href="#ordering-comparisons" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python 3.0 で順序比較のルールが簡単になりました。</p>
<ul class="simple">
<li><p class="first">順序比較演算子 (<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>)  は、そのオペランドが自然な順序づけを持たない場合 TypeError 例外を送出します。  <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">''</span></code>, <code class="docutils literal"><span class="pre">0</span> <span class="pre">&gt;</span> <span class="pre">None</span></code> または <code class="docutils literal"><span class="pre">len</span> <span class="pre">&lt;=</span> <span class="pre">len</span></code> のような式は無効になり、 <code class="docutils literal"><span class="pre">None</span> <span class="pre">&lt;</span> <span class="pre">None</span></code> は <code class="docutils literal"><span class="pre">False</span></code> を返す代わりに <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。その結果、 不均一なリスト（訳注：比較不能な型からなる要素が混在するリスト）のソートは意味がなくなりました。 &#8211; 全ての要素は互いに比較できなければなりません。これは <code class="docutils literal"><span class="pre">==</span></code> と <code class="docutils literal"><span class="pre">!=</span></code> 演算子には適用されないことに注意してください: 別々の比較不可能な型のオブジェクトを比較すると常に、互いに等しくないと評価されます。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">builtin.sorted()</span></code> と <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> メソッドは比較関数を与える <em>cmp</em> 引数を受け取らなくなりました。 かわりに <em>key</em> 引数を使用してください。 <em>key</em> と <em>reverse</em> 引数は &#8220;キーワード専用&#8221; となったことに注意してください。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">cmp()</span></code> 関数は廃止され、 <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> 特殊関数はもはやサポートされません。ソートには <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> を使用し、 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> には <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a>  を 、必要に応じて他の高級比較 (rich comparison) を使用してください。 (もし <code class="xref py py-func docutils literal"><span class="pre">cmp()</span></code> の機能が必要なら、 式 <code class="docutils literal"><span class="pre">(a</span> <span class="pre">&gt;</span> <span class="pre">b)</span> <span class="pre">-</span> <span class="pre">(a</span> <span class="pre">&lt;</span> <span class="pre">b)</span></code> を <code class="docutils literal"><span class="pre">cmp(a,</span> <span class="pre">b)</span></code> の代わに使用できるはずです)</p>
</li>
</ul>
</div>
<div class="section" id="integers">
<h3>整数<a class="headerlink" href="#integers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li><span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>: Essentially, <code class="xref py py-class docutils literal"><span class="pre">long</span></code> renamed to <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>.
That is, there is only one built-in integral type, named
<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>; but it behaves mostly like the old <code class="xref py py-class docutils literal"><span class="pre">long</span></code> type.</li>
<li><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a>: An expression like <code class="docutils literal"><span class="pre">1/2</span></code> returns a float.  Use
<code class="docutils literal"><span class="pre">1//2</span></code> to get the truncating behavior.  (The latter syntax has
existed for years, at least since Python 2.2.)</li>
<li><p class="first">整数の上限がなくなったため、<code class="xref py py-data docutils literal"><span class="pre">sys.maxint</span></code> 定数は削除されました。しかしながら、通常のリストや文字列の添え字よりも大きい整数として <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal"><span class="pre">sys.maxsize</span></code></a> を使うことができます。 <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal"><span class="pre">sys.maxsize</span></code></a> は実装の &#8220;自然な&#8221; 整数の大きさに一致し、同じプラットフォームでは (同じビルドオプションなら) 過去のリリースの <code class="xref py py-data docutils literal"><span class="pre">sys.maxint</span></code> と普通は同じです。</p>
</li>
<li><p class="first">long 整数の <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> はもはや末尾に <code class="docutils literal"><span class="pre">L</span></code> を持ちません。そのため、無条件に &#8220;L&#8221; を取り除くコードは代わりに最後の数字を取り除いてしまうでしょう。 (代わりに <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を使用してください。)</p>
</li>
<li><p class="first">8進数リテラルが <code class="docutils literal"><span class="pre">0720</span></code> の形でなくなりました。代わりに <code class="docutils literal"><span class="pre">0o720</span></code> を使ってください。</p>
</li>
</ul>
</div>
<div class="section" id="text-vs-data-instead-of-unicode-vs-8-bit">
<h3>Unicode 対 8 ビット、ではなく、テキスト対データに<a class="headerlink" href="#text-vs-data-instead-of-unicode-vs-8-bit" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>バイナリと Unicode について知っていると思っている全てが変わりました。</p>
<ul class="simple">
<li><p class="first">Python 3.0 でのコンセプトは、Unicode 文字列と 8 ビット文字列、という対比ではなくて、 <em>テキスト</em> と (バイナリ) <em>データ</em> の違いと考える、というものです。全てのテキストは Unicode です; 一方で <em>エンコードされた</em> Unicode はバイナリデータとして表現されます。テキストを保持するのに使われる型は <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> で、データには <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> を使います。2.x での状況との最大の違いは、Python 3.0 でテキストとデータを混ぜようとすれば <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> となることです。Python 2.x では Unicode と 8 ビット文字列を混ぜたとすれば、8 ビット文字列がたまたま 7 ビット (ASCII) バイトだけから出来ていれば動くし非 ASCII バイトがあれば <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> となっていたでしょう。この、データ値に依存した振る舞いが、何年にも渡って夥しい数の悲劇を生み出していました。</p>
</li>
<li><p class="first">この変更からの帰結として、Unicode、エンコーディング、あるいはバイナリデータを使うほとんど全てのコードは、原則として修正する必要があると思います。この変更は進歩のための破壊です。というのも 2.x 世界には、エンコードされたテキストとそうでないものをごっちゃにしている膨大な数のバグがあるはずだからです。Python 2.x のうちから準備しておくには、まずは全てのエンコードしていないテキストに <code class="xref py py-class docutils literal"><span class="pre">unicode</span></code> を使い、 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> はバイナリとエンコードされたデータだけに対して使うことから始めてください。そうしておけば <a class="reference internal" href="../glossary.html#term-2to3"><span class="xref std std-term">2to3</span></a> ツールがあなたのためにほとんどの仕事をしてくれるでしょう。</p>
</li>
<li><p class="first">Unicode テキストのリテラルに <code class="docutils literal"><span class="pre">u&quot;...&quot;</span></code> を使うことはもはやできません。しかし、バイナリーデータのリテラルには <code class="docutils literal"><span class="pre">b&quot;...&quot;</span></code> を使わなければなりません。(&#8212;訳注: この <code class="docutils literal"><span class="pre">u&quot;...&quot;</span></code> は Python 3.3 で再び使えるようになりました。 &#8212;)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 型と <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 型を混ぜて使うことは出来ませんから、それらはいつでも明示的に変換しなければいけません。 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> から <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> にするには <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a> を使ってください。そして <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> から <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> にするには <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a> を使います。それぞれ <code class="docutils literal"><span class="pre">bytes(s,</span> <span class="pre">encoding=...)</span></code> 、 <code class="docutils literal"><span class="pre">str(b,</span> <span class="pre">encoding=...)</span></code> を使うことも出来ます。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> がそうであるように、 <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> は <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> です。これとは独立させて <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> 型として、バッファ化されたバイナリデータを保持するための <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> が用意してあります。 <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> を受け付ける API のほぼ全てが <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> も許容します。その mutable API は <code class="xref py py-class docutils literal"><span class="pre">collections.MutableSequence</span></code> に基づいています。</p>
</li>
<li><p class="first">raw 文字列リテラル内にある全てのバックスラッシュが「字句通り」に解釈されます。つまり <code class="docutils literal"><span class="pre">'\U'</span></code> も <code class="docutils literal"><span class="pre">'\u'</span></code> も、 raw 文字列内にあっては何ら特別に扱われないということです。例えば <code class="docutils literal"><span class="pre">r'\u20ac'</span></code> は Python 3.0 では 6 文字の文字列です。Python 2.x では <code class="docutils literal"><span class="pre">ur'\u20ac'</span></code> が単一の「ユーロ」文字であったのにです。(無論この変更は raw 文字列リテラルについてだけのもので、ユーロ文字は Python 3.0 で <code class="docutils literal"><span class="pre">'\u20ac'</span></code> です。)</p>
</li>
<li><p class="first">組み込みであった <code class="xref py py-class docutils literal"><span class="pre">basestring</span></code> 抽象型なんてものは削除されたのです。 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> をお使いなさい。 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> と <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> は基底クラスを共有するのを正当化するのに足るほどには、機能的に共通していないのです。 <a class="reference internal" href="../glossary.html#term-2to3"><span class="xref std std-term">2to3</span></a> ツール (後述) は <code class="xref py py-class docutils literal"><span class="pre">basestring</span></code> を片っ端から <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> に置き換えてくれます。</p>
</li>
<li><p class="first">テキストファイルとして開かれたファイル (これは従来どおり <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> でのデフォルトのモード) は、 (メモリ内の) 文字列と (ディスクでの) バイト列との写像をするのに、常にエンコーディングを使います。バイナリファイル (モードに <code class="docutils literal"><span class="pre">b</span></code> を付けて開いたもの) はメモリ内では常にバイト列を使います。このことで、もしもファイルが誤ったモードやエンコーディングで開かれようとすると、I/O はきっと口やかましく失敗します。こっそり正しくないデータを生み出すのではなく。それに加えて、ファイルを開く際には Unix ユーザでさえもこれからは、 (テキストかバイナリかの) 正しいモードを選択する必要があるということです。プラットフォームにはそれ特有のデフォルトエンコーディングがあります。Unix 的プラットフォームではこれは環境変数 <code class="docutils literal"><span class="pre">LANG</span></code> にセットされているかもしれません (あるいは時々ほかのプラットフォーム特有の、ロケールに関係した環境変数にもセットされています)。全てとは言いませんが多くの場合は、システムのデフォルトは UTF-8 です; ですが決してこのデフォルトを当てにすべきではありません。純粋な ASCII テキスト以上のものを読み書きするどんなアプリケーションも、きっとエンコーディングをオーバライド出来る手段を持つべきです。 <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> 内にあるエンコーディングを熟知したストリームを使うことは、今ではもう必要なくなりました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a> の初期値はいまでは Unicode のみのテキストファイルです (つまりそれらは <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal"><span class="pre">io.TextIOBase</span></code></a> のインスタンスです)。バイト列データをそれらのストリームで読み書きするには、 <a class="reference internal" href="../library/io.html#io.TextIOBase.buffer" title="io.TextIOBase.buffer"><code class="xref py py-data docutils literal"><span class="pre">io.TextIOBase.buffer</span></code></a> 属性を使う必要があります。</p>
</li>
<li><p class="first">ファイル名は、API へは (Unicode) 文字列を渡し、 (Unicode) 文字列が返ります。これにはプラットフォーム特有の問題があるかもしれません。というのも、いくつかのプラットフォームではファイル名は任意のバイト文字列だからです。(他方では、Windows ではファイル名はネイティブに Unicode で格納されています。) 次善策として、ほとんどの API (たとえば <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> と <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> モジュール内の多くの関数) はファイル名として、文字列だけでなく <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> を受け付け、そして少しの API は <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> を返すかどうかを要求出来る手段を持っています。それゆえに <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">os.listdir()</span></code></a> は引数が <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> インスタンスであれば <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> のリストで返し、 <a class="reference internal" href="../library/os.html#os.getcwdb" title="os.getcwdb"><code class="xref py py-func docutils literal"><span class="pre">os.getcwdb()</span></code></a> はカレントディレクトリを <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> で返します。 <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">os.listdir()</span></code></a> が文字列のリストで返す際、適切にデコード出来ないファイル名は <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> とはせずに無視されることにご注意ください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.html#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">os.environ</span></code></a> や <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal"><span class="pre">sys.argv</span></code></a> のようないくつかのシステム API にも問題がありえます。システムにより利用可能とされるべきバイト列がデフォルトエンコーディングで解釈不能な場合です。環境変数 <code class="docutils literal"><span class="pre">LANG</span></code> をセットしてプログラムを再実行することが、おそらく最善のアプローチです。</p>
</li>
<li><p class="first"><span class="target" id="index-64"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3138"><strong>PEP 3138</strong></a>: 文字列への <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> はもう非 ASCII 文字をエスケープしません。ただし、制御文字、Unicode 標準で印字不可状態のコードポイントは今でもエスケープされます。</p>
</li>
<li><p class="first"><span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a>: ソースのエンコードのデフォルトが UTF-8 になりました。</p>
</li>
<li><p class="first"><span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3131"><strong>PEP 3131</strong></a>: 非 ASCII 文字を識別子として使用することが出来るようになりました。 (そうはいっても標準ライブラリは、コメント内での貢献者の名前以外では ASCII だけのままです。)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">StringIO</span></code> および <code class="xref py py-mod docutils literal"><span class="pre">cStringIO</span></code> モジュールは廃止されました。その代わり <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> モジュールをインポートして、テキストやデータには <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> や <a class="reference internal" href="../library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> を使用してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../howto/unicode.html#unicode-howto"><span class="std std-ref">Unicode HOWTO</span></a> を参照してください。Python 3.0 向けに更新されました。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="overview-of-syntax-changes">
<h2>構文の変更の概要<a class="headerlink" href="#overview-of-syntax-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションは Python 3.0 における全ての <em>構文の</em> 変更についての簡単な概要です。</p>
<div class="section" id="new-syntax">
<h3>新たな構文<a class="headerlink" href="#new-syntax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul>
<li><p class="first"><span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3107"><strong>PEP 3107</strong></a>: 関数引数と戻り値のアノテーション。これは関数のパラメータと戻り値へのアノテーションを行う標準的な手段を提供します (訳注: annotation を強いて訳せば「注釈」)。そのようなアノテーションには、実行時に <code class="xref py py-attr docutils literal"><span class="pre">__annotations__</span></code> 属性を調べること以外には何の意味付けもされていません。メタクラスやデコレータ、フレームワークを通じた実験を促進することが意図されています。</p>
</li>
<li><p class="first"><span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3102"><strong>PEP 3102</strong></a>: キーワードオンリー (keyword-only) 引数。パラメータリスト中で <code class="docutils literal"><span class="pre">*args</span></code> のあとに現れる名前付きパラメータは、呼び出す際には <em>必ず</em> キーワード引数の構文を使う必要があります (&#8212;訳注: <code class="docutils literal"><span class="pre">def</span> <span class="pre">fun(*a,</span> <span class="pre">kw):</span></code> という定義で <code class="docutils literal"><span class="pre">fun(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> は NG で <code class="docutils literal"><span class="pre">fun(1,</span> <span class="pre">2,</span> <span class="pre">kw=3)</span></code> としなければならない。ここまでは 2.x と同じ &#8212;)。この PEP により、可変引数リストを受け取らずにキーワード引数だけを許したい場合にそれを主張するために剥き出しの <code class="docutils literal"><span class="pre">*</span></code> をパラメータリスト内に書けるようになりました (&#8212;訳注: <code class="docutils literal"><span class="pre">def</span> <span class="pre">fun(*,</span> <span class="pre">kw):</span></code> と定義出来る。この定義では <code class="docutils literal"><span class="pre">fun(kw=1)</span></code> としてしか呼び出せない。 <code class="docutils literal"><span class="pre">fun(1)</span></code> はダメ。&#8212;)。</p>
</li>
<li><p class="first">クラス定義内で、基底クラスのリストのあとでキーワード引数が許されるようになりました。これは metaclass を指定するための新しい規約 (次セクション参照) に使われるものですが、 metaclass サポートだけのためだけでなく他の目的に使うことも出来ます。</p>
</li>
<li><p class="first"><span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3104"><strong>PEP 3104</strong></a>: <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> 文。 <code class="docutils literal"><span class="pre">nonlocal</span> <span class="pre">x</span></code> を使うと外側の (ただしグローバルでない) スコープから、直接変数を代入することが出来るようになります。 <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal"><span class="pre">nonlocal</span></code></a> は新しく予約語になりました。</p>
</li>
<li><p class="first"><span class="target" id="index-70"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3132"><strong>PEP 3132</strong></a>: 拡張されたイテレータのアンパッキング。 <code class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">*rest</span> <span class="pre">=</span> <span class="pre">some_sequence</span></code> のようなことを書けるようになりました。 <code class="docutils literal"><span class="pre">*rest,</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">stuff</span></code> も出来ます。 <code class="docutils literal"><span class="pre">rest</span></code> オブジェクトは常に (空かもしれなくても) リストです; 右辺には任意のイテラブルを置けます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <em>a</em> に <code class="docutils literal"><span class="pre">0</span></code> を、 <em>b</em> に <code class="docutils literal"><span class="pre">4</span></code> を、そして <em>rest</em> に <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> をセットします。</p>
</li>
<li><p class="first">Dictionary comprehensions: <code class="docutils literal"><span class="pre">{k:</span> <span class="pre">v</span> <span class="pre">for</span> <span class="pre">k,</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">stuff}</span></code> means the
same thing as <code class="docutils literal"><span class="pre">dict(stuff)</span></code> but is more flexible.  (This is
<span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0274"><strong>PEP 274</strong></a> vindicated. :-)</p>
</li>
<li><p class="first">セットリテラル、例えば <code class="docutils literal"><span class="pre">{1,</span> <span class="pre">2}</span></code>。<code class="docutils literal"><span class="pre">{}</span></code> は空の辞書であることに注意してください。空のセットには <code class="docutils literal"><span class="pre">set()</span></code> を使用してください。セットの内包表記もサポートされました。例えば <code class="docutils literal"><span class="pre">{x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">stuff}</span></code> は <code class="docutils literal"><span class="pre">set(stuff)</span></code> と同じ意味ですが、より柔軟です。</p>
</li>
<li><p class="first">新たな8進数リテラル、e.g. <code class="docutils literal"><span class="pre">0o720</span></code> (2.6 で既にありました)。古い8進数リテラル (<code class="docutils literal"><span class="pre">0720</span></code>) は廃止されました。</p>
</li>
<li><p class="first">新たなバイナリリテラル、e.g. <code class="docutils literal"><span class="pre">0b1010</span></code> (2.6 で既にありました) と、関連する新しい組み込み関数 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal"><span class="pre">bin()</span></code></a> が導入されました。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">b</span></code> または <code class="docutils literal"><span class="pre">B</span></code> で始まるバイトリテラルと、関連する新しい組み込み関数 <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-func docutils literal"><span class="pre">bytes()</span></code></a> が導入されました。</p>
</li>
</ul>
</div>
<div class="section" id="changed-syntax">
<h3>変更された構文<a class="headerlink" href="#changed-syntax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul>
<li><p class="first"><span class="target" id="index-71"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3109"><strong>PEP 3109</strong></a> と <span class="target" id="index-72"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3134"><strong>PEP 3134</strong></a>: 新たな <a class="reference internal" href="../reference/simple_stmts.html#raise"><code class="xref std std-keyword docutils literal"><span class="pre">raise</span></code></a> 文のシンタックス: <code class="samp docutils literal"><span class="pre">raise</span> <span class="pre">[</span><em><span class="pre">expr</span></em> <span class="pre">[from</span> <em><span class="pre">expr</span></em><span class="pre">]]</span></code>。以下を参照してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> と <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> は予約語になりました。 (実際には 2.6 から)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">True</span></code>、<code class="docutils literal"><span class="pre">False</span></code>、および <code class="docutils literal"><span class="pre">None</span></code> が予約語になりました。(2.6 では既に <code class="docutils literal"><span class="pre">None</span></code> が部分的に制限されていました)</p>
</li>
<li><p class="first"><a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> <em>exc</em>, <em>var</em> から <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> <em>exc</em> <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> <em>var</em> に変更されました。<span class="target" id="index-73"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3110"><strong>PEP 3110</strong></a> を参照してください。</p>
</li>
<li><p class="first"><span class="target" id="index-74"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a>: 新たなメタクラスのシンタックス．以下の;</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">M</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>代わりに次のようにしてください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">M</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>モジュールグローバルの <code class="xref py py-data docutils literal"><span class="pre">__metaclass__</span></code> 変数はもうサポートされません。(これは <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> を派生しない全てのクラスのデフォルトを簡単に新スタイルクラス化するための「松葉杖」でした。) (&#8212;訳注: 「新/旧スタイルクラス」は Python 2.x 固有の概念。Python 2.1 までの旧式クラスと、Python 2.2 で導入された、現在まで続く <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> を派生する (当時の旧からみた) 新スタイル。Python 2.2 から 2.7 では <code class="docutils literal"><span class="pre">class</span> <span class="pre">Clazz:</span></code> は (モジュールグローバルの <code class="xref py py-data docutils literal"><span class="pre">__metaclass__</span></code> を使わない限り) <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> を派生しない旧スタイルクラスでしたが、Python 3.x にはもはや「旧スタイルクラス」がないのでこれは Python 2.2 から 2.7 での <code class="docutils literal"><span class="pre">class</span> <span class="pre">Clazz(object):</span></code> と同じ意味です。&#8212;)</p>
</li>
<li><p class="first">リスト内包表記はもう <code class="samp docutils literal"><span class="pre">[...</span> <span class="pre">for</span> <em><span class="pre">var</span></em> <span class="pre">in</span> <em><span class="pre">item1</span></em><span class="pre">,</span> <em><span class="pre">item2</span></em><span class="pre">,</span> <span class="pre">...]</span></code> という構文形をサポートしません。代わりに <code class="samp docutils literal"><span class="pre">[...</span> <span class="pre">for</span> <em><span class="pre">var</span></em> <span class="pre">in</span> <span class="pre">(</span><em><span class="pre">item1</span></em><span class="pre">,</span> <em><span class="pre">item2</span></em><span class="pre">,</span> <span class="pre">...)]</span></code> を使用してください。また、リスト内包表記は異なるセマンティクスを持つことに注意してください。リスト内包表記は <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal"><span class="pre">list()</span></code></a> コンストラクタ内のジェネレータ式の糖衣構文に近く、特にループの制御変数はスコープ外ではもう使用することができません。</p>
</li>
<li><p class="first"><em>ellipsis</em> (<code class="docutils literal"><span class="pre">...</span></code>) はどこででも原子的な式として使うことが出来ます。
(以前はスライス内でのみ許されていました。)
また、<code class="docutils literal"><span class="pre">...</span></code> と書かなければ <em>ならなく</em> なりました。
(以前は文法の些細な偶然により <code class="docutils literal"><span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span></code> と書くことも出来ました。)</p>
</li>
</ul>
</div>
<div class="section" id="removed-syntax">
<h3>削除された操作<a class="headerlink" href="#removed-syntax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li><p class="first"><span class="target" id="index-75"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3113"><strong>PEP 3113</strong></a>: タプル引数のアンパックが削除されました.  <code class="docutils literal"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">(b,</span> <span class="pre">c)):</span> <span class="pre">...</span></code> のように書くことはできません。かわりに <code class="docutils literal"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">b_c):</span> <span class="pre">b,</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">b_c</span></code> を使用してください。</p>
</li>
<li><p class="first">バッククオートが削除されました (代わりに <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> を使用してください)。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">&lt;&gt;</span></code> が削除されました (代わりに <code class="docutils literal"><span class="pre">!=</span></code> を使用してください)。</p>
</li>
<li><p class="first">削除されたキーワード: <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> はキーワードでなくなりましたが、関数として残りました。 (幸運にも関数のシンタックスは 2.x でも許容されています。)  また、 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> はストリーム引数を受け取らなくなりました。<code class="docutils literal"><span class="pre">exec(f)</span></code> の代わりに <code class="docutils literal"><span class="pre">exec(f.read())</span></code> を使うことができます。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">l</span></code> または <code class="docutils literal"><span class="pre">L</span></code> で終わる整数リテラルはサポートされません。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">u</span></code> or <code class="docutils literal"><span class="pre">U</span></code> で始まる文字列リテラルはサポートされません。(&#8212;訳注: この <code class="docutils literal"><span class="pre">u&quot;...&quot;</span></code> は Python 3.3 で再び使えるようになりました。 &#8212;)</p>
</li>
<li><p class="first"><a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> <em>module</em> <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> <code class="docutils literal"><span class="pre">*</span></code> はモジュールレベルでのみ許され、関数内での使用は許されません。</p>
</li>
<li>The only acceptable syntax for relative imports is <code class="samp docutils literal"><span class="pre">from</span> <span class="pre">.[</span><em><span class="pre">module</span></em><span class="pre">]</span>
<span class="pre">import</span> <em><span class="pre">name</span></em></code>.  All <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> forms not starting with <code class="docutils literal"><span class="pre">.</span></code> are
interpreted as absolute imports.  (<span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a>)</li>
<li><p class="first">古い形式のクラスはサポートされません。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="changes-already-present-in-python-2-6">
<h2>Python 2.6 で既にあった変更<a class="headerlink" href="#changes-already-present-in-python-2-6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>おそらく多くのユーザが一足飛びに Python 2.5 から Python 3.0 に移行しようとするでしょうから、このセクションでは、もともとは Python 3.0 のためにデザインされたものの Python 2.6 にバックポートされた新機能について、読者に思い出してもらいましょう。 <a class="reference internal" href="2.6.html#whats-new-in-2-6"><span class="std std-ref">What&#8217;s New in Python 2.6</span></a> 内の対応するセクションにはもっと長い説明が書かれています。</p>
<ul class="simple">
<li><p class="first"><a class="reference internal" href="2.6.html#pep-0343"><span class="std std-ref">PEP 343: &#8220;with&#8221; ステートメント</span></a>. <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 文は今では標準機能となったので、 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> からインポートする必要はもうありません。 <a class="reference internal" href="2.6.html#new-26-context-managers"><span class="std std-ref">コンテキストマネージャを書く</span></a> と <a class="reference internal" href="2.6.html#new-module-contextlib"><span class="std std-ref">contextlib モジュール</span></a> も見てください。</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-0366"><span class="std std-ref">PEP 366: メインモジュールからの明示的相対インポート</span></a>. <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> オプションの有用性を強化します。パッケージ内にあるモジュールを参照している際に関係します。</p>
</li>
<li><a class="reference internal" href="2.6.html#pep-0370"><span class="std std-ref">PEP 370: ユーザごとの site-packages ディレクトリ</span></a>.</li>
<li><a class="reference internal" href="2.6.html#pep-0371"><span class="std std-ref">PEP 371: multiprocessing パッケージ</span></a>.</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3101"><span class="std std-ref">PEP 3101: 進化版文字列フォーマッティング</span></a>. 注意: 2.6 の記述では <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-meth docutils literal"><span class="pre">format()</span></code></a> メソッドが 8 ビット文字列と Unicode 文字列両方について述べていますが、3.0 では <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 型 (Unicode サポートを持ったテキスト文字列) だけがこのメソッドをサポートしています。 <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 型にはありません。計画では最終的にはこれだけが唯一の文字列フォーマットの API になり、Python 3.1 では <code class="docutils literal"><span class="pre">%</span></code> 演算子は非推奨扱いを開始する予定です。(&#8212; 訳注: <code class="docutils literal"><span class="pre">%</span></code> 演算子の撤廃は影響が大き過ぎるからか、現実には (ドキュメントでの軽い記述を除き) 実行時に特別に非推奨扱いされることは 3.5 になってさえもいまだありません。 &#8212;)</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3105"><span class="std std-ref">PEP 3105: print を関数にする</span></a>. これはもはや標準機能となったので、 <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> からインポートする必要はありません。詳細はこのドキュメントの上の方に書いてあります。</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3110"><span class="std std-ref">PEP 3110: 例外処理の変更</span></a>.   <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> <em>exc</em> <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> <em>var</em>  構文が標準となり、  <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> <em>exc</em>, <em>var</em> はもうサポートされません。(もちろん <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> <em>var</em> 部分は今でも省略可能です。)</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3112"><span class="std std-ref">PEP 3112: バイトリテラル</span></a>. 文字列リテラル <code class="docutils literal"><span class="pre">b&quot;...&quot;</span></code> 表記 (とそのお仲間 <code class="docutils literal"><span class="pre">b'...'</span></code>, <code class="docutils literal"><span class="pre">b&quot;&quot;&quot;...&quot;&quot;&quot;</span></code>, <code class="docutils literal"><span class="pre">br&quot;...&quot;</span></code> など) は今では <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 型です。</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3116"><span class="std std-ref">PEP 3116: 新しい I/O ライブラリ</span></a>. <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> モジュールが今ではファイル I/O の標準手段です。組み込みの <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> は今では <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal"><span class="pre">io.open()</span></code></a> へのエイリアスであり、また、追加のキーワード引数 <em>encoding</em>, <em>errors</em>, <em>newline</em>, <em>closefd</em> を持ちます。不正な <em>mode</em> 引数で <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal"><span class="pre">IOError</span></code></a> ではなく <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を投げるようになったことにも注意してください。テキストファイルオブジェクトの背後にあるバイナリファイルオブジェクトには、 <code class="xref py py-attr docutils literal"><span class="pre">f.buffer</span></code> でアクセスできます。(ただしエンコーディング・デコーディング操作の高速化のために、テキストオブジェクトは自身のバッファを保守管理していることに注意してください。)</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3118"><span class="std std-ref">PEP 3118: 改訂版バッファプロトコル</span></a>. 古いビルトインの <code class="xref py py-func docutils literal"><span class="pre">buffer()</span></code> は本当になくなりました; 新しいビルトイン <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-func docutils literal"><span class="pre">memoryview()</span></code></a> が (ほぼ) 同様の機能性を提供します。</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3119"><span class="std std-ref">PEP 3119: 抽象基底クラス</span></a>. <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュール内で定義されている <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to PEP 3119."><code class="xref py py-mod docutils literal"><span class="pre">abc</span></code></a> モジュールと ABC 群が今では言語においてもっと目立った役割を演じるようになっていて、たとえば <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> や <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> のようなビルトインのコレクション型はそれぞれ <code class="xref py py-class docutils literal"><span class="pre">collections.MutableMapping</span></code> と <code class="xref py py-class docutils literal"><span class="pre">collections.MutableSequence</span></code> の ABC に従うようになっています。</p>
</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3127"><span class="std std-ref">PEP 3127: 整数リテラルのサポートと文法</span></a>. 上述のとおり、新しい 8 進数リテラル表現だけが唯一の 8 進数リテラル表現となり、また、バイナリリテラルが追加されました。</p>
</li>
<li><a class="reference internal" href="2.6.html#pep-3129"><span class="std std-ref">PEP 3129: クラスデコレータ</span></a>.</li>
<li><p class="first"><a class="reference internal" href="2.6.html#pep-3141"><span class="std std-ref">PEP 3141: 数値の型階層</span></a>. <a class="reference internal" href="../library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal"><span class="pre">numbers</span></code></a> が、もう一つの新しく ABC を使うモジュールで、Python の「数値塔 (numeric tower)」を定義しています。新しい <a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> モジュールが <a class="reference internal" href="../library/numbers.html#numbers.Rational" title="numbers.Rational"><code class="xref py py-class docutils literal"><span class="pre">numbers.Rational</span></code></a> を実装していることにも注目してください。</p>
</li>
</ul>
</div>
<div class="section" id="library-changes">
<h2>ライブラリの変更<a class="headerlink" href="#library-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>時間の制約により、この文書は標準ライブラリの非常に幅広い変更について徹底的に取り上げてはいません。
ライブラリの大きな変更については <span class="target" id="index-76"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3108"><strong>PEP 3108</strong></a> を参照してください。
ここでは要約を示します:</p>
<ul>
<li><p class="first">Many old modules were removed.  Some, like <code class="xref py py-mod docutils literal"><span class="pre">gopherlib</span></code> (no
longer used) and <code class="xref py py-mod docutils literal"><span class="pre">md5</span></code> (replaced by <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal"><span class="pre">hashlib</span></code></a>), were
already deprecated by <span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0004"><strong>PEP 4</strong></a>.  Others were removed as a result
of the removal of support for various platforms such as Irix, BeOS
and Mac OS 9 (see <span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0011"><strong>PEP 11</strong></a>).  Some modules were also selected for
removal in Python 3.0 due to lack of use or because a better
replacement exists.  See <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3108"><strong>PEP 3108</strong></a> for an exhaustive list.</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">bsddb3</span></code> パッケージが削除されました。テストの不安定性と Berkeley DB のリリーススケジュールにより、中心標準ライブラリでの存在が中心開発者の大きな負担になっていることが徐々に分かってきたためです。しかしながら <code class="xref py py-mod docutils literal"><span class="pre">bsddb3</span></code> パッケージはまだ残っていて、<a class="reference external" href="https://www.jcea.es/programacion/pybsddb.htm">https://www.jcea.es/programacion/pybsddb.htm</a> で外部的に保守されています。</p>
</li>
<li><p class="first">Some modules were renamed because their old name disobeyed
<span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a>, or for various other reasons.  Here&#8217;s the list:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">以前の名前</p>
</th>
<th class="head"><p class="first last">新しい名前</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>_winreg</td>
<td>winreg</td>
</tr>
<tr class="row-odd"><td>ConfigParser</td>
<td>configparser</td>
</tr>
<tr class="row-even"><td>copy_reg</td>
<td>copyreg</td>
</tr>
<tr class="row-odd"><td>Queue</td>
<td>queue</td>
</tr>
<tr class="row-even"><td>SocketServer</td>
<td>socketserver</td>
</tr>
<tr class="row-odd"><td>markupbase</td>
<td>_markupbase</td>
</tr>
<tr class="row-even"><td>repr</td>
<td>reprlib</td>
</tr>
<tr class="row-odd"><td>test.test_support</td>
<td>test.support</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">Python 2.x でのよくあるパターンは、ピュア Python で実装した版とともに、オプショナルで、C 拡張として実装した「加速装置付き (accelerated)」版を持つ、というものです。例えば <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a> と <code class="xref py py-mod docutils literal"><span class="pre">cPickle</span></code> がそうです。それらモジュールの個々のユーザにとって、accelerated 版をインポートしてみてダメならピュア Python 版を使う、というのも重荷となるものです。Python 3.0 では、 accelerated 版はピュア Python 版の実装の詳細と考えます。ユーザは常に標準バージョンをインポートすべきです。これ自身が accelerated 版のインポートを試みてダメならピュア Python 版を使うようになっています。 <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a> / <code class="xref py py-mod docutils literal"><span class="pre">cPickle</span></code> のペアがこの対象になりました。 <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal"><span class="pre">profile</span></code></a> モジュールは 3.1 でこれが予定されています。 <code class="xref py py-mod docutils literal"><span class="pre">StringIO</span></code> モジュールは <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> モジュール内のクラスに変更されました。</p>
</li>
<li><p class="first">関連のあるモジュールのいくつかはパッケージにまとめられ、ふつうサブモジュール名は単純化されました。結果として以下のようなパッケージが出来ました:</p>
<ul class="simple">
<li><p class="first"><a class="reference internal" href="../library/dbm.html#module-dbm" title="dbm: Interfaces to various Unix &quot;database&quot; formats."><code class="xref py py-mod docutils literal"><span class="pre">dbm</span></code></a> (<code class="xref py py-mod docutils literal"><span class="pre">anydbm</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">dbhash</span></code>, <a class="reference internal" href="../library/dbm.html#module-dbm" title="dbm: Interfaces to various Unix &quot;database&quot; formats."><code class="xref py py-mod docutils literal"><span class="pre">dbm</span></code></a>, <code class="xref py py-mod docutils literal"><span class="pre">dumbdbm</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">gdbm</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">whichdb</span></code>)。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/html.html#module-html" title="html: Helpers for manipulating HTML."><code class="xref py py-mod docutils literal"><span class="pre">html</span></code></a> (<code class="xref py py-mod docutils literal"><span class="pre">HTMLParser</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">htmlentitydefs</span></code>)。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal"><span class="pre">http</span></code></a> (<code class="xref py py-mod docutils literal"><span class="pre">httplib</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">BaseHTTPServer</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">CGIHTTPServer</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">SimpleHTTPServer</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">Cookie</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">cookielib</span></code>)。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal"><span class="pre">tkinter</span></code></a> (<a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal"><span class="pre">turtle</span></code></a> を除く全ての <code class="xref py py-mod docutils literal"><span class="pre">Tkinter</span></code> 関連のモジュール)。
<a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal"><span class="pre">turtle</span></code></a> の対象読者は <a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal"><span class="pre">tkinter</span></code></a> にそれほど関心がありません。
また、Python 2.6 以降では <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal"><span class="pre">turtle</span></code></a> の機能は大幅に向上しました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal"><span class="pre">urllib</span></code></a> (<a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal"><span class="pre">urllib</span></code></a>, <code class="xref py py-mod docutils literal"><span class="pre">urllib2</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">urlparse</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">robotparse</span></code>)。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">xmlrpc</span></code> (<code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">DocXMLRPCServer</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">SimpleXMLRPCServer</span></code>)。</p>
</li>
</ul>
</li>
</ul>
<p><span class="target" id="index-77"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3108"><strong>PEP 3108</strong></a> で取り上げられていない標準ライブラリーの他の変更:</p>
<ul class="simple">
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">sets</span></code> は廃止されました。組み込みの <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal"><span class="pre">set()</span></code></a> クラスを使用してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> モジュールの整理: <code class="xref py py-func docutils literal"><span class="pre">sys.exitfunc()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">sys.exc_clear()</span></code>, <code class="xref py py-data docutils literal"><span class="pre">sys.exc_type</span></code>, <code class="xref py py-data docutils literal"><span class="pre">sys.exc_value</span></code>, <code class="xref py py-data docutils literal"><span class="pre">sys.exc_traceback</span></code> は削除されました。(<a class="reference internal" href="../library/sys.html#sys.last_type" title="sys.last_type"><code class="xref py py-data docutils literal"><span class="pre">sys.last_type</span></code></a> 等はまだあります。)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal"><span class="pre">array.array</span></code></a> 型の整理: <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> ならびに <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> メソッドは廃止されました。代わりに <code class="xref py py-meth docutils literal"><span class="pre">fromfile()</span></code> ならびに <code class="xref py py-meth docutils literal"><span class="pre">tofile()</span></code> を使用してください。また、array 向けの <code class="docutils literal"><span class="pre">'c'</span></code> タイプコードは廃止されました。バイトには <code class="docutils literal"><span class="pre">'b'</span></code> 、Unicode 文字には <code class="docutils literal"><span class="pre">'u'</span></code> を使用してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal"><span class="pre">operator</span></code></a> モジュールの整理: <code class="xref py py-func docutils literal"><span class="pre">sequenceIncludes()</span></code> および <code class="xref py py-func docutils literal"><span class="pre">isCallable()</span></code> は削除されました。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">thread</span></code> モジュールの整理: <code class="xref py py-func docutils literal"><span class="pre">acquire_lock()</span></code> ならびに <code class="xref py py-func docutils literal"><span class="pre">release_lock()</span></code> は廃止されました。代わりに <code class="xref py py-func docutils literal"><span class="pre">acquire()</span></code> ならびに <code class="xref py py-func docutils literal"><span class="pre">release()</span></code> を使用してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal"><span class="pre">random</span></code></a> モジュールの整理: <code class="xref py py-func docutils literal"><span class="pre">jumpahead()</span></code> API は削除されました。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">new</span></code> モジュールは廃止されました。</p>
</li>
<li><p class="first">関数 <code class="xref py py-func docutils literal"><span class="pre">os.tmpnam()</span></code>、<code class="xref py py-func docutils literal"><span class="pre">os.tempnam()</span></code> および <code class="xref py py-func docutils literal"><span class="pre">os.tmpfile()</span></code> は <a class="reference internal" href="../library/tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a> のため削除されました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/tokenize.html#module-tokenize" title="tokenize: Lexical scanner for Python source code."><code class="xref py py-mod docutils literal"><span class="pre">tokenize</span></code></a> モジュールはバイトでも機能するように変更されました。メインのエントリポイントは generate_tokens から <a class="reference internal" href="../library/tokenize.html#tokenize.tokenize" title="tokenize.tokenize"><code class="xref py py-func docutils literal"><span class="pre">tokenize.tokenize()</span></code></a> になりました。</p>
</li>
<li><p class="first"><code class="xref py py-data docutils literal"><span class="pre">string.letters</span></code> とその仲間 (<code class="xref py py-data docutils literal"><span class="pre">string.lowercase</span></code> と <code class="xref py py-data docutils literal"><span class="pre">string.uppercase</span></code>) は廃止されました。代わりに <a class="reference internal" href="../library/string.html#string.ascii_letters" title="string.ascii_letters"><code class="xref py py-data docutils literal"><span class="pre">string.ascii_letters</span></code></a> 等を使用してください。(削除された理由は <code class="xref py py-data docutils literal"><span class="pre">string.letters</span></code> とその仲間にロケール固有の挙動があったためです。そのようなものに対して、いつでも使えそうな &#8220;定数&#8221; として魅力的に名付けるのは良い考えとは言えません。)</p>
</li>
<li><p class="first">モジュール <code class="xref py py-mod docutils literal"><span class="pre">__builtin__</span></code> が <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> にリネームされました (アンダースコアの削除と &#8216;s&#8217; の追加)。
大半の大域名前空間における <code class="xref py py-data docutils literal"><span class="pre">__builtins__</span></code> 変数は変更されていません。
組み込みを変更するには <code class="xref py py-data docutils literal"><span class="pre">__builtins__</span></code> でなく <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> を使わなければなりません。</p>
</li>
</ul>
</div>
<div class="section" id="pep-3101-a-new-approach-to-string-formatting">
<h2><span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3101"><strong>PEP 3101</strong></a>: 文字列整形の新たなアプローチ<a class="headerlink" href="#pep-3101-a-new-approach-to-string-formatting" title="このヘッドラインへのパーマリンク">¶</a></h2>
<ul class="simple">
<li><p class="first">組み込みの新しい文字列書式化操作で、文字列の <code class="docutils literal"><span class="pre">%</span></code> 演算子を置き換えるものです。(しかしながら <code class="docutils literal"><span class="pre">%</span></code> 演算子はまだサポートされます; Python 3.1 で非推奨となり、将来のいつかの時点で削除されます。) 完全な詳細は <span class="target" id="index-78"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3101"><strong>PEP 3101</strong></a> をお読み下さい。 (&#8212; 訳注: <a class="reference internal" href="#changes-already-present-in-python-2-6">Python 2.6 で既にあった変更</a> での対応する記述に書いた訳注を参照。&#8212;)</p>
</li>
</ul>
</div>
<div class="section" id="changes-to-exceptions">
<h2>例外に関する変更<a class="headerlink" href="#changes-to-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>例外の送出や捕捉を行う API は整理され、 強力な新機能が追加されました:</p>
<ul>
<li><p class="first"><span class="target" id="index-25"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0352"><strong>PEP 352</strong></a>: All exceptions must be derived (directly or indirectly)
from <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a>.  This is the root of the exception
hierarchy.  This is not new as a recommendation, but the
<em>requirement</em> to inherit from <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a> is new.  (Python
2.6 still allowed classic classes to be raised, and placed no
restriction on what you can catch.)  As a consequence, string
exceptions are finally truly and utterly dead.</p>
</li>
<li><p class="first">ほとんど全ての例外は、実際は <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a> を継承すべきです。 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a> は最上位で扱われるべき例外、例えば <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a> や <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> の基底クラスとしてのみ使われるべきでしす。上記カテゴリーを除く全ての例外を処理するのに推奨されるイディオムは <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a> です。</p>
</li>
<li><p class="first"><code class="xref py py-exc docutils literal"><span class="pre">StandardError</span></code> は削除されました。</p>
</li>
<li><p class="first">例外はシーケンスとして振る舞わなくなりました。代わりに <code class="xref py py-attr docutils literal"><span class="pre">args</span></code> 属性を使用してください。</p>
</li>
<li><p class="first"><span class="target" id="index-79"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3109"><strong>PEP 3109</strong></a>: 例外の送出。
<code class="samp docutils literal"><span class="pre">raise</span> <em><span class="pre">Exception</span></em><span class="pre">,</span> <em><span class="pre">args</span></em></code> ではなく <code class="samp docutils literal"><span class="pre">raise</span> <em><span class="pre">Exception</span></em><span class="pre">(</span><em><span class="pre">args</span></em><span class="pre">)</span></code> としなければなりません。
加えて、トレースバックを明示的に指定することはもう出来ません。
そう <em>しなければならない</em> 場合は、代わりに <code class="xref py py-attr docutils literal"><span class="pre">__traceback__</span></code> 属性に直接割り当てることが出来ます (下記参照).</p>
</li>
<li><p class="first"><span class="target" id="index-80"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3110"><strong>PEP 3110</strong></a>: 例外の捕捉。
<code class="samp docutils literal"><span class="pre">except</span> <em><span class="pre">SomeException</span></em><span class="pre">,</span> <em><span class="pre">variable</span></em></code> ではなく <code class="samp docutils literal"><span class="pre">except</span> <em><span class="pre">SomeException</span></em> <span class="pre">as</span> <em><span class="pre">variable</span></em></code> としなければなりません。
その上 <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> ブロックがある場合 <em>variable</em> は明示的に削除されます。</p>
</li>
<li><p class="first"><span class="target" id="index-81"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3134"><strong>PEP 3134</strong></a>: 例外の連鎖。
暗黙の連鎖と明示的な連鎖の2つの場合があります。
暗黙の連鎖は例外が <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> や <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 処理ブロックで送出されたときに起こります。
この原因は大抵処理ブロック内のバグです。
これを <em>二次的な (secondary)</em> 例外と呼びます。
この場合 (処理中の) 元々の例外は二次的な例外の <code class="xref py py-attr docutils literal"><span class="pre">__context__</span></code> 属性に保存されます。
明示的な連鎖は以下の構文で起こします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="n">SecondaryException</span><span class="p">()</span> <span class="kn">from</span> <span class="nn">primary_exception</span>
</pre></div>
</div>
<p>(<em>primary_exception</em> は例外オブジェクトを生成する任意の式です。たぶんどこかで以前捕捉した例外でしょう。) 今の場合、一次的 (primary) な例外は二次的例外の <code class="xref py py-attr docutils literal"><span class="pre">__cause__</span></code> 属性に保存されます。未捕捉の例外が起こった際に表示されるトレースバックは <code class="xref py py-attr docutils literal"><span class="pre">__cause__</span></code> と <code class="xref py py-attr docutils literal"><span class="pre">__context__</span></code> 属性を渡り歩き、そして一次的例外を一番上に置いて、連鎖のそれぞれの構成要素ごとにトレースバックを分けて表示します。(Java ユーザにはこの振る舞いは御馴染みでしょう。)</p>
</li>
<li><p class="first"><span class="target" id="index-82"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3134"><strong>PEP 3134</strong></a>: 例外オブジェクトがトレースバックを <code class="xref py py-attr docutils literal"><span class="pre">__traceback__</span></code> 属性に格納するようになりました。
つまり、例外オブジェクトが例外関連の全情報を持つようになったということです。
<a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> を使う理由は (削除されていませんが) あまりありません。</p>
</li>
<li><p class="first">Windows が拡張モジュールのロードに失敗したときの例外メッセージが少し改善しました。
例えば、<code class="docutils literal"><span class="pre">error</span> <span class="pre">code</span> <span class="pre">193</span></code> は <code class="docutils literal"><span class="pre">%1</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">a</span> <span class="pre">valid</span> <span class="pre">Win32</span> <span class="pre">application</span></code> になりました。
文字列は英語でないロケールを扱えるようになりました。</p>
</li>
</ul>
</div>
<div class="section" id="miscellaneous-other-changes">
<h2>その他の変更<a class="headerlink" href="#miscellaneous-other-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="operators-and-special-methods">
<h3>演算子と特殊メソッド<a class="headerlink" href="#operators-and-special-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li><p class="first"><code class="docutils literal"><span class="pre">!=</span></code> は <code class="docutils literal"><span class="pre">==</span></code> と逆の結果をかえします（<code class="docutils literal"><span class="pre">==</span></code> が <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal"><span class="pre">NotImplemented</span></code></a> を返さなければ）。</p>
</li>
<li><p class="first">「非束縛メソッド (unbound methods)」という概念は言語から削除されました。クラス属性としてのメソッドを参照しても今では普通の関数オブジェクトが得られます。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">__getslice__()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">__setslice__()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">__delslice__()</span></code> はお亡くなりになりました。構文 <code class="docutils literal"><span class="pre">a[i:j]</span></code> は今では <code class="docutils literal"><span class="pre">a.__getitem__(slice(i,</span> <span class="pre">j))</span></code> と解釈されます (または代入や削除で使われる場合は順に <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal"><span class="pre">__setitem__()</span></code></a> か <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></code></a>)。</p>
</li>
<li><p class="first"><span class="target" id="index-83"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3114"><strong>PEP 3114</strong></a>:  <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> 標準メソッドは <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> に改名されました。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">__oct__()</span></code> ならびに <code class="xref py py-meth docutils literal"><span class="pre">__hex__()</span></code> 特殊メソッドは削除されました。
<a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal"><span class="pre">oct()</span></code></a> ならびに <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal"><span class="pre">hex()</span></code></a> は <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> を使って引数を整数に変換します。</p>
</li>
<li><p class="first"><code class="xref py py-attr docutils literal"><span class="pre">__members__</span></code> と <code class="xref py py-attr docutils literal"><span class="pre">__methods__</span></code> は削除されました。</p>
</li>
<li>The function attributes named <code class="xref py py-attr docutils literal"><span class="pre">func_X</span></code> have been renamed to
use the <code class="xref py py-data docutils literal"><span class="pre">__X__</span></code> form, freeing up these names in the function
attribute namespace for user-defined attributes.  To wit,
<code class="xref py py-attr docutils literal"><span class="pre">func_closure</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">func_code</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">func_defaults</span></code>,
<code class="xref py py-attr docutils literal"><span class="pre">func_dict</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">func_doc</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">func_globals</span></code>,
<code class="xref py py-attr docutils literal"><span class="pre">func_name</span></code> were renamed to <code class="xref py py-attr docutils literal"><span class="pre">__closure__</span></code>,
<code class="xref py py-attr docutils literal"><span class="pre">__code__</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">__defaults__</span></code>, <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>,
<code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">__globals__</span></code>, <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a>,
respectively.</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">__nonzero__()</span></code> は <a class="reference internal" href="../reference/datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> に改名されました。</p>
</li>
</ul>
</div>
<div class="section" id="builtins">
<h3>組み込み<a class="headerlink" href="#builtins" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li><p class="first"><span class="target" id="index-84"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a>: 新しくなった <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> 。今では <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> は引数なしで呼び出せます。(これが <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 内で定義される通常のインスタンスメソッド内であると仮定して) 正しいクラスとインスタンスが自動的に選択されます。引数ありの場合の <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal"><span class="pre">super()</span></code></a> の振る舞いには変更はありません。</p>
</li>
<li><p class="first"><span class="target" id="index-85"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3111"><strong>PEP 3111</strong></a>: <code class="xref py py-func docutils literal"><span class="pre">raw_input()</span></code> が <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a> にリネームされました。つまり、新しい <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a> 関数は <a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a> から行を読み、末尾の改行を取り除いて返します。入力が時期尚早に終わってしまったら <a class="reference internal" href="../library/exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a> になります。昔の <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a> の振る舞いが欲しければ <code class="docutils literal"><span class="pre">eval(input())</span></code> としてください。</p>
</li>
<li><p class="first">新しい組み込み関数 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a> が追加されました。 オブジェクトの <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドを呼び出します。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a> 関数の丸めの戦略と戻り値の型が変更されました。ど真ん中の場合に、四捨五入ではなく最近接偶数への丸めをするようになりました。(例えば <code class="docutils literal"><span class="pre">round(2.5)</span></code> は今では <code class="docutils literal"><span class="pre">2</span></code> を返します。 <code class="docutils literal"><span class="pre">3</span></code> ではなく。) (&#8212;訳注: 丸めモードについては <a class="reference external" href="https://en.wikipedia.org/wiki/Rounding#Tie-breaking">Wikipedia</a> 参照。&#8212;) <code class="docutils literal"><span class="pre">round(x[,</span> <span class="pre">n])</span></code> は常に浮動小数点数の結果を返す代わりに、 <code class="docutils literal"><span class="pre">x.__round__([n])</span></code> に処理を委譲するようになりました。これは一般的に、単一引数で呼ばれた際に整数を返し、二つの引数で呼ばれた場合は <code class="docutils literal"><span class="pre">x</span></code> と同じ型の値として返します。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">intern()</span></code> は <a class="reference internal" href="../library/sys.html#sys.intern" title="sys.intern"><code class="xref py py-func docutils literal"><span class="pre">sys.intern()</span></code></a> に移動しました。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">apply()</span></code> は削除されました。 <code class="docutils literal"><span class="pre">apply(f,</span> <span class="pre">args)</span></code> の代わりに <code class="docutils literal"><span class="pre">f(*args)</span></code> を使用してください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/functions.html#callable" title="callable"><code class="xref py py-func docutils literal"><span class="pre">callable()</span></code></a> は削除されました。 <code class="docutils literal"><span class="pre">callable(f)</span></code> のかわりに <code class="docutils literal"><span class="pre">isinstance(f,</span> <span class="pre">collections.Callable)</span></code> を使用してください。 <code class="xref py py-func docutils literal"><span class="pre">operator.isCallable()</span></code> も削除されました。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">coerce()</span></code> は削除されました。古い形式のクラスが削除されたため、この関数は必要ありません。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">execfile()</span></code> は削除されました。 <code class="docutils literal"><span class="pre">execfile(fn)</span></code> の代わりに <code class="docutils literal"><span class="pre">exec(open(fn).read())</span></code> を使用してください。</p>
</li>
<li>Removed the <code class="xref py py-class docutils literal"><span class="pre">file</span></code> type.  Use <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>.  There are now several
different kinds of streams that open can return in the <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> module.</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">reduce()</span></code> は削除されました。もし本当に必要なら <a class="reference internal" href="../library/functools.html#functools.reduce" title="functools.reduce"><code class="xref py py-func docutils literal"><span class="pre">functools.reduce()</span></code></a> を使用してください。ほぼ間違いなく <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループのほうがより可読性が高いでしょう。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">reload()</span></code> は削除されました。  <a class="reference internal" href="../library/imp.html#imp.reload" title="imp.reload"><code class="xref py py-func docutils literal"><span class="pre">imp.reload()</span></code></a> を使用してください。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">dict.has_key()</span></code> は削除されました &#8211; 代わりに <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 演算子を使用してください。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="build-and-c-api-changes">
<h2>ビルドならびに C API の変更<a class="headerlink" href="#build-and-c-api-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>時間がないため、以下のC APIへの変更点のリストは <em>かなり</em> 不完全です。</p>
<ul class="simple">
<li><p class="first">Mac OS 9, BeOS, RISCOS, Irix, Tru64 に限らず、いくつものプラットフォームのサポートが打ち切られました。</p>
</li>
<li><p class="first"><span class="target" id="index-86"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a>: 新たなバッファ API。</p>
</li>
<li><p class="first"><span class="target" id="index-87"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3121"><strong>PEP 3121</strong></a>: 例外モジュールの初期化と最終化</p>
</li>
<li><p class="first"><span class="target" id="index-88"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3123"><strong>PEP 3123</strong></a>: <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal"><span class="pre">PyObject_HEAD</span></code></a> を標準的な C に一致。</p>
</li>
<li><p class="first">制限付き実行 の C API サポートはこれ以上されません。</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">PyNumber_Coerce()</span></code>、<code class="xref c c-func docutils literal"><span class="pre">PyNumber_CoerceEx()</span></code>、<code class="xref c c-func docutils literal"><span class="pre">PyMember_Get()</span></code>、および <code class="xref c c-func docutils literal"><span class="pre">PyMember_Set()</span></code> C APIs は削除されました。</p>
</li>
<li><p class="first">新たな C API <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModuleNoBlock" title="PyImport_ImportModuleNoBlock"><code class="xref c c-func docutils literal"><span class="pre">PyImport_ImportModuleNoBlock()</span></code></a>、<a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal"><span class="pre">PyImport_ImportModule()</span></code></a> のように動きますが、インポートロックでブロックしません (代わりにエラーを返します)。</p>
</li>
<li><p class="first">ブール変換の C 水準のスロットとメソッドがリネームされました: <code class="docutils literal"><span class="pre">nb_nonzero</span></code> が <code class="docutils literal"><span class="pre">nb_bool</span></code> になりました。</p>
</li>
<li><p class="first">C API から <code class="xref c c-macro docutils literal"><span class="pre">METH_OLDARGS</span></code> と <code class="xref c c-macro docutils literal"><span class="pre">WITH_CYCLE_GC</span></code> が削除されました。</p>
</li>
</ul>
</div>
<div class="section" id="performance">
<h2>性能<a class="headerlink" href="#performance" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>3.0 の可搬化 (generalization) による正味の結果は、Python 3.0 を pystone ベンチマークすると Python 2.5 より 10% 遅くなる、というものでした。これはどうやら小さい整数についての特殊処理を削除したことに一番大きな要因があるようです。これには改善の余地がありますが、それは 3.0 リリース以降でしょう!</p>
</div>
<div class="section" id="porting-to-python-3-0">
<h2>Python 3.0 への移植<a class="headerlink" href="#porting-to-python-3-0" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>(&#8212;訳注: 今では独立したクックブック <a class="reference internal" href="../howto/pyporting.html#pyporting-howto"><span class="std std-ref">Python 2 から Python 3 への移植</span></a> があるのでそちらをご覧下さい。&#8212;) 既存の Python 2.5 や 2.6 のソースコードを Python 3.0 に移植する最良の策は以下の通りです:</p>
<ol class="arabic simple" start="0">
<li><p class="first">(必須:) 優秀なテストカバレッジから始めてください。</p>
</li>
<li><p class="first">Python 2.6 に移植します。Python 2.x を Python 2.(x+1) に移植する普通の作業以上のことをしてはいけません。確実に全てのテストを通してください。</p>
</li>
<li>(Still using 2.6:) Turn on the <code class="xref std std-option docutils literal"><span class="pre">-3</span></code> command line switch.
This enables warnings about features that will be removed (or
change) in 3.0.  Run your test suite again, and fix code that you
get warnings about until there are no warnings left, and all your
tests still pass.</li>
<li><p class="first"><code class="docutils literal"><span class="pre">2to3</span></code> をあなたのソースコードツリーに対して走らせます (このツールの詳細については <a class="reference internal" href="../library/2to3.html#to3-reference"><span class="std std-ref">2to3 - Python 2 から 3 への自動コード変換</span></a> をみてください)。Python 3.0 で変換結果のコードを走らせます。何か問題が残っていれば手動で修正し、修正後も全てのテストをパスするようにします。</p>
</li>
</ol>
<p>Python 2.6 と 3.0 両方で変更なしに動作するコードを書こうとすることはお奨め出来ません; それをするととても捻じ曲がったコーディングスタイルを使う必要があるでしょう。例えば <code class="docutils literal"><span class="pre">print</span></code> やメタクラスを避けたりとかそんな。Python 2.6 と 3.0 両バージョンともに対するサポートを必要とするライブラリを保守しているのであれば、最良のアプローチは上記スリーステップを修正して、2.6 版のソースコードを編集して <code class="docutils literal"><span class="pre">2to3</span></code> する、を繰り返すことです。これは 3.0 版のソースコードを編集するより良いです。(&#8212;訳注: ここで言っていることは正論なのですが、 <code class="docutils literal"><span class="pre">2to3</span></code> は「Python 3 では動くが Python 2 では動かない (かもしれない)」ものを生成します。2016 時点でも Python 2.7 はかなり元気 (予定では 2020 年までは公式にサポートされる) ですので両バージョン (ただし今だと 2.7 と 3.2 以降) で変更なしで動作するものを必要とすることは、残念ながらまだ多いでしょう (あなたが作っているのがライブラリであるならば)。これについては <a class="reference internal" href="../howto/pyporting.html#pyporting-howto"><span class="std std-ref">Python 2 から Python 3 への移植</span></a> に少し書かれています。 &#8212;)</p>
<p>C 拡張を Python 3.0 に移植するには、 <a class="reference internal" href="../howto/cporting.html#cporting-howto"><span class="std std-ref">Python 3 への拡張モジュール移植</span></a> を参照してください。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">What&#8217;s New In Python 3.0</a><ul>
<li><a class="reference internal" href="#common-stumbling-blocks">よくある悩みの種</a><ul>
<li><a class="reference internal" href="#print-is-a-function">print関数</a></li>
<li><a class="reference internal" href="#views-and-iterators-instead-of-lists">リストからビューおよびイテレータへ</a></li>
<li><a class="reference internal" href="#ordering-comparisons">順序比較</a></li>
<li><a class="reference internal" href="#integers">整数</a></li>
<li><a class="reference internal" href="#text-vs-data-instead-of-unicode-vs-8-bit">Unicode 対 8 ビット、ではなく、テキスト対データに</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-syntax-changes">構文の変更の概要</a><ul>
<li><a class="reference internal" href="#new-syntax">新たな構文</a></li>
<li><a class="reference internal" href="#changed-syntax">変更された構文</a></li>
<li><a class="reference internal" href="#removed-syntax">削除された操作</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes-already-present-in-python-2-6">Python 2.6 で既にあった変更</a></li>
<li><a class="reference internal" href="#library-changes">ライブラリの変更</a></li>
<li><a class="reference internal" href="#pep-3101-a-new-approach-to-string-formatting"><strong>PEP 3101</strong>: 文字列整形の新たなアプローチ</a></li>
<li><a class="reference internal" href="#changes-to-exceptions">例外に関する変更</a></li>
<li><a class="reference internal" href="#miscellaneous-other-changes">その他の変更</a><ul>
<li><a class="reference internal" href="#operators-and-special-methods">演算子と特殊メソッド</a></li>
<li><a class="reference internal" href="#builtins">組み込み</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">ビルドならびに C API の変更</a></li>
<li><a class="reference internal" href="#performance">性能</a></li>
<li><a class="reference internal" href="#porting-to-python-3-0">Python 3.0 への移植</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="3.1.html"
                        title="前の章へ">What&#8217;s New In Python 3.1</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2.7.html"
                        title="次の章へ">What&#8217;s New in Python 2.7</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/whatsnew/3.0.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="What’s New in Python 2.7"
             >次へ</a> |</li>
        <li class="right" >
          <a href="3.1.html" title="What’s New In Python 3.1"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What&#8217;s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 9月 02, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>