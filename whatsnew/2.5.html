
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What’s New in Python 2.5 &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="What’s New in Python 2.4" href="2.4.html" />
    <link rel="prev" title="What’s New in Python 2.6" href="2.6.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/whatsnew/2.5.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/whatsnew/2.5.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="What’s New in Python 2.4"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="What’s New in Python 2.6"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What’s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-2-5">
<h1>What’s New in Python 2.5<a class="headerlink" href="#what-s-new-in-python-2-5" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">A.M. Kuchling</td>
</tr>
</tbody>
</table>
<p>この文書は Python 2.5 の新機能について解説します。 Python 2.5 の最終リリースは 2006 年 8 月にスケジュールされました。<span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0356"><strong>PEP 356</strong></a> が予定されたリリーススケジュールを記述しています。</p>
<p>Python 2.5 の変更は言語とライブラリの改善の面白い組み合わせになりました。ライブラリの強化のほうが Python ユーザコミュニティにとっては重要でしょう。多数の大変利用価値の高いパッケージが追加されました。新しいモジュールとしては、XML 処理のための ElementTree (<code class="xref py py-mod docutils literal"><span class="pre">xml.etree</span></code>)、SQLite データベースのためのモジュール(<code class="xref py py-mod docutils literal"><span class="pre">sqlite</span></code>)、そして C 関数呼び出しのためのモジュール <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> があります。</p>
<p>言語の変更の意義は、中程度のものです。いくつかの心地よい機能が入りましたが、そのほとんどの機能は毎日使うというものでもありません。条件式(conditional expressions)がついに言語に追加されました。ちょっと変わった文法です。 <a class="reference internal" href="#pep-308"><span class="std std-ref">PEP 308: 条件式 (Conditional Expressions)</span></a> のセクションを参照してください。新しい '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' 文は後始末のコードを書くのを簡単にします(<a class="reference internal" href="#pep-343"><span class="std std-ref">PEP 343: &quot;with&quot; ステートメント</span></a> セクション)。ジェネレータに値を返すことが出来るようになりました(<a class="reference internal" href="#pep-342"><span class="std std-ref">PEP 342: ジェネレータの新機能</span></a> セクション)。インポートが、絶対パス、相対パスのどちらかで可視に出来るようになりました(<a class="reference internal" href="#pep-328"><span class="std std-ref">PEP 328: 絶対インポート、相対インポート</span></a> セクション)。例外ハンドリングのいくつかの境界のケースで、より良いハンドリングを行えるようになりました(<a class="reference internal" href="#pep-341"><span class="std std-ref">PEP 341: try/except/finally の一体化</span></a> セクション)。これらのどの改善も価値が高いですが、それらは言語機能を限定的に改善するものであって、いずれも Python のセマンティクスを広範に修正するものではありません。</p>
<p>言語とライブラリの追加と同様に、ほかの改善とバグフィックスもソースツリー全体に渡っています。SVN 変更ログを検索すると、Python 2.4 から 2.5 の間で適用されたパッチは 353、フィックスされたバグは 458 ありました(ともに少なく見積もってです)。</p>
<p>このドキュメントは新機能の完全な詳細を提供するのではなくて、変更について、役に立つ実例を使った簡易な概要を提供することを目的にしています。完全な詳細が知りたければ常に、 <a class="reference external" href="https://docs.python.org">https://docs.python.org</a> の Python 2.6 のドキュメントを参照すべきです。設計と実装の根拠を理解したい場合は、新機能に関する PEP を参照してください。可能な限り、 &quot;What’s New in Python&quot; は各変更の bug や patch に対してリンクしています。</p>
<p>このドキュメントについてのコメント、提案と誤りの報告は歓迎です。著者に電子メールを送るか、または Python バグトラッカーにバグをあげてください。</p>
<div class="section" id="pep-308-conditional-expressions">
<span id="pep-308"></span><h2>PEP 308: 条件式 (Conditional Expressions)<a class="headerlink" href="#pep-308-conditional-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>もう長いことずっと、人々は条件式を書くための手段を要望し続けてきました。それは Boolean 値が真か偽かによって値 A または B を返す式です。条件式により以下と同じ効果を持つ単一行代入式を書くことが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">true_value</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">false_value</span>
</pre></div>
</div>
<p>構文についての退屈で終わりのない議論が python-dev と comp.lang.python の両方で続いてきました。投票では、大半は何らかの形で条件式を望んでいることを示していましたが、明らかな過半数によって支持される構文はありませんでした。候補には C の <code class="docutils literal"><span class="pre">cond</span> <span class="pre">?</span> <span class="pre">true_v</span> <span class="pre">:</span> <span class="pre">false_v</span></code> や <code class="docutils literal"><span class="pre">if</span> <span class="pre">cond</span> <span class="pre">then</span> <span class="pre">true_v</span> <span class="pre">else</span> <span class="pre">false_v</span></code> を含む、ほか 16 のバリエーションがありました。</p>
<p>Guido van Rossum は結果として意外な構文を選択しました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">true_value</span> <span class="k">if</span> <span class="n">condition</span> <span class="k">else</span> <span class="n">false_value</span>
</pre></div>
</div>
<p>評価はこれでも既存の Boolean 式のように遅延的であり、評価順は少々前後します。真ん中の <em>condition</em> はまさに最初に評価されるのであって、 <em>true_value</em> 式はその <em>condition</em> が真の場合にのみ評価されます。同じように <em>false_value</em> は <em>condition</em> が偽の場合にのみ評価されるのです。</p>
<p>この構文は奇妙で退行しているようにも思えます; どうして condition が <em>真ん中</em> にあって C の <code class="docutils literal"><span class="pre">c</span> <span class="pre">?</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">y</span></code> のように前にないのでしょう? この決定は、標準ライブラリ内のモジュールにその新構文を適用し、結果のコードをどう読むかを見ることでチェックされました。条件式が使われる多くの場合で、一つの値はどうやら「一般の場合」で一つの値は「例外的な場合」のようで、条件を満たさないことが稀な場合にのみ使われていました。条件の構文はこのパターンで少しばかり明快さを増します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">contents</span> <span class="o">=</span> <span class="p">((</span><span class="n">doc</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">doc</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>私には上記ステートメントはこう読めます。「 <em>contents</em> は普通は <code class="docutils literal"><span class="pre">doc+'\n'</span></code> の値に代入される。ただし時々 <em>doc</em> が空になる。その特別な場合には空の値が代入されるのだ」。私は普通と普通でないのが明らかでない場合に頻繁に条件式を使うとは思いません。</p>
<p>言語が条件式に括弧を必要とすべきかどうかに関していくつか議論がありました。決定は Python 言語文法として括弧は <em>必要ない</em> とされましたが、スタイルの問題としては私は常に括弧を付けるべきと思います。以下 2 つの例を考えてみてください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># First version -- no parens</span>
<span class="n">level</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">logging</span> <span class="k">else</span> <span class="mi">0</span>

<span class="c1"># Second version -- with parens</span>
<span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">logging</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>最初の版の場合、私は読者の目はおそらくステートメントを「level = 1」「if logging」「else 0」にグループ化すると思います。そして condition は <em>level</em> への代入が行われるのかどうかを決めるのだ、と考えるであろうと。後者の版は読みやすいです、少なくとも私の意見では。代入はいつでも行われることも、選択が 2 つの値の間で起こることもはっきりしますから。</p>
<p>括弧を含めるもう一つの理由があります: 少し奇妙なリスト内包とラムダの組合せが、不完全な条件式になることがあります。 <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> にいくつかの例があるので見てください。条件式の周りをいつでも括弧で囲むなら、このケースにぶち当たることもありません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> - 条件式 (Conditional Expressions)</dt>
<dd>PEP 著 Guido van Rossum と Raymond D. Hettinger; 実装 Thomas Wouters.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-309-partial-function-application">
<span id="pep-309"></span><h2>PEP 309: 関数の部分適用<a class="headerlink" href="#pep-309-partial-function-application" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal"><span class="pre">functools</span></code></a> モジュールは、関数型スタイルのプログラミングのためのツールを含むことを意図したものです。</p>
<p>このモジュールには一つの有用なツールとして、 <code class="xref py py-func docutils literal"><span class="pre">partial()</span></code> 関数があります。関数型スタイルでプログラムを書くのに、あなたはときおり、いくつかのパラメータを持つ関数に一部パラメータを埋めたものを作りたくなります。Python 関数 <code class="docutils literal"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> を考えてみましょう; <code class="docutils literal"><span class="pre">f(1,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> と等価な <code class="docutils literal"><span class="pre">g(b,</span> <span class="pre">c)</span></code> を作れたら、と思うわけです。これは「関数の部分適用」と呼ばれています。</p>
<p><code class="docutils literal"><span class="pre">partial</span></code> は <code class="docutils literal"><span class="pre">(function,</span> <span class="pre">arg1,</span> <span class="pre">arg2,</span> <span class="pre">...</span> <span class="pre">kwarg1=value1,</span> <span class="pre">kwarg2=value2)</span></code> という引数を取ります。できあがったオブジェクトは呼び出し可能オブジェクトですので、それを呼べば、引数の埋まった <code class="docutils literal"><span class="pre">function</span></code> を実行したのと同じことになります。</p>
<p>以下にあるのは、小さいけれども現実的な一つの例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">log</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">subsystem</span><span class="p">):</span>
    <span class="s2">&quot;Write the contents of &#39;message&#39; to the specified subsystem.&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">subsystem</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="o">...</span>

<span class="n">server_log</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">subsystem</span><span class="o">=</span><span class="s1">&#39;server&#39;</span><span class="p">)</span>
<span class="n">server_log</span><span class="p">(</span><span class="s1">&#39;Unable to open socket&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>もうひとつ、PyGTK を使うプログラムからの例をみてみましょう。いま、「コンテキスト依存」のポップアップメニューを動的に構築しようとしています。そのメニューオプションから提供されるコールバックは、 <code class="xref py py-meth docutils literal"><span class="pre">open_item()</span></code> メソッドの部分適用版で、その最初の引数が適用済みです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="k">class</span> <span class="nc">Application</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">open_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="nf">init</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">open_func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_item</span><span class="p">,</span> <span class="n">item_path</span><span class="p">)</span>
        <span class="n">popup_menu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="s2">&quot;Open&quot;</span><span class="p">,</span> <span class="n">open_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal"><span class="pre">functools</span></code></a> モジュールのもう一つの関数は <code class="docutils literal"><span class="pre">update_wrapper(wrapper,</span> <span class="pre">wrapped)</span></code> で、より良く振舞うデコレータを書くのに役立ちます。 <code class="xref py py-func docutils literal"><span class="pre">update_wrapper()</span></code> は包まれるほうの名前、モジュール、ドキュメンテーション文字列属性をラッパー関数にコピーすることで、トレースバックを理解しやすくします。たとえばこう書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Calling decorated function&#39;</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">wraps()</span></code> は、ラップされる関数についての情報をコピーするために、あなた自身のデコレータ内で使えるデコレータです。先の例はこのようにも書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Calling decorated function&#39;</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0309"><strong>PEP 309</strong></a> - 関数の部分適用</dt>
<dd>PEP の提案と著:  Peter Harris; 実装: Hye-Shik Chang と Nick Coghlan, また、適応物が Raymond Hettinger により。 (—訳注: この PEP のタイトルに違和感を憶える人は多いと思います。functools のテリトリが「関数型スタイルのサポート」にあるのに。部分引数サポートのためのパッチが最終的に関数型スタイルに行き着いた (正確には、「partial のような高階関数を置く場所として functools という場所を使いましょう、partial から始めましょう」というのが提案の趣旨)、という経緯がこのタイトルに反映しています。—)</dd>
</dl>
</div>
</div>
<div class="section" id="pep-314-metadata-for-python-software-packages-v1-1">
<span id="pep-314"></span><h2>PEP 314: Metadata for Python Software Packages v1.1<a class="headerlink" href="#pep-314-metadata-for-python-software-packages-v1-1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Distutils にいくつかの単純な依存性解決サポートが追加されました。 <code class="xref py py-func docutils literal"><span class="pre">setup()</span></code> 関数に <code class="docutils literal"><span class="pre">requires</span></code>, <code class="docutils literal"><span class="pre">provides</span></code>,  <code class="docutils literal"><span class="pre">obsoletes</span></code> キーワードパラメータが追加されています。 <code class="docutils literal"><span class="pre">sdist</span></code> コマンドでソース配布物をビルドする際に、依存性についての情報が <code class="file docutils literal"><span class="pre">PKG-INFO</span></code> ファイルに記録されます。</p>
<p>もう一つ追加されたキーワードパラメータ <code class="docutils literal"><span class="pre">download_url</span></code> は、パッケージのソースコードの URL をセットします。これによりパッケージインデクス内のエントリを探し出すことが出来、パッケージの依存性を決めることが出来、必要パッケージをダウンロード出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">VERSION</span> <span class="o">=</span> <span class="s1">&#39;1.0&#39;</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;PyPackage&#39;</span><span class="p">,</span>
      <span class="n">version</span><span class="o">=</span><span class="n">VERSION</span><span class="p">,</span>
      <span class="n">requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numarray&#39;</span><span class="p">,</span> <span class="s1">&#39;zlib (&gt;=1.1.4)&#39;</span><span class="p">],</span>
      <span class="n">obsoletes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;OldPackage&#39;</span><span class="p">]</span>
      <span class="n">download_url</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/pypackage/dist/pkg-</span><span class="si">%s</span><span class="s1">.tar.gz&#39;</span>
                    <span class="o">%</span> <span class="n">VERSION</span><span class="p">),</span>
     <span class="p">)</span>
</pre></div>
</div>
<p>Python Package Index (<a class="reference external" href="https://pypi.python.org">https://pypi.python.org</a>) へのもう一つの新たな拡張は、パッケージについてのソースコードとバイナリアーカイブの保存についてです。新たな Distutils コマンド <strong class="command">upload</strong> は、レポジトリへパッケージをアップロードします。</p>
<p>パッケージがアップロードされる前には、Distutils <strong class="command">sdist</strong> コマンドを使って配布物をビルド可能でなければなりません。それさえ出来ていれば、 <code class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">upload</span></code> がパッケージを PyPI アーカイブに追加してくれます。追加で、パッケージに GPG 署名出来ます。これには <code class="xref std std-option docutils literal"><span class="pre">--sign</span></code> オプションと <code class="xref std std-option docutils literal"><span class="pre">--identity</span></code> オプションを使います。</p>
<p>パッケージのアップロードは Martin von Löwis と Richard Jones により実装されました。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0314"><strong>PEP 314</strong></a> - Metadata for Python Software Packages v1.1</dt>
<dd>PEP 提案と著 A.M. Kuchling、 Richard Jones、 Fred Drake; 実装 Richard Jones と Fred Drake.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-328-absolute-and-relative-imports">
<span id="pep-328"></span><h2>PEP 328: 絶対インポート、相対インポート<a class="headerlink" href="#pep-328-absolute-and-relative-imports" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>PEP 328 のうち簡単な方は Python 2.4 で実装されました: <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">names</span></code> 文において、 names を丸括弧で囲むことが出来るようにすることで、たくさんの名前をインポートしやすくしました。</p>
<p>より複雑なほうは Python 2.5 で実装されました: モジュールのインポートにおいて、それが絶対インポートなのかパッケージ相対のインポートなのかを指定出来るようにする、というものです。将来のバージョンの Python では絶対インポートをデフォルトにする方向に向かう予定です。</p>
<p>いま、あなたは以下のようなパッケージディレクトリを持っているとします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">pkg</span><span class="o">/</span>
<span class="n">pkg</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
<span class="n">pkg</span><span class="o">/</span><span class="n">main</span><span class="o">.</span><span class="n">py</span>
<span class="n">pkg</span><span class="o">/</span><span class="n">string</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p><code class="xref py py-mod docutils literal"><span class="pre">pkg</span></code> パッケージがモジュール <code class="xref py py-mod docutils literal"><span class="pre">pkg.main</span></code> とサブモジュール <code class="xref py py-mod docutils literal"><span class="pre">pkg.string</span></code> を持っています。</p>
<p><code class="file docutils literal"><span class="pre">main.py</span></code> のなかの人、になってみましょう。 <code class="docutils literal"><span class="pre">import</span> <span class="pre">string</span></code> 文を実行すると、何が起こるでしょうか? Python 2.4 とそれ以前のバージョンでは、相対インポートとして実行するためにパッケージのディレクトリ内のものを最初に探し、 <code class="file docutils literal"><span class="pre">pkg/string.py</span></code> を発見してそのファイル内容を <code class="xref py py-mod docutils literal"><span class="pre">pkg.string</span></code> モジュールであるとしてインポートし、そのモジュールは <code class="xref py py-mod docutils literal"><span class="pre">pkg.main</span></code> モジュール内の名前空間で、名前 <code class="docutils literal"><span class="pre">string</span></code> に束縛されます。</p>
<p>よろしいでしょう。欲しいものが <code class="xref py py-mod docutils literal"><span class="pre">pkg.string</span></code> であるならば。ですが欲しいのは Python 標準ライブラリモジュールの <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> なのだとしたら? <code class="xref py py-mod docutils literal"><span class="pre">pkg.string</span></code> を無視して標準モジュールを探す綺麗な方法はありません; 一般的に、 <code class="docutils literal"><span class="pre">sys.modules</span></code> の中身から探す必要がありました。これはちょっとばかり美しくありません。Holger Krekel の <code class="xref py py-mod docutils literal"><span class="pre">py.std</span></code> パッケージは標準ライブラリからモジュールをインポートするのに <code class="docutils literal"><span class="pre">import</span> <span class="pre">py;</span> <span class="pre">py.std.string.join()</span></code> と、よりこぎれいな方法を与えてくれますが、そのパッケージは全ての Python インストレーションでの利用が可能にはなっていません。</p>
<p>相対インポートに頼ったコードを読むことは、より不明瞭でもあります。読者は <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> と <code class="xref py py-mod docutils literal"><span class="pre">pkg.string</span></code> のどちらを使おうとしているのかについて、混乱するだろうからです。Python ユーザはすぐに、彼らのパッケージのサブモジュール名が標準ライブラリモジュールの名前と被らないようにすることを学びますが、あなたのサブモジュール名が将来のバージョンの Python に追加される新しいモジュールで使われる名前にならないようにすることは出来ません。</p>
<p>Python 2.5 では <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> の振る舞いを、 <code class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">absolute_import</span></code> ディレクティブを使うことによって絶対インポートに切り替えられます。この絶対インポートの振る舞いは将来バージョンの Python でデフォルトになります(おそらく Python 2.7 で)。(訳注: ご承知のとおり Python 2.7 でもこれはデフォルトとはなっていません。Python 3.x への移行のためにも 2.5 - 2.7 では <code class="docutils literal"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">absolute_import</span></code> を使うべきです。) 絶対インポートをデフォルトにしてしまえば、 <code class="docutils literal"><span class="pre">import</span> <span class="pre">string</span></code> はいつでも標準ライブラリ版を見つけます。ユーザは可能な限り絶対インポートを使い始めるべきで、あなたのコードでは <code class="docutils literal"><span class="pre">from</span> <span class="pre">pkg</span> <span class="pre">import</span> <span class="pre">string</span></code> と書き始めることが望まれます。</p>
<p>相対インポートは、 <code class="docutils literal"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> 形式を使う際にモジュール名の前にピリオドを付ければまだ可能です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Import names from pkg.string</span>
<span class="kn">from</span> <span class="nn">.string</span> <span class="k">import</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span>
<span class="c1"># Import pkg.string</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">string</span>
</pre></div>
</div>
<p>これは現在のパッケージからの相対で <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> モジュールをインポートしますので、 <code class="xref py py-mod docutils literal"><span class="pre">pkg.main</span></code> 内ではこれは、 <em>name1</em> と <em>name2</em> を <code class="xref py py-mod docutils literal"><span class="pre">pkg.string</span></code> からインポートするでしょう。加えて、先行する複数ピリオドは、現在のパッケージの親からの相対インポートを実行します。例えば、 <code class="xref py py-mod docutils literal"><span class="pre">A.B.C</span></code> モジュール内のコードはこのように出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">D</span>                 <span class="c1"># Imports A.B.D</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">E</span>                <span class="c1"># Imports A.E</span>
<span class="kn">from</span> <span class="nn">..F</span> <span class="k">import</span> <span class="n">G</span>               <span class="c1"># Imports A.F.G</span>
</pre></div>
</div>
<p>このピリオドによる書き方は <code class="docutils literal"><span class="pre">import</span> <span class="pre">modname</span></code> 形式のインポート文では使えず、 <code class="docutils literal"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> 形式でのみ使えます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> - マルチラインインポートと、絶対/相対インポート</dt>
<dd>PEP 著 Aahz; 実装 Thomas Wouters。</dd>
<dt><a class="reference external" href="https://pylib.readthedocs.org/">https://pylib.readthedocs.org/</a></dt>
<dd>Holger Krekel による py ライブラリで、 <code class="xref py py-mod docutils literal"><span class="pre">py.std</span></code> パッケージを含みます。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-338-executing-modules-as-scripts">
<span id="pep-338"></span><h2>PEP 338 - モジュールをスクリプトとして実行する<a class="headerlink" href="#pep-338-executing-modules-as-scripts" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.4 で追加されたモジュールをスクリプトとして実行するための <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> スイッチが、少し能力を高めました。Python インタプリタ内での C 実装に代わり、これの実現には新しいモジュール <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal"><span class="pre">runpy</span></code></a> を使うようになっています。</p>
<p><a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal"><span class="pre">runpy</span></code></a> モジュールはインポートのメカニズムをより洗練された方法で実装しているので、今では <code class="xref py py-mod docutils literal"><span class="pre">pychecker.checker</span></code> のようにパッケージ内のモジュールも実行出来ます。このモジュールは異なるインポートメカニズム、例えば <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal"><span class="pre">zipimport</span></code></a> モジュールもサポートします。このことにより、 <code class="docutils literal"><span class="pre">sys.path</span></code> に .zip アーカイブのパスを追加して、 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> スイッチでアーカイブ内のコードを実行する、といったことも出来ます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0338"><strong>PEP 338</strong></a> - モジュールをスクリプトとして実行する</dt>
<dd>PEP 著と実装 Nick Coghlan.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-341-unified-try-except-finally">
<span id="pep-341"></span><h2>PEP 341: try/except/finally の一体化<a class="headerlink" href="#pep-341-unified-try-except-finally" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.5 までは <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> ステートメントには 2 種類の味付けがありました。それを <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> ブロックに使うことが出来、それである種のコードの実行が必ず行われるように出来ましたし、一つあるいはそれより多くの <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> ブロックのために使うことが出来、それで指定した例外を捕捉出来ました。けれども <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> ブロックと <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> ブロックを同時に組み合わせることは出来なかったのは、その組み合わせた版のための正しいバイトコードを生成することが複雑で、組み合わせたステートメントがどんなセマンティクスであるべきなのかが明らかではなかったからです。</p>
<p>Guido van Rossum はいくらかの時間 Java での作業に時間を割きました。それは <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> ブロックと <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> ブロックを組み合わせるのと等価なものをサポートしています。そしてこの作業が、このステートメントがどういう意味であるべきかを明らかにしたのです。Python 2.5 では、あなたは今ではこう書くことが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">block</span><span class="o">-</span><span class="mi">1</span> <span class="o">...</span>
<span class="k">except</span> <span class="n">Exception1</span><span class="p">:</span>
    <span class="n">handler</span><span class="o">-</span><span class="mi">1</span> <span class="o">...</span>
<span class="k">except</span> <span class="n">Exception2</span><span class="p">:</span>
    <span class="n">handler</span><span class="o">-</span><span class="mi">2</span> <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">else</span><span class="o">-</span><span class="n">block</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">final</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p><em>block-1</em> 内のコードが実行されます。そのコードが例外を投げた場合、個々の <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> ブロックがテストされます: その例外が <code class="xref py py-class docutils literal"><span class="pre">Exception1</span></code> クラスであれば、 <em>handler-1</em> が実行されます; そうでない場合で <code class="xref py py-class docutils literal"><span class="pre">Exception2</span></code> クラスであれば、 <em>handler-2</em> が実行されます、以下同文。例外が起こらなければ、 <em>else-block</em> が実行されます。</p>
<p>以前に何が起こったのかに拠らず、コードブロック完了時やどれかの例外が処理されれば <em>final-block</em> が実行されます。例外ハンドラ内や <em>else-block</em> でエラーが起こったり、 新しく例外を投げる場合でさえ、 <em>final-block</em> 内のコードはそれでも実行されます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0341"><strong>PEP 341</strong></a> - try-except と try-finally を一体化する</dt>
<dd>PEP 著 Georg Brandl; 実装 Thomas Lee。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-342-new-generator-features">
<span id="pep-342"></span><h2>PEP 342: ジェネレータの新機能<a class="headerlink" href="#pep-342-new-generator-features" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.5 は、ジェネレータ <em>に向けて</em> 値を渡すための単純な手段を追加しました。Python 2.3 でジェネレータが導入された時点ではジェネレータが出来たのは出力だけでした。いったんジェネレータのコードが呼び出されてイテレータが作られたあとは、新しい情報をそのジェネレータ関数の再開位置に渡す手段はありませんでした。ヤクザな解決法としては、ジェネレータがグローバル変数を見るようにしたり、ミュータブルなオブジェクトを渡しておいて呼び出し元であとからそれを変更したり、といったものがありました。</p>
<p>基本的なジェネレータについて思い出してもらいましょう、単純な例はこんなです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">counter</span> <span class="p">(</span><span class="n">maximum</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">counter(10)</span></code> を呼び出すと、その結果は 0 から 10 までの値を返すイテレータです。 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文 (statement) に出会うと、そのイテレータは準備された値を返して、ローカル変数は保存しつつ関数の実行は一時停止します。続くイテレータの <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a> メソッド呼び出しによって実行がその <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文の次から再開します。</p>
<p>Python 2.3 では <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> は文 (statement) でした。しかるにそれでは値を返しません。Python 2.5 で <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> は式 (expression) になりました。値を返すわけですから、変数に代入出来ますし、ほかの演算に使えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>戻り値に何かする際は、 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式の周りには括弧は付けておいたほうがいいと思います、この例でのように。括弧はべつに必要はないのですが、どんな場合に必要かを憶えるよりは、いつでも付けるのが簡単でしょう。</p>
<p>(<span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 342</strong></a> がその規則を正確に説明していますが、それによると <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式は、代入式で右辺のトップレベルにあるとき以外はいつも括弧を付ける必要があります。つまり <code class="docutils literal"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">i</span></code> とは書けますが、 <code class="docutils literal"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">(yield</span> <span class="pre">i)</span> <span class="pre">+</span> <span class="pre">12</span></code> のように演算子があるときは括弧を使わなくてはいけません。)</p>
<p>ジェネレータに値を送るには <code class="docutils literal"><span class="pre">send(value)</span></code> メソッドを呼びます。するとジェネレータのコードが実行を再開し、 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a>  式がその <em>value</em> を返すのです。ふつうの <code class="docutils literal"><span class="pre">next()</span></code> メソッドを呼ぶと、 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> は <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します。</p>
<p>以下は前のと同じ例ですが、内部カウンタの値の変更を許す修正をしました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">counter</span> <span class="p">(</span><span class="n">maximum</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># If value provided, change counter</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>そしてカウンタ変更の例がこちらです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="n">counter</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;t.py&quot;</span>, line <span class="m">15</span>, in <span class="n">?</span>
    <span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> が <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返すことはよくあるのですから、そうなっていないかどうか必ずチェックしておくべきです。ジェネレータ関数を再開するために使うメソッドが <code class="xref py py-meth docutils literal"><span class="pre">send()</span></code> しかないのだと確信してるのでない限り、式の値をそのまま使ってはいけません。</p>
<p>ジェネレータには、 <code class="xref py py-meth docutils literal"><span class="pre">send()</span></code> のほかにも新しいメソッドが二つあります</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">throw(type,</span> <span class="pre">value=None,</span> <span class="pre">traceback=None)</span></code> はジェネレータ内で例外を投げるために使います; その例外はジェネレータの実行が停止したところの <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式によって投げられます。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> はジェネレータ内で <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> 例外を投げてイテレートを終了させます。この例外を受け取ったジェネレータのコードは <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> か <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を投げなくてはいけません; この例外を捕捉して何かほかのことをしようとするのは規則違反であり、 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を引き起こします; 関数が何かほかの例外を投げると、その例外は呼び出し元に伝播します。 <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> はジェネレータのガーベージコレクトによっても呼ばれます。</p>
<p><a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> が起こったときにクリーンアップ作業をする必要があるなら、 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> を捕捉するのではなく <code class="docutils literal"><span class="pre">try:</span> <span class="pre">...</span> <span class="pre">finaly:</span></code> するようお勧めします。</p>
</li>
</ul>
<p>これらの変更の合わせ技で、ジェネレータは情報の一方的な生産者から、生産者かつ消費者という存在に変貌を遂げたのです。</p>
<p>ジェネレータは <em>コルーチン</em> という、より一般化された形式のサブルーチンにもなります。サブルーチンは一カ所 (関数の冒頭) から入って別の一カ所 (<a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文) から出るだけですが、コルーチンはいろいろな場所 (<a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文) から入ったり出たり再開したりできるのです。わたしたちは Python でコルーチンを効果的に使うためのパターンを理解する必要があります。</p>
<p><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> メソッドの追加には、自明とは言えない副作用が一つあります。 <code class="xref py py-meth docutils literal"><span class="pre">close()</span></code> はジェネレータがガーベージコレクトされる際に呼ばれるので、ジェネレータコードはジェネレータが破棄される前に、一つ動くラストチャンスを持つのです。このラストチャンスは、ジェネレータ内の <code class="docutils literal"><span class="pre">try...finally</span></code> ステートメントがもはや必ず動けることを意味しています; <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節は必ず実行の機会を得ます。 <code class="docutils literal"><span class="pre">try...finally</span></code> と <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> を組み合わせられないという構文的な制限は、それゆえに取り除かれました。これは小さな言語の取るに足らないことのように見えますが、ジェネレータの使用と <code class="docutils literal"><span class="pre">try...finally</span></code> は PEP 343 で記述される <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> ステートメントの実装のために実際に必要です。この新しいステートメントについては続くセクションで見ていきましょう。</p>
<p>もう一つさらに深遠なこの変更の効果: 以前はジェネレータの <code class="xref py py-attr docutils literal"><span class="pre">gi_frame</span></code> 属性は常にフレームオブジェクトでした。今では <code class="xref py py-attr docutils literal"><span class="pre">gi_frame</span></code> は、ジェネレータが使い果たされた場合に <code class="docutils literal"><span class="pre">None</span></code> になります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 0342</strong></a> - 拡張されたジェネレータを用いたコルーチン</dt>
<dd><p class="first">PEP は Guido van Rossum と Phillip J. Eby によって書かれ、Phillip J. Eby によって実装されました。コルーチンとしてのジェネレータの用法のいくつかの手が込んだ例が含まれています。</p>
<p class="last">この機能の初期バージョンは Raymond Hettinger による <span class="target" id="index-62"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0288"><strong>PEP 288</strong></a> と Samuele Pedroni による <span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0325"><strong>PEP 325</strong></a> で提案されました。</p>
</dd>
<dt><a class="reference external" href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a></dt>
<dd>コルーチンに関する WikiPedia エントリ。</dd>
<dt><a class="reference external" href="http://www.sidhe.org/~dan/blog/archives/000178.html">http://www.sidhe.org/~dan/blog/archives/000178.html</a></dt>
<dd>Dan Sugalski による、Perl の視点からみたコルーチンの説明です。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-343-the-with-statement">
<span id="pep-343"></span><h2>PEP 343: &quot;with&quot; ステートメント<a class="headerlink" href="#pep-343-the-with-statement" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントは、以前なら後片付けが実行されるのを確実にするために <code class="docutils literal"><span class="pre">try...finally</span></code> ブロックを使ったであろうようなコードを、より単純明快にします。このセクションでは、このステートメントの普通の使い方を説明します。続くセクションでは実装の詳細を調べ、このステートメントとともに使うためにオブジェクトをどうやって書けば良いかをお見せします。</p>
<p>'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントは基本構造が以下となる新しい制御フロー構造です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">expression</span> <span class="p">[</span><span class="k">as</span> <span class="n">variable</span><span class="p">]:</span>
    <span class="k">with</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p>expression は評価されて結果がコンテキスト管理プロトコルをサポートするオブジェクトにならなければなりません (具体的にはメソッド <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> を持つオブジェクト)。 ( 訳注: Python ドキュメント全体で context manager protocol と context management protocol とで不統一。同じものです。 )</p>
<p><em>with-block</em> が呼び出される前に、 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> が呼ばれるので、セットアップコードをそこで実行出来ます。それは <em>variable</em> 名(与えられた場合)に束縛されることになる値も返します(注意深く読んで下さい、つまり <em>variable</em> には <em>expression</em> の結果が代入される <em>のではない</em> のです)。</p>
<p><em>with-block</em> ブロックの実行が終了後、ブロックが例外を送出する場合であろうとオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> が呼び出されますので、ここで後片付けコードを実行出来ます。</p>
<p>Python 2.5 でこのステートメントを有効にするには、以下のディレクティブをあなたのモジュールに追加する必要があります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">with_statement</span>
</pre></div>
</div>
<p>Python 2.6 ではこれは常に有効になります。</p>
<p>いくつかの Python 標準オブジェクトが既にコンテキスト管理プロトコルをサポートしていて、 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' とともに使えます。ファイルオブジェクトがその一例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span>
        <span class="o">...</span> <span class="n">more</span> <span class="n">processing</span> <span class="n">code</span> <span class="o">...</span>
</pre></div>
</div>
<p>このステートメントが実行し終わったあかつきには、 <em>f</em> のファイルオブジェクトは、たとえ <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループが道半ばにして例外と成り果てても、自動的にクローズされます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">このケースでは、 <em>f</em> は <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> が作ったオブジェクトと同じです。これはファイルオブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">file.__enter__()</span></code> が <em>self</em> を返しているからです。</p>
</div>
<p><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールのロック・条件変数でも '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントの恩恵にあずかれます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># Critical section of code</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>ブロックが実行される前にロックが獲得されて、ブロックが完了するやいなや必ず解放されます。</p>
<p><a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュール内の新しい <code class="xref py py-func docutils literal"><span class="pre">localcontext()</span></code> 関数は現在の decimal のコンテキスト (計算の望みの精度と丸め特性をカプセル化しています) を保存しておいてあとで元に戻すのを簡単にしてくれます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">localcontext</span>

<span class="c1"># Displays with default precision of 28 digits</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;578&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">16</span><span class="p">)):</span>
    <span class="c1"># All code in this block uses a precision of 16 digits.</span>
    <span class="c1"># The original context is restored on exiting the block.</span>
    <span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="writing-context-managers">
<span id="new-25-context-managers"></span><h3>コンテキストマネージャを書く<a class="headerlink" href="#writing-context-managers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>中身を紐解いてみれば、 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントはけっこう入り組んでいます。ほとんどの人にとっては、既存のオブジェクトを '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' とともに使うだけのことでその詳細は知らなくても良いので、そうしたいならこのセクションの残りの部分は読み飛ばして結構です。新しいオブジェクトの作者は基礎となる実装の詳細について知る必要があります。このまま読み進めるべきです。</p>
<p>コンテキスト管理プロトコルの高度な説明はこんなです:</p>
<ul class="simple">
<li>expression は評価されて、 &quot;コンテキストマネージャ(context manager)&quot;  にならなければなりません。コンテキストマネージャは <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドと <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドを持っていなければなりません。</li>
<li>コンテキストマネージャの <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドが呼び出されます。これの戻り値は <em>VAR</em> に代入されます。 <code class="docutils literal"><span class="pre">as</span> <span class="pre">VAR</span></code> 節がない場合は、この値は単に捨てられます。</li>
<li><em>BLOCK</em> 内のコードが実行されます。</li>
<li><em>BLOCK</em> が例外を起こした場合、コンテキストマネージャの <code class="docutils literal"><span class="pre">__exit__</span></code> メソッドが 3 つの引数とともに呼び出されます。これは例外の詳細です (<code class="docutils literal"><span class="pre">type,</span> <span class="pre">value,</span> <span class="pre">traceback</span></code>, これは <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> が返す値と同じで、例外が起こらなければ <code class="docutils literal"><span class="pre">None</span></code> です)。そのメソッドの戻り値は例外を再送出するかどうかを制御します: 全ての偽の値ではその例外が再送出され、 <code class="docutils literal"><span class="pre">True</span></code> では揉み消します。例外を揉み消すなど滅多なことでは欲しいと思わないでしょう。もしそうしてしまったら、 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントを含んだコードの作者は何か間違ったことが起こったことに決して気付かないですから。</li>
<li><em>BLOCK</em> が例外を起こさなかった場合も <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドが呼び出されます。ただし <em>type</em>, <em>value</em>, <em>traceback</em> は全て <code class="docutils literal"><span class="pre">None</span></code> です。</li>
</ul>
<p>例を通じて考えましょう。枝葉末節を含んだ完璧なコードを提示しようとは思いませんが、データベースのためにトランザクションをサポートするのに必要となるメソッドの書き方についてスケッチしてみようと思います。</p>
<p>(データベース用語に不慣れな方へ:データベースへの変更のセットは、トランザクションという単位でグループ化されています。トランザクションは「コミット」される、その意味は、全ての変更がデータベースに書き込まれることです、もしくは「ロールバック」される、この場合全ての変更が捨てられてデータベースが変更されません、この 2 つのいずれかになりえます。詳しくはなにかデータベースの著述を読んで下さい。)</p>
<p>データベース接続を表現するオブジェクトがあると仮定しましょう。私たちの目標は、そのオブジェクトのユーザがこのように書けるようになることです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">db_connection</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_connection</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into ...&#39;</span><span class="p">)</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;delete from ...&#39;</span><span class="p">)</span>
    <span class="c1"># ... more operations ...</span>
</pre></div>
</div>
<p>トランザクションはブロック内のコードがつつがなく終了すればコミットし、例外が発生すればロールバックすべきです。私が思い描いている <code class="xref py py-class docutils literal"><span class="pre">DatabaseConnection</span></code> の基本的なインターフェイスはこんなです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="c1"># Database interface</span>
    <span class="k">def</span> <span class="nf">cursor</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns a cursor object and starts a new transaction&quot;</span>
    <span class="k">def</span> <span class="nf">commit</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Commits current transaction&quot;</span>
    <span class="k">def</span> <span class="nf">rollback</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Rolls back current transaction&quot;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドはとっても簡単で、トランザクションを開始する必要があるだけです。このアプリケーションでは、カーソルオブジェクトを結果とすることが有用なので、メソッドはそれを返しましょう。ユーザはこれにより <code class="docutils literal"><span class="pre">as</span> <span class="pre">cursor</span></code> をその '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントにつけて、そのカーソルを変数名に束縛できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__enter__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Code to start a new transaction</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cursor</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッドはそれがほとんどの仕事をしなければならない場所なので、もっと複雑です。メソッドは例外が起こったのかどうかをチェックし、例外が起こっていなければトランザクションをコミットし、例外があればロールバックしなければいけません。</p>
<p>下記のコード内では実行がメソッドの末尾まで落ちていって、なのでデフォルトの <code class="docutils literal"><span class="pre">None</span></code> 返却になります。 <code class="docutils literal"><span class="pre">None</span></code> は偽なので、例外は自動的に再送出されます。望むならもっと明示的に、コメントでマークした部分で <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文を書いてもよろしいです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__exit__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No exception, so commit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Exception occurred, so rollback.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="c1"># return False</span>
</pre></div>
</div>
</div>
<div class="section" id="the-contextlib-module">
<span id="contextlibmod"></span><h3>contextlib モジュール<a class="headerlink" href="#the-contextlib-module" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新しい <a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールは、 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントで使えるオブジェクトを書く際に便利ないくつかの関数とデコレータを提供しています。</p>
<p>デコレータは <code class="xref py py-func docutils literal"><span class="pre">contextmanager()</span></code> という名前で、新たにクラスを書く代わりに一つジェネレータを書けば済むようにするものです。そのジェネレータは正確に一つの値を yield しなければなりません。 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> より上の部分のコードが <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドとして実行されます。yield した値は <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> メソッドの戻り値となって、 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントの <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 節があれば、その変数に束縛されます。 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> に続くコードが <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> メソッド内で実行されます。ブロック内では任意の例外が <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> ステートメントによって引き起こされます。</p>
<p>このデコレータを使って、前セクションの私たちのデータベースの例はこのように書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">db_transaction</span> <span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cursor</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールには <code class="docutils literal"><span class="pre">nested(mgr1,</span> <span class="pre">mgr2,</span> <span class="pre">...)</span></code> 関数もあって、これはたくさんのコンテキストマネージャを組み合わせることが出来るので、入れ子の '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' を書く必要性をなくしてくれます。この例では、単一の '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' でデータベーストランザクション開始とスレッドのロック獲得の両方をやってのけています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">nested</span> <span class="p">(</span><span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">),</span> <span class="n">lock</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">locked</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>最後になりますが、 <code class="docutils literal"><span class="pre">closing(object)</span></code> 関数は <em>object</em> をそのまま返して変数に束縛出来るようにし、かつブロックの終了で、与えた引数が持つ <code class="docutils literal"><span class="pre">object.close</span></code> を呼び出します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">closing</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.yahoo.com&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="docutils">
<dt><span class="target" id="index-64"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - &quot;with&quot; ステートメント</dt>
<dd>PEP は Guido van Rossum と Nick Coghlan によって書かれ、Mike Bland、 Guido van Rossum、Neal Norwitz により実装されました。この PEP は '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントによって生成されるコードを見せてくれるので、このステートメントがどうやって動作するのかを知るのに役立ちます。</dd>
</dl>
<p class="last"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールについてのドキュメント。</p>
</div>
</div>
</div>
<div class="section" id="pep-352-exceptions-as-new-style-classes">
<span id="pep-352"></span><h2>PEP 352: 例外の新スタイルクラス化<a class="headerlink" href="#pep-352-exceptions-as-new-style-classes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>例外クラスは、今では旧スタイルクラスだけではなく新スタイルクラスになれます。組み込みの <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a> クラスと全ての標準組み込み例外 (<a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a>, <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>, など) が今では新スタイルクラスです。</p>
<p>例外の継承階層が少し再編成されました。2.5 では継承関係はこのようになっています (—訳注: 2.6 ではさらに GeneratorExit が Exception ではなく BaseExceotion の直接の子になり、これは 3.x でも引き継がれています。—):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="ne">BaseException</span>       <span class="c1"># New in Python 2.5</span>
<span class="o">|-</span> <span class="ne">KeyboardInterrupt</span>
<span class="o">|-</span> <span class="ne">SystemExit</span>
<span class="o">|-</span> <span class="ne">Exception</span>
   <span class="o">|-</span> <span class="p">(</span><span class="nb">all</span> <span class="n">other</span> <span class="n">current</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">exceptions</span><span class="p">)</span>
</pre></div>
</div>
<p>この再編成が行われたのは、人々がしばしばプログラムのエラーを示す例外すべてを捕捉したがるからです。 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> と <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a> はエラーではありませんが、普通は <code class="kbd docutils literal"><span class="pre">Control-C</span></code> をユーザが叩いたか、コードが <a class="reference internal" href="../library/sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></code></a> を呼び出したかのような明示的なアクションを表します。剥き出しの <code class="docutils literal"><span class="pre">except:</span></code> はまさに全ての例外を捕捉しますから、一般に、再送出のために <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> と <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a> はリストする必要があります。お決まりのパターンはこんなです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">KeyboardInterrupt</span><span class="p">,</span> <span class="ne">SystemExit</span><span class="p">):</span>
    <span class="k">raise</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># Log error...</span>
    <span class="c1"># Continue running program...</span>
</pre></div>
</div>
<p>Python 2.5 では同じ結果を得るのにもう <code class="docutils literal"><span class="pre">except</span> <span class="pre">Exception</span></code> と書いても良いです。これは普通はエラーを示す例外全てを捕捉しつつも <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal"><span class="pre">KeyboardInterrupt</span></code></a> と <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal"><span class="pre">SystemExit</span></code></a> は置き去りにします。無論かつてまでのバージョン同様、剥き身の <code class="docutils literal"><span class="pre">except:</span></code> は全例外を捕捉します。</p>
<p>Python 3.0 での目標は、例外として raise される全てのクラスが <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a> からの、もしくは <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a>  のある子孫であることを要求することであり、Python 2.x シリーズの将来のリリースにおいてはこの制約の強制を始めるかもしれません。ですからあなたの全ての例外は、今からすぐに <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal"><span class="pre">Exception</span></code></a> 派生にするのが肝要です。捕捉例外を特定しない <code class="docutils literal"><span class="pre">except:</span></code> は Python 3.0 から取り除かれるべきであることが提案されていますが、Guido van Rossum はこれをどうするかまだ決めていません。 (—訳注: 2.7 では raise は「新スタイルクラスであれば」 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a> 派生であることを要求されますが、旧スタイルクラスであればなんでも許されてしまう点ではあまり変わっていません。これについての警告は <code class="xref std std-option docutils literal"><span class="pre">-3</span></code> などで受けることが出来ます。Python 3.0 でようやく全ての例外が <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal"><span class="pre">BaseException</span></code></a> 派生であることが強制されるようになりました。 また、 <code class="docutils literal"><span class="pre">except:</span></code> は 3.4 でも残っています。—)</p>
<p>例外として文字列を <code class="docutils literal"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">occurred&quot;</span></code> として raise することは Python 2.5 では非推奨であり警告を引き起こします。その目的は、あと少しのリリースで文字列例外を削除することです。 (—訳注: 2.6 以降の What’s New では明示的に書かれてはいませんが、2.7 では警告ではなくエラーです。—)</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0352"><strong>PEP 352</strong></a> - 例外のためのスーパークラス</dt>
<dd>PEP 著: Brett Cannon と Guido van Rossum; 実装: Brett Cannon.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-353-using-ssize-t-as-the-index-type">
<span id="pep-353"></span><h2>PEP 353: 添え字型に ssize_t を使う<a class="headerlink" href="#pep-353-using-ssize-t-as-the-index-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python の C API についての広範囲に渡る修正は、 <code class="xref c c-type docutils literal"><span class="pre">int</span></code> の代わりとなる新しい <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> 型を使うことです。これは 64 ビットプラットフォームにおいてインタプリタがより大きなデータを扱えるようにします。この変更は 32 ビットプラットフォームでの Python には影響しません。</p>
<p>Python インタプリタのあらゆる場所で、大きさや数え上げのために C の <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 型が使われていました; 例えばリストやタプルの要素数は <code class="xref c c-type docutils literal"><span class="pre">int</span></code> で格納されていました。ほとんどの 64 ビットプラットフォームでは今でも <code class="xref c c-type docutils literal"><span class="pre">int</span></code> を 32 ビット型として定義していますので、リストは <code class="docutils literal"><span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> = 2147483647 までしか保持出来なかった、ということです。(実際には 64 ビットコンパイラが使える小数の異なったプログラミングモデルもあります – <a class="reference external" href="http://www.unix.org/version2/whatsnew/lp64_wp.html">http://www.unix.org/version2/whatsnew/lp64_wp.html</a> の議論を参照して下さい – ですがほとんどの場合で利用可能なモデルでは <code class="xref c c-type docutils literal"><span class="pre">int</span></code> は 32 ビットのままです。)</p>
<p>2147483647 に要素数が制限されることは 32 ビットプラットフォームではあまり重大でもありません。その長さ制限を喰らう前にメモリを使い果たすでしょうから。それぞれのリストアイテムは、ポインタのための領域 (4 バイト) をアイテムを表現する <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span></code></a> に余分に必要とします。2147483647*4 は既に 32 ビットのアドレス空間が含められるバイト数を超えています。(—訳注: 意味不明。何か誤解があるような…? 4 バイトは 2147483647 (符号付きとして 2^31 - 1) でしょう。4 を掛ける説明なんかここでまったくされていない。なぜ掛ける? それと要素のインデクシングとアイテムの必要領域は議論には無関係なのでは?—)</p>
<p>しかしながら 64 ビットプラットフォームではさらに多くのメモリをアドレスすることが出来ます。リストのためのポインタではたった 16 GiB の領域を必要とするだけですから、Python プログラマがそのように巨大なリストを構築しようとすることは理不尽でもありません。それゆえ Python インタプリタは <code class="xref c c-type docutils literal"><span class="pre">int</span></code> に代わる何かほかの型を使う必要に迫られました。それは 64 ビットプラットフォームで 64 ビットを使うことです。その変更は 64 ビット機での非互換性をもたらすので、64 ビットユーザが比較的少数派である間は、今のところ漸近的推移で合意されました。 (5 年もしくは 10 年の間には <em>全て</em> が 64 ビット機であるかもしれませんので、この漸近的推移はより苦痛になるかもしれません。) — (—訳注: 16 GiB はどこから出てくる? 2147483647*4 と 2147483647*8 の間らしいが…。このセクション全体として、誤解か説明不足かどちらかです。 ssize_t として 64 ビットプラットフォームで 64 ビットアドレス空間を目いっぱい使える、このセクションはそれだけを言えばいいはずなのですが…。それと「漸近的推移」(transition)についてですが、これはこの変更の意図としては続く文の「まだ int のものがいる」ことを指しているのですが、文章の構造から考えると、この著者は「32 ビット機でさえ 64 ビットにするのが理想だ」を含意していたのではないかという気がします。—)</p>
<p>この変更は C 拡張モジュールの著者に大変大きく影響します。Python 文字列とリストやタプルのようなコンテナ型は、そのサイズを表すのに <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> を使うようになっています。 <a class="reference internal" href="../c-api/list.html#c.PyList_Size" title="PyList_Size"><code class="xref c c-func docutils literal"><span class="pre">PyList_Size()</span></code></a> のような関数は <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> を返します。拡張モジュール内のコードでは、ですので、ある程度の変数の <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> への変更が必要でしょう。</p>
<p><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> 関数と <a class="reference internal" href="../c-api/arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></code></a> 関数は新しい変換コード <code class="docutils literal"><span class="pre">n</span></code> を <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> のために持ちました。 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> の <code class="docutils literal"><span class="pre">s#</span></code> と <code class="docutils literal"><span class="pre">t#</span></code> はデフォルトではまだ <code class="xref c c-type docutils literal"><span class="pre">int</span></code> を出力しますが、 <code class="xref c c-macro docutils literal"><span class="pre">PY_SSIZE_T_CLEAN</span></code> を定義することが出来ます。 <code class="file docutils literal"><span class="pre">Python.h</span></code> インクルード前に定義してください。 <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> を返すようになります。</p>
<p><span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0353"><strong>PEP 353</strong></a> には、拡張の著者が読んで学ぶべき 64 ビットプラットフォームサポートについてのセクションがあります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0353"><strong>PEP 353</strong></a> - 添え字型に ssize_t を使う</dt>
<dd>PEP 著と実装 Martin von Löwis.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-357-the-index-method">
<span id="pep-357"></span><h2>PEP 357: '__index__' メソッド<a class="headerlink" href="#pep-357-the-index-method" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>NumPy 開発者たちは、新しい特殊メソッド、 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> を追加することによってしか解決できない問題を抱えていました。スライスの表現 <code class="docutils literal"><span class="pre">[start:stop:step]</span></code> を使う際、 <em>start</em>, <em>stop</em>, <em>step</em> は全て整数か長整数でなければなりません。NumPy は様々な特殊化された整数型を持っていて、符号なし、符号付きの 8、16、32、64 ビットに対応していますが、それらをスライスの添え字に使う手段はありませんでした。</p>
<p>スライシングに既存の <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal"><span class="pre">__int__()</span></code></a> メソッドをそのまま使うことは出来ません。それらは整数への型変換を実装するのにも使われるからです。スライシングが <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal"><span class="pre">__int__()</span></code></a> を使ったとすれば、浮動小数点数でさえスライスの添え字として使うことが合法になりますが、それは明らかに望む振る舞いではありません。</p>
<p>その代わりに新しい特殊メソッド <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> が追加されました。これは引数を取らずに、スライスの添え字として使われる整数を返します。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__index__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p>戻り値は Python 整数または長整数でなければなりません。インタプリタは戻り値が正しいかどうかをチェックし、要求に合わない場合に <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。</p>
<p>これに呼応する <code class="xref py py-attr docutils literal"><span class="pre">nb_index</span></code> スロットが C レベルの <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></code></a> 構造体に追加され、C 拡張はこれでこのプロトコルを実装出来ます。 <code class="docutils literal"><span class="pre">PyNumber_Index(obj)</span></code> は拡張コード内で <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> を呼び出してその結果を得るのに使えます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0357"><strong>PEP 357</strong></a> - スライシングのために任意のオブジェクトを使えるようにする</dt>
<dd>PEP 著と実装 Travis Oliphant.</dd>
</dl>
</div>
</div>
<div class="section" id="other-language-changes">
<span id="other-lang"></span><h2>その他の言語変更<a class="headerlink" href="#other-language-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下が、Python 2.5 言語コアに加えられた全ての変更点です。</p>
<ul>
<li><p class="first"><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 型に新たなフックが追加されています。サブクラスが、辞書に含まれないキーに対してデフォルトを提供出来るようにするものです。キーが見つからない場合、辞書の <code class="docutils literal"><span class="pre">__missing__(key)</span></code> メソッドが呼ばれます。このフックは <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュール内の新しいクラス <code class="xref py py-class docutils literal"><span class="pre">defaultdict</span></code> で使われています。続く例は存在しないキーに対してゼロを返す辞書を定義しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">zerodict</span> <span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__missing__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">zerodict</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="nb">print</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># Prints 1, 2</span>
<span class="nb">print</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>   <span class="c1"># Prints 0, 0</span>
</pre></div>
</div>
</li>
<li><p class="first">8 ビット文字列、Unicode ともに、ありがちなユースケースを単純化する  <code class="xref py py-meth docutils literal"><span class="pre">partition(sep)()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">rpartition(sep)()</span></code>  が追加されました。</p>
<p>文字列のスライスに使うために <code class="xref py py-meth docutils literal"><span class="pre">find(S)()</span></code> メソッドを使ってインデクスを得るのだけれども、やりたいのはそのセパレータ(S)の前後の部分文字列を得ることだ、といったことはしょっちゅう必要になります。 <code class="xref py py-meth docutils literal"><span class="pre">partition(sep)()</span></code> はこのパターンのコードを、一撃、に圧縮してくれます。これはセパレータ前の部分文字列、セパレータ自身、セパレータ後の部分文字列の 3 要素タプルを返します。セパレータが含まれない場合は、返却値の最初の要素に文字列全体が、残り2つは空文字列で返ります。 <code class="xref py py-meth docutils literal"><span class="pre">rpartition(sep)()</span></code> もほぼ同じことをしますがセパレータの検索をお尻から始めます。 <code class="docutils literal"><span class="pre">r</span></code> は逆順('reverse')を表します。</p>
<p>いくつかの例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;://&#39;</span><span class="p">)</span>
<span class="go">(&#39;http&#39;, &#39;://&#39;, &#39;www.python.org&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;file:/usr/share/doc/index.html&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;://&#39;</span><span class="p">)</span>
<span class="go">(&#39;file:/usr/share/doc/index.html&#39;, &#39;&#39;, &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;Subject: a quick question&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="go">(u&#39;Subject&#39;, u&#39;:&#39;, u&#39; a quick question&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="go">(&#39;www.python&#39;, &#39;.&#39;, &#39;org&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="go">(&#39;&#39;, &#39;&#39;, &#39;www.python.org&#39;)</span>
</pre></div>
</div>
<p>(Implemented by Fredrik Lundh following a suggestion by Raymond Hettinger.)</p>
</li>
<li><p class="first">文字列型の <code class="xref py py-meth docutils literal"><span class="pre">startswith()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">endswith()</span></code> メソッドが、チェックされる文字列のタプルを受け容れるようになりました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_image_file</span> <span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.gif&#39;</span><span class="p">,</span> <span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>(Implemented by Georg Brandl following a suggestion by Tom Lynn.)</p>
</li>
<li><p class="first">ビルトイン関数 <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a> と <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> に、 <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> における <code class="docutils literal"><span class="pre">key</span></code> に似たキーワード引数 <code class="docutils literal"><span class="pre">key</span></code> が追加されました。このパラメータには関数を与えます。これは一つの引数を取り、リスト内の全ての値に対して呼び出されます; <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a>/<a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> はこの関数を全要素に適用したもののなかでの最小値/最大値を返します。例えば、リスト中の最長の文字列を探すにはこのように出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="s1">&#39;longest&#39;</span><span class="p">,</span> <span class="s1">&#39;short&#39;</span><span class="p">]</span>
<span class="c1"># Prints &#39;longest&#39;</span>
<span class="nb">print</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
<span class="c1"># Prints &#39;short&#39;, because lexicographically &#39;short&#39; has the largest value</span>
<span class="nb">print</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contributed by Steven Bethard and Raymond Hettinger.)</p>
</li>
<li><p class="first">2 つの新たなビルトイン関数 <a class="reference internal" href="../library/functions.html#any" title="any"><code class="xref py py-func docutils literal"><span class="pre">any()</span></code></a> と <a class="reference internal" href="../library/functions.html#all" title="all"><code class="xref py py-func docutils literal"><span class="pre">all()</span></code></a> は、イテレータがいくつか真を含むかどうかを評価します。 <a class="reference internal" href="../library/functions.html#any" title="any"><code class="xref py py-func docutils literal"><span class="pre">any()</span></code></a> はイテレータのいずれかが返す値が真と評価される場合に <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を返し、そうでなければ <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> を返します。 <a class="reference internal" href="../library/functions.html#all" title="all"><code class="xref py py-func docutils literal"><span class="pre">all()</span></code></a> はイテレータが返す値の評価が真のみの場合に <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> を返します。 (Suggested by Guido van Rossum, and implemented by Raymond Hettinger.)</p>
</li>
<li><p class="first">クラスの <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> メソッドが返す値として、長整数と整数のどちらでも良くなりました。長整数が返されれば、その値のハッシュから取られます。以前のバージョンではこれは普通の整数であることが要求されていましたが、2.5 ではビルトイン関数 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal"><span class="pre">id()</span></code></a> が変更されて常に非負数が返り、ユーザはしばしば <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> 内で <code class="docutils literal"><span class="pre">id(self)</span></code> を使うようです (これはお奨めしませんが)。 (—訳注: 不思議な論法で意味がわかりません。id が非負を返すとなぜユーザは __hash__ の実装に使おうとするのか? ユーザがそれをしてしまうのは単にデフォルト実装がそうだから、というだけではないかと思います。__cmp__, __eq__ が「身元」以外の意味を使って比較を行うならば、 __cmp__ で id を使うのはシンプルに「ダメ」でしょう。–)</p>
</li>
<li><p class="first">モジュールのデフォルトエンコーディングが ASCII になりました(訳注: Python 3 からはデフォルトは utf-8 (PEP 3120))。8 ビット文字を含んでいるのにエンコーディング宣言がないモジュールが構文エラーになるようになりました。Python 2.4 では構文エラーとはならず警告でした。モジュールのエンコーディングをする方法については <span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a> を参照してください; 例えば、ソースコードの先頭付近にこのような行を追加することで出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: latin1 -*-</span>
</pre></div>
</div>
</li>
<li><p class="first">Unicode 文字列とデフォルトの ASCII エンコーディングで Unicode に変換出来ない 8 ビット文字列との比較を試みると、新しい警告 <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal"><span class="pre">UnicodeWarning</span></code></a> が引き起こされるようになっています。比較結果は偽です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="o">==</span> <span class="n">unichr</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>   <span class="c1"># Can&#39;t convert chr(128) to Unicode</span>
<span class="go">__main__:1: UnicodeWarning: Unicode equal comparison failed</span>
<span class="go">  to convert both arguments to Unicode - interpreting them</span>
<span class="go">  as being unequal</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mi">127</span><span class="p">)</span> <span class="o">==</span> <span class="n">unichr</span><span class="p">(</span><span class="mi">127</span><span class="p">)</span>   <span class="c1"># chr(127) can be converted</span>
<span class="go">True</span>
</pre></div>
</div>
<p>以前はこれは <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> を起こしていましたので、2.5 でのこれは辞書のアクセス時に悩ましい問題をもたらしました。キーとして使われている <code class="docutils literal"><span class="pre">unichr(128)</span></code> や <code class="docutils literal"><span class="pre">chr(128)</span></code> を探そうとすると <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> 例外が起こっていたでしょう。2.5 での、 辞書を実装している <code class="file docutils literal"><span class="pre">dictobject.c</span></code> のほかの変更により、これは揉み消すのではなく、引き続き例外を起こします(訳注: 原文では this exception といっているので <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> が起こるように読めるのですが、2.5 時点での振る舞いは確認出来ていませんが 2.7 では <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal"><span class="pre">UnicodeWarning</span></code></a> とともに <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> が発生する、のようになるはずです。2.6 以降の What’s New でのこれに関する言及はありませんが変更があったのかもしれません)。</p>
<p>この種の比較で例外を起こすのは完全に正しいことではあるものの、その変更はコードを破壊するかもしれないので、必要に応じて警告に出来るよう導入されたのが <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal"><span class="pre">UnicodeWarning</span></code></a> です。</p>
<p>(Implemented by Marc-André Lemburg.)</p>
</li>
<li><p class="first">Python プログラマがよくしでかす間違いとして、パッケージディレクトリに <code class="file docutils literal"><span class="pre">__init__.py</span></code> を入れ忘れる、というものがあります。この間違いのデバッグはややこしく、大抵 Python を <a class="reference internal" href="../using/cmdline.html#id4"><code class="xref std std-option docutils literal"><span class="pre">-v</span></code></a> スイッチ付きで起動して、パス検索全てをログ出力するハメになります。Python 2.5 ではパッケージディレクトリに <code class="file docutils literal"><span class="pre">__init__.py</span></code> がないことが検出されると新たに <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal"><span class="pre">ImportWarning</span></code></a> 警告を出すようになりました。デフォルトではこの警告は黙って無視されます; これを出したければ、 <a class="reference internal" href="../using/cmdline.html#cmdoption-w"><code class="xref std std-option docutils literal"><span class="pre">-Wd</span></code></a> スイッチをつけて Python を起動してください。(Implemented by Thomas Wouters.)</p>
</li>
<li><p class="first">クラス定義において、基底クラスのリストを空リストに出来るようになっています(訳注: object を派生しないので結果として旧スタイルクラスになります)。例えば以下は今や合法です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>(Implemented by Brett Cannon.)</p>
</li>
</ul>
<div class="section" id="interactive-interpreter-changes">
<span id="interactive"></span><h3>対話的なインタプリタの変更<a class="headerlink" href="#interactive-interpreter-changes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>対話的なインタプリタ内では、 <code class="docutils literal"><span class="pre">quit</span></code> と <code class="docutils literal"><span class="pre">exit</span></code>  はずっと、立ち去ろうと(quit しようと)試みてそうタイプしてしまうユーザにとってある種有用な文字列になっていました:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">quit</span>
<span class="go">&#39;Use Ctrl-D (i.e. EOF) to exit.&#39;</span>
</pre></div>
</div>
<p>Python 2.5 でも <code class="docutils literal"><span class="pre">quit</span></code> と <code class="docutils literal"><span class="pre">exit</span></code> はそれ自身そのような文字列を生成はしますが、同時に「呼び出す」ことが出来るオブジェクトになっています。初心者が思わず <code class="docutils literal"><span class="pre">quit()</span></code> や <code class="docutils literal"><span class="pre">exit()</span></code> してしまった場合、今では彼らが期待する通りにインタプリタが終了します。  (Implemented by Georg Brandl.)</p>
<p>Python 実行形式ファイルが標準的な長い形式の <a class="reference internal" href="../library/json.html#cmdoption-h"><code class="xref std std-option docutils literal"><span class="pre">--help</span></code></a> と <a class="reference internal" href="../using/cmdline.html#cmdoption-version"><code class="xref std std-option docutils literal"><span class="pre">--version</span></code></a> を受け付けるようになりました。Windows の場合はヘルプメッセージを出力するのに <a class="reference internal" href="../using/cmdline.html#cmdoption"><code class="xref std std-option docutils literal"><span class="pre">/?</span></code></a> オプションも受け付けます。(Implemented by Georg Brandl.)</p>
</div>
<div class="section" id="optimizations">
<span id="opts"></span><h3>最適化<a class="headerlink" href="#optimizations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Several of the optimizations were developed at the NeedForSpeed sprint, an event
held in Reykjavik, Iceland, from May 21–28 2006. The sprint focused on speed
enhancements to the CPython implementation and was funded by EWT LLC with local
support from CCP Games.  Those optimizations added at this sprint are specially
marked in the following list.</p>
<ul class="simple">
<li>When they were introduced  in Python 2.4, the built-in <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> and
<a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> types were built on top of Python’s dictionary type.   In 2.5
the internal data structure has been customized for implementing sets, and as a
result sets will use a third less memory and are somewhat faster. (Implemented
by Raymond Hettinger.)</li>
<li>The speed of some Unicode operations, such as finding substrings, string
splitting, and character map encoding and decoding, has been improved.
(Substring search and splitting improvements were added by Fredrik Lundh and
Andrew Dalke at the NeedForSpeed sprint. Character maps were improved by Walter
Dörwald and Martin von Löwis.)</li>
<li>The <code class="docutils literal"><span class="pre">long(str,</span> <span class="pre">base)</span></code> function is now faster on long digit strings
because fewer intermediate results are calculated.  The peak is for strings of
around 800–1000 digits where  the function is 6 times faster. (Contributed by
Alan McIntyre and committed at the NeedForSpeed sprint.)</li>
<li>It’s now illegal to mix iterating over a file  with <code class="docutils literal"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file</span></code> and
calling  the file object’s <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code>/<a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a>/<code class="xref py py-meth docutils literal"><span class="pre">readlines()</span></code>
methods.  Iteration uses an internal buffer and the  <code class="xref py py-meth docutils literal"><span class="pre">read*()</span></code> methods
don’t use that buffer.   Instead they would return the data following the
buffer, causing the data to appear out of order.  Mixing iteration and these
methods will now trigger a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> from the <code class="xref py py-meth docutils literal"><span class="pre">read*()</span></code> method.
(Implemented by Thomas Wouters.)</li>
<li>The <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> module now compiles structure format  strings into an
internal representation and caches this representation, yielding a 20% speedup.
(Contributed by Bob Ippolito at the NeedForSpeed sprint.)</li>
<li>The <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module got a 1 or 2% speedup by switching to  Python’s allocator
functions instead of the system’s  <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">free()</span></code>.
(Contributed by Jack Diederich at the NeedForSpeed sprint.)</li>
<li>The code generator’s peephole optimizer now performs simple constant folding
in expressions.  If you write something like <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">2+3</span></code>, the code generator
will do the arithmetic and produce code corresponding to <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">5</span></code>.  (Proposed
and implemented  by Raymond Hettinger.)</li>
<li>Function calls are now faster because code objects now keep  the most recently
finished frame (a &quot;zombie frame&quot;) in an internal field of the code object,
reusing it the next time the code object is invoked.  (Original patch by Michael
Hudson, modified by Armin Rigo and Richard Jones; committed at the NeedForSpeed
sprint.)  Frame objects are also slightly smaller, which may improve cache
locality and reduce memory usage a bit.  (Contributed by Neal Norwitz.)</li>
<li>Python’s built-in exceptions are now new-style classes, a change that speeds
up instantiation considerably.  Exception handling in Python 2.5 is therefore
about 30% faster than in 2.4. (Contributed by Richard Jones, Georg Brandl and
Sean Reifschneider at the NeedForSpeed sprint.)</li>
<li>Importing now caches the paths tried, recording whether  they exist or not so
that the interpreter makes fewer  <code class="xref c c-func docutils literal"><span class="pre">open()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">stat()</span></code> calls on
startup. (Contributed by Martin von Löwis and Georg Brandl.)</li>
</ul>
</div>
</div>
<div class="section" id="new-improved-and-removed-modules">
<span id="modules"></span><h2>新たなモジュール、改良されたモジュール、削除されたモジュール<a class="headerlink" href="#new-improved-and-removed-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>標準ライブラリは Python 2.5 で数多くの拡張とバグフィックスを行っています。ここでは注目に値する変更をモジュール名の辞書順で列挙します。変更についてのもっと完全なリストが見たければソースツリーの <code class="file docutils literal"><span class="pre">Misc/NEWS</span></code> を調べるか、全ての詳細について SVN ログに目を通してみてください。</p>
<ul>
<li><p class="first"><a class="reference internal" href="../library/audioop.html#module-audioop" title="audioop: Manipulate raw audio data."><code class="xref py py-mod docutils literal"><span class="pre">audioop</span></code></a> モジュールに a-LAW エンコーディングのサポートが追加され、また、u-LAW エンコーディングのコードも改善されています。 (Contributed by Lars Immisch.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュールに漸増的コーデックのサポートが追加されています。 <code class="xref py py-func docutils literal"><span class="pre">codec.lookup()</span></code> 関数がタプルではなく <code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code> を返すようになっています。 <code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code> のインスタンスは後方互換性を維持するために 4 要素タプルのように振舞うだけでなく、属性 <code class="xref py py-attr docutils literal"><span class="pre">encode</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">decode</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">incrementalencoder</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">incrementaldecoder</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">streamwriter</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">streamreader</span></code> を持ちます。漸増的コーデックは入力を受け取って出力するのを複数チャンクに分けて行えます; 出力は非漸増的コーデックに一回で入力全体を渡したものと同じになります。詳細は <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> モジュールのドキュメントを参照して下さい。 (Designed and implemented by Walter Dörwald.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールに新たに追加された <code class="xref py py-class docutils literal"><span class="pre">defaultdict</span></code> 型は、標準 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> のサブクラスです。この新しい型はほとんど辞書と同じに振る舞い、ただし、キーを要求された際にそのキーが存在していなかった場合に、自動的に辞書にデフォルト値を追加します。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">defaultdict</span></code> のコンストラクタの最初の引数は、キーが要求されて存在しない場合に呼び出されるファクトリ関数です。ファクトリ関数は引数を取りません。つまりこれに該当する <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal"><span class="pre">list()</span></code></a> や <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a> のようなビルトイン型のコンストラクタも使えます。例えば、その頭文字を基準に語の索引をこのように作ることが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">words</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Nel mezzo del cammin di nostra vita</span>
<span class="s2">mi ritrovai per una selva oscura</span>
<span class="s2">che la diritta via era smarrita&quot;&quot;&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="n">index</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="n">init_letter</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">index</span><span class="p">[</span><span class="n">init_letter</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">index</span></code> を出力するとこんな具合です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">defaultdict</span><span class="p">(</span><span class="o">&lt;</span><span class="nb">type</span> <span class="s1">&#39;list&#39;</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;cammin&#39;</span><span class="p">,</span> <span class="s1">&#39;che&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;era&#39;</span><span class="p">],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;del&#39;</span><span class="p">,</span> <span class="s1">&#39;di&#39;</span><span class="p">,</span> <span class="s1">&#39;diritta&#39;</span><span class="p">],</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mezzo&#39;</span><span class="p">,</span> <span class="s1">&#39;mi&#39;</span><span class="p">],</span>
        <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;la&#39;</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;oscura&#39;</span><span class="p">],</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;nel&#39;</span><span class="p">,</span> <span class="s1">&#39;nostra&#39;</span><span class="p">],</span>
        <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">],</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;selva&#39;</span><span class="p">,</span> <span class="s1">&#39;smarrita&#39;</span><span class="p">],</span>
        <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ritrovai&#39;</span><span class="p">],</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;una&#39;</span><span class="p">],</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;vita&#39;</span><span class="p">,</span> <span class="s1">&#39;via&#39;</span><span class="p">]}</span>
</pre></div>
</div>
<p>(Contributed by Guido van Rossum.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> モジュールで提供されている両端キュー (double-ended queue) 型 <code class="xref py py-class docutils literal"><span class="pre">deque</span></code> に、キュー内で最初に現れる <em>value</em> を削除するメソッド <code class="xref py py-meth docutils literal"><span class="pre">remove(value)()</span></code> メソッドが追加されています。 <em>value</em> が見つからなければ <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">新規モジュール: <a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> モジュールには '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a>' ステートメントで使えるヘルパ関数が含まれています。詳細は <a class="reference internal" href="#contextlibmod"><span class="std std-ref">contextlib モジュール</span></a> をみてください。</p>
</li>
<li><p class="first">新規モジュール: <a class="reference internal" href="../library/profile.html#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal"><span class="pre">cProfile</span></code></a> モジュールは既存の <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal"><span class="pre">profile</span></code></a> モジュールの C 実装で、遥かに小さなオーバヘッドで実行出来ます。モジュールのインターフェイスは <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal"><span class="pre">profile</span></code></a> と同じです: 関数をプロファイルするのには <code class="docutils literal"><span class="pre">cProfile.run('main()')</span></code> と実行し、プロファイル結果をファイルに書き出すなど出来ます。これは Hotshot プロファイラとして知られるものではないですが (これも C で書かれてますが <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal"><span class="pre">profile</span></code></a> モジュールのインターフェイスとは別物です)、将来バージョンの Python で保守が続けられる予定です。(Contributed by Armin Rigo.)</p>
<p>また、プロファイラによる計測データの解析のための <a class="reference internal" href="../library/profile.html#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal"><span class="pre">pstats</span></code></a> モジュールが、 <code class="xref py py-class docutils literal"><span class="pre">Stats</span></code> コンストラクタの <em>stream</em> 引数による直接ファイル出力に対応しました。 (Contributed by Skip Montanaro.)</p>
</li>
<li><p class="first">カンマ区切りフォーマットで書かれたファイルの解析を行う <a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal"><span class="pre">csv</span></code></a> モジュールに、数多くの拡張とバグフィックスがありました。 <code class="xref py py-meth docutils literal"><span class="pre">csv.field_size_limit(new_limit)()</span></code> 関数を呼び出すことにより、フィールドの最大バイト数を制限出来るようになっています; <em>new_limit</em> 引数を省略すると現在設定されている制限値を返します。 <code class="xref py py-class docutils literal"><span class="pre">reader</span></code> クラスに <code class="xref py py-attr docutils literal"><span class="pre">line_num</span></code> 属性が追加されています。これはソースから読み込んだ物理行数を表します; レコードは物理行複数行に渡る場合がありますので、 <code class="xref py py-attr docutils literal"><span class="pre">line_num</span></code> は読み込んだレコード数とは同じではありません。</p>
<p>CSV パーサは引用符内のマルチラインをより厳密に扱うようになっています。以前は、引用符で囲まれたフィールドが改行文字(newline)で終了することなく終端すると、改行文字が返却フィールドに追加されていました。この振る舞いはフィールドに復帰文字(carriage return)を含んだファイルを読み込む際に問題だったため、改行文字を挿入することなくフィールドを返すように変更されました。このことにより、フィールド内に埋め込まれた改行文字が重要な場合、入力は改行文字が保存される方法で行分割されるはずです。(—訳注: リファレンスも含めこの説明の表現がわかりにくいです。行指向で読み込む場合改行コードのモード(NL, CR NL, CR)依存で「物理行が終了した」とみなされるわけですが、このモード依存(CR 時)の振る舞いがなくなった、ということです。—)</p>
<p>(Contributed by Skip Montanaro and Andrew McNamara.)</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal"><span class="pre">datetime</span></code></a> class in the <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal"><span class="pre">datetime</span></code></a>  module now has a
<code class="docutils literal"><span class="pre">strptime(string,</span> <span class="pre">format)</span></code>  method for parsing date strings, contributed
by Josh Spoerri. It uses the same format characters as <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal"><span class="pre">time.strptime()</span></code></a> and
<a class="reference internal" href="../library/time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;10:13:15 2006-03-07&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;%H:%M:%S %Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal"><span class="pre">difflib</span></code></a> モジュールのメソッド <code class="xref py py-meth docutils literal"><span class="pre">SequenceMatcher.get_matching_blocks()</span></code> が、合致するサブシーケンスを記述するブロックについて、最小範囲リストを返すよう保障するようになりました。以前は時折 2 つのリストエントリに合致要素ブロックが分割されることがありました。(Enhancement by Tim Peters.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> モジュールに、実行されるべきものから例を守る <code class="docutils literal"><span class="pre">SKIP</span></code> オプションが追加されています。これは、読者のための使用例として意図しているけれども実際のテストケースとして意図していないようなコードスニペットのために用意されました。</p>
<p><code class="xref py py-func docutils literal"><span class="pre">testfile()</span></code> 関数と <code class="xref py py-class docutils literal"><span class="pre">DocFileSuite</span></code> にファイルのエンコーディングを指定するための <em>encoding</em> パラメータが追加されました。これにより docstring 内に非 ASCII 文字列を含むテストが簡単になります。(Contributed by Bjorn Tillenius.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal"><span class="pre">email</span></code></a> パッケージがバージョン 4.0 にアップデートされました (Contributed by Barry Warsaw.)</p>
</li>
<li id="index-18"><p class="first"><a class="reference internal" href="../library/fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal"><span class="pre">fileinput</span></code></a> モジュールがさらに柔軟性を持つようになりました。Unicode ファイル名がサポートがサポートされるようになりました。 <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal"><span class="pre">input()</span></code></a> 関数に <em>mode</em> パラメータが追加されました。これは <code class="docutils literal"><span class="pre">&quot;r&quot;</span></code> がデフォルトで、バイナリとして読み込みことも出来ますし、 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> モードも使えます。もう一つの新しいパラメータ <em>openhook</em> で、ファイルを開くのに <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> の代わりのものを使えます。ファイル集合のイテレートでは、 <code class="xref py py-class docutils literal"><span class="pre">FileInput</span></code> オブジェクトの <code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code> が現在開いているファイルのファイル記述子を返します。 (Contributed by Georg Brandl.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal"><span class="pre">gc</span></code></a> モジュールに、新しい関数 <code class="xref py py-func docutils literal"><span class="pre">get_count()</span></code> が追加されています。これは GC 3 世代についての現在の検出を含む 3 要素タプルを返します。これはガーベージコレクタの決算情報です; これらの数が指定された閾値に到達すると、ガーベージコレクトのスイープが起こります。既存の <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal"><span class="pre">gc.collect()</span></code></a> 関数は省略可能な <em>generation</em> 引数を取るようになっていて、これはどの世代を検出するかを指定する 0、1、2 です。 (Contributed by Barry Warsaw.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal"><span class="pre">heapq</span></code></a> モジュールの <code class="xref py py-func docutils literal"><span class="pre">nsmallest()</span></code> 関数と <code class="xref py py-func docutils literal"><span class="pre">nlargest()</span></code> 関数がキーワードパラメータ <code class="docutils literal"><span class="pre">key</span></code> をサポートするようになっています。これは <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a>/<a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> 関数と <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> メソッドで提供されているものと似たものです。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;short&quot;</span><span class="p">,</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="s1">&#39;longest&#39;</span><span class="p">,</span> <span class="s1">&#39;longer still&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>  <span class="c1"># Return two lowest elements, lexicographically</span>
<span class="go">[&#39;longer still&#39;, &#39;longest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>   <span class="c1"># Return two shortest elements</span>
<span class="go">[&#39;short&#39;, &#39;medium&#39;]</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal"><span class="pre">itertools.islice()</span></code></a> 関数が start と step として <code class="docutils literal"><span class="pre">None</span></code> を受け付けるようになっています。これは slice オブジェクトとの互換性を高めるもので、つまり以下のように書くことが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>     <span class="c1"># Create slice object</span>
<span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a> モジュールの <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a> 関数が更新され、2 つの関数 <code class="xref py py-func docutils literal"><span class="pre">format_string()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">currency()</span></code> が追加されました。</p>
<p><a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a> 関数の <em>val</em> パラメータは以前は一つ以上の %文字指定子が現れる文字列が許されていました; 今はこのパラメータは正確に一つの %文字指定子を含む、周りに囲むテキストのない文字列でなければなりません。省略可能な <em>monetary</em> パラメータも追加されています。これが <code class="docutils literal"><span class="pre">True</span></code> の場合、通貨の書式化の 3 桁ごとに区切るセパレータに、ロケールのルールを使います。</p>
<p>複数 %文字指定子を含む文字列をフォーマットするには、 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a> のように働き、任意のテキストと %文字指定子を混ぜた文字列をサポートする新しい <code class="xref py py-func docutils literal"><span class="pre">format_string()</span></code> 関数を使ってください。</p>
<p>現在ロケール設定に関連した数字を書式化する <code class="xref py py-func docutils literal"><span class="pre">currency()</span></code> 関数も追加されています。</p>
<p>(Contributed by Georg Brandl.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/mailbox.html#module-mailbox" title="mailbox: Manipulate mailboxes in various formats"><code class="xref py py-mod docutils literal"><span class="pre">mailbox</span></code></a> モジュールでは、メールボックスについてそれを読むことに加えて修正出来る能力を追加するための、大々的な書き換えが行われています。 <code class="xref py py-class docutils literal"><span class="pre">mbox</span></code>, <code class="xref py py-class docutils literal"><span class="pre">MH</span></code>, <code class="xref py py-class docutils literal"><span class="pre">Maildir</span></code> を含む新しいクラス群はメールボックス読み込みに使われますが、メッセージ追加のための <code class="docutils literal"><span class="pre">add(message)</span></code> 、削除の <code class="docutils literal"><span class="pre">remove(key)</span></code> 、ロック/アンロックのための <code class="xref py py-meth docutils literal"><span class="pre">lock()</span></code>/<code class="xref py py-meth docutils literal"><span class="pre">unlock()</span></code> も持っています。続く例は maildir 形式から mbox 形式に変換する例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mailbox</span>

<span class="c1"># &#39;factory=None&#39; uses email.Message.Message as the class representing</span>
<span class="c1"># individual messages.</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">mailbox</span><span class="o">.</span><span class="n">Maildir</span><span class="p">(</span><span class="s1">&#39;maildir&#39;</span><span class="p">,</span> <span class="n">factory</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">dest</span> <span class="o">=</span> <span class="n">mailbox</span><span class="o">.</span><span class="n">mbox</span><span class="p">(</span><span class="s1">&#39;/tmp/mbox&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
    <span class="n">dest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contributed by Gregory K. Johnson.  Funding was provided by Google’s 2005
Summer of Code.)</p>
</li>
<li><p class="first">新規モジュール: <a class="reference internal" href="../library/msilib.html#module-msilib" title="msilib: Creation of Microsoft Installer files, and CAB files. (Windows)"><code class="xref py py-mod docutils literal"><span class="pre">msilib</span></code></a> モジュールで、 Microsoft インストーラの <code class="file docutils literal"><span class="pre">.msi</span></code> ファイルと CAB ファイルの作成をすることが出来ます。 <code class="file docutils literal"><span class="pre">.msi</span></code> データベースの読み込みサポートもいくらか入っています。 (Contributed by Martin von Löwis.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/nis.html#module-nis" title="nis: Interface to Sun's NIS (Yellow Pages) library. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">nis</span></code></a> モジュールで、システムデフォルトのドメイン以外のドメインへのアクセスが可能になりました。 <a class="reference internal" href="../library/nis.html#nis.match" title="nis.match"><code class="xref py py-func docutils literal"><span class="pre">nis.match()</span></code></a> と <a class="reference internal" href="../library/nis.html#nis.maps" title="nis.maps"><code class="xref py py-func docutils literal"><span class="pre">nis.maps()</span></code></a> に <em>domain</em> 引数を渡します。 (Contributed by Ben Bell.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal"><span class="pre">operator</span></code></a> モジュールの <code class="xref py py-func docutils literal"><span class="pre">itemgetter()</span></code> 関数と <code class="xref py py-func docutils literal"><span class="pre">attrgetter()</span></code> 関数が複数フィールドをサポートするようになりました。 <code class="docutils literal"><span class="pre">operator.attrgetter('a',</span> <span class="pre">'b')</span></code> のように呼び出すと、 <code class="xref py py-attr docutils literal"><span class="pre">a</span></code> と <code class="xref py py-attr docutils literal"><span class="pre">b</span></code> 属性を取り出す関数を返します。この新機能と <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> メソッドの <code class="docutils literal"><span class="pre">key</span></code> パラメータを組み合わせると、複数フィールドでのリストのソートが簡単になります。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library. (非推奨)"><code class="xref py py-mod docutils literal"><span class="pre">optparse</span></code></a> モジュールが Optik ライブラリのバージョン 1.5.1 に更新されました。 <code class="xref py py-class docutils literal"><span class="pre">OptionParser</span></code> クラスに <code class="xref py py-attr docutils literal"><span class="pre">epilog</span></code> 属性と <code class="xref py py-meth docutils literal"><span class="pre">destroy()</span></code> メソッドが追加されています。前者はヘルプメッセージのあとに出力される文字列です。後者はオブジェクトによって作られた循環参照を破棄します。 (Contributed by Greg Ward.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> モジュールに多数の変更がありました。 <code class="xref py py-attr docutils literal"><span class="pre">stat_float_times</span></code> 値のデフォルトが真となっていて、これはつまり <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a> が時刻の値を浮動小数点数で返すということです。(ただし必ずしも <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a> が秒の端数が正確な値を返すという意味ではありません; 全てのシステムがそのような精度をサポートしてはいません。)</p>
<p>定数 <a class="reference internal" href="../library/os.html#os.SEEK_SET" title="os.SEEK_SET"><code class="xref py py-attr docutils literal"><span class="pre">os.SEEK_SET</span></code></a>, <a class="reference internal" href="../library/os.html#os.SEEK_CUR" title="os.SEEK_CUR"><code class="xref py py-attr docutils literal"><span class="pre">os.SEEK_CUR</span></code></a>, <a class="reference internal" href="../library/os.html#os.SEEK_END" title="os.SEEK_END"><code class="xref py py-attr docutils literal"><span class="pre">os.SEEK_END</span></code></a> が追加されました; これらは <a class="reference internal" href="../library/os.html#os.lseek" title="os.lseek"><code class="xref py py-func docutils literal"><span class="pre">os.lseek()</span></code></a> 関数へ渡すパラメータです。ロックに用いる 2 つの定数 <a class="reference internal" href="../library/os.html#os.O_SHLOCK" title="os.O_SHLOCK"><code class="xref py py-attr docutils literal"><span class="pre">os.O_SHLOCK</span></code></a> と <a class="reference internal" href="../library/os.html#os.O_EXLOCK" title="os.O_EXLOCK"><code class="xref py py-attr docutils literal"><span class="pre">os.O_EXLOCK</span></code></a> が追加されました。</p>
<p>2 つの新しい関数 <code class="xref py py-func docutils literal"><span class="pre">wait3()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">wait4()</span></code> が追加されています。これらは <code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code> 関数に似ています。これは子プロセスが終了するのを待ってプロセス ID とその終了コードを返しますが、 <code class="xref py py-func docutils literal"><span class="pre">wait3()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">wait4()</span></code> は追加の情報を返します。 <code class="xref py py-func docutils literal"><span class="pre">wait3()</span></code> はプロセス ID を入力に取りませんので任意の子プロセス終了を待ち、 <a class="reference internal" href="../library/resource.html#resource.getrusage" title="resource.getrusage"><code class="xref py py-func docutils literal"><span class="pre">resource.getrusage()</span></code></a> 関数から返る <em>process-id</em>, <em>exit-status</em>, <em>resource-usage</em> の 3 要素タプルを返します。 <code class="docutils literal"><span class="pre">wait4(pid)</span></code> はプロセス ID を取ります。 (Contributed by Chad J. Schroeder.)</p>
<p>FreeBSD では、 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a> 関数がナノ秒精度の時刻を返し、また、返却オブジェクトが <code class="xref py py-attr docutils literal"><span class="pre">st_gen</span></code> と <code class="xref py py-attr docutils literal"><span class="pre">st_birthtime</span></code> を持つようになっています。 <code class="xref py py-attr docutils literal"><span class="pre">st_flags</span></code> 属性も、プラットフォームがサポートされている場合には利用可能です。 (Contributed by Antti Louko and Diego Pettenò.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal"><span class="pre">pdb</span></code></a> モジュールで提供される Python デバッガが、ブレイクポイントに到達して実行が停止する際に実行するコマンドのリストを記憶するようになりました。ブレイクポイント #1 を作ったら、 <code class="docutils literal"><span class="pre">commands</span> <span class="pre">1</span></code> を入力し、実行するコマンド群を入力し、 <code class="docutils literal"><span class="pre">end</span></code> でリストを終えます。コマンドリストには <code class="docutils literal"><span class="pre">continue</span></code> や <code class="docutils literal"><span class="pre">next</span></code> のような実行再開コマンドを含めることが出来ます。 (Contributed by Grégoire Dooms.)</p>
</li>
<li><p class="first">ライブラリ: <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>, <code class="xref py py-mod docutils literal"><span class="pre">cPickle</span></code> モジュールが <a class="reference internal" href="../library/pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></code></a> が <code class="docutils literal"><span class="pre">None</span></code> を返すことを許さなくなっています; 必ず引数のタプルを返さなければなりません。また同様に、非推奨となっていた <em>bin</em> キーワードパラメータも、もはや拒絶します。 <code class="docutils literal"><span class="pre">None</span></code> を返すことは Python 2.4 では非推奨となっていて、これにてその機能の削除は完成したことになります。</p>
</li>
<li><p class="first">パッケージ検索のための色々なユーティリティを含む <a class="reference internal" href="../library/pkgutil.html#module-pkgutil" title="pkgutil: Utilities for the import system."><code class="xref py py-mod docutils literal"><span class="pre">pkgutil</span></code></a> モジュールが、PEP 302 のインポートフックをサポートするよう拡張されて、ZIP 形式アーカイブに格納されたパッケージに対しても動作するようになりました。 (Contributed by Phillip J. Eby.)</p>
</li>
<li><p class="first">Marc-André Lemburg による pybench ベンチマークスイートが <code class="file docutils literal"><span class="pre">Tools/pybench</span></code> ディレクトリに含まれるようになりました。pybench スイートは、広く使われている <code class="file docutils literal"><span class="pre">pystone.py</span></code> プログラムの改善版で、インタプリタの速度についてのより詳しい計測を行います。 <code class="file docutils literal"><span class="pre">pystone.py</span></code> のように多くの異なる演算を実行したり単独の数字に縮退する代わりに、これは関数コール、タプルのスライス、メソッドの検索、数値演算のような特定の演算を計測します。 (—訳注: Tools についての言及すべてに共通することですが、原則として Tools は「全て」を入手する手段はソースコード配布を利用することだけです。インストールされるものはプラットフォーム依存や linux であればディストリビュータによっても変わります。顕著なのは Windows で、Tools 配下のものはごく限られたものだけがインストールされます。pybench もソースコード配布物にのみ含まれ、Windows 公式インストーラではインストールされません。なお、 <code class="file docutils literal"><span class="pre">pystone.py</span></code> は Lib/test 内にあります。—)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">pyexpat</span></code> モジュールが使う Expat パーサをバージョン 2.0 にしました。 (Contributed by Trent Mick.)</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal"><span class="pre">Queue</span></code></a> class provided by the <code class="xref py py-mod docutils literal"><span class="pre">Queue</span></code> module gained two new
methods.  <code class="xref py py-meth docutils literal"><span class="pre">join()</span></code> blocks until all items in the queue have been retrieved
and all processing work on the items  have been completed.  Worker threads call
the other new method,  <code class="xref py py-meth docutils literal"><span class="pre">task_done()</span></code>, to signal that processing for an item
has been completed.  (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">古い <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">regsub</span></code> モジュール、これは Python 2.0 からずっと非推奨になっていましたが、ついに削除されました。ほかにも、 <code class="xref py py-mod docutils literal"><span class="pre">statcache</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">tzparse</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">whrandom</span></code> が削除されています。</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">dircmp</span></code> や <code class="xref py py-mod docutils literal"><span class="pre">ni</span></code> といった石器時代のモジュールを大事にしまっていた <code class="file docutils literal"><span class="pre">lib-old</span></code> ディレクトリも削除されました。  <code class="file docutils literal"><span class="pre">lib-old</span></code> がデフォルトで <code class="docutils literal"><span class="pre">sys.path</span></code> に含まれることはなかったので、あなたが明示的にそれを <code class="docutils literal"><span class="pre">sys.path</span></code> に入れてこなかった限り、この削除はあなたには関係ないでしょう。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/rlcompleter.html#module-rlcompleter" title="rlcompleter: Python identifier completion, suitable for the GNU readline library."><code class="xref py py-mod docutils literal"><span class="pre">rlcompleter</span></code></a> モジュールが <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">readline</span></code></a> モジュールのインポートに依存しないようになりました。これにより非 Unix プラットフォームで動作するようになりました。 (Patch from Robert Kiendl.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">SimpleXMLRPCServer</span></code> クラスと <code class="xref py py-mod docutils literal"><span class="pre">DocXMLRPCServer</span></code> クラスに XML-RPC 操作を限られた URL パスに制限する <code class="xref py py-attr docutils literal"><span class="pre">rpc_paths</span></code> 属性が追加されています; デフォルトでは <code class="docutils literal"><span class="pre">'/'</span></code> と <code class="docutils literal"><span class="pre">'/RPC2'</span></code> のみが許されています。 <code class="xref py py-attr docutils literal"><span class="pre">rpc_paths</span></code> に <code class="docutils literal"><span class="pre">None</span></code> か空のタプルを渡すことで、このパスのチェックは無効になります。</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> module now supports <code class="xref py py-const docutils literal"><span class="pre">AF_NETLINK</span></code> sockets on Linux,
thanks to a patch from Philippe Biondi.   Netlink sockets are a Linux-specific
mechanism for communications between a user-space process and kernel code; an
introductory  article about them is at <a class="reference external" href="https://www.linuxjournal.com/article/7356">https://www.linuxjournal.com/article/7356</a>.
In Python code, netlink addresses are represented as a tuple of 2 integers,
<code class="docutils literal"><span class="pre">(pid,</span> <span class="pre">group_mask)</span></code>.</p>
<p>ソケットオブジェクトの 2 つの新たなメソッド、 <code class="docutils literal"><span class="pre">recv_into(buffer)</span></code>, <code class="docutils literal"><span class="pre">recvfrom_into(buffer)</span></code> は、受信データを、文字列データとして返す代わりにバッファプロトコルをサポートするオブジェクトに書き込みます。このことにより、受信データを直接 array やメモリマップドファイルに置けます。</p>
<p>ソケットオブジェクトには <code class="xref py py-meth docutils literal"><span class="pre">getfamily()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">gettype()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">getproto()</span></code> アクセッサメソッドも追加されています。それぞれソケットについてのアドレスファミリ、タイプ、プロトコルを取得します。</p>
</li>
<li><p class="first">新規モジュール: <a class="reference internal" href="../library/spwd.html#module-spwd" title="spwd: The shadow password database (getspnam() and friends). (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">spwd</span></code></a> モジュールは、シャドーパスワードをサポートするシステムにおいて、シャドーパスワードデータベースへのアクセスを提供します。</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">pack()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">unpack()</span></code> メソッドでフォーマット文字列を <code class="xref py py-class docutils literal"><span class="pre">Struct</span></code> オブジェクトにコンパイルすることで、 <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> がより高速になっています。これは <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールでコンパイル済み正規表現オブジェクトを作れるのに似ています。モジュールレベルの <code class="xref py py-func docutils literal"><span class="pre">pack()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">unpack()</span></code> 関数もそのまま使えます; それらは <code class="xref py py-class docutils literal"><span class="pre">Struct</span></code> オブジェクトを作ってキャッシュします。あるいは <code class="xref py py-class docutils literal"><span class="pre">Struct</span></code> インスタンスを直接使えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s1">&#39;ih3s&#39;</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="mi">1972</span><span class="p">,</span> <span class="mi">187</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="n">year</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also pack and unpack data to and from buffer objects directly using the
<code class="docutils literal"><span class="pre">pack_into(buffer,</span> <span class="pre">offset,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">...)</span></code> and <code class="docutils literal"><span class="pre">unpack_from(buffer,</span>
<span class="pre">offset)</span></code> methods.  This lets you store data directly into an array or a
memory-mapped file.</p>
<p>(<code class="xref py py-class docutils literal"><span class="pre">Struct</span></code> objects were implemented by Bob Ippolito at the NeedForSpeed
sprint.  Support for buffer objects was added by Martin Blais, also at the
NeedForSpeed sprint.)</p>
</li>
<li><p class="first">Python デベロッパは 2.5 開発プロセスの間で CVS から Subversion に移行しました。ビルドバージョンについての正確な情報は <code class="docutils literal"><span class="pre">sys.subversion</span></code> により取得可能で、これは 3 要素タプル <code class="docutils literal"><span class="pre">(interpreter-name,</span> <span class="pre">branch-name,</span> <span class="pre">revision-range)</span></code> です。例えば執筆時点では 2.5 で <code class="docutils literal"><span class="pre">('CPython',</span> <span class="pre">'trunk',</span> <span class="pre">'45313:45315')</span></code> を返します。 (—訳注: Python 3.2 から 3.3 にかけて、開発が Mercurial に移行していて、これは 2.7 メンテナンスリリースの間にあたります。今(3.6 dev 時点)では全て Mercurial に移行しており、 <code class="docutils literal"><span class="pre">sys.subversion</span></code> は今では意味のある値は返しません。3.3 からは既に <code class="docutils literal"><span class="pre">sys.subversion</span></code> は削除されています。—)</p>
<p>この情報は C 拡張から <a class="reference internal" href="../c-api/init.html#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal"><span class="pre">Py_GetBuildInfo()</span></code></a> 関数を使っても得ることが出来ます。これはビルド情報についての文字列を返し、例えば <code class="docutils literal"><span class="pre">&quot;trunk:45355:45356M,</span> <span class="pre">Apr</span> <span class="pre">13</span> <span class="pre">2006,</span> <span class="pre">07:42:19&quot;</span></code> のような値です。 (Contributed by Barry Warsaw.)</p>
</li>
<li><p class="first">もう一つの新規関数 <a class="reference internal" href="../library/sys.html#sys._current_frames" title="sys._current_frames"><code class="xref py py-func docutils literal"><span class="pre">sys._current_frames()</span></code></a> は、実行スレッドについての現在スタックフレームを、各スレッドの識別子がキーの辞書として返します。辞書の値は、関数が呼ばれた時点のそのスレッドで現在アクティブになっているスタックフレームの一番上です。(Contributed by Tim Peters.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal"><span class="pre">tarfile</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">TarFile</span></code> クラスに <code class="xref py py-meth docutils literal"><span class="pre">extractall()</span></code> メソッドが追加されました。アーカイブから全てのメンバをカレントディレクトリに抽出します。抽出ターゲットとして別のディレクトリも指定できますし、アーカイブメンバのサブセットのみ解凍することも出来ます。</p>
<p>ストリームモードで開く tarfile に使われる圧縮を、モード <code class="docutils literal"><span class="pre">'r|*'</span></code> を使って自動で検出出来るようになっています。 (Contributed by Lars Gustäbel.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールで、新しいスレッドを作る際に使われるスタックサイズを設定出来るようになりました。 <code class="docutils literal"><span class="pre">stack_size([*size*])</span></code> 関数は現在構成されているスタックサイズを返し、省略可能引数 <em>size</em> パラメータを与えると新しい値を設定します。全てのプラットフォームがスタックサイズ変更をサポートしているわけではなく、Windows、POSIX スレッド、OS/2 で可能です。 (Contributed by Andrew MacIntyre.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal"><span class="pre">unicodedata</span></code></a> モジュールが、 Unicode 文字データベースのバージョン 4.1.0 を使うように更新されました。いくつかの仕様によってバージョン 3.2.0 が必要とされるので、 <a class="reference internal" href="../library/unicodedata.html#unicodedata.ucd_3_2_0" title="unicodedata.ucd_3_2_0"><code class="xref py py-attr docutils literal"><span class="pre">unicodedata.ucd_3_2_0</span></code></a> としてまだ利用可能です。</p>
</li>
<li><p class="first">新モジュール: <a class="reference internal" href="../library/uuid.html#module-uuid" title="uuid: UUID objects (universally unique identifiers) according to RFC 4122"><code class="xref py py-mod docutils literal"><span class="pre">uuid</span></code></a> モジュールは <span class="target" id="index-70"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4122.html"><strong>RFC 4122</strong></a> による UUID (universally unique identifiers) を生成します。その RFC ではいくつかの異なる UUID のバージョンを定義しており、文字列から生成するもの、システム特性から生成するもの、純粋に乱数から生成するものがあります。このモジュールでは <code class="xref py py-class docutils literal"><span class="pre">UUID</span></code> クラスと <code class="xref py py-func docutils literal"><span class="pre">uuid1()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">uuid3()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">uuid4()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">uuid5()</span></code> 関数を持っていて、それら異なったバージョンの UUID を生成します。(UUID バージョン 2 は <span class="target" id="index-71"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4122.html"><strong>RFC 4122</strong></a> にありませんのでこのモジュールにもないです)</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">uuid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a UUID based on the host ID and current time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">()</span>
<span class="go">UUID(&#39;a8098c1a-f86e-11da-bd1a-00112444be1e&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a UUID using an MD5 hash of a namespace UUID and a name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid3</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">NAMESPACE_DNS</span><span class="p">,</span> <span class="s1">&#39;python.org&#39;</span><span class="p">)</span>
<span class="go">UUID(&#39;6fa459ea-ee8a-3ca4-894e-db77e160355e&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a random UUID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
<span class="go">UUID(&#39;16fd2706-8baf-433b-82eb-8c7fada847da&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid5</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">NAMESPACE_DNS</span><span class="p">,</span> <span class="s1">&#39;python.org&#39;</span><span class="p">)</span>
<span class="go">UUID(&#39;886313e1-3b8a-5372-9b90-0c9aee199e5d&#39;)</span>
</pre></div>
</div>
<p>(Contributed by Ka-Ping Yee.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code> 型と <code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code> 型に、辞書内に含まれる弱参照を巡回する新たなメソッドが追加されています。 <code class="xref py py-meth docutils literal"><span class="pre">iterkeyrefs()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">keyrefs()</span></code> が <code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code> に追加され、 <code class="xref py py-meth docutils literal"><span class="pre">itervaluerefs()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">valuerefs()</span></code> が <code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code> に追加されました。(Contributed by Fred L. Drake, Jr.)</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/webbrowser.html#module-webbrowser" title="webbrowser: Easy-to-use controller for Web browsers."><code class="xref py py-mod docutils literal"><span class="pre">webbrowser</span></code></a> module received a number of enhancements. It’s now
usable as a script with <code class="docutils literal"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">webbrowser</span></code>, taking a URL as the argument;
there are a number of switches  to control the behaviour (<code class="xref std std-option docutils literal"><span class="pre">-n</span></code> for a new
browser window,  <code class="xref std std-option docutils literal"><span class="pre">-t</span></code> for a new tab).  New module-level functions,
<code class="xref py py-func docutils literal"><span class="pre">open_new()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">open_new_tab()</span></code>, were added  to support this.  The
module’s <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> function supports an additional feature, an <em>autoraise</em>
parameter that signals whether to raise the open window when possible. A number
of additional browsers were added to the supported list such as Firefox, Opera,
Konqueror, and elinks.  (Contributed by Oleg Broytmann and Georg Brandl.)</p>
</li>
<li><p class="first">The <code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code> module now supports returning  <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal"><span class="pre">datetime</span></code></a> objects
for the XML-RPC date type.  Supply  <code class="docutils literal"><span class="pre">use_datetime=True</span></code> to the <code class="xref py py-func docutils literal"><span class="pre">loads()</span></code>
function or the <code class="xref py py-class docutils literal"><span class="pre">Unmarshaller</span></code> class to enable this feature. (Contributed
by Skip Montanaro.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal"><span class="pre">zipfile</span></code></a> モジュールが ZIP64 バージョンのフォーマットをサポートしました。これで 4GiB を超える zip 書庫を作れ、4GiB を超えるファイルを書庫に含めることが出来ます。 (Contributed by Ronald Oussoren.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal"><span class="pre">zlib</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">Compress</span></code> , <code class="xref py py-class docutils literal"><span class="pre">Decompress</span></code> オブジェクトが <a class="reference internal" href="../library/copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a> メソッドをサポートするようになりました。オブジェクトの内部状態を複製して新しい <code class="xref py py-class docutils literal"><span class="pre">Compress</span></code> あるいは <code class="xref py py-class docutils literal"><span class="pre">Decompress</span></code> オブジェクトを返します。 (Contributed by Chris AtLee.)</p>
</li>
</ul>
<div class="section" id="the-ctypes-package">
<span id="module-ctypes"></span><h3>ctypes パッケージ<a class="headerlink" href="#the-ctypes-package" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Thomas Heller による <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> パッケージが標準ライブラリに追加されました。 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> はシェアドライブラリや DLL の任意の関数呼び出しを担ってくれます。熟練ユーザであれば <code class="xref py py-mod docutils literal"><span class="pre">dl</span></code> モジュールは知っているでしょう。これはシェアドライブラリのロードとその中の関数呼び出しをするための関数を提供していました。 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> パッケージはこれより遥かに手が込んでいます。</p>
<p>シェアドライブラリや DLL をロードするには、 <code class="xref py py-class docutils literal"><span class="pre">CDLL</span></code> クラスのインスタンスを、その名前かパスを渡して構築します。構築したら、 <code class="xref py py-class docutils literal"><span class="pre">CDLL</span></code> オブジェクトの属性にアクセスすることで任意の関数呼び出しが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ctypes</span>

<span class="n">libc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="s1">&#39;libc.so.6&#39;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Line of output</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>様々な C の型についての型コンストラクタが提供されています: <code class="xref py py-func docutils literal"><span class="pre">c_int()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">c_float()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">c_double()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">c_char_p()</span></code> (<code class="xref c c-type docutils literal"><span class="pre">char</span> <span class="pre">*</span></code> に等価), など。Python 型とは違い、C 版は全て <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> です; <code class="xref py py-attr docutils literal"><span class="pre">value</span></code> 属性を介して値を代入出来ます。 Python 整数と文字列は自動的に対応する C 型に変換されますが、それ以外の型では適切な型コンストラクタを使わなければなりません。(<em>なければなりません</em> と言いました。間違えれば、インタプリタがセグメンテーション違反で落ちるなどしょっちゅうです。)</p>
<p>C 関数がメモリ領域を更新するものである場合、Python 文字列に <code class="xref py py-func docutils literal"><span class="pre">c_char_p()</span></code> を使うべきではありません。 Python 文字列は <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> であることを前提としているからです; この規則を犯すことは頭を掻き毟るバグを引き起こすでしょう。更新可能なメモリ領域が必要な場合は <code class="xref py py-func docutils literal"><span class="pre">create_string_buffer()</span></code> を使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;this is a string&quot;</span>
<span class="n">buf</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">libc</span><span class="o">.</span><span class="n">strfry</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</pre></div>
</div>
<p>C 関数はデフォルトでは整数を返すと仮定されますが、関数オブジェクトの <code class="xref py py-attr docutils literal"><span class="pre">restype</span></code> 属性をセットすることでこれを変更出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="p">(</span><span class="s1">&#39;2.71828&#39;</span><span class="p">)</span>
<span class="go">-1783957616</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="p">(</span><span class="s1">&#39;2.71828&#39;</span><span class="p">)</span>
<span class="go">2.71828</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> では同時に Python の C API も提供していて、 <code class="docutils literal"><span class="pre">ctypes.pythonapi</span></code> オブジェクトとして利用出来ます。このオブジェクトは関数呼び出し前に <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a> を解放 <em>しません</em> 。インタプリタ内のコードを呼び出すのにロックは保持されていなければならないからです。 <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> ポインタを構築する <code class="xref py py-class docutils literal"><span class="pre">py_object()</span></code> 型コンストラクタもあります。単純な利用法はこうです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ctypes</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">PyObject_SetItem</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">d</span><span class="p">),</span>
          <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">),</span>  <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># d is now {&#39;abc&#39;, 1}.</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">py_object()</span></code> を使うことを忘れないように; 怠るとセグメンテーション違反と相成る、はず。</p>
<p><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> が周辺ライブラリとして登場してしばらく経ちますが、<a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> が存在していることに依存できないとなれば人々はまだハードコードされた拡張モジュールを書いて配布します。 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> が Python 中核に含められた今、おそらく開発者たちは、拡張モジュールの代わりに <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> を介してアクセスするライブラリの上に Python ラッパーを書き始めるでしょう,</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="docutils">
<dt><a class="reference external" href="http://starship.python.net/crew/theller/ctypes/">http://starship.python.net/crew/theller/ctypes/</a></dt>
<dd>ctypes のウェブページで、チュートリアル、リファレンス、FAQ があります。</dd>
</dl>
<p class="last"><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> モジュールについてのドキュメント。</p>
</div>
</div>
<div class="section" id="the-elementtree-package">
<span id="module-etree"></span><h3>ElementTree パッケージ<a class="headerlink" href="#the-elementtree-package" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>XML 処理のための、Fredrik Lundh の ElementTree ライブラリのサブセットが、標準ライブラリに <code class="xref py py-mod docutils literal"><span class="pre">xml.etree</span></code> として追加されました。利用可能なモジュールは ElementTree 1.2.6 よりの <code class="xref py py-mod docutils literal"><span class="pre">ElementTree</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">ElementPath</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">ElementInclude</span></code> です。 C 実装 <code class="xref py py-mod docutils literal"><span class="pre">cElementTree</span></code> モジュールも含まれています。</p>
<p>このセクションの残りの部分は ElementTree 利用の簡単な概略について提供します。完全なドキュメントは <a class="reference external" href="http://effbot.org/zone/element-index.htm">http://effbot.org/zone/element-index.htm</a> より利用可能です。</p>
<p>ElementTree は XML ドキュメントを、要素ノードのツリーとして表現します。ドキュメントのテキストコンテントは <code class="xref py py-attr docutils literal"><span class="pre">text</span></code> 属性と <code class="xref py py-attr docutils literal"><span class="pre">tail</span></code> 属性に格納されます (これが ElementTree と Document Object Model (DOM) との一番大きな違いです; DOM 内ではノードの数多くの型があります。 <code class="xref py py-class docutils literal"><span class="pre">TextNode</span></code> はその一つです。)</p>
<p>最も一般的に使う解析関数は <code class="xref py py-func docutils literal"><span class="pre">parse()</span></code> です。これは (ファイル名が含まれるとみなされる) 文字列またはファイルのようなオブジェクトを受け取って、 <code class="xref py py-class docutils literal"><span class="pre">ElementTree</span></code> インスタンスを返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree</span> <span class="k">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">ET</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;ex-1.xml&#39;</span><span class="p">)</span>

<span class="n">feed</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span>
          <span class="s1">&#39;http://planet.python.org/rss10.xml&#39;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">feed</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">ElementTree</span></code> インスタンスを手にしてしまえば、あとはルートの <code class="xref py py-class docutils literal"><span class="pre">Element</span></code> ノードを得るために <code class="xref py py-meth docutils literal"><span class="pre">getroot()</span></code> を呼び出せます。</p>
<p>文字列リテラルを受け取って (<code class="xref py py-class docutils literal"><span class="pre">ElementTree</span></code> ではなく) <code class="xref py py-class docutils literal"><span class="pre">Element</span></code> ノードを返す <code class="xref py py-func docutils literal"><span class="pre">XML()</span></code> 関数 もあります。この関数を使えば、簡単に XML リテラルを使って XML 断片からツリーを組み上げることが綺麗に出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">svg</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&lt;svg width=&quot;10px&quot; version=&quot;1.0&quot;&gt;</span>
<span class="s2">             &lt;/svg&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">svg</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;320px&#39;</span><span class="p">)</span>
<span class="n">svg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span>
</pre></div>
</div>
<p>個々の XML 要素はいくつかの辞書のような、いくつかのリストのようなメソッドをサポートしています。辞書的な操作は属性値のアクセスに使い、リスト的な操作は子ノードのアクセスに使います。</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">演算</th>
<th class="head">結果</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">elem[n]</span></code></td>
<td>n 番目の子要素を返す。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">elem[m:n]</span></code></td>
<td>m 番目から n 番目までの子要素を返す(—訳注: n は含まない—)。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">len(elem)</span></code></td>
<td>子要素数を返す。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">list(elem)</span></code></td>
<td>子要素のリストを返す。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">elem.append(elem2)</span></code></td>
<td><em>elem2</em> を子として追加する。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">elem.insert(index,</span> <span class="pre">elem2)</span></code></td>
<td>指定された位置に <em>elem2</em> を挿入する。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">elem[n]</span></code></td>
<td>n 番目の子要素を削除する。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">elem.keys()</span></code></td>
<td>属性名のリストを返す。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">elem.get(name)</span></code></td>
<td>属性 <em>name</em> の値を返す。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">elem.set(name,</span> <span class="pre">value)</span></code></td>
<td>属性 <em>name</em> に新しい値をセットする。</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">elem.attrib</span></code></td>
<td>属性を含んだ辞書を取り出す。</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">elem.attrib[name]</span></code></td>
<td>属性 <em>name</em> を削除する。</td>
</tr>
</tbody>
</table>
<p>コメントと処理命令 (processing instruction=PI) も、 <code class="xref py py-class docutils literal"><span class="pre">Element</span></code> ノードで表現されます。ノードがコメントあるいは処理命令であるかをチェックするにはこのようにします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="n">ET</span><span class="o">.</span><span class="n">Comment</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">elif</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="n">ET</span><span class="o">.</span><span class="n">ProcessingInstruction</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>XML 出力を生成するには <code class="xref py py-meth docutils literal"><span class="pre">ElementTree.write()</span></code> メソッドを呼び出す必要があります。 <code class="xref py py-func docutils literal"><span class="pre">parse()</span></code> のように、文字列もしくはファイルのようなオブジェクトを渡せます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Encoding is US-ASCII</span>
<span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>

<span class="c1"># Encoding is UTF-8</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(警告: 出力に使われるデフォルトエンコーディングは ASCII です。一般的な XML での作業では要素名に任意の Unicode 文字を含められるので、ASCII エンコーディングはあまり役に立ちません。要素名に 127 より大きなどんな文字が含まれても例外となりますので。ですから任意の Unicode 文字を扱うために UTF-8 のようなエンコーディングを指定するのが吉です。)</p>
<p>このセクションでは  ElementTree インターフェイスのほんの一部しか記載していません。さらに詳しい情報については、パッケージの公式ドキュメントを参照して下さい。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://effbot.org/zone/element-index.htm">http://effbot.org/zone/element-index.htm</a></dt>
<dd>ElementTree の公式ドキュメント</dd>
</dl>
</div>
</div>
<div class="section" id="the-hashlib-package">
<span id="module-hashlib"></span><h3>hashlib パッケージ<a class="headerlink" href="#the-hashlib-package" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Gregory P. Smith による新モジュール <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal"><span class="pre">hashlib</span></code></a> が、 <code class="xref py py-mod docutils literal"><span class="pre">md5</span></code> と <code class="xref py py-mod docutils literal"><span class="pre">sha</span></code> モジュールを置き換えるものとして追加されました。 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal"><span class="pre">hashlib</span></code></a> は新たなセキュアハッシュ (SHA-224, SHA-256, SHA-384, SHA-512) サポートを追加しています。利用可能な場合、このモジュールは OpenSSL を使ってアルゴリズムのプラットフォームに最適化された高速実装を使います。</p>
<p>古い <code class="xref py py-mod docutils literal"><span class="pre">md5</span></code> と <code class="xref py py-mod docutils literal"><span class="pre">sha</span></code> モジュールは、後方互換のための hashlib へのラッパーとして残されています。新しいモジュールのインターフェイスは古いものと似てはいますが同じではありません。一番顕著な違いはそのコンストラクタ関数で、新しくハッシュオブジェクトを作るための名前が違います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Old versions</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">md5</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">md5</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

<span class="c1"># New version</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>

<span class="c1"># Old versions</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">sha</span><span class="o">.</span><span class="n">sha</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">sha</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

<span class="c1"># New version</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>

<span class="c1"># Hash that weren&#39;t previously available</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha224</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha384</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha512</span><span class="p">()</span>

<span class="c1"># Alternative form</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;md5&#39;</span><span class="p">)</span>          <span class="c1"># Provide algorithm as a string</span>
</pre></div>
</div>
<p>ハッシュオブジェクトを作ってしまえばあとはそのメソッドは以前と同じです: <code class="xref py py-meth docutils literal"><span class="pre">update(string)()</span></code> は指定された文字列を現在のダイジェスト状態にハッシュ更新し、 <code class="xref py py-meth docutils literal"><span class="pre">digest()</span></code> と <code class="xref py py-meth docutils literal"><span class="pre">hexdigest()</span></code> は結果のダイジェスト値をバイナリ文字列・16進数表記文字列として返し、 <a class="reference internal" href="../library/copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code></a> はダイジェスト状態を複製して新たなハッシュオブジェクトを作ります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal"><span class="pre">hashlib</span></code></a> モジュールについてのドキュメント。</p>
</div>
</div>
<div class="section" id="the-sqlite3-package">
<span id="module-sqlite"></span><h3>sqlite3 パッケージ<a class="headerlink" href="#the-sqlite3-package" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>pysqlite モジュール (<a class="reference external" href="http://www.pysqlite.org">http://www.pysqlite.org</a>) は SQLite 埋め込みデータベースへのラッパーであり、これが標準ライブラリに <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal"><span class="pre">sqlite3</span></code></a> 名のパッケージとして追加されました。</p>
<p>SQLite は、軽量なディスク上のデータベースを提供する C ライブラリです。別のサーバプロセスを用意する必要なく、 SQL クエリー言語の非標準的な一種を使用してデータベースにアクセスできます。一部のアプリケーションは内部データ保存に SQLite を使えます。また、SQLite を使ってアプリケーションのプロトタイプを作り、その後そのコードを PostgreSQL や Oracle のような大規模データベースに移植するということも可能です。</p>
<p>pysqlite  は Gerhard Häring によって書かれ、 <span class="target" id="index-72"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249"><strong>PEP 249</strong></a> に記述された DB-API 2.0 仕様に準拠した SQL インタフェースを提供するものです。</p>
<p>ソースコードから Python をビルドする場合は注意してください。Python ソースツリーは SQLite コードを含まずラッパーモジュールのみを含んでいます。Python ビルド前に SQLite ライブラリとヘッダをインストールする必要があります。必要ヘッダが利用可能となっていればモジュールはビルドされます。</p>
<p>このモジュールを使うには、最初にデータベースを表す <code class="xref py py-class docutils literal"><span class="pre">Connection</span></code> オブジェクトを作ります。ここではデータはファイル <code class="file docutils literal"><span class="pre">/tmp/example</span></code> に格納されているものとします。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;/tmp/example&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>特別な名前である <code class="docutils literal"><span class="pre">:memory:</span></code> を使うと RAM 上にデータベースを作ることもできます。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code> があれば、 <code class="xref py py-class docutils literal"><span class="pre">Cursor</span></code> オブジェクトを作りその <code class="xref py py-meth docutils literal"><span class="pre">execute()</span></code> メソッドを呼んで SQL コマンドを実行することができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="c1"># Create table</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;create table stocks</span>
<span class="s1">(date text, trans text, symbol text,</span>
<span class="s1"> qty real, price real)&#39;&#39;&#39;</span><span class="p">)</span>

<span class="c1"># Insert a row of data</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;insert into stocks</span>
<span class="s2">          values (&#39;2006-01-05&#39;,&#39;BUY&#39;,&#39;RHAT&#39;,100,35.14)&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>たいてい、SQL 操作は Python 変数の値を使う必要があります。この時、クエリーを Python の文字列操作を使って構築することは、安全とは言えないので、すべきではありません。そのようなことをするとプログラムが SQL インジェクション攻撃に対し脆弱になりかねません。</p>
<p>代わりに、DB-API のパラメータ割り当てを使います。 <code class="docutils literal"><span class="pre">?</span></code> を変数の値を使いたいところに埋めておきます。その上で、値のタプルをカーソルの <code class="xref py py-meth docutils literal"><span class="pre">execute()</span></code> メソッドの第2引数として引き渡します。(他のデータベースモジュールでは変数の場所を示すのに <code class="docutils literal"><span class="pre">%s</span></code> や <code class="docutils literal"><span class="pre">:1</span></code> などの異なった表記を用いることがあります。) 例を示します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Never do this -- insecure!</span>
<span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;IBM&#39;</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;... where symbol = &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">symbol</span><span class="p">)</span>

<span class="c1"># Do this instead</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,)</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from stocks where symbol=?&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="c1"># Larger example</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;2006-03-28&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">45.00</span><span class="p">),</span>
          <span class="p">(</span><span class="s1">&#39;2006-04-05&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;MSOFT&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">72.00</span><span class="p">),</span>
          <span class="p">(</span><span class="s1">&#39;2006-04-06&#39;</span><span class="p">,</span> <span class="s1">&#39;SELL&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">53.00</span><span class="p">),</span>
         <span class="p">):</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into stocks values (?,?,?,?,?)&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>SELECT 文を実行した後データを取得する方法は3つありどれを使っても構いません。一つはカーソルをイテレータ (<a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>) として扱う、一つはカーソルの <code class="xref py py-meth docutils literal"><span class="pre">fetchone()</span></code> メソッドを呼んで一致した内の一行を取得する、もう一つは <code class="xref py py-meth docutils literal"><span class="pre">fetchall()</span></code> メソッドを呼んで一致した全ての行のリストとして受け取る、という3つです。</p>
<p>以下の例ではイテレータの形を使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from stocks order by price&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">row</span>
<span class="gp">...</span>
<span class="go">(u&#39;2006-01-05&#39;, u&#39;BUY&#39;, u&#39;RHAT&#39;, 100, 35.140000000000001)</span>
<span class="go">(u&#39;2006-03-28&#39;, u&#39;BUY&#39;, u&#39;IBM&#39;, 1000, 45.0)</span>
<span class="go">(u&#39;2006-04-06&#39;, u&#39;SELL&#39;, u&#39;IBM&#39;, 500, 53.0)</span>
<span class="go">(u&#39;2006-04-05&#39;, u&#39;BUY&#39;, u&#39;MSOFT&#39;, 1000, 72.0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>For more information about the SQL dialect supported by SQLite, see
<a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="docutils">
<dt><a class="reference external" href="http://www.pysqlite.org">http://www.pysqlite.org</a></dt>
<dd>pysqlite のウェブページ。</dd>
<dt><a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a></dt>
<dd>SQLite のウェブページ。ここの文書ではサポートされる SQL 方言の文法と使えるデータ型を説明しています。</dd>
</dl>
<p><a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal"><span class="pre">sqlite3</span></code></a> モジュールについてのドキュメント。</p>
<dl class="last docutils">
<dt><span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249"><strong>PEP 249</strong></a> - Database API Specification 2.0</dt>
<dd>Marc-Andre Lemburg により書かれた PEP。</dd>
</dl>
</div>
</div>
<div class="section" id="the-wsgiref-package">
<span id="module-wsgiref"></span><h3>wsgiref パッケージ<a class="headerlink" href="#the-wsgiref-package" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Web Server Gateway Interface (WSGI) v1.0 は、 Web サーバと Python で記述された Web アプリケーションとの標準インターフェースであり、 <span class="target" id="index-73"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0333"><strong>PEP 333</strong></a> で定義されています。  <a class="reference internal" href="../library/wsgiref.html#module-wsgiref" title="wsgiref: WSGI Utilities and Reference Implementation."><code class="xref py py-mod docutils literal"><span class="pre">wsgiref</span></code></a> パッケージは WSGI 仕様のリファレンス実装です。</p>
<p>パッケージには WSGI アプリケーションとして動作する基礎的な HTTP サーバが含まれています; このサーバは製品ユースではないデバッグ目的に有用です。サーバをセットアップするには僅か数行で済みます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">wsgiref</span> <span class="k">import</span> <span class="n">simple_server</span>

<span class="n">wsgi_app</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8000</span>
<span class="n">httpd</span> <span class="o">=</span> <span class="n">simple_server</span><span class="o">.</span><span class="n">make_server</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">wsgi_app</span><span class="p">)</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://www.wsgi.org">http://www.wsgi.org</a></dt>
<dd>WSGI 関連のリソースについて集約しているウェブサイト。</dd>
<dt><span class="target" id="index-24"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0333"><strong>PEP 333</strong></a> - Python Web Server Gateway Interface v1.0</dt>
<dd>PEP 著 Phillip J. Eby.</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="build-and-c-api-changes">
<span id="build-api"></span><h2>ビルドならびに C API の変更<a class="headerlink" href="#build-and-c-api-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のビルド過程と C API の変更は以下の通りです:</p>
<ul>
<li><p class="first">Python ソースツリーは CVS から Subversion に変換されました。この複雑な移行手続きは Martin von Löwis によって指揮されつつがなく遂行されました。この手続きは <span class="target" id="index-74"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0347"><strong>PEP 347</strong></a> にて開発されました。</p>
</li>
<li><p class="first">Coverity, a company that markets a source code analysis tool called Prevent,
provided the results of their examination of the Python source code.  The
analysis found about 60 bugs that  were quickly fixed.  Many of the bugs were
refcounting problems, often occurring in error-handling code.  See
<a class="reference external" href="https://scan.coverity.com">https://scan.coverity.com</a> for the statistics.</p>
</li>
<li><p class="first"><span class="target" id="index-75"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0353"><strong>PEP 353</strong></a> に由来する C API の大きな変更がありました。これはインタプリタを <code class="xref c c-type docutils literal"><span class="pre">int</span></code> ではなく <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> 型定義を使うように修正するものです。詳細は前のほうのセクション <a class="reference internal" href="#pep-353"><span class="std std-ref">PEP 353: 添え字型に ssize_t を使う</span></a> を参照して下さい。</p>
</li>
<li><p class="first">The design of the bytecode compiler has changed a great deal,  no longer
generating bytecode by traversing the parse tree.  Instead the parse tree is
converted to an abstract syntax tree (or AST), and it is  the abstract syntax
tree that’s traversed to produce the bytecode.</p>
<p>It’s possible for Python code to obtain AST objects by using the
<a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> built-in and specifying <code class="docutils literal"><span class="pre">_ast.PyCF_ONLY_AST</span></code> as the value of
the  <em>flags</em> parameter:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">_ast</span> <span class="k">import</span> <span class="n">PyCF_ONLY_AST</span>
<span class="n">ast</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;a=0</span>
<span class="s2">for i in range(10):</span>
<span class="s2">    a += i</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">,</span> <span class="n">PyCF_ONLY_AST</span><span class="p">)</span>

<span class="n">assignment</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">for_loop</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>No official documentation has been written for the AST code yet, but <span class="target" id="index-27"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0339"><strong>PEP 339</strong></a>
discusses the design.  To start learning about the code, read the definition of
the various AST nodes in <code class="file docutils literal"><span class="pre">Parser/Python.asdl</span></code>.  A Python script reads this
file and generates a set of C structure definitions in
<code class="file docutils literal"><span class="pre">Include/Python-ast.h</span></code>.  The <code class="xref c c-func docutils literal"><span class="pre">PyParser_ASTFromString()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">PyParser_ASTFromFile()</span></code>, defined in <code class="file docutils literal"><span class="pre">Include/pythonrun.h</span></code>, take
Python source as input and return the root of an AST representing the contents.
This AST can then be turned into a code object by <code class="xref c c-func docutils literal"><span class="pre">PyAST_Compile()</span></code>.  For
more information, read the source code, and then ask questions on python-dev.</p>
<p>The AST code was developed under Jeremy Hylton’s management, and implemented by
(in alphabetical order) Brett Cannon, Nick Coghlan, Grant Edwards, John
Ehresman, Kurt Kaiser, Neal Norwitz, Tim Peters, Armin Rigo, and Neil
Schemenauer, plus the participants in a number of AST sprints at conferences
such as PyCon.</p>
</li>
<li><p class="first">Evan Jones’s patch to obmalloc, first described in a talk at PyCon DC 2005,
was applied.  Python 2.4 allocated small objects in 256K-sized arenas, but never
freed arenas.  With this patch, Python will free arenas when they’re empty.  The
net effect is that on some platforms, when you allocate many objects, Python’s
memory usage may actually drop when you delete them and the memory may be
returned to the operating system.  (Implemented by Evan Jones, and reworked by
Tim Peters.)</p>
<p>Note that this change means extension modules must be more careful when
allocating memory.  Python’s API has many different functions for allocating
memory that are grouped into families.  For example, <a class="reference internal" href="../c-api/memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>,
<a class="reference internal" href="../c-api/memory.html#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a>, and <a class="reference internal" href="../c-api/memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a> are one family that allocates
raw memory, while <a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Realloc()</span></code></a>, and
<a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Free()</span></code></a> are another family that’s supposed to be used for
creating Python objects.</p>
<p>Previously these different families all reduced to the platform’s
<code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> functions.  This meant  it didn’t matter if
you got things wrong and allocated memory with the <code class="xref c c-func docutils literal"><span class="pre">PyMem()</span></code> function but
freed it with the <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-func docutils literal"><span class="pre">PyObject()</span></code></a> function.  With 2.5’s changes to obmalloc,
these families now do different things and mismatches will probably result in a
segfault.  You should carefully test your C extension modules with Python 2.5.</p>
</li>
<li><p class="first">ビルトインの集合型のために公式の C API が作られました。新しく作るのには <a class="reference internal" href="../c-api/set.html#c.PySet_New" title="PySet_New"><code class="xref c c-func docutils literal"><span class="pre">PySet_New()</span></code></a> か <a class="reference internal" href="../c-api/set.html#c.PyFrozenSet_New" title="PyFrozenSet_New"><code class="xref c c-func docutils literal"><span class="pre">PyFrozenSet_New()</span></code></a> を、要素の追加には <a class="reference internal" href="../c-api/set.html#c.PySet_Add" title="PySet_Add"><code class="xref c c-func docutils literal"><span class="pre">PySet_Add()</span></code></a> 、削除には <a class="reference internal" href="../c-api/set.html#c.PySet_Discard" title="PySet_Discard"><code class="xref c c-func docutils literal"><span class="pre">PySet_Discard()</span></code></a> 、 <a class="reference internal" href="../c-api/set.html#c.PySet_Contains" title="PySet_Contains"><code class="xref c c-func docutils literal"><span class="pre">PySet_Contains()</span></code></a> と <a class="reference internal" href="../c-api/set.html#c.PySet_Size" title="PySet_Size"><code class="xref c c-func docutils literal"><span class="pre">PySet_Size()</span></code></a> で集合オブジェクトの状態を調べます。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">C コードから Python インタプリタの正確なリビジョンについての情報を取得出来るようになりました。 <a class="reference internal" href="../c-api/init.html#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal"><span class="pre">Py_GetBuildInfo()</span></code></a> 関数を呼び出すことでビルド情報についての文字列が <code class="docutils literal"><span class="pre">&quot;trunk:45355:45356M,</span> <span class="pre">Apr</span> <span class="pre">13</span> <span class="pre">2006,</span> <span class="pre">07:42:19&quot;</span></code> のように返ります。 (Contributed by Barry Warsaw.)</p>
</li>
<li><p class="first">Two new macros can be used to indicate C functions that are local to the
current file so that a faster calling convention can be used.
<code class="docutils literal"><span class="pre">Py_LOCAL(type)</span></code> declares the function as returning a value of the
specified <em>type</em> and uses a fast-calling qualifier.
<code class="docutils literal"><span class="pre">Py_LOCAL_INLINE(type)</span></code> does the same thing and also requests the
function be inlined.  If <code class="xref c c-func docutils literal"><span class="pre">PY_LOCAL_AGGRESSIVE()</span></code> is defined before
<code class="file docutils literal"><span class="pre">python.h</span></code> is included, a set of more aggressive optimizations are enabled
for the module; you should benchmark the results to find out if these
optimizations actually make the code faster.  (Contributed by Fredrik Lundh at
the NeedForSpeed sprint.)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">PyErr_NewException(name,</span> <span class="pre">base,</span> <span class="pre">dict)</span></code> が <em>base</em> 引数としてベースクラスのタプルを受け付けるようになりました。 (Contributed by Georg Brandl.)</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">PyErr_Warn()</span></code> 関数が、 <code class="docutils literal"><span class="pre">PyErr_WarnEx(category,</span> <span class="pre">message,</span> <span class="pre">stacklevel)</span></code> を採用のために非推奨となっています。後者はこの関数と呼び出し元との間を隔てるスタックフレーム数を指定できます。 <em>stacklevel</em> を 1 とすると関数呼び出しは <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_WarnEx" title="PyErr_WarnEx"><code class="xref c c-func docutils literal"><span class="pre">PyErr_WarnEx()</span></code></a> からとなり、2 であればその一つ上から、などです。 (Added by Neal Norwitz.)</p>
</li>
<li><p class="first">CPython は今でも C で書かれていますが、コードは C++ コンパイラでもエラーなしでコンパイル出来るようになりました。   (Implemented by Anthony Baxter, Martin von Löwis, Skip Montanaro.)</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">PyRange_New()</span></code> 関数が削除されました。これは一度もドキュメントされたことはありませんし、コアコード内で一度も使われたこともなく、また、手薄なエラーチェックを持った危険なものでした。あまりないとは思いますがもしあなたの拡張が使っていたのであれば、以下のようなもので置き換え出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nb">range</span> <span class="o">=</span> <span class="n">PyObject_CallFunction</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">PyRange_Type</span><span class="p">,</span> <span class="s2">&quot;lll&quot;</span><span class="p">,</span>
                              <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<div class="section" id="port-specific-changes">
<span id="ports"></span><h3>ポート特有の変更<a class="headerlink" href="#port-specific-changes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>MacOS X (10.3 以上): モジュールの動的ロードに、MacOS 固有の関数ではなく <code class="xref c c-func docutils literal"><span class="pre">dlopen()</span></code> 関数を使うようになりました。</li>
<li>MacOS X: an <code class="xref std std-option docutils literal"><span class="pre">--enable-universalsdk</span></code> switch was added to the
<strong class="program">configure</strong> script that compiles the interpreter as a universal binary
able to run on both PowerPC and Intel processors. (Contributed by Ronald
Oussoren; <a class="reference external" href="https://bugs.python.org/issue2573">bpo-2573</a>.)</li>
<li>Windows: <code class="file docutils literal"><span class="pre">.dll</span></code> はもはや拡張モジュールのファイル拡張子としてはサポートされません。これからは <code class="file docutils literal"><span class="pre">.pyd</span></code> だけが拡張モジュールとして検索されるファイル拡張子です。</li>
</ul>
</div>
</div>
<div class="section" id="porting-to-python-2-5">
<span id="porting"></span><h2>Python 2.5 への移植<a class="headerlink" href="#porting-to-python-2-5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションでは前述の変更により必要となるかもしれないコードの変更を列挙します:</p>
<ul class="simple">
<li>ASCII がモジュールのデフォルトエンコーディングになっています(訳注: Python 3 からはデフォルトは utf-8 (PEP 3120))。8 ビット文字を含んでいるのにエンコーディング宣言がないモジュールが構文エラーになるようになりました。Python 2.4 では構文エラーとはならず警告でした。</li>
<li>以前はジェネレータの <code class="xref py py-attr docutils literal"><span class="pre">gi_frame</span></code> 属性は常にフレームオブジェクトでしたが、 <a class="reference internal" href="#pep-342"><span class="std std-ref">PEP 342: ジェネレータの新機能</span></a> で説明した <span class="target" id="index-76"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 342</strong></a> での変更により、 <code class="xref py py-attr docutils literal"><span class="pre">gi_frame</span></code> は <code class="docutils literal"><span class="pre">None</span></code> になりえます。</li>
<li>Unicode 文字列とデフォルトの ASCII エンコーディングで Unicode に変換出来ない 8 ビット文字列との比較を試みると、新しい警告 <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal"><span class="pre">UnicodeWarning</span></code></a> が引き起こされるようになっています。以前はそのような比較では <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> 例外を起こしていました。</li>
<li>ライブラリ: <a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal"><span class="pre">csv</span></code></a> モジュールは引用符内のマルチラインをより厳密に扱うようになっています。フィールド内に改行を埋め込んでいるファイルがある場合は、その入力は改行文字を残すやり方で行分解されるはずです。</li>
<li>ライブラリ: <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a> モジュールの <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal"><span class="pre">format()</span></code></a> 関数は、以前は %文字指示子が一つを超えてさえいなければ任意の文字列を受け付けていたかもしれませんが、Python 2.5 からは正確に一つの、ほかに周りをテキストで囲まれていない %文字指示子でなければなりません。</li>
<li>ライブラリ: <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>, <code class="xref py py-mod docutils literal"><span class="pre">cPickle</span></code> モジュールが <a class="reference internal" href="../library/pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal"><span class="pre">__reduce__()</span></code></a> が <code class="docutils literal"><span class="pre">None</span></code> を返すことを許さなくなっています; 必ず引数のタプルを返さなければなりません。また同様に、非推奨となっていた <em>bin</em> キーワードパラメータも、もはや拒絶します。</li>
<li>ライブラリ: <code class="xref py py-mod docutils literal"><span class="pre">SimpleXMLRPCServer</span></code> クラスと <code class="xref py py-mod docutils literal"><span class="pre">DocXMLRPCServer</span></code> クラスに XML-RPC 操作を限られた URL パスに制限する <code class="xref py py-attr docutils literal"><span class="pre">rpc_paths</span></code> 属性が追加されています; デフォルトでは <code class="docutils literal"><span class="pre">'/'</span></code> と <code class="docutils literal"><span class="pre">'/RPC2'</span></code> のみが許されています。 <code class="xref py py-attr docutils literal"><span class="pre">rpc_paths</span></code> に <code class="docutils literal"><span class="pre">None</span></code> か空のタプルを渡すことで、このパスのチェックは無効になります。</li>
<li>C API: 64 ビット機でより大きなデータを処理出来るよう、多くの関数が <code class="xref c c-type docutils literal"><span class="pre">int</span></code> の代わりに <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> を使うようになっています。拡張コードでは警告を避けて 64 ビット機サポートをするのに同じ変更が必要でしょう。この変更についての議論について書いた <a class="reference internal" href="#pep-353"><span class="std std-ref">PEP 353: 添え字型に ssize_t を使う</span></a> を参照して下さい。</li>
<li>C API: obmalloc の変更により、 <code class="xref c c-func docutils literal"><span class="pre">PyMem_*()</span></code> 系関数と <code class="xref c c-func docutils literal"><span class="pre">PyObject_*()</span></code> 系関数を混ぜて使わないように注意しなければなりません。ある系列の <code class="xref c c-func docutils literal"><span class="pre">*_Malloc()</span></code> でメモリを獲得するならば、解放は対応するほうの <code class="xref c c-func docutils literal"><span class="pre">*_Free()</span></code> 関数を使わなければいけません。</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The author would like to thank the following people for offering suggestions,
corrections and assistance with various drafts of this article: Georg Brandl,
Nick Coghlan, Phillip J. Eby, Lars Gustäbel, Raymond Hettinger, Ralf W.
Grosse-Kunstleve, Kent Johnson, Iain Lowe, Martin von Löwis, Fredrik Lundh, Andrew
McNamara, Skip Montanaro, Gustavo Niemeyer, Paul Prescod, James Pryor, Mike
Rovner, Scott Weikart, Barry Warsaw, Thomas Wouters.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">What’s New in Python 2.5</a><ul>
<li><a class="reference internal" href="#pep-308-conditional-expressions">PEP 308: 条件式 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#pep-309-partial-function-application">PEP 309: 関数の部分適用</a></li>
<li><a class="reference internal" href="#pep-314-metadata-for-python-software-packages-v1-1">PEP 314: Metadata for Python Software Packages v1.1</a></li>
<li><a class="reference internal" href="#pep-328-absolute-and-relative-imports">PEP 328: 絶対インポート、相対インポート</a></li>
<li><a class="reference internal" href="#pep-338-executing-modules-as-scripts">PEP 338 - モジュールをスクリプトとして実行する</a></li>
<li><a class="reference internal" href="#pep-341-unified-try-except-finally">PEP 341: try/except/finally の一体化</a></li>
<li><a class="reference internal" href="#pep-342-new-generator-features">PEP 342: ジェネレータの新機能</a></li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: &quot;with&quot; ステートメント</a><ul>
<li><a class="reference internal" href="#writing-context-managers">コンテキストマネージャを書く</a></li>
<li><a class="reference internal" href="#the-contextlib-module">contextlib モジュール</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-352-exceptions-as-new-style-classes">PEP 352: 例外の新スタイルクラス化</a></li>
<li><a class="reference internal" href="#pep-353-using-ssize-t-as-the-index-type">PEP 353: 添え字型に ssize_t を使う</a></li>
<li><a class="reference internal" href="#pep-357-the-index-method">PEP 357: '__index__' メソッド</a></li>
<li><a class="reference internal" href="#other-language-changes">その他の言語変更</a><ul>
<li><a class="reference internal" href="#interactive-interpreter-changes">対話的なインタプリタの変更</a></li>
<li><a class="reference internal" href="#optimizations">最適化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-removed-modules">新たなモジュール、改良されたモジュール、削除されたモジュール</a><ul>
<li><a class="reference internal" href="#the-ctypes-package">ctypes パッケージ</a></li>
<li><a class="reference internal" href="#the-elementtree-package">ElementTree パッケージ</a></li>
<li><a class="reference internal" href="#the-hashlib-package">hashlib パッケージ</a></li>
<li><a class="reference internal" href="#the-sqlite3-package">sqlite3 パッケージ</a></li>
<li><a class="reference internal" href="#the-wsgiref-package">wsgiref パッケージ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">ビルドならびに C API の変更</a><ul>
<li><a class="reference internal" href="#port-specific-changes">ポート特有の変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-5">Python 2.5 への移植</a></li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="2.6.html"
                        title="前の章へ">What’s New in Python 2.6</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2.4.html"
                        title="次の章へ">What’s New in Python 2.4</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/whatsnew/2.5.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="What’s New in Python 2.4"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="What’s New in Python 2.6"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What’s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 4月 17, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>