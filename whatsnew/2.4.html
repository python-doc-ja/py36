
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>What’s New in Python 2.4 &#8212; Python 3.6.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="What’s New in Python 2.3" href="2.3.html" />
    <link rel="prev" title="What’s New in Python 2.5" href="2.5.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/whatsnew/2.4.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/whatsnew/2.4.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="What’s New in Python 2.3"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="What’s New in Python 2.5"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What’s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-2-4">
<h1>What’s New in Python 2.4<a class="headerlink" href="#what-s-new-in-python-2-4" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">著者:</th><td class="field-body">A.M. Kuchling</td>
</tr>
</tbody>
</table>
<p>この文書は 2005 年 3 月 30 日にリリースされた Python 2.4.1 の新機能について解説します。</p>
<p>Python 2.4 は、真ん中サイズ、のリリースです。急進的だった Python 2.2 ほどには多くの変更をしていませんが、保守的だった 2.3 よりは多くの機能を導入しています。新しい言語機能で最も重要なのが、関数デコレータとジェネレータ式です。ほかのほとんどの変更は標準ライブラリに対するものです。</p>
<p>Python 2.3 から 2.4 の CVS 変更ログによれば、適用されたパッチは 481、フィックスされたバグは 502 ありました。ともに、少なく見積もって、です。</p>
<p>このドキュメントは個々の新機能の完全な詳細を提供するのではなくて、簡易な概要を提供することを目的にしています。完全な詳細が知りたければ、 Python ライブラリリファレンス、Python リファレンスマニュアルのような Python 2.4 のドキュメントを参照してください。多くの場合個別の新機能についての実装の説明やデザインの根拠については PEP に託されています。</p>
<div class="section" id="pep-218-built-in-set-objects">
<h2>PEP 218: ビルトインの集合オブジェクト<a class="headerlink" href="#pep-218-built-in-set-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.3 では <code class="xref py py-mod docutils literal"><span class="pre">sets</span></code> を導入しました。集合データ型の C 実装が Python コアに新たに、2 つの新しいビルトイン型 <code class="xref py py-func docutils literal"><span class="pre">set(iterable)()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">frozenset(iterable)()</span></code> として追加されています。これらは要素が集合に属しているかのメンバシップテスト、シーケンスからの重複の削除、それに和集合 (union)、共通集合 (intersection)、 差 (difference)、対称差 (symmetric difference) といった数学演算を高速に行います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>              <span class="c1"># form a set from a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">a</span>                            <span class="c1"># fast membership testing</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>                                   <span class="c1"># unique letters in a</span>
<span class="go">set([&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                          <span class="c1"># convert back into a string</span>
<span class="go">&#39;arbcd&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;alacazam&#39;</span><span class="p">)</span>                 <span class="c1"># form a second set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>                               <span class="c1"># letters in a but not in b</span>
<span class="go">set([&#39;r&#39;, &#39;d&#39;, &#39;b&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span>                               <span class="c1"># letters in either a or b</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>                               <span class="c1"># letters in both a and b</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span>                               <span class="c1"># letters in a or b but not both</span>
<span class="go">set([&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>                          <span class="c1"># add a new element</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;wxy&#39;</span><span class="p">)</span>                     <span class="c1"># add multiple new elements</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;r&#39;, &#39;w&#39;, &#39;y&#39;, &#39;x&#39;, &#39;z&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>                       <span class="c1"># take one element out</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;r&#39;, &#39;w&#39;, &#39;y&#39;, &#39;z&#39;])</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal"><span class="pre">frozenset()</span></code></a> 型は <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal"><span class="pre">set()</span></code></a> の <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> 版です。 immutable かつハッシュ可能なので、辞書のキーやほかの set のメンバとして使えるでしょう。</p>
<p>2.3 で追加された <code class="xref py py-mod docutils literal"><span class="pre">sets</span></code> モジュールは標準ライブラリに残されていて、 <code class="xref py py-class docutils literal"><span class="pre">Set</span></code> や <code class="xref py py-class docutils literal"><span class="pre">ImmutableSet</span></code> をサブクラス化したければ便利かもしれません。今のところこれを撤廃する予定はありません。(—訳注: <code class="xref py py-mod docutils literal"><span class="pre">sets</span></code> モジュールは 2.6 で非推奨となっています。—)</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-35"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0218"><strong>PEP 218</strong></a> - 集合オブジェクト型をビルトインに追加する</dt>
<dd>元々は Greg Wilson によって提案され、完全な実装は Raymond Hettinger によってなされました。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-237-unifying-long-integers-and-integers">
<h2>PEP 237: 長整数と整数を一体化していく<a class="headerlink" href="#pep-237-unifying-long-integers-and-integers" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この PEP の非常に長期に渡る移行は Python 2.2 に始まり、Python 2.4 でさらにもう一歩前進しています。2.3 では int/long の一体化後に異なる振る舞いをする整数演算をすると <a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal"><span class="pre">FutureWarning</span></code></a> 警告を出して、結果の値は (プラットフォーム依存で) 32 ビットまたは 64 ビットに制限していました。2.4 ではこれらの式はもう警告は出さず、代わりにいつでも(2.3 とは違った)長整数となる結果をはじき出します。</p>
<p>問題を起こしうる式は主として左シフトで、そして長い 16 進リテラルと 8 進リテラルです。例えば <code class="docutils literal"><span class="pre">2</span> <span class="pre">&lt;&lt;</span> <span class="pre">32</span></code> は 2.3 では警告とともに 32 ビットプラットフォームでは結果は 0 になります。Python 2.4 ではこの式は正しい答えの 8589934592 になります。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-36"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> - 長整数と整数を一体化していく</dt>
<dd>オリジナルの PEP は Moshe Zadka と GvR (Guido van Rossum) によって書かれました。.2.4 での変更については Kalle Svensson によって実装されました。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-289-generator-expressions">
<h2>PEP 289: ジェネレータ式<a class="headerlink" href="#pep-289-generator-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.2 で導入されたイテレータ機能と 2.3 で追加された <a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> モジュールによって、一度に全てをメモリに持つことなく大きなデータセットを回すループ処理を書くのが簡単になりました。全てのアイテムを含む Python リストを生成してしまうので、リスト内包表記はこの考えにはうまく馴染みません。これによる不可避のメモリへのオブジェクト全展開は、データセットが巨大な場合は問題です。関数型スタイルのプログラムを書こうとして、このように書くのは自然かもしれません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">link</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">get_all_links</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">link</span><span class="o">.</span><span class="n">followed</span><span class="p">]</span>
<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>こうではなく</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">get_all_links</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">followed</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>最初の形の方が簡潔でおそらく読みやすいですが、扱っているのがとても多くのリンクオブジェクトであるならば、全てのリンクオブジェクトが一気にメモリに載らないように二つ目の形で書く必要がありました。</p>
<p>ジェネレータ式はリスト内包と似た動作をしますが、リスト全体を実体化しません; 代わりにそれは、要素を一つずつ返すジェネレータを返します。上述の例はこう書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">links</span> <span class="o">=</span> <span class="p">(</span><span class="n">link</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">get_all_links</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">link</span><span class="o">.</span><span class="n">followed</span><span class="p">)</span>
<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>上の例でのように、ジェネレータ式は常に括弧の中に書かなければなりません。関数呼び出しを囲む括弧もそれに含まれるので、関数にそのまま渡すイテレータを作りたければこれで良いです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="nb">sum</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">count</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">list_all_objects</span><span class="p">())</span>
</pre></div>
</div>
<p>ジェネレータ式はリスト内包とは色々小さい点で違います。最も顕著なのはループ変数 (上の例での <em>obj</em>) がジェネレータ式の外からアクセス不能なことです。リスト内包はループの制御変数が最後に代入された値で残ります; 将来のバージョンの Python では、この振る舞いはリスト内包がこの点でジェネレータ式と同じになるように変更されます。 (—訳注: Python 2.7 でもリスト内包のこの振る舞いは変わっておらず、警告ともなりません。制御変数が内包のスコープ外で可視でなくなったのは Python 3.0 からです。—)</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-37"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0289"><strong>PEP 289</strong></a> - ジェネレータ式</dt>
<dd>Raymond Hettinger によって提案され、Hye-Shik Chang に導かれた早期の尽力によって Jiwon Seo により実装されました。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-292-simpler-string-substitutions">
<h2>PEP 292: より単純な文字列置換 (string substitution)<a class="headerlink" href="#pep-292-simpler-string-substitutions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>標準ライブラリに、文字列を変数で置換するための代替メカニズムをもたらす新しいくつかのクラスが追加されました; この置換のスタイルは、訓練されていないユーザがテンプレートを編集する必要があるようなアプリケーションにとって、より良いものでしょう。</p>
<p>変数置換を名前で行うためのいつもの方法は <code class="docutils literal"><span class="pre">%</span></code> 演算子です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%(page)i</span><span class="s1">: </span><span class="si">%(title)s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;page&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;The Best of Times&#39;</span><span class="p">}</span>
<span class="go">&#39;2: The Best of Times&#39;</span>
</pre></div>
</div>
<p>テンプレート文字列を書くのに、閉じ括弧のあとの <code class="docutils literal"><span class="pre">i</span></code> や <code class="docutils literal"><span class="pre">s</span></code> を忘れやすいです。これはそのテンプレートが Python モジュール内にあるなら大問題でもありません。コードを実行し、「サポートされないフォーマット文字 (unsupported format character)」な <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を喰らい、問題を直すだけのことです。ですが、例えば Mailman のようなアプリケーションを考えてみてください。テンプレート文字列や翻訳は、Python 言語について承知していないユーザが編集するのです。フォーマット文字列の構文はそのようなユーザに説明するには複雑で、彼らが間違いをやらかした場合には、親切なフィードバックを彼らに与えるのは難しいのです。</p>
<p>PEP 292 は <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> モジュールに <code class="xref py py-class docutils literal"><span class="pre">Template</span></code> クラスを追加します。これは置換を指示するのに <code class="docutils literal"><span class="pre">$</span></code> を使います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="s1">&#39;$page: $title&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">substitute</span><span class="p">({</span><span class="s1">&#39;page&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;The Best of Times&#39;</span><span class="p">})</span>
<span class="go">&#39;2: The Best of Times&#39;</span>
</pre></div>
</div>
<p>辞書にキーが見つからない場合、 <code class="xref py py-meth docutils literal"><span class="pre">substitute()</span></code> メソッドは <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> を送出します。 <code class="xref py py-meth docutils literal"><span class="pre">safe_substitute()</span></code> メソッドもあり、これはキー不在を無視します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="s1">&#39;$page: $title&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">({</span><span class="s1">&#39;page&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="go">&#39;3: $title&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-38"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0292"><strong>PEP 292</strong></a> - より単純な文字列置換 (string substitution)</dt>
<dd>Barry Warsaw 著、実装</dd>
</dl>
</div>
</div>
<div class="section" id="pep-318-decorators-for-functions-and-methods">
<h2>PEP 318: 関数とメソッドのためのデコレータ<a class="headerlink" href="#pep-318-decorators-for-functions-and-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.2 は Python オブジェクトモデルを静的メソッド、クラスメソッドを追加することで拡張はしましたが、それらを定義する新たな手段を提供するような Python 構文の拡張はしませんでした。このため、 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal"><span class="pre">def</span></code></a> でメソッドは普通に書いたのち、新型メソッドとしての関数へ仕立て上げる <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a> または <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> にその結果のメソッドを渡す、という手順を取る必要がありました。このような具合でした:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">meth</span> <span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
       <span class="o">...</span>

   <span class="n">meth</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>   <span class="c1"># Rebind name to wrapped-up class method</span>
</pre></div>
</div>
<p>メソッドがとても長かったりすると、関数のボディの後ろの <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a> 呼び出しは見失ったり忘れたりしやすいものでした。</p>
<p>そのような定義をもっと読みやすくするために何か構文を追加する、という意図は常にありましたが、2.2 のリリース時点では良い構文は明らかではありませんでした。本日時点でさえ <em>いまだ</em> 明らかとは言えませんが、ユーザは静的メソッドとクラスメソッドを簡単に手にする手段を注文し続けています; 新たな構文的機能はこの要求に合うように追加されました。</p>
<p>この新たな機能は「関数デコレータ (function decorators)」と呼ばれます。この名前は <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal"><span class="pre">classmethod()</span></code></a>, <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal"><span class="pre">staticmethod()</span></code></a>, とその仲間たちが関数オブジェクトに追加的な情報を保存することから着想を得たものです; それらは関数をより多くの詳細で <em>デコレート (修飾) している</em> というわけです。</p>
<p>記法は Java より拝借して <code class="docutils literal"><span class="pre">'&#64;'</span></code> 文字を指示子として使います。この新たな構文を使うと、上記の例はこのように書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>

   <span class="nd">@classmethod</span>
   <span class="k">def</span> <span class="nf">meth</span> <span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
       <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">&#64;classmethod</span></code> は <code class="docutils literal"><span class="pre">meth=classmethod(meth)</span></code> 代入の速記法です。より一般的には、このように書けば…:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="nd">@A</span>
<span class="nd">@B</span>
<span class="nd">@C</span>
<span class="k">def</span> <span class="nf">f</span> <span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>これはデコレータ前史の以下コードと等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span> <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</pre></div>
</div>
<p>デコレータは関数定義の前になければなりません。一行ごとに一つのデコレータです。 def ステートメントと同じ行にあってはダメです。つまり <code class="docutils literal"><span class="pre">&#64;A</span> <span class="pre">def</span> <span class="pre">f():</span> <span class="pre">...</span></code> は不正です。モジュールレベルかクラス内の関数定義のみをデコレート出来ます; クラス定義はデコレート出来ません。(— 訳注: クラス定義のデコレータは Python 2.6 で追加されました (PEP 3129) 。—)</p>
<p>デコレータはただの関数です。引数としてデコレートされる関数を取り、同じ関数か何か新しいオブジェクトを返すだけの。結果がほかのデコレータ適用されるの出ない限りは、デコレータの戻り値は呼び出し可能である必要はありません (普通はそうですが)。あなた自身のデコレータを書くのは簡単です。続く単純な例は、関数オブジェクトに単に属性をセットするだけのものです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">func</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;decorated&#39;</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">func</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@deco</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;function f at 0x402ef0d4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">attr</span>
<span class="go">&#39;decorated&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>もう少しだけ現実的な例として、続く例ではデコレータに、与えられた引数が整数かどうかチェックさせてみます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">require_int</span> <span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span> <span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@require_int</span>
<span class="k">def</span> <span class="nf">p1</span> <span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">arg</span>

<span class="nd">@require_int</span>
<span class="k">def</span> <span class="nf">p2</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">arg</span><span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p><span class="target" id="index-39"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0318"><strong>PEP 318</strong></a> にある例はこのアイディアのもっと凝った版が含まれていて、それは要求型の指定と戻り値のチェックの両方が出来ます。</p>
<p>デコレータ関数は引数を取ることが出来ます。引数が与えられた場合、あなたのデコレータ関数はそれら引数のみで呼び出され、そして新しいデコレータを返さなければなりません; この関数は単一の関数を取らなければならず、前述のように関数を返さなければなりません。言い換えると、 <code class="docutils literal"><span class="pre">&#64;A</span> <span class="pre">&#64;B</span> <span class="pre">&#64;C(args)</span></code> はこうなります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span> <span class="o">...</span>
<span class="n">_deco</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">_deco</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</pre></div>
</div>
<p>これが正しいと理解するには少しばかり頭をひねる必要がありますが、難しすぎることはありません。</p>
<p>デコレータに関係した小さな変更は、関数の <code class="xref py py-attr docutils literal"><span class="pre">func_name</span></code> 属性が書き込み可能になったことです。この属性はトレースバックでの関数名表示に使われますので、デコレータは構築して返却する新しい関数の名前を変更すべきです。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-40"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0318"><strong>PEP 318</strong></a> - 関数、メソッド、クラスのためのデコレータ</dt>
<dd>Kevin D. Smith, Jim Jewett, Skip Montanaro により著されました。数多くの人々が関数デコレータ実装のパッチを書きましたが、実際にチェックインされたものは Mark Russell が書いた #979728 でした。</dd>
<dt><a class="reference external" href="https://wiki.python.org/moin/PythonDecoratorLibrary">https://wiki.python.org/moin/PythonDecoratorLibrary</a></dt>
<dd>数多くのデコレータ例を含む Wiki ページ。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-322-reverse-iteration">
<h2>PEP 322: 逆順のイテレーション<a class="headerlink" href="#pep-322-reverse-iteration" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新しいビルトイン関数 <code class="docutils literal"><span class="pre">reversed(seq)</span></code> は、シーケンスを受け取って、シーケンスの要素を逆順にループするイテレータを返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="go">3</span>
<span class="go">2</span>
<span class="go">1</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">range(1,4)[::-1]</span></code> のようにする拡張スライスでのやり方に比較して <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> は読みやすく、実行が高速で、大体の場合はメモリ使用が少なく済みます。</p>
<p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal"><span class="pre">reversed()</span></code></a> は任意のイテレータは受け付けず、シーケンスのみ受け付けることに注意してください。イテレータを逆順にしたければ、最初に <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal"><span class="pre">list()</span></code></a> でリストに変換してください:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">line</span>
<span class="gp">...</span>
<span class="go">root:*:0:0:System Administrator:/var/root:/bin/tcsh</span>
<span class="go">  ...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0322"><strong>PEP 322</strong></a>  - 逆順のイテレーション</dt>
<dd>Raymond Hettinger 著、実装.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-324-new-subprocess-module">
<h2>PEP 324: 新しい subprocess モジュール<a class="headerlink" href="#pep-324-new-subprocess-module" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>標準ライブラリはサブプロセスを実行するのに数多くの手段を提供しています。これらは異なった機能、異なった複雑さのレベルを提供しています。 <code class="docutils literal"><span class="pre">os.system(command)</span></code> の利用は簡単です。ですがこれは遅く (コマンドを実行するシェルを起動しますので)、危険でもあります (シェルのメタ文字を注意深くエスケープする必要があります)。 <code class="xref py py-mod docutils literal"><span class="pre">popen2</span></code> モジュールが提供するクラス群はサブプロセスより標準出力、標準エラー出力をキャプチャ出来ますが、名前付けがややこしいです。 <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> モジュールはこれを綺麗にし、必要とするであろう機能全てを与える一体化されたインターフェイスを提供しています。</p>
<p><code class="xref py py-mod docutils literal"><span class="pre">popen2</span></code> のクラス所蔵品群の代わりに <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> には <code class="xref py py-class docutils literal"><span class="pre">Popen</span></code> と呼ばれる単一のクラスが含まれています。これのコンストラクタは数多くの異なるキーワード引数を取ります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Popen</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">bufsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">executable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">preexec_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">close_fds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">startupinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">creationflags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p><em>args</em> は普通は文字列のシーケンスで、サブプロセスとして実行するプログラムへの引数群となります。 (<em>shell</em> 引数が真の場合は <em>args</em> はシェルに解釈を任せるために渡す文字列に出来、つまりこの場合 <a class="reference internal" href="../library/os.html#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">os.system()</span></code></a> と同じことをします。)</p>
<p><em>stdin</em>, <em>stdout</em>, <em>stderr</em> はサブプロセスの入力・出力・エラーのストリームを指定します。ファイルオブジェクトかファイル記述子を渡すことが出来ます。あるいは定数 <code class="docutils literal"><span class="pre">subprocess.PIPE</span></code> を渡してサブプロセスと親とのパイプを作成することが出来ます。</p>
<p id="index-7">コンストラクタには多くの便利なオプションがあります:</p>
<ul class="simple">
<li><em>close_fds</em> はサブプロセス実行前に全てのファイル記述子をクローズすることを要求します。</li>
<li><em>cwd</em> はサブプロセスを実行する作業ディレクトリを指定します (デフォルトは親の作業ディレクトリです)。</li>
<li><em>env</em> は環境変数を指定する辞書です。</li>
<li><em>preexec_fn</em> は子が開始する前に呼び出される関数です。</li>
<li><em>universal_newlines</em> で、子の入出力を、Python の <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 機能で開きます。</li>
</ul>
<p><code class="xref py py-class docutils literal"><span class="pre">Popen</span></code> インスタンスを作ってしまえば、あとはサブプロセスが終了するまで停止するために <code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code> メソッド呼び出すことが出来、停止することなく終了をチェックするのに <code class="xref py py-meth docutils literal"><span class="pre">poll()</span></code> メソッドを呼び出すことが出来、あるいは <code class="docutils literal"><span class="pre">communicate(data)</span></code> を呼び出して、子の標準入力に <em>data</em> を送信することが出来ます。 <code class="docutils literal"><span class="pre">communicate(data)</span></code> はサブプロセスが送信する標準出力と標準エラー出力を読み込み、タプル <code class="docutils literal"><span class="pre">(stdout_data,</span> <span class="pre">stderr_data)</span></code> を返します。</p>
<p><code class="xref py py-func docutils literal"><span class="pre">call()</span></code> は <code class="xref py py-class docutils literal"><span class="pre">Popen</span></code> コンストラクタにその引数を流し込むショートカットで、コマンドが終了するまで待ち、サブプロセスの終了コードを返します。これは <a class="reference internal" href="../library/os.html#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">os.system()</span></code></a> に対する安全な置き換えとなりえます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">sts</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s1">&#39;dpkg&#39;</span><span class="p">,</span> <span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/new-package.deb&#39;</span><span class="p">])</span>
<span class="k">if</span> <span class="n">sts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Success</span>
    <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># dpkg returned an error</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>コマンドはシェルを使うことなく呼び出されます。もしシェルを本当に使いたいのであればキーワード引数として <code class="docutils literal"><span class="pre">shell=True</span></code> を与えた上でシーケンスの代わりに文字列を与えることが出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">sts</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;dpkg -i /tmp/new-package.deb&#39;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>PEP にはシェルと Python コードの様々な例が採られていて、シェルスクリプトをいかにして <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> を用いて Python コードに変換するかを示しています。PEP のこのセクションを読むことを強くお勧めします。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-42"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0324"><strong>PEP 324</strong></a> - subprocess - プロセスのための新たなモジュール</dt>
<dd>Fredrik Lundh 他によるサポートによって、Peter Åstrand により PEP 著と実装が行われました。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-327-decimal-data-type">
<h2>PEP 327: Decimal データ型<a class="headerlink" href="#pep-327-decimal-data-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python は常に根底となる C <code class="xref c c-type docutils literal"><span class="pre">double</span></code> に基く浮動小数点(FP=floating-point)数をデータ型としてサポートします。しかしながら、ほとんどのプログラミングが浮動小数点数を提供する一方で、多くの人々 (プログラマでさえも) は浮動小数点数が小数をいくらか正確には表現出来ないことを知りません。新しい <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> 型はこれら小数を、ユーザが指定する精度限界まで正確に表現出来ます。</p>
<div class="section" id="why-is-decimal-needed">
<h3>なぜ Decimal が必要なのか?<a class="headerlink" href="#why-is-decimal-needed" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>浮動小数点数が使う表現方法に起因する制約があります。浮動小数点数は 3 つの構成要素から成ります:</p>
<ul class="simple">
<li>符号(sign)。正または負。</li>
<li>仮数部(mantissa)。一桁の 2 進値に端数部が続きます。例えば 2 進数で <code class="docutils literal"><span class="pre">1.01</span></code> は <code class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">0/2</span> <span class="pre">+</span> <span class="pre">1/4</span></code> で 10 進表記で 1.25 です。</li>
<li>指数部(exponent)。小数点がその数値のどこに位置するかを表します。</li>
</ul>
<p>例えば 1.25 は、正の符号を持ち、仮数部の値は (2 進数で) 1.01 で、指数部は 0 です (小数点は移動の必要がありません)。5 は同じ符号と仮数部を持ち、指数部は、仮数部が 4 倍なので 2 (2 を底とする 2 の 冪乗) です; 1.25 * 4 は 5 です。</p>
<p>現代的なシステムでは普通、浮動小数点数のサポートは IEEE 754 と名付けられた標準に従っています。 C の <code class="xref c c-type docutils literal"><span class="pre">double</span></code> 型は普通は 64 ビットの IEEE 754 数として実装され、これは仮数部として 52 ビットを使います。つまり数値は 52 ビットで記述される精度しか持てません。展開が循環に続く数値を表現しようと試みると、展開は 52 ビットより後ろは打ち切られます (訳注: expansion(展開) は 1/2 + 1/2**2 + … 形式の級数展開を踏まえた表現。わかると思いますが一応)。不幸にもほとんどのソフトウェアは出力を 10 進数で行い、しばしば 10 進数でそうでないのに 2 進数では循環小数になります。例えば 10 進での 1.1 は 2 進で <code class="docutils literal"><span class="pre">1.0001100110011</span> <span class="pre">...</span></code> です; .1 = 1/16 + 1/32 + 1/256 プラスこれの無限繰り返し。IEEE 754 は 52 桁以降を切り落とす必要があるので、表現が少し不正確になります。</p>
<p>ときどきあなたはこの不正確さを、数値を表示する際に目にするでしょう:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.1</span>
<span class="go">1.1000000000000001</span>
</pre></div>
</div>
<p>この不正確さは数値を表示する際にいつでも目に見えるわけではありません。浮動小数点数から文字列への変換が C ライブラリによって提供されていて、C ライブラリのほとんどが賢明な出力を生成しようと頑張っているからです。それが表示されないにしても、不正確さはそれでも存在していて、後続の計算への誤差が大きくなりえます。</p>
<p>多くのアプリケーションではこれは重要ではありません。モニタにプロットして表示するのに 1.1 と 1.1000000000000001 の差は小さすぎて見えません。大抵は出力を一定の桁位置までに制限して出力するものですし、2 やら 3 やら 8 桁などの位置で丸めたりすれば誤差は決して露わにはなりません。ですがそれが重要なアプリケーションにとっては、あなた自身のカスタム数学ルーチンのための実装作業は膨大になります。</p>
<p>こうして <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> 型が作られました。</p>
</div>
<div class="section" id="the-decimal-type">
<h3><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> 型<a class="headerlink" href="#the-decimal-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新しいモジュール <a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> が Python 標準ライブラリに追加されました。これには 2 つのクラス <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code>, <code class="xref py py-class docutils literal"><span class="pre">Context</span></code> を含みます。 <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> インスタンスは数値を表現し、 <code class="xref py py-class docutils literal"><span class="pre">Context</span></code> インスタンスは、精度やデフォルトの丸めモードなどのさまざまな設定をまとめるのに使われます。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> のインスタンスは普通の Python 整数や浮動小数点数のように <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> です。 <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> のインスタンスは整数や文字列から構築出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1972</span><span class="p">)</span>
<span class="go">Decimal(&quot;1972&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.1&quot;</span><span class="p">)</span>
<span class="go">Decimal(&quot;1.1&quot;)</span>
</pre></div>
</div>
<p>符号(sign)、10進数値のタプルで表した仮数部(mantissa)、指数部(exponent)を含んだタプルを渡すことも出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&quot;-14.75&quot;)</span>
</pre></div>
</div>
<p>注意: 符号ビットは負符号の有無なので、 0 が正、1  が負です。</p>
<p>浮動小数点数からの変換は少々問題です: 1.1 を表現する浮動小数点数は 10 進数値の正確な 1.1 に変換すべきでしょうか、それとも 1.1 が持つどんな不正確さもそのまま持ち込むべきでしょうか? 決定は、問題をはぐらかして、その種の変換を API の範疇外とする、というものでした。代わりにあなたは浮動小数点数を望みの精度で文字列に変換して、その文字列を <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> コンストラクタに渡す必要があります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">Decimal(&quot;1.1&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
<span class="go">Decimal(&quot;1.100000000000&quot;)</span>
</pre></div>
</div>
<p>いったん <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> を手にしてしまえばあとは普通の数学演算が使えます。制約の一つ: べき乗には整数の指数しか使えません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;35.72&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.73&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="go">Decimal(&quot;37.45&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">-</span><span class="n">b</span>
<span class="go">Decimal(&quot;33.99&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="go">Decimal(&quot;61.7956&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
<span class="go">Decimal(&quot;20.64739884393063583815028902&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">**</span> <span class="mi">2</span>
<span class="go">Decimal(&quot;1275.9184&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">**</span><span class="n">b</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">x ** (non-integer)</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> インスタンスと整数は混ぜて使えますが、浮動小数点数とは出来ません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="mi">4</span>
<span class="go">Decimal(&quot;39.72&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="mf">4.5</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">You can interact Decimal only with int, long or Decimal data types.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> 数を <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a>, <a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> モジュールで使うことは出来ますが、演算実行前にその場で浮動小数点数に変換されて、結果精度と正確性を失う可能性があります。戻り値は普通の浮動小数点数であって <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> ではありません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">cmath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;123456789012.345&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">351364.18288201344</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="p">)</span>
<span class="go">351364.18288201344j</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> インスタンスは <code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code> インスタンスを返す <code class="xref py py-meth docutils literal"><span class="pre">sqrt()</span></code> メソッドを持っていますが、三角関数のようななにかほかのことが必要な場合は、それらを実装する必要があるでしょう。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&quot;351364.1828820134592177245001&quot;)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-context-type">
<h3><code class="xref py py-class docutils literal"><span class="pre">Context</span></code> 型<a class="headerlink" href="#the-context-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref py py-class docutils literal"><span class="pre">Context</span></code> クラスのインスタンスは decimal 演算についてのいくつかの設定をカプセル化しています:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal"><span class="pre">prec</span></code> は精度で、小数桁数です。</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">rounding</span></code> は丸めのモードを指定します。 <a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> にはこの値に渡せる定数が定義されています: <code class="xref py py-const docutils literal"><span class="pre">ROUND_DOWN</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ROUND_CEILING</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code>, それに色々。</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">traps</span></code> は特定のエラー状態に出会った場合に何が起こるべきかを指定する辞書です: 例外を発生させるか値を返すかどちらかです。いくつかのエラー状態の例としては、ゼロ除算、精度損失、オーバーフローがあります。</li>
</ul>
<p>スレッドローカルなデフォルトのコンテキストを、 <code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code> を呼び出すことで利用出来ます; デフォルトの精度、丸めモード、トラップ処理に代えてこのコンテキストのプロパティを変更出来ます。続く例はデフォルトコンテキストの精度を変更する効果についてお見せします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span>
<span class="go">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&quot;0.1428571428571428571428571429&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&quot;0.142857143&quot;)</span>
</pre></div>
</div>
<p>エラー状態の場合のデフォルトアクションを選択出来ます; モジュールは無限大(infinity)あるいは非数(not-a-number: NaN)を返すか、例外を投げるかです:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">decimal.DivisionByZero</span>: <span class="n">x / 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&quot;Infinity&quot;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">Context</span></code> インスタンスは <code class="xref py py-meth docutils literal"><span class="pre">to_eng_string()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">to_sci_string()</span></code> のような、数値の書式化のための色々なメソッドも持っています。</p>
<p>さらに詳しく知りたければ <a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> モジュールのドキュメントを読んで下さい。これには簡単に始められるチュートリアルとリファレンスが入っています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0327"><strong>PEP 327</strong></a> - Decimal データ型</dt>
<dd>Facundo Batista によって著され、Facundo Batista, Eric Price, Raymond Hettinger, Aahz,  Tim Peters らによって実装されました。</dd>
<dt><a class="reference external" href="http://www.lahey.com/float.htm">http://www.lahey.com/float.htm</a></dt>
<dd>この記事は浮動小数点数の不正確さが起こりうるたくさんの問題について、Fortran コードを使って解説しています。</dd>
<dt><a class="reference external" href="http://speleotrove.com/decimal/">http://speleotrove.com/decimal/</a></dt>
<dd>10 進数ベースの表現についての記述です(訳注: decimal-based は小数ベースとも 10 進数ベースとも取れるのですが、後者にしておきました)。この表現方法は標準として提案されていて、この Python の decimal 型の基礎になっています。この題材の多くが Rexx 言語設計者である Mike Cowlishaw によって著されました。</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="pep-328-multi-line-imports">
<h2>PEP 328: マルチラインインポート<a class="headerlink" href="#pep-328-multi-line-imports" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>言語の変更の一つは小さな文法的な微調整で、モジュールからたくさんの名前をインポートするのを簡単にするためのものです。 <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">names</span></code> 文において、 <em>names</em> はカンマ区切りのシーケンスです。シーケンスがとても長くなった場合、同じモジュールからのインポート文を何度も書くか、行末をバックスラッシュでエスケープするかするでしょう、このように:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">SimpleXMLRPCServer</span> <span class="k">import</span> <span class="n">SimpleXMLRPCServer</span><span class="p">,</span>\
            <span class="n">SimpleXMLRPCRequestHandler</span><span class="p">,</span>\
            <span class="n">CGIXMLRPCRequestHandler</span><span class="p">,</span>\
            <span class="n">resolve_dotted_attribute</span>
</pre></div>
</div>
<p>Python 2.4 での文法的な変更は、単純に names を丸括弧で囲んでも良い、とするだけのものです。Python は丸括弧内の改行を無視しますので、バックスラッシュはもう必要ありません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">SimpleXMLRPCServer</span> <span class="k">import</span> <span class="p">(</span><span class="n">SimpleXMLRPCServer</span><span class="p">,</span>
                                <span class="n">SimpleXMLRPCRequestHandler</span><span class="p">,</span>
                                <span class="n">CGIXMLRPCRequestHandler</span><span class="p">,</span>
                                <span class="n">resolve_dotted_attribute</span><span class="p">)</span>
</pre></div>
</div>
<p>その PEP は、全ての <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文が絶対インポートであること、相対インポートであることを示すには <code class="docutils literal"><span class="pre">.</span></code> 文字で開始すること、の提案もしています。PEP のこの部分は Python 2.4 では実装されていませんが、 Python 2.5 向けには完了しています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> - マルチラインインポートと、絶対/相対インポート</dt>
<dd>Aahz 著.  Multi-line imports は Dima Dorfman により実装。</dd>
</dl>
</div>
</div>
<div class="section" id="pep-331-locale-independent-float-string-conversions">
<h2>PEP 331: Locale に依存しない Float/String 変換<a class="headerlink" href="#pep-331-locale-independent-float-string-conversions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a> モジュールにより、Python ソフトウェアは特定の国や言語の地域化をする色々な変換や表示の変換を選択出来ます。ところがこのモジュールは、数値ロケールを変更しないように気を配らなければなりませんでした。というのも Python 内の色んな関数実装が、数値ロケールが <code class="docutils literal"><span class="pre">'C'</span></code> ロケールにセットされたままであることを必要としていたからです。しばしばこれは、コードが C ライブラリの <code class="xref c c-func docutils literal"><span class="pre">atof()</span></code> 関数を使っていることに原因がありました。</p>
<p>Not setting the numeric locale caused trouble for extensions that used third-party
C libraries, however, because they wouldn’t have the correct locale set.
The motivating example was GTK+, whose user interface widgets weren’t displaying
numbers in the current locale.</p>
<p>この PEP に記述された解法は、ロケール設定を無視して ASCII のみの変換を実施する 3 つの新しい Python API 関数を追加することです:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">PyOS_ascii_strtod(str,</span> <span class="pre">ptr)</span></code>  と <code class="docutils literal"><span class="pre">PyOS_ascii_atof(str,</span> <span class="pre">ptr)</span></code> はともに、文字列を C の <code class="xref c c-type docutils literal"><span class="pre">double</span></code> に変換します。</li>
<li><code class="docutils literal"><span class="pre">PyOS_ascii_formatd(buffer,</span> <span class="pre">buf_len,</span> <span class="pre">format,</span> <span class="pre">d)</span></code>  は <code class="xref c c-type docutils literal"><span class="pre">double</span></code> を ASCII 文字列に変換します。</li>
</ul>
<p>The code for these functions came from the GLib library
(<a class="reference external" href="https://developer.gnome.org/glib/stable/">https://developer.gnome.org/glib/stable/</a>), whose developers kindly
relicensed the relevant functions and donated them to the Python Software
Foundation.  The <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a> module  can now change the numeric locale,
letting extensions such as GTK+  produce the correct results.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0331"><strong>PEP 331</strong></a> - Locale に依存しない Float/String 変換</dt>
<dd>Christian R. Reis 著, 実装 Gustavo Carneiro.</dd>
</dl>
</div>
</div>
<div class="section" id="other-language-changes">
<h2>その他の言語変更<a class="headerlink" href="#other-language-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下が、Python 2.4 言語コアに加えられた全ての変更点です。</p>
<ul>
<li><p class="first">関数とメソッドのためのデコレータが追加されました。 (<span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0318"><strong>PEP 318</strong></a>).</p>
</li>
<li><p class="first">ビルトインの <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal"><span class="pre">set()</span></code></a> 型と <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal"><span class="pre">frozenset()</span></code></a> 型が追加されました (<span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0218"><strong>PEP 218</strong></a>)。ほか新たなビルトイン関数 <code class="docutils literal"><span class="pre">reversed(seq)</span></code> 関数が追加されました (<span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0322"><strong>PEP 322</strong></a>)。</p>
</li>
<li><p class="first">ジェネレータ式が追加されました (<span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0289"><strong>PEP 289</strong></a>).</p>
</li>
<li><p class="first">いくらかの数値式は、もう 32 ビットや 64 ビットに制限されません (<span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>).</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">names</span></code> ステートメントにおいて、 <em>names</em> を括弧で囲むことが出来るようになりました (<span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a>).</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/stdtypes.html#dict.update" title="dict.update"><code class="xref py py-meth docutils literal"><span class="pre">dict.update()</span></code></a> メソッドが <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> コンストラクタと同じ形式の引数を取れるようになりました。これには任意のマッピング、キー/値ペアのイテラブルとキーワード引数を含みます。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">文字列の <code class="xref py py-meth docutils literal"><span class="pre">ljust()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">rjust()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">center()</span></code> メソッドで空白以外の埋め文字を省略可能引数で指定出来るようになりました。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">ほかに、文字列には <code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code> メソッドも追加されています。これは <code class="xref py py-meth docutils literal"><span class="pre">split()</span></code> メソッドと似た動きをしますが、後ろから順に分割します (Contributed by Sean Reifschneider.)</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;www&#39;, &#39;python.org&#39;]</span>
<span class="go">&#39;www.python.org&#39;.rsplit(&#39;.&#39;, 1)</span>
<span class="go">[&#39;www.python&#39;, &#39;org&#39;]</span>
</pre></div>
</div>
</li>
<li><p class="first">リストの <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> メソッドに 3 つのキーワード引数 <em>cmp</em>, <em>key</em>, <em>reverse</em> が追加されています。これらパラメータは <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> のある種の用法を単純にします。これらは全て省略可能です。</p>
<p><em>cmp</em> パラメータには比較関数を渡します。これは 2 つのパラメータを取り、パラメータの比較結果に応じて -1, 0, +1 のいずれかを返します。この関数はリストのソートに使われます。これまでの <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> に唯一許されていたのがこの <em>cmp</em> パラメータでした。</p>
<p><em>key</em> には単一パラメータ関数を渡します。これはリスト要素を受け取り、要素の比較キーを返す関数です。リストはその比較キーを使ってソートされます。続く例はリストを大文字小文字区別なく並び替えます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>                 <span class="c1"># Case-sensitive sort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;D&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using &#39;key&#39; parameter to sort list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;D&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Old-fashioned way</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;D&#39;]</span>
</pre></div>
</div>
<p>例の最後のものは <em>cmp</em> パラメータを使っています。これが大文字小文字区別のない並び替えの昔ながらの方法です。むろん動きます。が、 <em>key</em> パラメータでのやり方より遅いです。 <em>cmp</em> では <code class="xref py py-meth docutils literal"><span class="pre">lower()</span></code> メソッド呼び出しが比較ごとなので要素ごとに 2 回呼び出すことになりますが、 <em>key</em> だと呼び出しはそれぞれの要素ごとに <code class="xref py py-meth docutils literal"><span class="pre">lower()</span></code> 呼び出しを一回だけで済ませられます。</p>
<p>単純なキー関数や比較関数には、しばしば <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> 関数を避けて非束縛メソッドを使えます。例えば上記の大文字小文字によらない並べ替えはこのように書くのが最善です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;D&#39;]</span>
</pre></div>
</div>
<p>最後の <em>reverse</em> パラメータはブーリアン値を取ります。真ならばリストは逆順にソートされます。 <code class="docutils literal"><span class="pre">L.sort();</span> <span class="pre">L.reverse()</span></code> と書く代わりにこれからは <code class="docutils literal"><span class="pre">L.sort(reverse=True)</span></code> と書けます。</p>
<p>ソートの結果がステーブル(安定)であることが保障されるようになりました。つまり 2 つの要素が同列である場合、入力と同じ順序が保たれます。例えば人物リストを名前でソートしたのちに年齢でソートすると結果は、年齢でソートされていますが同年齢の人物は名前順です。</p>
<p>(All changes to <code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code> contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">新たに追加されたビルトイン関数 <code class="docutils literal"><span class="pre">sorted(iterable)</span></code> はインプレイスなメソッド <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> と似た振る舞いをしますが、式内で使えます。違いは:</p>
</li>
<li><p class="first">入力には任意のイテラブルを取れます;</p>
</li>
<li><p class="first">新しく構築されたコピーをソートし、オリジナルは無傷のままにします; そして</p>
</li>
<li><p class="first">式として新しいソート済みコピーを返します。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">10</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>       <span class="c1"># usable in a list comprehension</span>
<span class="go">[11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>                               <span class="c1"># original is left unchanged</span>
<span class="go">[9,7,8,3,2,4,1,6,5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="s1">&#39;Monty Python&#39;</span><span class="p">)</span>          <span class="c1"># any iterable may be an input</span>
<span class="go">[&#39; &#39;, &#39;M&#39;, &#39;P&#39;, &#39;h&#39;, &#39;n&#39;, &#39;n&#39;, &#39;o&#39;, &#39;o&#39;, &#39;t&#39;, &#39;t&#39;, &#39;y&#39;, &#39;y&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># List the contents of a dict sorted by key values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">colormap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">red</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">black</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">yellow</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">colormap</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
<span class="gp">...</span>
<span class="go">black 4</span>
<span class="go">blue 2</span>
<span class="go">green 3</span>
<span class="go">red 1</span>
<span class="go">yellow 5</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">整数演算はもはや <code class="xref py py-exc docutils literal"><span class="pre">OverflowWarning</span></code> は引き起こしません。 <code class="xref py py-exc docutils literal"><span class="pre">OverflowWarning</span></code> 警告は Python 2.5 で撤廃されます。</p>
</li>
<li><p class="first">インタプリタに新たに <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal"><span class="pre">-m</span></code></a> スイッチが加わりました。これは名前を取り、 <code class="docutils literal"><span class="pre">sys.path</span></code> にある対応するモジュールを検索し、そしてそのモジュールをスクリプトとして実行します。たとえば Python プロファイラを <code class="docutils literal"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">profile</span></code> で起動することが出来るようになりました。 (Contributed by Nick Coghlan.)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">eval(expr,</span> <span class="pre">globals,</span> <span class="pre">locals)</span></code> 関数と <code class="docutils literal"><span class="pre">execfile(filename,</span> <span class="pre">globals,</span> <span class="pre">locals)</span></code> 関数、 <code class="docutils literal"><span class="pre">exec</span></code> 文が <em>locals</em> パラメータに任意のマッピング型を受け取れるようになりました。以前は正規の Python 辞書である必要がありました。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">ビルトイン関数の <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> と <code class="xref py py-func docutils literal"><span class="pre">itertools.izip()</span></code> が引数なしで呼ばれた場合に空リストを返すようになりました。以前は <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外でした。これにより可変引数リストをこなしやすくなります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transpose</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)])</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transpose</span><span class="p">([])</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first">Encountering a failure while importing a module no longer leaves a partially-initialized
module object in <code class="docutils literal"><span class="pre">sys.modules</span></code>.  The incomplete module object left
behind would fool further imports of the same module into succeeding, leading to
confusing errors.   (Fixed by Tim Peters.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> が定数になっています。 <code class="docutils literal"><span class="pre">None</span></code> という名前に新しい値を割り当てようとするコードは、今では構文エラーになります。 (Contributed by Raymond Hettinger.)</p>
</li>
</ul>
<div class="section" id="optimizations">
<h3>最適化<a class="headerlink" href="#optimizations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>The inner loops for list and tuple slicing were optimized and now run about
one-third faster.  The inner loops for dictionaries were also optimized,
resulting in performance boosts for <code class="xref py py-meth docutils literal"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">items()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">iterkeys()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">itervalues()</span></code>, and <code class="xref py py-meth docutils literal"><span class="pre">iteritems()</span></code>. (Contributed by
Raymond Hettinger.)</li>
<li>The machinery for growing and shrinking lists was optimized for speed and for
space efficiency.  Appending and popping from lists now runs faster due to more
efficient code paths and less frequent use of the underlying system
<code class="xref c c-func docutils literal"><span class="pre">realloc()</span></code>.  List comprehensions also benefit.   <code class="xref py py-meth docutils literal"><span class="pre">list.extend()</span></code> was
also optimized and no longer converts its argument into a temporary list before
extending the base list.  (Contributed by Raymond Hettinger.)</li>
<li><a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal"><span class="pre">list()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-func docutils literal"><span class="pre">tuple()</span></code></a>, <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a>, <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal"><span class="pre">filter()</span></code></a>, and <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> now
run several times faster with non-sequence arguments that supply a
<a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> method.  (Contributed by Raymond Hettinger.)</li>
<li>The methods <code class="xref py py-meth docutils literal"><span class="pre">list.__getitem__()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">dict.__getitem__()</span></code>, and
<code class="xref py py-meth docutils literal"><span class="pre">dict.__contains__()</span></code> are now implemented as <code class="xref py py-class docutils literal"><span class="pre">method_descriptor</span></code>
objects rather than <code class="xref py py-class docutils literal"><span class="pre">wrapper_descriptor</span></code> objects.  This form of  access
doubles their performance and makes them more suitable for use as arguments to
functionals: <code class="docutils literal"><span class="pre">map(mydict.__getitem__,</span> <span class="pre">keylist)</span></code>. (Contributed by Raymond
Hettinger.)</li>
<li>Added a new opcode, <code class="docutils literal"><span class="pre">LIST_APPEND</span></code>, that simplifies the generated bytecode
for list comprehensions and speeds them up by about a third.  (Contributed by
Raymond Hettinger.)</li>
<li>The peephole bytecode optimizer has been improved to  produce shorter, faster
bytecode; remarkably, the resulting bytecode is  more readable.  (Enhanced by
Raymond Hettinger.)</li>
<li>String concatenations in statements of the form <code class="docutils literal"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">+</span> <span class="pre">&quot;abc&quot;</span></code> and <code class="docutils literal"><span class="pre">s</span> <span class="pre">+=</span>
<span class="pre">&quot;abc&quot;</span></code> are now performed more efficiently in certain circumstances.  This
optimization won’t be present in other Python implementations such as Jython, so
you shouldn’t rely on it; using the <code class="xref py py-meth docutils literal"><span class="pre">join()</span></code> method of strings is still
recommended when you want to efficiently glue a large number of strings
together. (Contributed by Armin Rigo.)</li>
</ul>
<p>The net result of the 2.4 optimizations is that Python 2.4 runs the pystone
benchmark around 5% faster than Python 2.3 and 35% faster than Python 2.2.
(pystone is not a particularly good benchmark, but it’s the most commonly used
measurement of Python’s performance.  Your own applications may show greater or
smaller benefits from Python 2.4.)</p>
</div>
</div>
<div class="section" id="new-improved-and-deprecated-modules">
<h2>新たなモジュール、改良されたモジュール、非推奨のモジュール<a class="headerlink" href="#new-improved-and-deprecated-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いつものように、Python の標準ライブラリには数多くの拡張とバグ修正がありました。ここでは最も注目に値する変更について、モジュールの辞書順に列挙します。変更の完全なリストについてはソースツリーの <code class="file docutils literal"><span class="pre">Misc/NEWS</span></code> を調べるか、あるいは全ての詳細について CVS ログに目を通してみてください。</p>
<ul>
<li><p class="first"><a class="reference internal" href="../library/asyncore.html#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code class="xref py py-mod docutils literal"><span class="pre">asyncore</span></code></a> モジュールの <code class="xref py py-func docutils literal"><span class="pre">loop()</span></code> 関数に、 <em>count</em> パラメータが追加されました。これはポーリングのループ回数を制限するものです。デフォルトは無限ループです。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/base64.html#module-base64" title="base64: RFC 3548: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code class="xref py py-mod docutils literal"><span class="pre">base64</span></code></a> モジュールが RFC 3548 のより完全な、Base64, Base32, Base16 サポートとなり、また、小文字を受け付けるかどうかと代替アルファベットのサポートも追加されました。 (Contributed by Barry Warsaw.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/bisect.html#module-bisect" title="bisect: Array bisection algorithms for binary searching."><code class="xref py py-mod docutils literal"><span class="pre">bisect</span></code></a> モジュールが性能改善のために C 実装を使うようになりました。 (Contributed by Dmitry Vasiliev.)</p>
</li>
<li><p class="first">Hye-Shik Chang によって保守されている東アジアのコーデックの CJKCodecs コレクションが Python 2.4 に統合されました。新たなエンコーディングは:</p>
</li>
<li><p class="first">Chinese (PRC): gb2312, gbk, gb18030, big5hkscs, hz</p>
</li>
<li><p class="first">Chinese (ROC): big5, cp950</p>
</li>
<li><dl class="first docutils">
<dt>Japanese: cp932, euc-jis-2004, euc-jp, euc-jisx0213, iso-2022-jp,</dt>
<dd><p class="first last">iso-2022-jp-1, iso-2022-jp-2, iso-2022-jp-3, iso-2022-jp-ext, iso-2022-jp-2004,
shift-jis, shift-jisx0213, shift-jis-2004</p>
</dd>
</dl>
</li>
<li><p class="first">Korean: cp949, euc-kr, johab, iso-2022-kr</p>
</li>
<li><p class="first">ほか、新たなエンコーディングが追加されています: HP Roman8,  ISO_8859-11, ISO_8859-16, PCTP-154, TIS-620.</p>
</li>
<li><p class="first">UTF-8, UTF-16 コーデックが部分的な入力を受け取った場合により上手に処理するようになりました。以前は <code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code> クラスは不足データを読み出そうと試みるために、それがストリームからデコード処理を再開することを不可能にしていました。 <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> メソッドは今ではそのとき読めているデータを返し、次の呼び出しで以前の読み残しのデコード処理から再開します。(Implemented by Walter Dörwald.)</p>
</li>
<li><p class="first">There is a new <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> module for  various specialized collection
datatypes.  Currently it contains just one type, <code class="xref py py-class docutils literal"><span class="pre">deque</span></code>, a double-ended
queue that supports efficiently adding and removing elements from either
end:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="s1">&#39;ghi&#39;</span><span class="p">)</span>        <span class="c1"># make a new deque with three items</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>           <span class="c1"># add a new entry to the right side</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>       <span class="c1"># add a new entry to the left side</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>                       <span class="c1"># show the representation of the deque</span>
<span class="go">deque([&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>                 <span class="c1"># return and remove the rightmost item</span>
<span class="go">&#39;j&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>             <span class="c1"># return and remove the leftmost item</span>
<span class="go">&#39;f&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>                 <span class="c1"># list the contents of the deque</span>
<span class="go">[&#39;g&#39;, &#39;h&#39;, &#39;i&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;h&#39;</span> <span class="ow">in</span> <span class="n">d</span>                <span class="c1"># search the deque</span>
<span class="go">True</span>
</pre></div>
</div>
<p><code class="xref py py-mod docutils literal"><span class="pre">Queue</span></code> や <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> のようないくつかのモジュールで、 <a class="reference internal" href="../library/collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal"><span class="pre">collections.deque</span></code></a> を生かして性能改善を成し遂げています。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">ConfigParser</span></code> クラスは少し拡張されました。 <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> メソッドが解析成功したファイルのリストを返すようになり、 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-meth docutils literal"><span class="pre">set()</span></code></a> メソッドは <em>value</em> 引数が文字列でないと <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出するようになりました。(Contributed by John Belmonte and David Goodger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">curses</span></code></a> モジュールが ncurses 拡張の <code class="xref py py-func docutils literal"><span class="pre">use_default_colors()</span></code> をサポートするようになりました。透明性をサポートするターミナルを持つプラットフォームならば、このことで透明背景に出来ます。 (Contributed by Jörg Lehmann.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal"><span class="pre">difflib</span></code></a> モジュールに <code class="xref py py-class docutils literal"><span class="pre">HtmlDiff</span></code> クラスが追加されています。これは対象テキストをサイドバイサイドで視覚化する HTML テーブルを作ります。 (Contributed by Dan Gass.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal"><span class="pre">email</span></code></a> パッケージがバージョン 3.0 に更新されています。多くの非推奨だった API が削除され、Python 2.3 以前のバージョンへのサポートが削除されています。パッケージのバージョン 3.0 は MIME メッセージについての漸増的な新パーサを使います。これは <code class="xref py py-mod docutils literal"><span class="pre">email.FeedParser</span></code> モジュールで利用可能です。この新パーサはメモリ内に全てのメッセージを読み込んでおく必要がなく、メッセージが不正であっても例外は投げません; 代わりにメッセージの全ての問題についてを <code class="xref py py-attr docutils literal"><span class="pre">defect</span></code> 属性に記録します。 (Developed by Anthony Baxter, Barry Warsaw, Thomas Wouters, and others.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal"><span class="pre">heapq</span></code></a> モジュールは C に変換されました。性能改善は 10 倍となり、モジュールはより大きなデータを扱うのに相応しいものになりました。加えて、モジュールには新しく 2 つの関数が追加されました。それは <code class="xref py py-func docutils literal"><span class="pre">nlargest()</span></code> と <code class="xref py py-func docutils literal"><span class="pre">nsmallest()</span></code> で、データセット内の大きいものから N 番目まで、小さいものから N 番目までを、高価な完全なソートを要することなく取り出すのに使います。(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">httplib</span></code> モジュールに、HTTP 関連の種々の RFC ドキュメントで定義されている HTTP ステータスコードについての定数群が追加されました。定数名は例えば <code class="xref py py-const docutils literal"><span class="pre">OK</span></code>, <code class="xref py py-const docutils literal"><span class="pre">CREATED</span></code>, <code class="xref py py-const docutils literal"><span class="pre">CONTINUE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">MOVED_PERMANENTLY</span></code> のようなものです。完全なリストは pydoc を使って列挙してください。 (Contributed by Andrew Eland.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">imaplib</span></code></a> モジュールが IMAP の THREAD コマンドをサポートするようになりました。 (contributed by Yves Dionne) また、 <code class="xref py py-meth docutils literal"><span class="pre">deleteacl()</span></code> メソッドと <code class="xref py py-meth docutils literal"><span class="pre">myrights()</span></code> メソッドが追加されました。 (contributed by Arnaud Mazin).</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> モジュールに <code class="docutils literal"><span class="pre">groupby(iterable[,</span> <span class="pre">*func*])</span></code> 関数が追加されました。 <em>iterable</em> は何か要素のストリームを返すものをイテレート出来るもので、省略可能な <em>func</em> パラメータは要素を取ってキー値を返す関数です。省略されればキーは要素自身です。 <code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code> は要素群をキー値の合致ごとサブシーケンスにグループ化して、キー値とサブシーケンスに対するイテレータを組とする 2 要素タプルのシリーズを返します。</p>
<p>例をお見せするのが早いでしょう。ここでは <em>key</em> 関数は単に数値が偶数か奇数かを返すだけです。 <code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code> の結果は偶数または奇数の一連の流れを返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key_val</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">key_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 [2, 4, 6]</span>
<span class="go">1 [7]</span>
<span class="go">0 [8]</span>
<span class="go">1 [9, 11]</span>
<span class="go">0 [12, 14]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code> は典型的にはソート済み入力に使います。 <code class="xref py py-func docutils literal"><span class="pre">groupby()</span></code> のロジックは除外、数え上げ、重複要素の特定を手軽に行う Unix の <code class="docutils literal"><span class="pre">uniq</span></code> フィルタに似ています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">word</span> <span class="o">=</span> <span class="s1">&#39;abracadabra&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>   <span class="c1"># Turn string into a sorted list of letters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span>
<span class="go">[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;r&#39;, &#39;r&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">letters</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">k</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">a [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;]</span>
<span class="go">b [&#39;b&#39;, &#39;b&#39;]</span>
<span class="go">c [&#39;c&#39;]</span>
<span class="go">d [&#39;d&#39;]</span>
<span class="go">r [&#39;r&#39;, &#39;r&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># List unique letters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">letters</span><span class="p">)]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;r&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Count letter occurrences</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">letters</span><span class="p">)]</span>
<span class="go">[(&#39;a&#39;, 5), (&#39;b&#39;, 2), (&#39;c&#39;, 1), (&#39;d&#39;, 1), (&#39;r&#39;, 2)]</span>
</pre></div>
</div>
<p>(Contributed by Hye-Shik Chang.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> には <code class="docutils literal"><span class="pre">tee(iterator,</span> <span class="pre">N)</span></code> という新たな関数も追加されています。これは <em>iterator</em> の、独立した <em>N</em> 個の複製イテレータを返します。 <em>N</em> は省略されればデフォルトは 2 です。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">tee</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span>
<span class="go">(&lt;itertools.tee object at 0x402c2080&gt;, &lt;itertools.tee object at 0x402c2090&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>               <span class="c1"># Run the first iterator to exhaustion</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span>               <span class="c1"># Run the second iterator to exhaustion</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">tee()</span></code> がイテレータから返される値のコピーを維持する必要があることに注意してください。最悪の場合はそれら全てを維持する必要があるかもしれません。ですのでこれは長丁場の入力に対して、先行するイテレータが後続のイテレータの遥か先を突っ走れる場合には注意深く使わなければなりません。その分断が大きいようであれば、 <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal"><span class="pre">list()</span></code></a> を代わりに使うほうが良いかもしれません。イテレータたちが相互に近い場所を追跡する場合は <code class="xref py py-func docutils literal"><span class="pre">tee()</span></code> は理想的です。ブックマーク、ウィンドウ処理、あるいは先読みイテレータといったものに適用出来るのではないでしょうか。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal"><span class="pre">locale</span></code></a> モジュールに数多くの関数が追加されました。例えば <code class="xref py py-func docutils literal"><span class="pre">bind_textdomain_codeset()</span></code> は特定のエンコーディングを指定し、 <code class="docutils literal"><span class="pre">l\*gettext</span></code> 系の関数は選択されたエンコーディングでメッセージを返します。(Contributed by Gustavo Niemeyer.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> パッケージの <code class="xref py py-func docutils literal"><span class="pre">basicConfig()</span></code> 関数に、ログ設定を簡単にするいくつかのキーワード引数が追加されました。デフォルトの振る舞いはログメッセージを標準エラー出力に出力することですが、様々なキーワード引数でログを特定のファイルに書いたり、ログのフォーマットを変えたり、ロギングのレベルを変えたり出来ます。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;/var/log/application.log&#39;</span><span class="p">,</span>
    <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># Log all messages</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%(levelname):%(process):%(thread):%(message)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>ほかの <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> パッケージへの追加としては、 便利メソッド <code class="docutils literal"><span class="pre">log(level,</span> <span class="pre">msg)</span></code> や、ログファイルを時間間隔でローテートするクラス <code class="xref py py-class docutils literal"><span class="pre">TimedRotatingFileHandler</span></code> などがあります。モジュールには元々 <code class="xref py py-class docutils literal"><span class="pre">RotatingFileHandler</span></code> が含まれており、こちらはファイルが特定のサイズを超過した場合にローテートするものです。両クラスとも新しく導出された <code class="xref py py-class docutils literal"><span class="pre">BaseRotatingHandler</span></code> 基底クラスから派生していて、これはまた別のローテートするハンドラを実装するのに使えます。</p>
<p>(Changes implemented by Vinay Sajip.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal"><span class="pre">marshal</span></code></a> モジュールが、データ構造のアンパックで内部化した文字列を共有するようになりました。これはある種の pickle 文字列のサイズを切り詰めるでしょうが、主要な効能は <code class="file docutils literal"><span class="pre">.pyc</span></code> ファイルが顕著に小さくなることです。(Contributed by Martin von Löwis.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/nntplib.html#module-nntplib" title="nntplib: NNTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">nntplib</span></code></a> モジュールの <code class="xref py py-class docutils literal"><span class="pre">NNTP</span></code> クラスに <code class="xref py py-meth docutils literal"><span class="pre">description()</span></code> メソッドと <code class="xref py py-meth docutils literal"><span class="pre">descriptions()</span></code> メソッドが追加されています。各々単一の、もしくは範囲で、ニュースグループを抽出します。 (Contributed by Jürgen A. Erhard.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal"><span class="pre">operator</span></code></a> モジュールに 2 つの関数 <code class="docutils literal"><span class="pre">attrgetter(attr)</span></code> と <code class="docutils literal"><span class="pre">itemgetter(index)</span></code> が追加されています。両関数ともに、単一引数を取ってそれに対応する属性かアイテムを返す呼び出し可能オブジェクトを返します。これら呼び出し可能オブジェクトは <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal"><span class="pre">map()</span></code></a> や <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> とともに使う際の優れたデータ抽出器になります。例えば:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
<span class="go">[2, 1, 4, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># Sort list by second tuple item</span>
<span class="go">[(&#39;d&#39;, 1), (&#39;c&#39;, 2), (&#39;b&#39;, 3), (&#39;a&#39;, 4)]</span>
</pre></div>
</div>
<p>(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library. (非推奨)"><code class="xref py py-mod docutils literal"><span class="pre">optparse</span></code></a> モジュールが色々更新されました。モジュールはメッセージを <a class="reference internal" href="../library/gettext.html#gettext.gettext" title="gettext.gettext"><code class="xref py py-func docutils literal"><span class="pre">gettext.gettext()</span></code></a> を通して Optik のヘルプとエラーメッセージを国際化するのを可能にしています。オプションのヘルプメッセージは文字列 <code class="docutils literal"><span class="pre">'%default'</span></code> を含めることが出来るようになっており、これはオプションのデフォルト値に置換されます。(Contributed by Greg Ward.)</p>
</li>
<li><p class="first">長期間の計画として、いつかの将来の Python バージョンでは <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal"><span class="pre">email</span></code></a> パッケージにより <code class="xref py py-mod docutils literal"><span class="pre">rfc822</span></code> モジュールを置き換える計画です。この目的のために、 <a class="reference internal" href="../library/email.util.html#email.utils.formatdate" title="email.utils.formatdate"><code class="xref py py-func docutils literal"><span class="pre">email.utils.formatdate()</span></code></a> が、 <code class="xref py py-func docutils literal"><span class="pre">rfc822.formatdate()</span></code> の置き換えとして使えるように変更されています。新しい e-mail 処理コードはこれを使って書くことを考えてください。(Change implemented by Anthony Baxter.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> モジュールに <code class="docutils literal"><span class="pre">urandom(n)</span></code> が追加されました。これは <em>n</em> バイトの乱数データを含む文字列を返します。この関数はプラットフォーム固有の乱数発生源にアクセスします。例えば Linux での <code class="file docutils literal"><span class="pre">/dev/urandom</span></code> や Windows での CryptoAPI です。 (Contributed by Trevor Perrin.)</p>
</li>
<li><p class="first">もう一つの新規関数 <code class="docutils literal"><span class="pre">os.path.lexists(path)</span></code> は <em>path</em> によって指定されたファイルがそれがシンボリックリンクかどうかによらず、存在している場合に真を返します。これは、既存の <code class="docutils literal"><span class="pre">os.path.exists(path)</span></code> 関数が <em>path</em> がシンボリックリンクでその指し先が存在しない場合に偽を返すのとは異なります。 (Contributed by Beni Cherniavsky.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> モジュールの下層にある <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">posix</span></code></a> モジュールに <code class="xref py py-func docutils literal"><span class="pre">getsid()</span></code> 関数が追加されました。 (Contributed by J. Raynor.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/poplib.html#module-poplib" title="poplib: POP3 protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">poplib</span></code></a> モジュールが  POP over SSL をサポートするようになりました.  (Contributed by Hector Urtubia.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal"><span class="pre">profile</span></code></a> モジュールが C 拡張の関数をプロファイル出来るようになりました。 (Contributed by Nick Bastin.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal"><span class="pre">random</span></code></a> モジュールに、 <code class="docutils literal"><span class="pre">getrandbits(N)</span></code> 関数が追加されました。 <em>N</em> ビット長の長整数を返します。既存の <code class="xref py py-meth docutils literal"><span class="pre">randrange()</span></code> メソッドは <code class="xref py py-meth docutils literal"><span class="pre">getrandbits()</span></code> を適切な場所で使うようになり、任意の大きな乱数値生成をより効果的にしています。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールの正規表現言語が拡張されて、単純な条件式 <code class="docutils literal"><span class="pre">(?(group)A|B)</span></code> を書けるようになっています。 <em>group</em> は数値グループ ID か正規表現内で <code class="docutils literal"><span class="pre">(?P&lt;group&gt;...)</span></code> で定義したグループ名のどちらかです。指定したグループが合致した場合は、正規表現パターン <em>A</em> が文字列に対してテストされ、そうでなければパターン <em>B</em> が代わりに試されます。(Contributed by Gustavo Niemeyer.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールはもう再帰をすることはありません。Gustavo Niemeyer による膨大な量の仕事のおかげです。再帰する正規表現エンジンでは、ある種のパターンでは大量の C スタック空間を消費し、スタックのオーバーフローを起こすことがありました。例えば表現 <code class="docutils literal"><span class="pre">(a|b)+</span></code> が文字 <code class="docutils literal"><span class="pre">a</span></code> から成る 3 万バイトの文字列に対してマッチすると、一文字ごとに一つのスタックフレームを消費していました。Python 2.3 ではスタックオーバーフローのチェックを試みて <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を投げようとしましたが、ある種のパターンではチェックをすり抜けてしまって、運が悪いとセグメンテーション違反を起こしていました。Python 2.4 の正規表現エンジンではこのパターンと問題を起こすことなくマッチ出来ます。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a> モジュールで、 <a class="reference internal" href="../library/signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal"><span class="pre">signal.signal()</span></code></a> へのパラメータのエラーチェックを厳しくしています。例えば <code class="xref py py-const docutils literal"><span class="pre">SIGKILL</span></code> シグナルへのハンドラはセット出来ません。以前のバージョンの Python ではこれを黙って受け容れていましたが、2.4 では <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を投げます。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールに 2 つ新しい関数が追加されています。 <code class="xref py py-func docutils literal"><span class="pre">socketpair()</span></code> 関数は接続したソケットのペアを返し、 <code class="docutils literal"><span class="pre">getservbyport(port)</span></code> は与えたポート番号からサービス名を探して返します。(Contributed by Dave Cole and Barry Warsaw.)</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">sys.exitfunc()</span></code> 関数は非推奨となりました。コードは既存の <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal"><span class="pre">atexit</span></code></a> モジュールを使うべきです。これは複数の終了関数呼び出しを正しく処理出来ます。結果的には <code class="xref py py-func docutils literal"><span class="pre">sys.exitfunc()</span></code> は純粋に <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal"><span class="pre">atexit</span></code></a> のみから使われる内部インターフェイスとなるでしょう。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal"><span class="pre">tarfile</span></code></a> モジュールがデフォルトで GNU フォーマットを生成するようになっています。 (Contributed by Lars Gustäbel.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> モジュールで、スレッドローカルなデータのサポートについて、品の良い単純な方法でサポート出来ました。モジュールは <code class="xref py py-class docutils literal"><span class="pre">local</span></code> クラスを持っており、その属性値は異なるスレッドごとにローカルになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">data</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;www.python.org&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</pre></div>
</div>
<p>この場合他のスレッドは <code class="xref py py-attr docutils literal"><span class="pre">number</span></code> 属性、 <code class="xref py py-attr docutils literal"><span class="pre">url</span></code> 属性に自身の値を代入、抽出出来ます。 <code class="xref py py-class docutils literal"><span class="pre">local</span></code> クラスは属性初期化であるとかメソッドの追加のためにサブクラス化することも出来ます。 (Contributed by Jim Fulton.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal"><span class="pre">timeit</span></code></a> モジュールはループを計測中は周期的なガーベージコレクションを自動で無効化するようになりました。この変更により、繰り返しの計測の比較がやりやすくなります。 (Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールがサポートするオブジェクトが非常に幅広くなりました。これには Python 関数、クラスインスタンス, set, frozenset, deque, array と正規表現パターンオブジェクトが含まれます。(Contributed by Raymond Hettinger.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">xmlrpclib</span></code> モジュールが、単一の HTTP 操作内で複数 XML-RPC 呼び出しを転送するためのマルチコール拡張をサポートするようになりました。 (Contributed by Brian Quinlan.)</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal"><span class="pre">mpz</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">rotor</span></code>,  <code class="xref py py-mod docutils literal"><span class="pre">xreadlines</span></code>  モジュールは削除されました。</p>
</li>
</ul>
<div class="section" id="cookielib">
<h3>cookielib<a class="headerlink" href="#cookielib" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref py py-mod docutils literal"><span class="pre">cookielib</span></code> ライブラリは HTTP クッキーのクライアントサイドでの処理をサポートするもので、サーバサイドでのクッキーサポートを模倣したものです。クッキーはクッキー瓶 (cookie jar) に記憶されます。ライブラリはウェブサーバから提供されたクッキーをクッキー瓶に保存し、サーバに接続時に瓶からクッキーを取り出します。ウェブブラウザ内と同じく、ポリシーオブジェクトがクッキーを受け容れるかどうかを制御します。</p>
<p>セッションを跨いでクッキーを記憶するために、2 つのクッキー瓶実装が提供されています。一つは Netscape フォーマットでクッキーを記憶するのでアプリケーションは Mozilla か Lynx のクッキーファイルを使え、もう一つは Perl の libwww ライブラリと同じフォーマットでクッキーを記憶します。</p>
<p><code class="xref py py-mod docutils literal"><span class="pre">urllib2</span></code> は <code class="xref py py-mod docutils literal"><span class="pre">cookielib</span></code> と連携するように変更されました: <code class="xref py py-class docutils literal"><span class="pre">HTTPCookieProcessor</span></code> がアクセスしている URL で使われるクッキー瓶を管理します。</p>
<p>このモジュールは John J. Lee により寄稿されました。</p>
</div>
<div class="section" id="doctest">
<h3>doctest<a class="headerlink" href="#doctest" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Edward Loper と Tim Peters のおかげにより、 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> モジュールに注目に値するリファクタリングが入りました。テストはこれまで通り単純に <a class="reference internal" href="../library/doctest.html#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal"><span class="pre">doctest.testmod()</span></code></a> を実行するすることで行えますが、リファクタリングはモジュールの操作をカスタマイズする色々な手段を提供してくれます。</p>
<p>新規クラス <code class="xref py py-class docutils literal"><span class="pre">DocTestFinder</span></code> は指定したオブジェクトの docstring からテストを抽出します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; f(2,2)</span>
<span class="sd">4</span>
<span class="sd">&gt;&gt;&gt; f(3,2)</span>
<span class="sd">6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

<span class="n">finder</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">DocTestFinder</span><span class="p">()</span>

<span class="c1"># Get list of DocTest instances</span>
<span class="n">tests</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>新規クラス <code class="xref py py-class docutils literal"><span class="pre">DocTestRunner</span></code> はテストを個々に実行し、結果の要約を生成出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">runner</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">DocTestRunner</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
    <span class="n">tried</span><span class="p">,</span> <span class="n">failed</span> <span class="o">=</span> <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">runner</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>上の例はこのような出力を生成します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="n">items</span> <span class="n">passed</span> <span class="nb">all</span> <span class="n">tests</span><span class="p">:</span>
   <span class="mi">2</span> <span class="n">tests</span> <span class="ow">in</span> <span class="n">f</span>
<span class="mi">2</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mi">1</span> <span class="n">items</span><span class="o">.</span>
<span class="mi">2</span> <span class="n">passed</span> <span class="ow">and</span> <span class="mi">0</span> <span class="n">failed</span><span class="o">.</span>
<span class="n">Test</span> <span class="n">passed</span><span class="o">.</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">DocTestRunner</span></code> は実際の出力と結果の期待値の比較に、 <code class="xref py py-class docutils literal"><span class="pre">OutputChecker</span></code> のインスタンスを使います。このクラスはその振る舞いをカスタマイズする色々なフラグを取ります。意欲的なユーザであれば <code class="xref py py-class docutils literal"><span class="pre">OutputChecker</span></code> の完全な新しいサブクラスも書けます。</p>
<p>デフォルトの出力チェッカーは多くのお手軽機能を持っています。例えば <a class="reference internal" href="../library/doctest.html#doctest.ELLIPSIS" title="doctest.ELLIPSIS"><code class="xref py py-const docutils literal"><span class="pre">doctest.ELLIPSIS</span></code></a> オプションフラグは、出力の期待値内での省略記号 (<code class="docutils literal"><span class="pre">...</span></code>) と任意文字列を一致するとみなし、瑣末な部分が変化するような出力に簡単に適合するように出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">o</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; o(1)</span>
<span class="sd">&lt;__main__.C instance at 0x...&gt;</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>もう一つの特殊文字列 <code class="docutils literal"><span class="pre">&lt;BLANKLINE&gt;</span></code> は空行に合致します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">p</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; p(1)</span>
<span class="sd">&lt;BLANKLINE&gt;</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>もう一つの新機能は出力の diff スタイル出力で、オプションフラグに <a class="reference internal" href="../library/doctest.html#doctest.REPORT_UDIFF" title="doctest.REPORT_UDIFF"><code class="xref py py-const docutils literal"><span class="pre">doctest.REPORT_UDIFF</span></code></a> (unified diffs), <a class="reference internal" href="../library/doctest.html#doctest.REPORT_CDIFF" title="doctest.REPORT_CDIFF"><code class="xref py py-const docutils literal"><span class="pre">doctest.REPORT_CDIFF</span></code></a> (context diffs), <a class="reference internal" href="../library/doctest.html#doctest.REPORT_NDIFF" title="doctest.REPORT_NDIFF"><code class="xref py py-const docutils literal"><span class="pre">doctest.REPORT_NDIFF</span></code></a> (delta-style) を指定することで利用出来ます。例えば以下があるとして:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">g</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; g(4)</span>
<span class="sd">here</span>
<span class="sd">is</span>
<span class="sd">a</span>
<span class="sd">lengthy</span>
<span class="sd">&gt;&gt;&gt;&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="s1">&#39;here is a rather lengthy list of words&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[:</span><span class="n">n</span><span class="p">]:</span>
        <span class="nb">print</span> <span class="n">word</span>
</pre></div>
</div>
<p>Running the above function’s tests with <a class="reference internal" href="../library/doctest.html#doctest.REPORT_UDIFF" title="doctest.REPORT_UDIFF"><code class="xref py py-const docutils literal"><span class="pre">doctest.REPORT_UDIFF</span></code></a> specified,
you get the following output:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>**********************************************************************
File &quot;t.py&quot;, line 15, in g
Failed example:
    g(4)
Differences (unified diff with -expected +actual):
    @@ -2,3 +2,3 @@
     is
     a
    -lengthy
    +rather
**********************************************************************
</pre></div>
</div>
</div>
</div>
<div class="section" id="build-and-c-api-changes">
<h2>ビルドならびに C API の変更<a class="headerlink" href="#build-and-c-api-changes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のビルド過程と C API の変更は以下の通りです:</p>
<ul class="simple">
<li>拡張関数からの戻り値として一般的に使うための 3 つの便利なマクロが追加されています: <a class="reference internal" href="../c-api/none.html#c.Py_RETURN_NONE" title="Py_RETURN_NONE"><code class="xref c c-macro docutils literal"><span class="pre">Py_RETURN_NONE</span></code></a>, <a class="reference internal" href="../c-api/bool.html#c.Py_RETURN_TRUE" title="Py_RETURN_TRUE"><code class="xref c c-macro docutils literal"><span class="pre">Py_RETURN_TRUE</span></code></a>, <a class="reference internal" href="../c-api/bool.html#c.Py_RETURN_FALSE" title="Py_RETURN_FALSE"><code class="xref c c-macro docutils literal"><span class="pre">Py_RETURN_FALSE</span></code></a> (Contributed by Brett Cannon.)</li>
<li>もう一つの新規マクロ <code class="xref c c-macro docutils literal"><span class="pre">Py_CLEAR(obj)</span></code> は <em>obj</em> の参照カウントをデクリメントの上で <em>obj</em> をヌルポインタにセットします。 (Contributed by Jim Fulton.)</li>
<li>新規関数 <code class="docutils literal"><span class="pre">PyTuple_Pack(N,</span> <span class="pre">obj1,</span> <span class="pre">obj2,</span> <span class="pre">...,</span> <span class="pre">objN)</span></code> は Python オブジェクトの可変長引数リストからタプルを構築します。 (Contributed by Raymond Hettinger.)</li>
<li>新規関数 <code class="docutils literal"><span class="pre">PyDict_Contains(d,</span> <span class="pre">k)</span></code> は、処理内で起こる例外のマスキングなしでの高速なルックアップを実装しています。 (Contributed by Raymond Hettinger.)</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">Py_IS_NAN(X)</span></code> マクロは float または double の <em>X</em> が NaN の場合に 1 を返します。 (Contributed by Tim Peters.)</li>
<li>C コードは新たに追加された <a class="reference internal" href="../c-api/init.html#c.PyEval_ThreadsInitialized" title="PyEval_ThreadsInitialized"><code class="xref c c-func docutils literal"><span class="pre">PyEval_ThreadsInitialized()</span></code></a> 関数を呼び出すことで、必要のないロックを避けることが出来ます。これは任意のスレッド操作が実行されているかどうかを教えてくれます。この関数が偽を返すなら、ロック操作は必要ありません。 (Contributed by Nick Coghlan.)</li>
<li>新規関数 <a class="reference internal" href="../c-api/arg.html#c.PyArg_VaParseTupleAndKeywords" title="PyArg_VaParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_VaParseTupleAndKeywords()</span></code></a> は <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> と同じですが、たくさんの引数の代わりに <code class="xref c c-type docutils literal"><span class="pre">va_list</span></code> を取ることだけが違います。(Contributed by Greg Chapman.)</li>
<li>新たなメソッドフラグ <code class="xref py py-const docutils literal"><span class="pre">METH_COEXISTS</span></code> は、同じ名前を持っている <a class="reference internal" href="../c-api/structures.html#c.PyCFunction" title="PyCFunction"><code class="xref c c-type docutils literal"><span class="pre">PyCFunction</span></code></a> と共存する、スロット内で定義される関数を許します。これは <code class="xref py py-meth docutils literal"><span class="pre">set.__contains__()</span></code> のようなメソッドへのアクセス時間を半分にします。 (Contributed by Raymond Hettinger.)</li>
<li>Python can now be built with additional profiling for the interpreter itself,
intended as an aid to people developing the Python core.  Providing
<code class="xref std std-option docutils literal"><span class="pre">--enable-profiling</span></code> to the <strong class="program">configure</strong> script will let you
profile the interpreter with <strong class="program">gprof</strong>, and providing the
<code class="xref std std-option docutils literal"><span class="pre">--with-tsc</span></code> switch enables profiling using the Pentium’s
Time-Stamp-Counter register.  Note that the <code class="xref std std-option docutils literal"><span class="pre">--with-tsc</span></code> switch is slightly
misnamed, because the profiling feature also works on the PowerPC platform,
though that processor architecture doesn’t call that register &quot;the TSC
register&quot;.  (Contributed by Jeremy Hylton.)</li>
<li><code class="xref c c-type docutils literal"><span class="pre">tracebackobject</span></code> 型は <code class="xref c c-type docutils literal"><span class="pre">PyTracebackObject</span></code> にリネームされました。</li>
</ul>
<div class="section" id="port-specific-changes">
<h3>ポート特有の変更<a class="headerlink" href="#port-specific-changes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li>Windows ポートは MSVC++ 6 と 7.1 でビルド出来ます。 (Contributed by Martin von Löwis.)</li>
</ul>
</div>
</div>
<div class="section" id="porting-to-python-2-4">
<h2>Python 2.4 への移植<a class="headerlink" href="#porting-to-python-2-4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このセクションでは前述の変更により必要となるかもしれないコードの変更を列挙します:</p>
<ul class="simple">
<li>大き過ぎる値を持つ左シフトと 16 進/ 8 進定数が <a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal"><span class="pre">FutureWarning</span></code></a> を引き起こした上で 32 ビットまたは 64 ビットに制限される、という振る舞いはもうしません。代わりに長整数を返します。</li>
<li>整数演算はもはや <code class="xref py py-exc docutils literal"><span class="pre">OverflowWarning</span></code> は引き起こしません。 <code class="xref py py-exc docutils literal"><span class="pre">OverflowWarning</span></code> 警告は Python 2.5 で撤廃されます。</li>
<li>ビルトイン関数の <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a> と <code class="xref py py-func docutils literal"><span class="pre">itertools.izip()</span></code> が引数なしで呼ばれた場合に、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外を起こすのではなく空リストを返すようになりました。</li>
<li>You can no longer compare the <code class="xref py py-class docutils literal"><span class="pre">date</span></code> and <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal"><span class="pre">datetime</span></code></a> instances
provided by the <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal"><span class="pre">datetime</span></code></a> module.  Two  instances of different classes
will now always be unequal, and  relative comparisons (<code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>) will raise
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>.</li>
<li><code class="xref py py-func docutils literal"><span class="pre">dircache.listdir()</span></code> は空リストを返す代わりに呼び出し元に例外を投げます。</li>
<li><code class="xref py py-func docutils literal"><span class="pre">LexicalHandler.startDTD()</span></code> はパブリックでシステムの ID を間違った順序で受け取っていました。これは修正されました; この間違った順序に依存したアプリケーションは修正しなければなりません。</li>
<li><a class="reference internal" href="../library/fcntl.html#fcntl.ioctl" title="fcntl.ioctl"><code class="xref py py-func docutils literal"><span class="pre">fcntl.ioctl()</span></code></a> は <em>mutate_flag</em> 引数が省略されて問題に関係がある場合は警告を出します。</li>
<li><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal"><span class="pre">tarfile</span></code></a> モジュールがデフォルトで GNU フォーマットを生成するようになっています。</li>
<li>Encountering a failure while importing a module no longer leaves a
partially-initialized module object in <code class="docutils literal"><span class="pre">sys.modules</span></code>.</li>
<li><a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> が定数になっています。 <code class="docutils literal"><span class="pre">None</span></code> という名前に新しい値を割り当てようとするコードは、今では構文エラーになります。</li>
<li><code class="xref py py-func docutils literal"><span class="pre">signals.signal()</span></code> 関数は、ある種の不正な値では <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> を投げるようになっています。以前はこれらエラーは黙って通していました。例えばもう <code class="xref py py-const docutils literal"><span class="pre">SIGKILL</span></code> へはハンドラは渡せません。</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<span id="acks"></span><h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します: Koray Can, Hye-Shik Chang, Michael Dyck, Raymond Hettinger, Brian Hurt, Hamish Lawson, Fredrik Lundh, Sean Reifschneider, Sadruddin Rejeb.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">What’s New in Python 2.4</a><ul>
<li><a class="reference internal" href="#pep-218-built-in-set-objects">PEP 218: ビルトインの集合オブジェクト</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: 長整数と整数を一体化していく</a></li>
<li><a class="reference internal" href="#pep-289-generator-expressions">PEP 289: ジェネレータ式</a></li>
<li><a class="reference internal" href="#pep-292-simpler-string-substitutions">PEP 292: より単純な文字列置換 (string substitution)</a></li>
<li><a class="reference internal" href="#pep-318-decorators-for-functions-and-methods">PEP 318: 関数とメソッドのためのデコレータ</a></li>
<li><a class="reference internal" href="#pep-322-reverse-iteration">PEP 322: 逆順のイテレーション</a></li>
<li><a class="reference internal" href="#pep-324-new-subprocess-module">PEP 324: 新しい subprocess モジュール</a></li>
<li><a class="reference internal" href="#pep-327-decimal-data-type">PEP 327: Decimal データ型</a><ul>
<li><a class="reference internal" href="#why-is-decimal-needed">なぜ Decimal が必要なのか?</a></li>
<li><a class="reference internal" href="#the-decimal-type"><code class="docutils literal"><span class="pre">Decimal</span></code> 型</a></li>
<li><a class="reference internal" href="#the-context-type"><code class="docutils literal"><span class="pre">Context</span></code> 型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-328-multi-line-imports">PEP 328: マルチラインインポート</a></li>
<li><a class="reference internal" href="#pep-331-locale-independent-float-string-conversions">PEP 331: Locale に依存しない Float/String 変換</a></li>
<li><a class="reference internal" href="#other-language-changes">その他の言語変更</a><ul>
<li><a class="reference internal" href="#optimizations">最適化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新たなモジュール、改良されたモジュール、非推奨のモジュール</a><ul>
<li><a class="reference internal" href="#cookielib">cookielib</a></li>
<li><a class="reference internal" href="#doctest">doctest</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">ビルドならびに C API の変更</a><ul>
<li><a class="reference internal" href="#port-specific-changes">ポート特有の変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-4">Python 2.4 への移植</a></li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="2.5.html"
                        title="前の章へ">What’s New in Python 2.5</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2.3.html"
                        title="次の章へ">What’s New in Python 2.3</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/whatsnew/2.4.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="What’s New in Python 2.3"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="What’s New in Python 2.5"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What’s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 1月 06, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>