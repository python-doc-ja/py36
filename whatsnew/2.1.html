<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>What’s New in Python 2.1 &#8212; Python 3.6.1 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.1 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.6.1 ドキュメント" href="../contents.html" />
    <link rel="up" title="What’s New in Python" href="index.html" />
    <link rel="next" title="What’s New in Python 2.0" href="2.0.html" />
    <link rel="prev" title="What’s New in Python 2.2" href="2.2.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/whatsnew/2.1.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/whatsnew/2.1.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="What’s New in Python 2.0"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="What’s New in Python 2.2"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What&#8217;s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-2-1">
<h1>What&#8217;s New in Python 2.1<a class="headerlink" href="#what-s-new-in-python-2-1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">A.M. Kuchling</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>はじめに<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この記事はPython 2.1の新機能について説明します。Python 2.1には Python 2.0ほど多くの変更点はありませんが、楽しい驚きがあります。2.1はPythonの拡張計画（PEP）を使い動かす最初のリリースであり、大きい変更点のほとんどは、より詳細なドキュメントや変更のための設計原理を提供するPEPに付随しています。この記事は新機能について網羅していませんが、Pythonプログラマのための新機能について概要を示します。特に興味のある任意の新機能の詳細については、Python 2.1ドキュメントか特定のPEPを参照してください。</p>
<p>Python開発チームの最近の目標の一つとして新しいリリースのペースを上げており、一つのリリースにつき6～9ヶ月ごとにリリースしています。2.1はこの速いペースになって出てきた最初のリリースで、初のアルファ版は、2.0の最終版がリリースされた3ヶ月後の1月に登場しました。</p>
<p>Python 2.1の最終版は2001年4月17日に作成されました。</p>
</div>
<div class="section" id="pep-227-nested-scopes">
<h2>PEP 227: 入れ子状のスコープ<a class="headerlink" href="#pep-227-nested-scopes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python2.1における最も大きな変更点はPythonのスコープルールです。Python2.0では、ある指定された時点である変数の名前を検索するために多くても3つの名前空間、つまりローカル、モジュールレベル、ビルトイン名前空間しか使われませんでした。このことは直感的な期待と一致せずしばしば人々を驚かせました。例えば、入れ子になった再帰関数の定義は動きません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>名前 <code class="docutils literal"><span class="pre">g</span></code> はローカルの名前空間にもモジュールレベルの名前空間にも紐付かないので、関数 <code class="xref py py-func docutils literal"><span class="pre">g()</span></code> は常に <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a> 例外を上げます。これは実際には大した問題ではありません (このような内部関数を再帰的に定義する頻度はそう多くありません)が、 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> ステートメントをより使いにくくするのでこれについては問題です。 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> を使うコードにおいて、デフォルトの引数としてこれらを渡してコピーされるローカル変数を頻繁に見かけます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s2">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>過度な関数型スタイルで書かれた Python コードの可読性は、結果的にはひどく苦痛を感じるものですね。</p>
<p>Python 2.1の最も重要な変更点は、この問題を解決するために静的なスコープが追加されたことです。最初の効果として、<code class="docutils literal"><span class="pre">name=name</span></code> という例ではデフォルトの引数は必要ありません。簡単に言えば、指定された引数名が関数内の値に割り当てられない場合(<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal"><span class="pre">def</span></code></a>、<a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> または <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ステートメントの割り当てによって)、変数の参照は外側のスコープのローカル名前空間で検索されます。ルールや実装の詳細はPEPで参照できます。</p>
<p>この変更は、同じ変数名がモジュールレベルと関数の定義が含まれている関数内のローカルの両方で変数名として使用されているコードで、互換性の問題を引き起こす可能性があります。ですがむしろ気にしなくてよいでしょう。そのようなコードはそもそも最初から相当こんがらかっているので。</p>
<p>この変更の副作用の一つは、 <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> と <code class="docutils literal"><span class="pre">exec</span></code> の両ステートメントが特定の条件下の関数スコープ内で不正となることです。 Python のリファレンスマニュアルははじめからずっと <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> はトップレベルモジュールでのみ合法であると言ってきましたが、以前の CPython インタプリタはこれを一度も強制していませんでした。入れ子になったスコープ実装の一環として、Python のソースをバイトコードに変換するコンパイラは、内包されたスコープ内の変数にアクセスするために別のコードを生成する必要があります。 <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>, <code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> はコンパイラにこれを理解することを不可能にしてしまいます。なぜならそれらはコンパイル時にはわからないローカル名前空間に名前を追加するからです。それゆえ、もし関数が関数定義を含んだり自由な変数に <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> の語句を含んだりする場合、コンパイラは <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a> 例外を上げて知らせます。</p>
<p>前述した説明を少し明確にするため、例を挙げます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c1"># The next line is a syntax error</span>
    <span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p><code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> 文を含む 4 行目は文法エラーです。 <code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> としては新しいローカル変数 <code class="docutils literal"><span class="pre">x</span></code> を定義したいのですが、これは <code class="xref py py-func docutils literal"><span class="pre">g()</span></code> からアクセスされなければなりません。</p>
<p>これは実際には大した制約でもないはずです。 <code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> が Python コードで使われるのは稀です(使われているとしたら大抵どこか貧弱な設計であることの証)。</p>
<p>互換性の問題が考慮されて、入れ子のスコープは段階的導入につながりました; Python 2.1 ではそれらはデフォルトで有効になっていませんが、PEP 236 に記載されているように、future 文を使用してモジュール内でオンにすることができます。(PEP 236 の更なる議論について、続くセクションを参照してください。) Python 2.2では入れ子になったスコープがデフォルトになり、それをオフにする方法はありませんが、ユーザは 2.1 の全ライフタイムを通して、導入の結果起きるあらゆる破損を修正し続けるでしょう。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-26"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0227"><strong>PEP 227</strong></a> - 静的に入れ子になったスコープ</dt>
<dd><p class="first last">Jeremy Hylton著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-236-future-directives">
<h2>PEP 236: __future__ 指示文<a class="headerlink" href="#pep-236-future-directives" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ネストされたスコープへのこの対応は、リリース 2.1 ではコードを壊すことの危険性について広く懸念されており、  Pythoneer 達に保守的なアプローチを選ばせるには十分でした。このアプローチは、必須とするリリース N+1 に対する、 リリース N でのオプション機能として有効化という序奏、というものです。</p>
<p>この構文は <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> という名の予約モジュールを使う <code class="docutils literal"><span class="pre">from...import</span></code> ステートメントを使用します。ネストしたスコープは以下のステートメントで有効にできます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">nested_scopes</span>
</pre></div>
</div>
<p>普通 の <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ステートメントに見えますが、実は違います; このような未来のステートメントが置かれる場所には厳格なルールがあります。これらはモジュールの冒頭にしか置けませんし、必ず何らかのPythonコードや正規の <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ステートメントの前になければなりません。それと言うのもこのようなステートメントは、Pythonのバイトコードコンパイラがコードを解析し、バイトコードを生成する方法に影響しますので、生成されるバイトコードとなるステートメントの前になくてはならないのです。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-27"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> - バック・トゥ・ザ・ <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a></dt>
<dd><p class="first last">Tim Peter著、Jeremy Hylton主実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-207-rich-comparisons">
<h2>PEP 207: 拡張比較<a class="headerlink" href="#pep-207-rich-comparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以前のバージョンでは、ユーザ定義クラスや拡張型の比較を実装するための Python のサポートはとても単純なものでした。クラスは 2 つのインスタンスを与えられる <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> メソッドを実装でき、実際の値がどうあれ、同値の場合には 0 、そうでないなら +1 か -1 を返せるだけでした; メソッドは例外を上げることも、ブール値以外のものを返すこともできませんでした。Numeric Python が使われるような複雑な計算プログラムでは、要素ごとに与えられた比較結果を含む行列を返し、2 つの行列を要素単位で比較できることがより便利なので、Numeric Python のユーザはこのモデルがとても脆弱で限定的であることにしばしば気付きました。もし 2 つの行列サイズが異なる場合、この比較はエラー通知の例外を上げられなければなりません。</p>
<p>Python2.1で、このニーズを満たすために拡張比較が追加されました。Pythonのクラスは、<code class="docutils literal"><span class="pre">&lt;</span></code>、<code class="docutils literal"><span class="pre">&lt;=</span></code>、<code class="docutils literal"><span class="pre">&gt;</span></code>、<code class="docutils literal"><span class="pre">&gt;=</span></code>、<code class="docutils literal"><span class="pre">==</span></code>、<code class="docutils literal"><span class="pre">!=</span></code> の各演算を個別にオーバーロードできます。この新しい特殊メソッドの名前は:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">演算</p>
</th>
<th class="head"><p class="first last">メソッド名</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;=</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&gt;=</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">==</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">!=</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a></td>
</tr>
</tbody>
</table>
<p>(特殊メソッドはFortranの <code class="docutils literal"><span class="pre">.LT.</span></code> や <code class="docutils literal"><span class="pre">.LE.</span></code> 等々の演算子にちなんで命名されています。プログラマはほぼ確実にこれらの名前を熟知していますので、覚えやすいでしょう。)</p>
<p>これらの特殊メソッドは <code class="docutils literal"><span class="pre">method(self,</span> <span class="pre">other)</span></code> の形式になっており、<code class="docutils literal"><span class="pre">self</span></code> が演算子の左辺、<code class="docutils literal"><span class="pre">other</span></code> が右辺のオブジェクトになります。例えば、式 <code class="docutils literal"><span class="pre">A</span> <span class="pre">&lt;</span> <span class="pre">B</span></code> は <code class="docutils literal"><span class="pre">A.__lt__(B)</span></code> を呼び出します。</p>
<p>これらの特殊メソッドは何でも、つまり真偽値や行列、リストや他のPython オブジェクトを返せます。もし比較が不可能であったり、矛盾していたり、意味がない場合は、代わりに例外を上げることができます。</p>
<p>ビルトインの <code class="xref py py-func docutils literal"><span class="pre">cmp(A,B)()</span></code> 関数は拡張比較機構を利用出来、使用する比較演算を指定する省略可能引数を受け付けるようになっています。指定には文字列 <code class="docutils literal"><span class="pre">&quot;&lt;&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;&lt;=&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;&gt;&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;&gt;=&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;==&quot;</span></code>, or <code class="docutils literal"><span class="pre">&quot;!=&quot;</span></code> のいずれか一つを渡します。省略可能のその 3 番目引数が省略されて呼ばれれば、 <code class="xref py py-func docutils literal"><span class="pre">cmp()</span></code> は以前のバージョンの Python のように -1, 0, または +1 だけを返します; 指定されれば、それはその適切なメソッドを呼び出し、任意の Python オブジェクトを返せます。(訳注: 2015年の今となって、ここに書かれている cmp の仕様が実在したのか不明な状態になっている。ビルトインの cmp リファレンスにはこれに関係する履歴は書かれていない。What&#8217;s New を 2.7 まで追いかけても以後変更された記録はない。)</p>
<p>C プログラマにとって興味深い関連する変更があります。型オブジェクトに新しい <code class="docutils literal"><span class="pre">tp_richcmp</span></code> スロットと、この拡張された比較を行うAPIが追加されました。ここではC APIについて言及しませんが、あながた関連する関数のリストを見たければ、PEP 207かバージョン2.1のC APIドキュメントを参照してください。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-28"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0207"><strong>PEP 207</strong></a>: 拡張比較</dt>
<dd><p class="first last">David Ascher によるかつての仕事に大きく拠りますが  Guido van Rossum によって著され、実装されました。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-230-warning-framework">
<h2>PEP 230: 警告フレームワーク<a class="headerlink" href="#pep-230-warning-framework" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>10 年の間に、Python は途中で廃止されたモジュールと機能の特定の番号を蓄積してきました。どれだけのコードが活用されているか知る術はないので、機能を削除して問題ないか把握することは困難です。その機能に依存するプログラムは一つもないかもしれませんし、たくさんあるかもしれません。より構造化された方法で古い機能を削除できるようにするために、警告のフレームワークが追加されました。Python の開発者がある機能を取り除きたいときは、まずは Python の次のバージョンで警告を引き起こします。続く Python バージョンで開発者はその機能を削除出来、ユーザは古い機能の使用を取り除くために Python リリースサイクル一つ丸々使えます。</p>
<p>Python 2.1 はこのスキームで使われる警告フレームワークを追加します。また、警告の表示機能や表示させたくない警告を除外する機能を提供する、 <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> モジュールを追加します。サードパーティーのモジュールはまた、彼らがサポート対象外にしたい古い機能を非推奨と知らしめるのにこのフレームワークを利用できます。</p>
<p>例えば、Python2.1では <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code> モジュールは廃止されたので、これをインポートすると警告が表示されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regex</span>
<span class="go">__main__:1: DeprecationWarning: the regex module</span>
<span class="go">         is deprecated; please use the re module</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>警告は <a class="reference internal" href="../library/warnings.html#warnings.warn" title="warnings.warn"><code class="xref py py-func docutils literal"><span class="pre">warnings.warn()</span></code></a> 関数を呼び出すことで発行できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;feature X no longer supported&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>最初のパラメータは警告メッセージです。任意追加のパラメータは、特定の警告カテゴリを指定するために利用することができます。</p>
<p>特定の警告を無効にするためにフィルターを追加できます。また警告を抑止するためにメッセージまたはモジュール名に正規表現が適用できます。例えば <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code> モジュールを使ったプログラムで、今すぐには <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールに変換する時間をかけられないプログラムがあるとします。警告は以下呼び出しにより抑制できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                        <span class="n">message</span><span class="o">=</span><span class="s1">&#39;.*regex module is deprecated&#39;</span><span class="p">,</span>
                        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                        <span class="n">module</span> <span class="o">=</span> <span class="s1">&#39;__main__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a> モジュール内で引き起こされた <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-class docutils literal"><span class="pre">DeprecationWarning</span></code></a> 警告だけに適用され、 <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code> モジュールが非推奨となったことについてのメッセージにマッチする正規表現を適用するフィルタを追加し、そして結果としてそのような警告は無視されることになります。警告を一回きりの表示にしたり、違反コードが実行されるたびに表示したり、警告ではなく例外に切り替えてプログラム停止することも出来ます(例外が普通の方法で捕捉されない限り、です、もちろん)。</p>
<p>関数は、警告を発行するための Python の C API にも追加されました。詳細については PEP 230 または Python の API ドキュメントを参照してください。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-29"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0005"><strong>PEP 5</strong></a> - 言語の進化のためのガイドライン</dt>
<dd><p class="first last">Python から古い機能を削除する時に従うべき手順を示すため、 Paul Prescod により書かれました。当 PEP に記載された方針は正式に採用されていませんが、最終的な方針も Prescod の提案とおそらくさほど違いはないでしょう。</p>
</dd>
<dt><span class="target" id="index-30"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0230"><strong>PEP 230</strong></a> - 警告フレームワーク</dt>
<dd><p class="first last">Guido van Rossum 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-229-new-build-system">
<h2>PEP 229: 新しいビルドシステム<a class="headerlink" href="#pep-229-new-build-system" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のコンパイル時、ユーザはソースツリーの中に入って、様々な追加モジュールを有効にするために <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> ファイルを編集しなければなりませんでした; デフォルトのセットは比較的小さくて、ほとんどの Unix プラットフォームで、コンパイルするモジュールを制限しています。これは、特に Linux に顕著ですが、たくさんの追加機能を持った Unix プラットフォームでは、Python インストレーションはしばしば、そう出来るのに有用なモジュールを全く含まない、といったことが起こることを意味しています。</p>
<p>Python 2.0 は、配布と拡張のインストールをするためのモジュールのセットである Distutils を追加しました。Python 2.1 では Distutils を、たくさんの拡張モジュールの標準ライブラリを、サポートする機器かどうかを自動検出してコンパイルするのに使っています。これが Python インストレーションをより簡単に、より機能的とするものであることが期待されています。</p>
<p>モジュールを有効化するために <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> を編集する必要性の代わりに、Python ソースツリーのトップレベルディレクトリにある <code class="file docutils literal"><span class="pre">setup.py</span></code> スクリプトがビルド時に実行され、システムのモジュールとヘッダファイルを調べることによって、どのモジュールが有効に出来るのかを検出しようと試みます。モジュールが <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> 内でそう構成されていれば、 <code class="file docutils literal"><span class="pre">setup.py</span></code> スクリプトはそのモジュールをコンパイルしようとはせずに <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> ファイル内容に従います。これは特定のプラットフォームで必要となるヘンチクリンなコマンドラインフラグやライブラリフラグを特定する手段も与えてくれます。</p>
<p>もう一つの大きなビルド機構の変更点は Neil Schemenauer による再構成で、今や Python は、トップディレクトリと <code class="file docutils literal"><span class="pre">Python/</span></code>, <code class="file docutils literal"><span class="pre">Parser/</span></code>, <code class="file docutils literal"><span class="pre">Objects/</span></code>, <code class="file docutils literal"><span class="pre">Modules/</span></code> サブディレクトリにあった別々の Makefile が再帰的にビルドする代わりに、再帰をしないトップレベルの単一 makefile を使うようになっています。このことで Python のビルドは速くなり、 Makefile をもてあそぶのが単純明快になっています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-31"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0229"><strong>PEP 229</strong></a> - Distutils を使った Python のビルド</dt>
<dd><p class="first last">A.M. Kuchling 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-205-weak-references">
<h2>PEP 205: 弱参照<a class="headerlink" href="#pep-205-weak-references" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールを通して利用出来る弱参照(weak references)は、ささやかですが有用な、Python プログラマの道具箱に新たに加わったデータ型です。</p>
<p>オブジェクトへの参照(辞書内やリスト内を思い浮かべてください)を記憶しておくということは、オブジェクトを生き永らえさせるという副作用を持っています。少しばかりの、この振る舞いが望ましくない特殊なケースがあります。オブジェクトのキャッシュがその最もありがちな一つで、もう一つはツリーのようなデータ構造での循環参照です。</p>
<p>例えば、 ひとさまの関数 <code class="docutils literal"><span class="pre">f(x)</span></code> の結果をキャッシュしておくメモ化関数を考えてみましょう。関数 <code class="docutils literal"><span class="pre">f(x)</span></code> の引数ごとに辞書に記憶します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Cache the returned object</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p>This version works for simple things such as integers, but it has a side effect;
the <code class="docutils literal"><span class="pre">_cache</span></code> dictionary holds a reference to the return values, so they&#8217;ll
never be deallocated until the Python process exits and cleans up. This isn&#8217;t
very noticeable for integers, but if <code class="xref py py-func docutils literal"><span class="pre">f()</span></code> returns an object, or a data
structure that takes up a lot of memory, this can be a problem.</p>
<p>弱参照は、オブジェクトをその時間を超えて生き永らえさせたくないキャッシュの実装のための手段を提供します。オブジェクトがアクセス出来るのが弱参照からのみである場合、そのオブジェクトは解放されて、その弱参照は参照しているそのオブジェクトがもはや存在しないことを表明します。オブジェクト <em>obj</em> への弱参照を作るには、 <code class="docutils literal"><span class="pre">wr</span> <span class="pre">=</span> <span class="pre">weakref.ref(obj)</span></code> とします。参照されているオブジェクトは、それがあたかも関数であったかのように弱参照を「コール」することで得ます: <code class="docutils literal"><span class="pre">wr()</span></code> 。それは参照されたオブジェクトを返すか、もう存在していないのであれば <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>これでオブジェクトを生き残らせないキャッシュを使う <code class="xref py py-func docutils literal"><span class="pre">memoize()</span></code> を、キャッシュ内に弱参照を記憶するというやり方で書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]()</span>
        <span class="c1"># If weak reference object still exists,</span>
        <span class="c1"># return it</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">obj</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Cache a weak reference</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールでは、弱参照のように振舞うプロキシオブジェクトも作れます &#8212; プロキシオブジェクトによってのみ参照されるオブジェクトが解放されます &#8211; オブジェクトを取り出すために明示的に「呼び出す」必要をなくすためにプロキシは、全てのオブジェクトへの操作を、オブジェクトが生きている限り透過的に転送します。オブジェクトが解放された場合、プロキシを使おうとすると <a class="reference internal" href="../library/weakref.html#weakref.ReferenceError" title="weakref.ReferenceError"><code class="xref py py-exc docutils literal"><span class="pre">weakref.ReferenceError</span></code></a> 例外が起こります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">proxy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># Equivalent to obj.attr</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span> <span class="c1"># Equivalent to obj.meth()</span>
<span class="k">del</span> <span class="n">obj</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c1"># raises weakref.ReferenceError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-32"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0205"><strong>PEP 205</strong></a> - 弱参照</dt>
<dd><p class="first last">Fred L. Drake, Jr. 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-232-function-attributes">
<h2>PEP 232: 関数の属性<a class="headerlink" href="#pep-232-function-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.1 では、関数に任意の情報をアタッチさせる(付随させる)ことが出来るようになりました。人々はしばしば関数やメソッドについての情報を保持するのに docstring を使ってきました。というのも <code class="docutils literal"><span class="pre">__doc__</span></code> だけが唯一関数に任意の情報をアタッチ出来る方法だったからです。例えば、Zope ウェブアプリケーションでは、関数は docstring に情報を持つことによって公開アクセスのために安全かどうかマークされ、John Aycock の SPARK 解析フレームワークでは docstring は BNF 文法記述の部分を、解析のために保持していました。この「詰め込み」は嘆かわしいことです。docstring はまったくもって関数のドキュメンテーションを保持するのに意図されたものです。例えば Zope では自分のために行儀よく関数にドキュメント付け出来ないということです。</p>
<p>ついに関数に、任意の属性をセットし、取り出すことが出来るようになりました。普通の Python 構文で出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span> <span class="k">pass</span>

<span class="n">f</span><span class="o">.</span><span class="n">publish</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">secure</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="s2">&quot;A ::= B (C D)*&quot;</span>
</pre></div>
</div>
<p>属性を含んだ辞書に、関数の属性 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> としてアクセス出来ます。クラスインスタンスの <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 属性とは違って、関数では実際には、 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> に別の辞書を代入出来ます。ですが、新しい値は普通の Python 辞書に制限されています; ズルは <em>出来ません</em> し、 <code class="xref py py-class docutils literal"><span class="pre">UserDict</span></code> インスタンスやなにかほかのマッピングのように振舞うデタラメなオブジェクトはセット出来ません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-33"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0232"><strong>PEP 232</strong></a> - 関数の属性</dt>
<dd><p class="first last">Barry Warsaw 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-235-importing-modules-on-case-insensitive-platforms">
<h2>PEP 235: 大文字小文字を区別しないプラットフォームでのモジュールの読み込み<a class="headerlink" href="#pep-235-importing-modules-on-case-insensitive-platforms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかのオペレーティングシステムは、大小文字区別に無関心なファイルシステムを持っています。MacOS と Windows がその代表例です。それらシステムにおいてはファイル名 <code class="docutils literal"><span class="pre">FILE.PY</span></code> と <code class="docutils literal"><span class="pre">file.py</span></code> の区別が出来ません。たとえそれが元のファイル名を尊重して格納出来たとしてもです(それらは大小文字維持、でもあります)。</p>
<p>Python 2.1 では <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文が、case-insensitive (大小文字に無関心)なプラットフォームで case-sensitivity (大小文字への繊細さ)をシミュレートして動作します。Python は今や、まずはデフォルトで case-sensitive なマッチによる検索をし、それで見つからなければ <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を投げます。ですから <code class="docutils literal"><span class="pre">import</span> <span class="pre">file</span></code> は <code class="docutils literal"><span class="pre">FILE.PY</span></code> をインポートしません。case-insensitive マッチングは Python インタプリタ開始前に環境変数 <span class="target" id="index-34"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONCASEOK"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONCASEOK</span></code></a> をセットすることで要求出来ます。</p>
</div>
<div class="section" id="pep-217-interactive-display-hook">
<h2>PEP 217: 対話モード用 Display Hook<a class="headerlink" href="#pep-217-interactive-display-hook" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python インタプリタを対話的に使う際には、コマンドの出力結果表示にはビルトインの <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 関数が使われます。Python 2.1 ではこの <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> の代わりに呼び出される呼び出し可能オブジェクトを、 <a class="reference internal" href="../library/sys.html#sys.displayhook" title="sys.displayhook"><code class="xref py py-func docutils literal"><span class="pre">sys.displayhook()</span></code></a> 変数にセット出来ます。たとえば特別な pretty- printing 関数をセット出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create a recursive data structure</span>
<span class="gp">... </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="c1"># Show Python&#39;s default output</span>
<span class="go">[1, 2, 3, [...]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use pprint.pprint() as the display function</span>
<span class="gp">... </span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">displayhook</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[1, 2, 3,  &lt;Recursion on list with id=135143996&gt;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-35"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0217"><strong>PEP 217</strong></a> - Display Hook の対話的な使用</dt>
<dd><p class="first last">Moshe Zadka 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-208-new-coercion-model">
<h2>PEP 208: 新しい型強制モデル<a class="headerlink" href="#pep-208-new-coercion-model" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>数値強制が C レベルでどのようになされるかについての修正は、とても大きなものでした。これは Python の C 拡張の著者にのみ影響し、数値操作をサポートする拡張型を書くのをより柔軟にするものです。</p>
<p>拡張型はその <code class="docutils literal"><span class="pre">PyTypeObject</span></code> 構造体に、新しい型強制モデルをサポートすることを示すために <code class="docutils literal"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code> フラグをセット出来るようになりました。そのような拡張型内では、数値的スロット関数は 2 つの引数が同じ型であることを仮定しなくなります。代わりに、2 つの引数が異なる型を渡せて、内部的に型変換を実行出来ます。スロット関数にそれが処理出来ない型が渡された場合は、それが失敗であることを表すために <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> シングルトン値への参照を返せます。この場合他の数値関数が試されて、おそらく操作を実行出来ます。それでも <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> を返すなら <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が送出されます。Python で書かれた数値メソッドも <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> を返せます。この場合インタプリタはメソッドが存在しないものとして振舞います。 (おそらく <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> が投げられたり、オブジェクトのほかの数値メソッドが試されます。)</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-36"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0208"><strong>PEP 208</strong></a> - 型強制モデルの手直し</dt>
<dd><p class="first last">Neil Schemenauer により著され、実装されましたが、大変多くを Marc-André Lemburg による以前の仕事に拠っています。C レベルで今では数値操作がどのように処理されるようになったかの細かい点を理解したければ、これを読んで下さい。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-241-metadata-in-python-packages">
<h2>PEP 241: Pythonソフトウェアパッケージのためのメタデータ<a class="headerlink" href="#pep-241-metadata-in-python-packages" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python ユーザからの日常的な不平は、既にある全ての Python モジュールの単一のカタログがないことです。T. Middleton の <a class="reference external" href="http://www.vex.net/parnassus/">http://www.vex.net/parnassus/</a> にある Vaults of Parnassus が Python モジュールの最小限のカタログとしてありますが、Vaults にソフトウェアを登録することはオプショナルであって、多くの人々はわざわざそれをしません。</p>
<p>この問題をどうにかするための最初の小さな一歩として、Distutils の <strong class="command">sdist</strong> コマンドを使ってパッケージ化する Python ソフトウェアに <code class="file docutils literal"><span class="pre">PKG-INFO</span></code> と名付けられたファイルを含むようにしました。これには名前、バージョン、著者 (カタログ化の用語ではメタデータ) のような情報を含んでいます。PEP 241 が <code class="file docutils literal"><span class="pre">PKG-INFO</span></code> ファイルに持てるフィールドの完全なリストを記述しています。Python 2.1 を使ったソフトウェアをパッケージ化し始めた人々によってパッケージがどんどんメタデータを含み、自動的なカタログ化システムを構築し、それを実験することが出来るようになります。その結果の経験により、おそらく本当に良いカタログを設計出来、Python 2.2 でそのサポートを構築出来るでしょう。例えば Distutils の <strong class="command">sdist</strong> コマンドと <strong class="command">bdist_*</strong> コマンド群はあなたのパッケージをカタログサーバに自動的にアップロードする <code class="docutils literal"><span class="pre">upload</span></code> オプションをサポート出来るでしょう。</p>
<p><code class="file docutils literal"><span class="pre">PKG-INFO</span></code> を含んだパッケージの作成は Python 2.1 を使っていなくても開始することが出来ます。Distutils の新しいリリースが以前のバージョンの Python ユーザ向けにも作られているからです。Distutils のバージョン 1.0.2 が、多数のバグフィックスや拡張とともに、 PEP 241 の変更を含んでいます。これは <a class="reference external" href="https://www.python.org/community/sigs/current/distutils-sig/">https://www.python.org/community/sigs/current/distutils-sig/</a> にある Distutils SIG から入手可能です。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-37"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0241"><strong>PEP 241</strong></a> - Pythonソフトウェアパッケージのためのメタデータ</dt>
<dd><p class="first last">A.M. Kuchling 著、実装</p>
</dd>
<dt><span class="target" id="index-38"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0243"><strong>PEP 243</strong></a> - レポジトリアップロードモジュールのメカニズム</dt>
<dd><p class="first last">Sean Reifschneider により著されました。このドラフト PEP は中央サーバに Python パッケージをアップロードする機構について提案しています。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="new-and-improved-modules">
<h2>新しいモジュールと改良されたモジュール<a class="headerlink" href="#new-and-improved-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<ul>
<li><p class="first">Ka-Ping Yee が 2 つの新規モジュールを寄稿しました: <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal"><span class="pre">inspect</span></code></a> モジュールは、動作中の Python コードについての情報を取得するもので、 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal"><span class="pre">pydoc</span></code></a> モジュールは docstring を対話的に HTML またはテキストに変換します。オマケとして、 <code class="file docutils literal"><span class="pre">Tools/scripts/pydoc</span></code> が自動的にインストールされるようになっていて、これは指定した Python モジュール、パッケージ、またはクラス名のドキュメントを <code class="xref py py-mod docutils literal"><span class="pre">pydoc.py</span></code> を使って出力します。例えば <code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">xml.dom</span></code> はこのような出力をします:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Python</span> <span class="n">Library</span> <span class="n">Documentation</span><span class="p">:</span> <span class="n">package</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="ow">in</span> <span class="n">xml</span>

<span class="n">NAME</span>
    <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="o">-</span> <span class="n">W3C</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="n">implementation</span> <span class="k">for</span> <span class="n">Python</span><span class="o">.</span>

<span class="n">FILE</span>
    <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python2</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">xml</span><span class="o">/</span><span class="n">dom</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">pyc</span>

<span class="n">DESCRIPTION</span>
    <span class="n">The</span> <span class="n">Python</span> <span class="n">mapping</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">documented</span> <span class="ow">in</span> <span class="n">the</span>
    <span class="n">Python</span> <span class="n">Library</span> <span class="n">Reference</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">section</span> <span class="n">on</span> <span class="n">the</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="n">package</span><span class="o">.</span>

    <span class="n">This</span> <span class="n">package</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">following</span> <span class="n">modules</span><span class="p">:</span>
      <span class="o">...</span>
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">pydoc</span></code> には TK ベースの対話的ヘルプブラウザも含まれています。 <code class="file docutils literal"><span class="pre">pydoc</span></code> はすぐに病みつきになります。お試しあれ。</p>
</li>
<li><p class="first">2 つの異なる単体テスト用モジュールが標準ライブラリに追加されました。Tim Peters によって寄稿された <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> モジュールは、docstring 内に埋め込まれた実例を実行することによるテストのフレームワークで、期待の出力と結果を比較します。Steve Purcell の手による PyUnit は JUnit に触発された単体テストフレームワークです。JUnit も Kent Beck の Smalltalk のテストフレームワーク由来です。PyUnit についてのより詳細な情報は <a class="reference external" href="http://pyunit.sourceforge.net/">http://pyunit.sourceforge.net/</a> を参照してください。</p>
</li>
<li><p class="first">新規の <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal"><span class="pre">difflib</span></code></a> モジュールは <code class="xref py py-class docutils literal"><span class="pre">SequenceMatcher</span></code> クラスを含んでおり、これは 2 つのシーケンスを比較し、一方のシーケンスから他方に変換するのに必要な変更点を計算します。例えば、このモジュールは Unix の <strong class="program">diff</strong> プログラムに似たツールを書くのに使えます。事実、サンプルプログラム <code class="file docutils literal"><span class="pre">Tools/scripts/ndiff.py</span></code> が、そのようなスクリプトをどのようにして書くかを実演しています。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/curses.panel.html#module-curses.panel" title="curses.panel: A panel stack extension that adds depth to  curses windows."><code class="xref py py-mod docutils literal"><span class="pre">curses.panel</span></code></a> はパネルライブラリへのラッパーであり、ncurses と SYSV curses の一部であり、 Thomas Gellekum により寄稿されました。パネルライブラリは深さ(depth)の追加機能を持つウィンドウを提供しています。ウィンドウは深さ順での高い方、低い方に移動出来、パネルライブラリはパネルがどこで重なるか、区域のどちらが可視かを理解します。</p>
</li>
<li><p class="first">PyXML パッケージは Python 2.0 から少しのリリースでいなくなり、Python 2.1 では <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal"><span class="pre">xml</span></code></a> パッケージの更新バージョンを含んでいます。いくつかの特筆すべき変更点には Expat 1.2 以降のバージョンのサポートがあり、Expat パーサで Python でサポートされる任意のエンコーディングのファイルを処理出来るようにし、SAX、DOM、 <code class="xref py py-mod docutils literal"><span class="pre">minidom</span></code> モジュールについての色々なバグフィックスがあります。</p>
</li>
<li><p class="first">Ka-Ping Yee は未捕捉の例外を処理するもうひとつのフックも寄稿しました。 <a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal"><span class="pre">sys.excepthook()</span></code></a> には呼び出し可能オブジェクトをセット出来ます。例外がどの <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>...<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> にも捕捉されない場合に、例外は <a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal"><span class="pre">sys.excepthook()</span></code></a> に通されて、そこで好きなことを何でも出来ます。9 回目の Python カンファレンスにおいて、Ping はこのフックを使ったアプリケーションのデモを行いました。そこでは、スタックフレームを列挙するだけでなくそれぞれのフレームでの関数の引数とローカル変数の列挙も行う拡張トレースバックの表示をしていました。</p>
</li>
<li><p class="first"><code class="xref py py-func docutils literal"><span class="pre">asctime()</span></code> や <code class="xref py py-func docutils literal"><span class="pre">localtime()</span></code> のような <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal"><span class="pre">time</span></code></a> モジュールの多くの関数が、エポックからの秒数での浮動小数点数の引数を必要とします。これら関数の最も一般的な使い方は現在時刻とともに用いるものですから、浮動小数点数引数が省略可能となりました。値が与えられなければ現在時刻が使われます。例えばログファイルのエントリは普通現在時刻を含んだ文字列が必要なものですが、Python 2.1 では、以前では長々しい <code class="docutils literal"><span class="pre">time.asctime(time.localtime(time.time()))</span></code> と書かなければならなかったものを代わりに <code class="docutils literal"><span class="pre">time.asctime()</span></code> とすることが出来ます。</p>
<p>この変更は Thomas Wouters により提案され、実装されました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">ftplib</span></code></a> モジュールがデフォルトでパッシブモードでファイルを取得するようになりました。これはパッシブモードがファイアウォール配下ではより良く動作するようだからです。この要望は Debian のバグトラッキングシステムから起こりました。ほかの Debian パッケージがファイル取得に <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">ftplib</span></code></a> を使い、ファイアウォールの元で動作しなかったのです。このことが誰かの問題になるとは思えません。Netscape のデフォルトがパッシブモードですし、苦情を言う人々も稀でした。ですがもしもパッシブモードがあなたのアプリケーションやネットワーク構成にとって不適切である場合には、FTP オブジェクトの <code class="docutils literal"><span class="pre">set_pasv(0)</span></code> を呼び出して、パッシブモードを無効にしてください。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールに、Grant Edwards により寄稿された、生のソケットへのアクセスのサポートが追加されました。</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/profile.html#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal"><span class="pre">pstats</span></code></a> モジュールに、Python プログラムの時間計測プロファイルを表示する単純な対話的統計ブラウザが含まれるようになり、これはモジュールがスクリプトとして実行された場合に呼び出されます。Eric S. Raymond によって寄稿されました。</p>
</li>
<li><p class="first">実装依存の関数ですが <code class="docutils literal"><span class="pre">sys._getframe([depth])</span></code> が、現在の呼び出しスタックより、指定したフレームオブジェクトを返すものとして追加されました。 <a class="reference internal" href="../library/sys.html#sys._getframe" title="sys._getframe"><code class="xref py py-func docutils literal"><span class="pre">sys._getframe()</span></code></a> は呼び出しスタックの一番上のフレームを返します。オプショナルな整数引数 <em>depth</em> を与えると、関数はスタックの一番上から下 <em>depth</em> ぶんの呼び出しのフレームを返します。例えば <code class="docutils literal"><span class="pre">sys._getframe(1)</span></code> は呼び出し元のフレームオブジェクトを返します。</p>
<p>この関数は CPython のみに含まれ、 Jython や .NET 実装にはありません。デバッグのためだけに用い、製品コード内にこれを書いてしまう誘惑に打ち克ってください。</p>
</li>
</ul>
</div>
<div class="section" id="other-changes-and-fixes">
<h2>その他の変更と修正<a class="headerlink" href="#other-changes-and-fixes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>短めのリリースサイクルだったため Python 2.1 では比較的少ない変更でした。CVS 変更ログの検索では 117 のパッチ適用と 136 のバグフィックスが見つかります。ともに少なく見積もっています。いくつかの注目に値する変更を紹介します:</p>
<ul>
<li><p class="first">特殊化されたオブジェクトアロケータがオプショナルで利用可能になっています。これはシステムの <code class="xref py py-func docutils literal"><span class="pre">malloc()</span></code> よりも速くて省メモリであるはずです。このアロケータは C の <code class="xref py py-func docutils literal"><span class="pre">malloc()</span></code> 関数を大きなメモリプールを得るのに使い、それより小さなメモリ要求はこれらプールで実現しています。この機能は <strong class="program">configure</strong> スクリプトに <code class="xref std std-option docutils literal"><span class="pre">--with-pymalloc</span></code> オプションを与えることで有効化出来ます。実装の詳細については <code class="file docutils literal"><span class="pre">Objects/obmalloc.c</span></code> をみてください。</p>
<p>C 拡張モジュールの作者はこのオブジェクトアロケータを有効にしてテストすべきです。というのもある種の誤ったコードが破壊されて、ランタイムにコアダンプを引き起こしうるからです。Python の C API 内には数多くのメモリアロケーション関数がありますが、これは以前は単に C ライブラリの <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> と <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> への別名であり、何かの間違いでミスマッチな関数呼び出しをしても、誤りは気付かれないものでした。今回のこのオブジェクトアロケータを有効化すると、これら関数は <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> と <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> への別名ではまったくなくて、メモリ解放に誤った関数を呼び出すとコアダンプし得ます。例えば <code class="xref py py-func docutils literal"><span class="pre">PyMem_New()</span></code> を使って獲得したメモリは <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> ではなく <code class="xref py py-func docutils literal"><span class="pre">PyMem_Del()</span></code> を使って解放する必要があります。Python に含まれるいくつかのモジュールがまさにこれに抵触し、修正の必要がありました。間違いなく多くのサードパーティモジュールが同じ問題を抱えているでしょう。</p>
<p>オブジェクトアロケータは Vladimir Marangozov により寄稿されました。</p>
</li>
<li><p class="first">The speed of line-oriented file I/O has been improved because people often
complain about its lack of speed, and because it&#8217;s often been used as a naïve
benchmark.  The <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> method of file objects has therefore been
rewritten to be much faster.  The exact amount of the speedup will vary from
platform to platform depending on how slow the C library&#8217;s <code class="xref py py-func docutils literal"><span class="pre">getc()</span></code> was, but
is around 66%, and potentially much faster on some particular operating systems.
Tim Peters did much of the benchmarking and coding for this change, motivated by
a discussion in comp.lang.python.</p>
<p>A new module and method for file objects was also added, contributed by Jeff
Epler. The new method, <code class="xref py py-meth docutils literal"><span class="pre">xreadlines()</span></code>, is similar to the existing
<code class="xref py py-func docutils literal"><span class="pre">xrange()</span></code> built-in.  <code class="xref py py-func docutils literal"><span class="pre">xreadlines()</span></code> returns an opaque sequence object
that only supports being iterated over, reading a line on every iteration but
not reading the entire file into memory as the existing <code class="xref py py-meth docutils literal"><span class="pre">readlines()</span></code> method
does. You&#8217;d use it like this:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">xreadlines</span><span class="p">():</span>
    <span class="c1"># ... do something for each line ...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>For a fuller discussion of the line I/O changes, see the python-dev summary for
January 1&#8211;15, 2001 at <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2001-January/">https://mail.python.org/pipermail/python-dev/2001-January/</a>.</p>
</li>
<li><p class="first">辞書に新しくメソッド <code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code> が追加されました。これで辞書の内容を破壊的にイテレートすることが出来ます。これは大きな辞書では速くなりえます。全てのキーまたは値を含んだリストを構築する必要がないからです。 <code class="docutils literal"><span class="pre">D.popitem()</span></code> は辞書 <code class="docutils literal"><span class="pre">D</span></code> からランダムに <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> ペアを削除して、その 2 要素タプルを返します。これは Moshe Zadka による示唆と事前のパッチののちに、Tim Peters と Guido van Rossum によりほとんどが実装されました。(&#8212;訳注: 速くなる理由の説明が、イテレータもジェネレータもなかった Python 2.1 時点での説明であることに注意してください。&#8212;)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> を使ってインポートする際にインポートされる名前を制御出来るようになりました。インポートされるべき名前のリストを含む <code class="docutils literal"><span class="pre">__all__</span></code> 属性を定義することでこれを行えます。一つのよくある不平が、 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> や <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a> のように、ほかのモジュールをモジュールがインポートする場合に、 <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> がインポートしているモジュールの名前空間内にそれらを追加することです。これをフィックスするには、 <code class="docutils literal"><span class="pre">__all__</span></code> に公開名を単に列挙します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># List public names</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Database&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>このパッチのより厳密な版が最初に示唆されて Ben Wolfson により実装されましたが、python-dev でのいくつかの議論を経てからより弱い最終版がチェックインされました。</p>
</li>
<li><p class="first">文字列に <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> を適用するとこれまでは表示出来ない文字について、8 進エスケープが使われていました。例えば改行コードは <code class="docutils literal"><span class="pre">'\012'</span></code> でした。これは Python の起源である C に追従した名残ですが、こんにちでは普段使いで 8 進エスケープが使われることは非常に少なくなりました。Ka-Ping Yee が 8 進の代わりに 16 進を使いつつ相応の文字には <code class="docutils literal"><span class="pre">\n</span></code>, <code class="docutils literal"><span class="pre">\t</span></code>, <code class="docutils literal"><span class="pre">\r</span></code> などのエスケープを使うよう示唆し、この新しい書式化を実装しました。</p>
</li>
<li><p class="first">コンパイル時点で検出される構文エラーがエラーとなったファイル名と行番号を含む例外を送出できるようになり、またこれによりコンパイラの再編成という喜ばしい副作用がありました。Jeremy Hylton により達成されました。</p>
</li>
<li><p class="first">他のモジュールをインポートする C 拡張が <code class="xref py py-func docutils literal"><span class="pre">PyImport_ImportModule()</span></code> を使うように変更されました。これによりインストールされている任意のインポートフックが使われます。これは C コードより他のモジュールをインポートする必要があるサードパーティ拡張にも推奨されます。</p>
</li>
<li><p class="first">Unicode 文字データベースのサイズが Fredrik Lundh のおかげでさらに 340K だけ小さくなりました。</p>
</li>
<li><p class="first">いくつかの新たなポートの寄与: MacOS X (by Steven Majewski), Cygwin (by Jason Tishler); RISCOS (by Dietmar Schwertberger); Unixware 7  (by Billy G. Allie).</p>
</li>
</ul>
<p>そしてよくあるマイナーなバグフィックス、マイナーなメモリリーク、ドキュメンテーション文字列の編集やほかの微調整があり、全てを列挙するには長過ぎます。もし見たいのであれば、CVS ログで完全な詳細を読んで下さい。</p>
</div>
<div class="section" id="acknowledgements">
<h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します:  Graeme Cross, David Goodger, Jay Graves, Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas Wouters.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">What&#8217;s New in Python 2.1</a><ul>
<li><a class="reference internal" href="#introduction">はじめに</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 入れ子状のスコープ</a></li>
<li><a class="reference internal" href="#pep-236-future-directives">PEP 236: __future__ 指示文</a></li>
<li><a class="reference internal" href="#pep-207-rich-comparisons">PEP 207: 拡張比較</a></li>
<li><a class="reference internal" href="#pep-230-warning-framework">PEP 230: 警告フレームワーク</a></li>
<li><a class="reference internal" href="#pep-229-new-build-system">PEP 229: 新しいビルドシステム</a></li>
<li><a class="reference internal" href="#pep-205-weak-references">PEP 205: 弱参照</a></li>
<li><a class="reference internal" href="#pep-232-function-attributes">PEP 232: 関数の属性</a></li>
<li><a class="reference internal" href="#pep-235-importing-modules-on-case-insensitive-platforms">PEP 235: 大文字小文字を区別しないプラットフォームでのモジュールの読み込み</a></li>
<li><a class="reference internal" href="#pep-217-interactive-display-hook">PEP 217: 対話モード用 Display Hook</a></li>
<li><a class="reference internal" href="#pep-208-new-coercion-model">PEP 208: 新しい型強制モデル</a></li>
<li><a class="reference internal" href="#pep-241-metadata-in-python-packages">PEP 241: Pythonソフトウェアパッケージのためのメタデータ</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新しいモジュールと改良されたモジュール</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">その他の変更と修正</a></li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="2.2.html"
                        title="前の章へ">What&#8217;s New in Python 2.2</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2.0.html"
                        title="次の章へ">What&#8217;s New in Python 2.0</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/whatsnew/2.1.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="What’s New in Python 2.0"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="What’s New in Python 2.2"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.1</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What&#8217;s New in Python</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2017, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 4月 19, 2017
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.4.9 を使って作成されました。
    </div>

  </body>
</html>