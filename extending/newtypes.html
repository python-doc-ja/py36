
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2. Defining New Types &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="3. C および C++ 拡張のビルド" href="building.html" />
    <link rel="prev" title="1. C や C++ による Python の拡張" href="extending.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/extending/newtypes.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/extending/newtypes.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="3. C および C++ 拡張のビルド"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="extending.html" title="1. C や C++ による Python の拡張"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python インタプリタの拡張と埋め込み</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="defining-new-types">
<span id="id1"></span><h1>2. Defining New Types<a class="headerlink" href="#defining-new-types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>As mentioned in the last chapter, Python allows the writer of an extension
module to define new types that can be manipulated from Python code, much like
strings and lists in core Python.</p>
<p>This is not hard; the code for all extension types follows a pattern, but there
are some details that you need to understand before you can get started.</p>
<div class="section" id="the-basics">
<span id="dnt-basics"></span><h2>2.1. The Basics<a class="headerlink" href="#the-basics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Python runtime sees all Python objects as variables of type
<a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a>, which serves as a &quot;base type&quot; for all Python objects.
<a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span></code></a> itself only contains the refcount and a pointer to the
object’s &quot;type object&quot;.  This is where the action is; the type object determines
which (C) functions get called when, for instance, an attribute gets looked
up on an object or it is multiplied by another object.  These C functions
are called &quot;type methods&quot;.</p>
<p>So, if you want to define a new object type, you need to create a new type
object.</p>
<p>This sort of thing can only be explained by example, so here’s a minimal, but
complete, module that defines a new type:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="cm">/* Type-specific fields go here. */</span>
<span class="p">}</span> <span class="n">noddy_NoddyObject</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">noddy_NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span> <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddymodule</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">noddy_NoddyType</span><span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">PyType_GenericNew</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddymodule</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that’s quite a bit to take in at once, but hopefully bits will seem familiar
from the last chapter.</p>
<p>The first bit that will be new is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
<span class="p">}</span> <span class="n">noddy_NoddyObject</span><span class="p">;</span>
</pre></div>
</div>
<p>This is what a Noddy object will contain—in this case, nothing more than what
every Python object contains—a field called <code class="docutils literal"><span class="pre">ob_base</span></code> of type
<a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span></code></a>.  <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span></code></a> in turn, contains an <code class="docutils literal"><span class="pre">ob_refcnt</span></code>
field and a pointer to a type object.  These can be accessed using the macros
<a class="reference internal" href="../c-api/structures.html#c.Py_REFCNT" title="Py_REFCNT"><code class="xref c c-macro docutils literal"><span class="pre">Py_REFCNT</span></code></a> and <a class="reference internal" href="../c-api/structures.html#c.Py_TYPE" title="Py_TYPE"><code class="xref c c-macro docutils literal"><span class="pre">Py_TYPE</span></code></a> respectively.  These are the fields
the <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal"><span class="pre">PyObject_HEAD</span></code></a> macro brings in.  The reason for the macro is to
standardize the layout and to enable special debugging fields in debug builds.</p>
<p>Note that there is no semicolon after the <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal"><span class="pre">PyObject_HEAD</span></code></a> macro;
one is included in the macro definition.  Be wary of adding one by
accident; it’s easy to do from habit, and your compiler might not complain,
but someone else’s probably will!  (On Windows, MSVC is known to call this an
error and refuse to compile the code.)</p>
<p>For contrast, let’s take a look at the corresponding definition for standard
Python floats:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">double</span> <span class="n">ob_fval</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyFloatObject</span><span class="p">;</span>
</pre></div>
</div>
<p>Moving on, we come to the crunch — the type object.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">noddy_NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span> <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_async */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now if you go and look up the definition of <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> in
<code class="file docutils literal"><span class="pre">object.h</span></code> you’ll see that it has many more fields that the definition
above.  The remaining fields will be filled with zeros by the C compiler, and
it’s common practice to not specify them explicitly unless you need them.</p>
<p>This is so important that we’re going to pick the top of it apart still
further:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This line is a bit of a wart; what we’d like to write is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>as the type of a type object is &quot;type&quot;, but this isn’t strictly conforming C and
some compilers complain.  Fortunately, this member will be filled in for us by
<a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>              <span class="cm">/* tp_name */</span>
</pre></div>
</div>
<p>The name of our type.  This will appear in the default textual representation of
our objects and in some error messages, for example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="n">noddy</span><span class="p">.</span><span class="n">new_noddy</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span><span class="o">:</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nl">TypeError</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">add</span> <span class="n">type</span> <span class="s">&quot;noddy.Noddy&quot;</span> <span class="n">to</span> <span class="n">string</span>
</pre></div>
</div>
<p>Note that the name is a dotted name that includes both the module name and the
name of the type within the module. The module in this case is <code class="xref py py-mod docutils literal"><span class="pre">noddy</span></code> and
the type is <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code>, so we set the type name to <code class="xref py py-class docutils literal"><span class="pre">noddy.Noddy</span></code>.
One side effect of using an undotted name is that the pydoc documentation tool
will not list the new type in the module documentation.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span>  <span class="cm">/* tp_basicsize */</span>
</pre></div>
</div>
<p>This is so that Python knows how much memory to allocate when you call
<a class="reference internal" href="../c-api/allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_New()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If you want your type to be subclassable from Python, and your type has the same
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> as its base type, you may have problems with multiple
inheritance.  A Python subclass of your type will have to list your type first
in its <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal"><span class="pre">__bases__</span></code></a>, or else it will not be able to call your type’s
<a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> method without getting an error.  You can avoid this problem by
ensuring that your type has a larger value for <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> than its
base type does.  Most of the time, this will be true anyway, because either your
base type will be <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>, or else you will be adding data members to
your base type, and therefore increasing its size.</p>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">,</span>                          <span class="cm">/* tp_itemsize */</span>
</pre></div>
</div>
<p>This has to do with variable length objects like lists and strings. Ignore this
for now.</p>
<p>Skipping a number of type methods that we don’t provide, we set the class flags
to <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_DEFAULT" title="Py_TPFLAGS_DEFAULT"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_DEFAULT</span></code></a>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/* tp_flags */</span>
</pre></div>
</div>
<p>All types should include this constant in their flags.  It enables all of the
members defined until at least Python 3.3.  If you need further members,
you will need to OR the corresponding flags.</p>
<p>We provide a doc string for the type in <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_doc" title="PyTypeObject.tp_doc"><code class="xref c c-member docutils literal"><span class="pre">tp_doc</span></code></a>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
</pre></div>
</div>
<p>Now we get into the type methods, the things that make your objects different
from the others.  We aren’t going to implement any of these in this version of
the module.  We’ll expand this example later to have more interesting behavior.</p>
<p>For now, all we want to be able to do is to create new <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> objects.
To enable object creation, we have to provide a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> implementation.
In this case, we can just use the default implementation provided by the API
function <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a>.  We’d like to just assign this to the
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> slot, but we can’t, for portability sake, On some platforms or
compilers, we can’t statically initialize a structure member with a function
defined in another C module, so, instead, we’ll assign the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> slot
in the module initialization function just before calling
<a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">noddy_NoddyType</span><span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">PyType_GenericNew</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>All the other type methods are <em>NULL</em>, so we’ll go over them later — that’s
for a later section!</p>
<p>Everything else in the file should be familiar, except for some code in
<code class="xref c c-func docutils literal"><span class="pre">PyInit_noddy()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>This initializes the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> type, filing in a number of members,
including <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> that we initially set to <em>NULL</em>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
</pre></div>
</div>
<p>This adds the type to the module dictionary.  This allows us to create
<code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> instances by calling the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> class:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">noddy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mynoddy</span> <span class="o">=</span> <span class="n">noddy</span><span class="p">.</span><span class="n">Noddy</span><span class="p">()</span>
</pre></div>
</div>
<p>That’s it!  All that remains is to build it; put the above code in a file called
<code class="file docutils literal"><span class="pre">noddy.c</span></code> and</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">from</span> <span class="n">distutils</span><span class="p">.</span><span class="n">core</span> <span class="n">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy.c&quot;</span><span class="p">])])</span>
</pre></div>
</div>
<p>in a file called <code class="file docutils literal"><span class="pre">setup.py</span></code>; then typing</p>
<div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python setup.py build
</pre></div>
</div>
<p>at a shell should produce a file <code class="file docutils literal"><span class="pre">noddy.so</span></code> in a subdirectory; move to
that directory and fire up Python — you should be able to <code class="docutils literal"><span class="pre">import</span> <span class="pre">noddy</span></code> and
play around with Noddy objects.</p>
<p>That wasn’t so hard, was it?</p>
<p>Of course, the current Noddy type is pretty uninteresting. It has no data and
doesn’t do anything. It can’t even be subclassed.</p>
<div class="section" id="adding-data-and-methods-to-the-basic-example">
<h3>2.1.1. Adding data and methods to the Basic example<a class="headerlink" href="#adding-data-and-methods-to-the-basic-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Let’s extend the basic example to add some data and methods.  Let’s also make
the type usable as a base class. We’ll create a new module, <code class="xref py py-mod docutils literal"><span class="pre">noddy2</span></code> that
adds these capabilities:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;structmember.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span> <span class="cm">/* first name */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>  <span class="cm">/* last name */</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span>   <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddy2module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy2&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy2module</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This version of the module has a number of changes.</p>
<p>We’ve added an extra include:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;structmember.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>This include provides declarations that we use to handle attributes, as
described a bit later.</p>
<p>The name of the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> object structure has been shortened to
<code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code>.  The type object name has been shortened to <code class="xref py py-class docutils literal"><span class="pre">NoddyType</span></code>.</p>
<p>The  <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> type now has three data attributes, <em>first</em>, <em>last</em>, and
<em>number</em>.  The <em>first</em> and <em>last</em> variables are Python strings containing first
and last names. The <em>number</em> attribute is an integer.</p>
<p>The object structure is updated accordingly:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>
</pre></div>
</div>
<p>Because we now have data to manage, we have to be more careful about object
allocation and deallocation.  At a minimum, we need a deallocation method:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which is assigned to the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> member:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/*tp_dealloc*/</span>
</pre></div>
</div>
<p>This method decrements the reference counts of the two Python attributes. We use
<a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_XDECREF()</span></code></a> here because the <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> members
could be <em>NULL</em>.  It then calls the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal"><span class="pre">tp_free</span></code></a> member of the object’s type
to free the object’s memory.  Note that the object’s type might not be
<code class="xref py py-class docutils literal"><span class="pre">NoddyType</span></code>, because the object may be an instance of a subclass.</p>
<p>We want to make sure that the first and last names are initialized to empty
strings, so we provide a new method:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and install it in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> member:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
</pre></div>
</div>
<p>The new member is responsible for creating (as opposed to initializing) objects
of the type.  It is exposed in Python as the <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> method.  See the
paper titled &quot;Unifying types and classes in Python&quot; for a detailed discussion of
the <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> method.  One reason to implement a new method is to assure
the initial values of instance variables.  In this case, we use the new method
to make sure that the initial values of the members <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> and
<code class="xref py py-attr docutils literal"><span class="pre">last</span></code> are not <em>NULL</em>. If we didn’t care whether the initial values were
<em>NULL</em>, we could have used <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a> as our new method, as we
did before.  <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a> initializes all of the instance variable
members to <em>NULL</em>.</p>
<p>The new method is a static method that is passed the type being instantiated and
any arguments passed when the type was called, and that returns the new object
created. New methods always accept positional and keyword arguments, but they
often ignore the arguments, leaving the argument handling to initializer
methods. Note that if the type supports subclassing, the type passed may not be
the type being defined.  The new method calls the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> slot to
allocate memory. We don’t fill the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> slot ourselves. Rather
<a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> fills it for us by inheriting it from our base class,
which is <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> by default.  Most types use the default allocation.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If you are creating a co-operative <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> (one that calls a base type’s
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> or <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a>), you must <em>not</em> try to determine what method
to call using method resolution order at runtime.  Always statically determine
what type you are going to call, and call its <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> directly, or via
<code class="docutils literal"><span class="pre">type-&gt;tp_base-&gt;tp_new</span></code>.  If you do not do this, Python subclasses of your
type that also inherit from other Python-defined classes may not work correctly.
(Specifically, you may not be able to create instances of such subclasses
without getting a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>.)</p>
</div>
<p>We provide an initialization function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>by filling the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> slot.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>         <span class="cm">/* tp_init */</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> slot is exposed in Python as the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> method. It
is used to initialize an object after it’s created. Unlike the new method, we
can’t guarantee that the initializer is called.  The initializer isn’t called
when unpickling objects and it can be overridden.  Our initializer accepts
arguments to provide initial values for our instance. Initializers always accept
positional and keyword arguments. Initializers should return either <code class="docutils literal"><span class="pre">0</span></code> on
success or <code class="docutils literal"><span class="pre">-1</span></code> on error.</p>
<p>Initializers can be called multiple times.  Anyone can call the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a>
method on our objects.  For this reason, we have to be extra careful when
assigning the new values.  We might be tempted, for example to assign the
<code class="xref py py-attr docutils literal"><span class="pre">first</span></code> member like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But this would be risky.  Our type doesn’t restrict the type of the
<code class="xref py py-attr docutils literal"><span class="pre">first</span></code> member, so it could be any kind of object.  It could have a
destructor that causes code to be executed that tries to access the
<code class="xref py py-attr docutils literal"><span class="pre">first</span></code> member.  To be paranoid and protect ourselves against this
possibility, we almost always reassign members before decrementing their
reference counts.  When don’t we have to do this?</p>
<ul class="simple">
<li>when we absolutely know that the reference count is greater than 1</li>
<li>when we know that deallocation of the object <a class="footnote-reference" href="#id7" id="id2">[1]</a> will not cause any calls
back into our type’s code</li>
<li>when decrementing a reference count in a <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> handler when
garbage-collections is not supported <a class="footnote-reference" href="#id8" id="id3">[2]</a></li>
</ul>
<p>We want to expose our instance variables as attributes. There are a
number of ways to do that. The simplest way is to define member definitions:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and put the definitions in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal"><span class="pre">tp_members</span></code></a> slot:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
</pre></div>
</div>
<p>Each member definition has a member name, type, offset, access flags and
documentation string. See the <a class="reference internal" href="#generic-attribute-management"><span class="std std-ref">総称的な属性を管理する</span></a> section below for
details.</p>
<p>A disadvantage of this approach is that it doesn’t provide a way to restrict the
types of objects that can be assigned to the Python attributes.  We expect the
first and last names to be strings, but any Python objects can be assigned.
Further, the attributes can be deleted, setting the C pointers to <em>NULL</em>.  Even
though we can make sure the members are initialized to non-<em>NULL</em> values, the
members can be set to <em>NULL</em> if the attributes are deleted.</p>
<p>We define a single method, <code class="xref py py-meth docutils literal"><span class="pre">name()</span></code>, that outputs the objects name as the
concatenation of the first and last names.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The method is implemented as a C function that takes a <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> (or
<code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> subclass) instance as the first argument.  Methods always take an
instance as the first argument. Methods often take positional and keyword
arguments as well, but in this case we don’t take any and don’t need to accept
a positional argument tuple or keyword argument dictionary. This method is
equivalent to the Python method:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">name</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
   <span class="k">return</span> <span class="s">&quot;%s %s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">last</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we have to check for the possibility that our <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> and
<code class="xref py py-attr docutils literal"><span class="pre">last</span></code> members are <em>NULL</em>.  This is because they can be deleted, in which
case they are set to <em>NULL</em>.  It would be better to prevent deletion of these
attributes and to restrict the attribute values to be strings.  We’ll see how to
do that in the next section.</p>
<p>Now that we’ve defined the method, we need to create an array of method
definitions:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and assign them to the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> slot:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
</pre></div>
</div>
<p>Note that we used the <a class="reference internal" href="../c-api/structures.html#METH_NOARGS" title="METH_NOARGS"><code class="xref py py-const docutils literal"><span class="pre">METH_NOARGS</span></code></a> flag to indicate that the method is
passed no arguments.</p>
<p>Finally, we’ll make our type usable as a base class.  We’ve written our methods
carefully so far so that they don’t make any assumptions about the type of the
object being created or used, so all we need to do is to add the
<a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_BASETYPE</span></code></a> to our class flag definition:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="cm">/*tp_flags*/</span>
</pre></div>
</div>
<p>We rename <code class="xref c c-func docutils literal"><span class="pre">PyInit_noddy()</span></code> to <code class="xref c c-func docutils literal"><span class="pre">PyInit_noddy2()</span></code> and update the module
name in the <a class="reference internal" href="../c-api/module.html#c.PyModuleDef" title="PyModuleDef"><code class="xref c c-type docutils literal"><span class="pre">PyModuleDef</span></code></a> struct.</p>
<p>Finally, we update our <code class="file docutils literal"><span class="pre">setup.py</span></code> file to build the new module:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">from</span> <span class="n">distutils</span><span class="p">.</span><span class="n">core</span> <span class="n">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
         <span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy.c&quot;</span><span class="p">]),</span>
         <span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy2&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy2.c&quot;</span><span class="p">]),</span>
         <span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="providing-finer-control-over-data-attributes">
<h3>2.1.2. Providing finer control over data attributes<a class="headerlink" href="#providing-finer-control-over-data-attributes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In this section, we’ll provide finer control over how the <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> and
<code class="xref py py-attr docutils literal"><span class="pre">last</span></code> attributes are set in the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> example. In the previous
version of our module, the instance variables <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">last</span></code>
could be set to non-string values or even deleted. We want to make sure that
these attributes always contain strings.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;structmember.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|SSi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_getfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_setfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the first attribute&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;The first attribute value must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_getlast</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_setlast</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the last attribute&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;The last attribute value must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyGetSetDef</span> <span class="n">Noddy_getseters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getfirst</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setfirst</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getlast</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setlast</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span>   <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="n">Noddy_getseters</span><span class="p">,</span>           <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddy3module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy3&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy3module</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To provide greater control, over the <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> attributes,
we’ll use custom getter and setter functions.  Here are the functions for
getting and setting the <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> attribute:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_getfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">Noddy_setfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the first attribute&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                    <span class="s">&quot;The first attribute value must be a str&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
  <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The getter function is passed a <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> object and a &quot;closure&quot;, which is
void pointer. In this case, the closure is ignored. (The closure supports an
advanced usage in which definition data is passed to the getter and setter. This
could, for example, be used to allow a single set of getter and setter functions
that decide the attribute to get or set based on data in the closure.)</p>
<p>The setter function is passed the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> object, the new value, and the
closure. The new value may be <em>NULL</em>, in which case the attribute is being
deleted.  In our setter, we raise an error if the attribute is deleted or if the
attribute value is not a string.</p>
<p>We create an array of <a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></code></a> structures:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyGetSetDef</span> <span class="n">Noddy_getseters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getfirst</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setfirst</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getlast</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setlast</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and register it in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code class="xref c c-member docutils literal"><span class="pre">tp_getset</span></code></a> slot:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_getseters</span><span class="p">,</span>           <span class="cm">/* tp_getset */</span>
</pre></div>
</div>
<p>to register our attribute getters and setters.</p>
<p>The last item in a <a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></code></a> structure is the closure mentioned
above. In this case, we aren’t using the closure, so we just pass <em>NULL</em>.</p>
<p>We also remove the member definitions for these attributes:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We also need to update the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> handler to only allow strings <a class="footnote-reference" href="#id9" id="id4">[3]</a> to
be passed:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|SSi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With these changes, we can assure that the <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">last</span></code>
members are never <em>NULL</em> so we can remove checks for <em>NULL</em> values in almost all
cases. This means that most of the <a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_XDECREF()</span></code></a> calls can be converted to
<a class="reference internal" href="../c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_DECREF()</span></code></a> calls. The only place we can’t change these calls is in the
deallocator, where there is the possibility that the initialization of these
members failed in the constructor.</p>
<p>We also rename the module initialization function and module name in the
initialization function, as we did before, and we add an extra definition to the
<code class="file docutils literal"><span class="pre">setup.py</span></code> file.</p>
</div>
<div class="section" id="supporting-cyclic-garbage-collection">
<h3>2.1.3. Supporting cyclic garbage collection<a class="headerlink" href="#supporting-cyclic-garbage-collection" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python has a cyclic-garbage collector that can identify unneeded objects even
when their reference counts are not zero. This can happen when objects are
involved in cycles.  For example, consider:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">del</span> <span class="n">l</span>
</pre></div>
</div>
<p>In this example, we create a list that contains itself. When we delete it, it
still has a reference from itself. Its reference count doesn’t drop to zero.
Fortunately, Python’s cyclic-garbage collector will eventually figure out that
the list is garbage and free it.</p>
<p>In the second version of the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> example, we allowed any kind of
object to be stored in the <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> or <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> attributes <a class="footnote-reference" href="#id10" id="id5">[4]</a>. This
means that <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> objects can participate in cycles:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">noddy2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">noddy2</span><span class="p">.</span><span class="n">Noddy</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">l</span>
</pre></div>
</div>
<p>This is pretty silly, but it gives us an excuse to add support for the
cyclic-garbage collector to the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> example.  To support cyclic
garbage collection, types need to fill two slots and set a class flag that
enables these slots:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;structmember.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">vret</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Noddy_clear</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span>    <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="p">(</span><span class="n">traverseproc</span><span class="p">)</span><span class="n">Noddy_traverse</span><span class="p">,</span>   <span class="cm">/* tp_traverse */</span>
    <span class="p">(</span><span class="n">inquiry</span><span class="p">)</span><span class="n">Noddy_clear</span><span class="p">,</span>           <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddy4module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy4&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy4module</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The traversal method provides access to subobjects that could participate in
cycles:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">vret</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For each subobject that can participate in cycles, we need to call the
<code class="xref c c-func docutils literal"><span class="pre">visit()</span></code> function, which is passed to the traversal method. The
<code class="xref c c-func docutils literal"><span class="pre">visit()</span></code> function takes as arguments the subobject and the extra argument
<em>arg</em> passed to the traversal method.  It returns an integer value that must be
returned if it is non-zero.</p>
<p>Python provides a <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> macro that automates calling visit
functions.  With <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a>, <code class="xref c c-func docutils literal"><span class="pre">Noddy_traverse()</span></code> can be simplified:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Note that the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> implementation must name its arguments exactly
<em>visit</em> and <em>arg</em> in order to use <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a>.  This is to encourage
uniformity across these boring implementations.</p>
</div>
<p>We also need to provide a method for clearing any subobjects that can
participate in cycles.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice the use of a temporary variable in <code class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></code>. We use the
temporary variable so that we can set each member to <em>NULL</em> before decrementing
its reference count.  We do this because, as was discussed earlier, if the
reference count drops to zero, we might cause code to run that calls back into
the object.  In addition, because we now support garbage collection, we also
have to worry about code being run that triggers garbage collection.  If garbage
collection is run, our <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler could get called. We can’t
take a chance of having <code class="xref c c-func docutils literal"><span class="pre">Noddy_traverse()</span></code> called when a member’s reference
count has dropped to zero and its value hasn’t been set to <em>NULL</em>.</p>
<p>Python provides a <a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></code></a> that automates the careful decrementing of
reference counts.  With <a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></code></a>, the <code class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></code> function can
be simplified:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that <code class="xref c c-func docutils literal"><span class="pre">Noddy_dealloc()</span></code> may call arbitrary functions through
<code class="docutils literal"><span class="pre">__del__</span></code> method or weakref callback. It means circular GC can be
triggered inside the function.  Since GC assumes reference count is not zero,
we need to untrack the object from GC by calling <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_UnTrack()</span></code></a>
before clearing members. Here is reimplemented deallocator which uses
<a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_UnTrack()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></code>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Noddy_clear</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we add the <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag to the class flags:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span> <span class="cm">/* tp_flags */</span>
</pre></div>
</div>
<p>That’s pretty much it.  If we had written custom <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> or
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal"><span class="pre">tp_free</span></code></a> slots, we’d need to modify them for cyclic-garbage collection.
Most extensions will use the versions automatically provided.</p>
</div>
<div class="section" id="subclassing-other-types">
<h3>2.1.4. Subclassing other types<a class="headerlink" href="#subclassing-other-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>It is possible to create new extension types that are derived from existing
types. It is easiest to inherit from the built in types, since an extension can
easily use the <code class="xref py py-class docutils literal"><span class="pre">PyTypeObject</span></code> it needs. It can be difficult to share
these <code class="xref py py-class docutils literal"><span class="pre">PyTypeObject</span></code> structures between extension modules.</p>
<p>In this example we will create a <code class="xref py py-class docutils literal"><span class="pre">Shoddy</span></code> type that inherits from the
built-in <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> type. The new type will be completely compatible with
regular lists, but will have an additional <code class="xref py py-meth docutils literal"><span class="pre">increment()</span></code> method that
increases an internal counter.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">shoddy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">shoddy</span><span class="p">.</span><span class="n">Shoddy</span><span class="p">(</span><span class="n">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">increment</span><span class="p">())</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">increment</span><span class="p">())</span>
<span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyListObject</span> <span class="n">list</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Shoddy</span><span class="p">;</span>


<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Shoddy_increment</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Shoddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;increment&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Shoddy_increment</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;increment state counter&quot;</span><span class="p">)},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Shoddy_init</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyList_Type</span><span class="p">.</span><span class="n">tp_init</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">ShoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;shoddy.Shoddy&quot;</span><span class="p">,</span>         <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Shoddy</span><span class="p">),</span>          <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="cm">/* tp_flags */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_iternext */</span>
    <span class="n">Shoddy_methods</span><span class="p">,</span>          <span class="cm">/* tp_methods */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Shoddy_init</span><span class="p">,</span>   <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_alloc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">shoddymodule</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;shoddy&quot;</span><span class="p">,</span>
    <span class="s">&quot;Shoddy module&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_shoddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

    <span class="n">ShoddyType</span><span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shoddymodule</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Shoddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, the source code closely resembles the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> examples in
previous sections. We will break down the main differences between them.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyListObject</span> <span class="n">list</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Shoddy</span><span class="p">;</span>
</pre></div>
</div>
<p>The primary difference for derived type objects is that the base type’s object
structure must be the first value. The base type will already include the
<a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-func docutils literal"><span class="pre">PyObject_HEAD()</span></code></a> at the beginning of its structure.</p>
<p>When a Python object is a <code class="xref py py-class docutils literal"><span class="pre">Shoddy</span></code> instance, its <em>PyObject*</em> pointer can
be safely cast to both <em>PyListObject*</em> and <em>Shoddy*</em>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Shoddy_init</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyList_Type</span><span class="p">.</span><span class="n">tp_init</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
       <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the <code class="xref py py-attr docutils literal"><span class="pre">__init__</span></code> method for our type, we can see how to call through to
the <code class="xref py py-attr docutils literal"><span class="pre">__init__</span></code> method of the base type.</p>
<p>This pattern is important when writing a type with custom <code class="xref py py-attr docutils literal"><span class="pre">new</span></code> and
<code class="xref py py-attr docutils literal"><span class="pre">dealloc</span></code> methods. The <code class="xref py py-attr docutils literal"><span class="pre">new</span></code> method should not actually create the
memory for the object with <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a>, that will be handled by the base
class when calling its <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a>.</p>
<p>When filling out the <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-func docutils literal"><span class="pre">PyTypeObject()</span></code></a> for the <code class="xref py py-class docutils literal"><span class="pre">Shoddy</span></code> type, you see
a slot for <code class="xref c c-func docutils literal"><span class="pre">tp_base()</span></code>. Due to cross platform compiler issues, you can’t
fill that field directly with the <a class="reference internal" href="../c-api/list.html#c.PyList_Type" title="PyList_Type"><code class="xref c c-func docutils literal"><span class="pre">PyList_Type()</span></code></a>; it can be done later in
the module’s <code class="xref c c-func docutils literal"><span class="pre">init()</span></code> function.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_shoddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

    <span class="n">ShoddyType</span><span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shoddymodule</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Shoddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Before calling <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a>, the type structure must have the
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal"><span class="pre">tp_base</span></code></a> slot filled in. When we are deriving a new type, it is not
necessary to fill out the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> slot with <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a>
– the allocate function from the base type will be inherited.</p>
<p>After that, calling <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> and adding the type object to the
module is the same as with the basic <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> examples.</p>
</div>
</div>
<div class="section" id="type-methods">
<span id="dnt-type-methods"></span><h2>2.2. Type Methods<a class="headerlink" href="#type-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節ではさまざまな実装可能なタイプメソッドと、それらが何をするものであるかについて、ざっと説明します。</p>
<p>以下は <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> の定義です。デバッグビルドでしか使われないいくつかのメンバは省いてあります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>

    <span class="cm">/* Methods to implement standard operations */</span>

    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
    <span class="n">getattrfunc</span> <span class="n">tp_getattr</span><span class="p">;</span>
    <span class="n">setattrfunc</span> <span class="n">tp_setattr</span><span class="p">;</span>
    <span class="n">PyAsyncMethods</span> <span class="o">*</span><span class="n">tp_as_async</span><span class="p">;</span> <span class="cm">/* formerly known as tp_compare (Python 2)</span>
<span class="cm">                                    or tp_reserved (Python 3) */</span>
    <span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>

    <span class="cm">/* Method suites for standard classes */</span>

    <span class="n">PyNumberMethods</span> <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
    <span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
    <span class="n">PyMappingMethods</span> <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

    <span class="cm">/* More standard operations (here for binary compatibility) */</span>

    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
    <span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>
    <span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>

    <span class="cm">/* Functions to access object as input/output buffer */</span>
    <span class="n">PyBufferProcs</span> <span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

    <span class="cm">/* Flags to define presence of optional/expanded features */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tp_flags</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span> <span class="cm">/* Documentation string */</span>

    <span class="cm">/* call function for all accessible objects */</span>
    <span class="n">traverseproc</span> <span class="n">tp_traverse</span><span class="p">;</span>

    <span class="cm">/* delete references to contained objects */</span>
    <span class="n">inquiry</span> <span class="n">tp_clear</span><span class="p">;</span>

    <span class="cm">/* rich comparisons */</span>
    <span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>

    <span class="cm">/* weak reference enabler */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_weaklistoffset</span><span class="p">;</span>

    <span class="cm">/* Iterators */</span>
    <span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
    <span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>

    <span class="cm">/* Attribute descriptor and subclassing stuff */</span>
    <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">tp_descr_get</span><span class="p">;</span>
    <span class="n">descrsetfunc</span> <span class="n">tp_descr_set</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_dictoffset</span><span class="p">;</span>
    <span class="n">initproc</span> <span class="n">tp_init</span><span class="p">;</span>
    <span class="n">allocfunc</span> <span class="n">tp_alloc</span><span class="p">;</span>
    <span class="n">newfunc</span> <span class="n">tp_new</span><span class="p">;</span>
    <span class="n">freefunc</span> <span class="n">tp_free</span><span class="p">;</span> <span class="cm">/* Low-level free-memory routine */</span>
    <span class="n">inquiry</span> <span class="n">tp_is_gc</span><span class="p">;</span> <span class="cm">/* For PyObject_IS_GC */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span> <span class="cm">/* method resolution order */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>
    <span class="n">destructor</span> <span class="n">tp_del</span><span class="p">;</span>

    <span class="cm">/* Type attribute cache version tag. Added in version 2.6 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tp_version_tag</span><span class="p">;</span>

    <span class="n">destructor</span> <span class="n">tp_finalize</span><span class="p">;</span>

<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
<p>Now that’s a <em>lot</em> of methods.  Don’t worry too much though - if you have a type
you want to define, the chances are very good that you will only implement a
handful of these.</p>
<p>As you probably expect by now, we’re going to go over this and give more
information about the various handlers.  We won’t go in the order they are
defined in the structure, because there is a lot of historical baggage that
impacts the ordering of the fields; be sure your type initialization keeps the
fields in the right order!  It’s often easiest to find an example that includes
all the fields you need (even if they’re initialized to <code class="docutils literal"><span class="pre">0</span></code>) and then change
the values to suit your new type.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing */</span>
</pre></div>
</div>
<p>The name of the type - as mentioned in the last section, this will appear in
various places, almost entirely for diagnostic purposes. Try to choose something
that will be helpful in such a situation!</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>
</pre></div>
</div>
<p>These fields tell the runtime how much memory to allocate when new objects of
this type are created.  Python has some built-in support for variable length
structures (think: strings, lists) which is where the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> field
comes in.  This will be dealt with later.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span>
</pre></div>
</div>
<p>ここには Python スクリプトリファレンス <code class="docutils literal"><span class="pre">obj.__doc__</span></code> が doc string を返すときの文字列 (あるいはそのアドレス) を入れます。</p>
<p>Now we come to the basic type methods—the ones most extension types will
implement.</p>
<div class="section" id="finalization-and-de-allocation">
<h3>2.2.1. ファイナライズとメモリ解放<a class="headerlink" href="#finalization-and-de-allocation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-c" id="index-0"><div class="highlight"><pre><span></span><span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
</pre></div>
</div>
<p>型のインスタンスの参照カウントがゼロになり、Python インタプリタがそれを潰して再利用したくなると、この関数が呼ばれます。解放すべきメモリをその型が保持していたり、それ以外にも実行すべき後処理がある場合は、それらをここに入れられます。オブジェクトそれ自体もここで解放される必要があります。この関数の例は、以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">newdatatype_dealloc</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="index-1">メモリ解放関数でひとつ重要なのは、処理待ちの例外にいっさい手をつけないことです。なぜなら、解放用の関数は Python インタプリタがスタックを元の状態に戻すときに呼ばれることが多いからです。そして (通常の関数からの復帰でなく) 例外のためにスタックが巻き戻されるときは、すでに発生している例外からメモリ解放関数を守るものはありません。解放用の関数がおこなう動作が追加の Python のコードを実行してしまうと、それらは例外が発生していることを検知するかもしれません。これはインタプリタが誤解させるエラーを発生させることにつながります。これを防ぐ正しい方法は、安全でない操作を実行する前に処理待ちの例外を保存しておき、終わったらそれを元に戻すことです。これは <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Fetch" title="PyErr_Fetch"><code class="xref c c-func docutils literal"><span class="pre">PyErr_Fetch()</span></code></a> および <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Restore" title="PyErr_Restore"><code class="xref c c-func docutils literal"><span class="pre">PyErr_Restore()</span></code></a> 関数を使うことによって可能になります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">my_dealloc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">cbresult</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">err_type</span><span class="p">,</span> <span class="o">*</span><span class="n">err_value</span><span class="p">,</span> <span class="o">*</span><span class="n">err_traceback</span><span class="p">;</span>

        <span class="cm">/* This saves the current exception state */</span>
        <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">cbresult</span> <span class="o">=</span> <span class="n">PyObject_CallObject</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cbresult</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">PyErr_WriteUnraisable</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">cbresult</span><span class="p">);</span>

        <span class="cm">/* This restores the saved exception state */</span>
        <span class="n">PyErr_Restore</span><span class="p">(</span><span class="n">err_type</span><span class="p">,</span> <span class="n">err_value</span><span class="p">,</span> <span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>メモリ解放関数の中で安全に行えることにはいくつか制限があります。
1つ目は、その型が (<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> を使って) ガベージコレクションをサポートしている場合、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> が呼び出されるまでに、消去されファイナライズされてしまうオブジェクトのメンバーが有り得ることです。
2つ目は、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> の中ではオブジェクトは不安定な状態にあることです: つまり参照カウントが0であるということです。
(上の例にあるような) 複雑なオブジェクトや API の呼び出しでは、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> を再度呼び出し、二重解放からクラッシュすることになるかもしれません。</p>
<p>Python 3.4 からは、複雑なファイナライズのコードは <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> に置かず、代わりに新しく導入された <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal"><span class="pre">tp_finalize</span></code></a> という型メソッドを使うことが推奨されています。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a> で新しいファイナライズの仕組みが説明されています。</p>
</div>
</div>
</div>
<div class="section" id="object-presentation">
<span id="index-3"></span><h3>2.2.2. オブジェクト表現<a class="headerlink" href="#object-presentation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python では、オブジェクトの文字列表現を生成するのに 2つのやり方があります: <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 関数を使う方法と、 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>  関数を使う方法です。 (<a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数は単に <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を呼び出します。) これらのハンドラはどちらも省略できます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>
<span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラは呼び出されたインスタンスの文字列表現を格納した文字列オブジェクトを返す必要があります。簡単な例は以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_repr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;Repr-ified_newdatatype{{size:\%d}}&quot;</span><span class="p">,</span>
                                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラが指定されていなければ、インタプリタはその型の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal"><span class="pre">tp_name</span></code></a> とそのオブジェクトの一意な識別値をもちいて文字列表現を作成します。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> ハンドラと <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> の関係は、上の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラと <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> の関係に相当します。つまり、これは Python のコードがオブジェクトのインスタンスに対して <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を呼び出したときに呼ばれます。この関数の実装は <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラのそれと非常に似ていますが、得られる文字列表現は人間が読むことを意図されています。 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> が指定されていない場合、かわりに <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラが使われます。</p>
<p>以下は簡単な例です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_str</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;Stringified_newdatatype{{size:\%d}}&quot;</span><span class="p">,</span>
                                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="attribute-management">
<h3>2.2.3. 属性を管理する<a class="headerlink" href="#attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>属性をもつどのオブジェクトに対しても、その型は、それらオブジェクトの属性をどのように解決するか制御する関数を提供する必要があります。必要な関数としては、属性を (それが定義されていれば) 取り出すものと、もうひとつは属性に (それが許可されていれば) 値を設定するものです。属性を削除するのは特殊なケースで、この場合は新しい値としてハンドラに <em>NULL</em> が渡されます。</p>
<p>Python は 2つの属性ハンドラの組をサポートしています。属性をもつ型はどちらか一組を実装するだけでよく、それらの違いは一方の組が属性の名前を <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> として受け取るのに対してもう一方の組は属性の名前を <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> として受け取る、というものです。それぞれの型はその実装にとって都合がよい方を使えます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">getattrfunc</span>  <span class="n">tp_getattr</span><span class="p">;</span>        <span class="cm">/* char * version */</span>
<span class="n">setattrfunc</span>  <span class="n">tp_setattr</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>       <span class="cm">/* PyObject * version */</span>
<span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>
</pre></div>
</div>
<p>オブジェクトの属性へのアクセスがつねに (すぐあとで説明する) 単純な操作だけならば、 <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> を使って属性を管理する関数として、総称的 (generic) な実装を使えます。特定の型に特化した属性ハンドラの必要性は Python 2.2 からほとんど完全になくなりました。しかし、多くの例はまだ、この新しく使えるようになった総称的なメカニズムを使うよう更新されてはいません。</p>
<div class="section" id="generic-attribute-management">
<span id="id6"></span><h4>2.2.3.1. 総称的な属性を管理する<a class="headerlink" href="#generic-attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>ほとんどの型は <em>単純な</em> 属性を使うだけです。では、どのような属性が単純だといえるのでしょうか? それが満たすべき条件はごくわずかです:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が呼ばれたとき、すでに属性の名前がわかっていること。</li>
<li>属性を参照したり設定したりするときに、特別な記録のための処理が必要でなく、また参照したり設定した値に対してどんな操作も実行する必要がないこと。</li>
</ol>
<p>これらの条件は、属性の値や、値が計算されるタイミング、または格納されたデータがどの程度妥当なものであるかといったことになんら制約を課すものではないことに注意してください。</p>
<p><a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が呼ばれると、これはそのタイプオブジェクトに参照されている 3つのテーブルを使って、そのタイプオブジェクトの辞書中にデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>) を作成します。各デスクリプタは、インスタンスオブジェクトの属性に対するアクセスを制御します。それぞれのテーブルはなくてもかまいません。もしこれら 3つがすべて <em>NULL</em> だと、その型のインスタンスはその基底型から継承した属性だけを持つことになります。また、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> および <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> が <em>NULL</em> のままだった場合も、基底型にこれらの属性の操作がまかせられます。</p>
<p>テーブルはタイプオブジェクト中の 3つのメンバとして宣言されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> が <em>NULL</em> でない場合、これは <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal"><span class="pre">PyMethodDef</span></code></a> 構造体への配列を指している必要があります。テーブル中の各エントリは、つぎのような構造体のインスタンスです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_name</span><span class="p">;</span>       <span class="cm">/* method name */</span>
    <span class="n">PyCFunction</span>  <span class="n">ml_meth</span><span class="p">;</span>       <span class="cm">/* implementation function */</span>
    <span class="kt">int</span>          <span class="n">ml_flags</span><span class="p">;</span>      <span class="cm">/* flags */</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_doc</span><span class="p">;</span>        <span class="cm">/* docstring */</span>
<span class="p">}</span> <span class="n">PyMethodDef</span><span class="p">;</span>
</pre></div>
</div>
<p>その型が提供する各メソッドについてひとつのエントリを定義する必要があります。基底型から継承してきたメソッドについてはエントリは必要ありません。これの最後には、配列の終わりを示すための見張り番 (sentinel) として追加のエントリがひとつ必要です。この場合、 <code class="xref py py-attr docutils literal"><span class="pre">ml_name</span></code> メンバが sentinel として使われ、その値は <em>NULL</em> でなければなりません。</p>
<p>2番目のテーブルは、インスタンス中に格納されるデータと直接対応づけられた属性を定義するのに使います。いくつもの C の原始的な型がサポートされており、アクセスを読み出し専用にも読み書き可能にもできます。このテーブルで使われる構造体は次のように定義されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">doc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyMemberDef</span><span class="p">;</span>
</pre></div>
</div>
<p>このテーブルの各エントリに対してデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>)が作成され、値をインスタンスの構造体から抽出しうる型に対してそれらが追加されます。 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-attr docutils literal"><span class="pre">type</span></code></a> メンバは <code class="file docutils literal"><span class="pre">structmember.h</span></code> ヘッダで定義された型のコードをひとつ含んでいる必要があります。この値は Python における値と C における値をどのように変換しあうかを定めるものです。 <code class="xref py py-attr docutils literal"><span class="pre">flags</span></code> メンバはこの属性がどのようにアクセスされるかを制御するフラグを格納するのに使われます。</p>
<p>以下のフラグ用定数は <code class="file docutils literal"><span class="pre">structmember.h</span></code> で定義されており、これらはビットごとの OR を取って組み合わせられます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">定数</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">READONLY</span></code></td>
<td>絶対に変更できない。</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">READ_RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では参照できない。</td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">WRITE_RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では変更できない。</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では参照も変更もできない。</td>
</tr>
</tbody>
</table>
<p id="index-4"><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal"><span class="pre">tp_members</span></code></a> を使ったひとつの面白い利用法は、実行時に使われるデスクリプタを作成しておき、単にテーブル中にテキストを置いておくことによって、この方法で定義されたすべての属性に doc string を関連付けられるようにすることです。アプリケーションはこのイントロスペクション用 API を使って、クラスオブジェクトからデスクリプタを取り出し、その <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> 属性を使って doc string を得られます。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> テーブルと同じように、ここでも <code class="xref py py-attr docutils literal"><span class="pre">name</span></code> メンバの値を <em>NULL</em> にした見張り用エントリが必要です。</p>
</div>
<div class="section" id="type-specific-attribute-management">
<h4>2.2.3.2. 特定の型に特化した属性の管理<a class="headerlink" href="#type-specific-attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>話を単純にするため、ここでは <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> を使ったバージョンのみを示します。name パラメータの型はインターフェイスとして <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> を使うか <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> を使うかの違いしかありません。この例では、上の総称的な例と同じことを効率的にやりますが、 Python 2.2 で追加された総称的な型のサポートを使わずにやります。これはハンドラの関数がどのようにして呼ばれるのかを説明します。これで、たとえその機能を拡張する必要があるとき、何をどうすればいいかわかるでしょう。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> ハンドラはオブジェクトが属性への参照を要求するときに呼ばれます。これは、そのクラスの <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドが呼ばれるであろう状況と同じ状況下で呼び出されます。</p>
<p>以下に例を示します。:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_getattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;data&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                 <span class="s">&quot;&#39;%.50s&#39; object has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> ハンドラは、クラスのインスタンスの <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> または <a class="reference internal" href="../reference/datamodel.html#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal"><span class="pre">__delattr__()</span></code></a> メソッドが呼ばれるであろう状況で呼び出されます。ある属性が削除されるとき、3番目のパラメータは <em>NULL</em> になります。以下の例はたんに例外を発生させるものですが、もし本当にこれと同じことをしたいなら、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> ハンドラを <em>NULL</em> に設定すべきです。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">newdatatype_setattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span> <span class="s">&quot;Read-only attribute: \%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="object-comparison">
<h3>2.2.4. オブジェクトの比較<a class="headerlink" href="#object-comparison" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> ハンドラは比較処理が要求されたときに呼び出されます。
<a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> のような <a class="reference internal" href="../reference/datamodel.html#richcmpfuncs"><span class="std std-ref">拡張比較メソッド</span></a> に類似しており、 <a class="reference internal" href="../c-api/object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal"><span class="pre">PyObject_RichCompare()</span></code></a> と <a class="reference internal" href="../c-api/object.html#c.PyObject_RichCompareBool" title="PyObject_RichCompareBool"><code class="xref c c-func docutils literal"><span class="pre">PyObject_RichCompareBool()</span></code></a> からも呼び出されます。</p>
<p>この関数は 2 つの Python オブジェクトと演算子を引数に取り、演算子は <code class="docutils literal"><span class="pre">Py_EQ</span></code>, <code class="docutils literal"><span class="pre">Py_NE</span></code>, <code class="docutils literal"><span class="pre">Py_LE</span></code>, <code class="docutils literal"><span class="pre">Py_GT</span></code>, <code class="docutils literal"><span class="pre">Py_LT</span></code>, <code class="docutils literal"><span class="pre">Py_GT</span></code> のどれか 1 つです。関数は指定された演算子に従って 2 つのオブジェクトを比較し、比較に成功した場合の <code class="docutils literal"><span class="pre">Py_True</span></code> および <code class="docutils literal"><span class="pre">Py_False</span></code> か、比較処理が実装されておらず、もう一方のオブジェクトの比較処理を試行することを示す <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> か、例外が設定された場合の <em>NULL</em> のいづれかを返します。</p>
<p>これは内部ポインタのサイズが等しければ等しいと見なすデータ型のサンプル実装です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_richcmp</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">;</span>

    <span class="cm">/* code to make sure that both arguments are of type</span>
<span class="cm">       newdatatype omitted */</span>

    <span class="n">size1</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">size2</span> <span class="o">=</span> <span class="n">obj2</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">Py_LT</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&lt;</span>  <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_LE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&lt;=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_EQ</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">==</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_NE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">!=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_GT</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&gt;</span>  <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_GE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&gt;=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">c</span> <span class="o">?</span> <span class="nl">Py_True</span> <span class="p">:</span> <span class="n">Py_False</span><span class="p">;</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="abstract-protocol-support">
<h3>2.2.5. 抽象的なプロトコルのサポート<a class="headerlink" href="#abstract-protocol-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python はいくつもの <em>抽象的な</em> “プロトコル”をサポートしています。これらを使用する特定のインターフェイスについては <a class="reference internal" href="../c-api/abstract.html#abstract"><span class="std std-ref">抽象オブジェクトレイヤ (abstract objects layer)</span></a> で解説されています。</p>
<p>これら多数の抽象的なインターフェイスは、Python の実装が開発される初期の段階で定義されていました。とりわけ数値や辞書、そしてシーケンスなどのプロトコルは最初から Python の一部だったのです。それ以外のプロトコルはその後追加されました。型の実装にあるいくつかのハンドラルーチンに依存するようなプロトコルのために、古いプロトコルはハンドラの入ったオプションのブロックとして定義し、型オブジェクトから参照するようになりました。タイプオブジェクトの主部に追加のスロットをもつ新しいプロトコルについては、フラグ用のビットを立てることでそれらのスロットが存在しており、インタプリタがチェックすべきであることを指示できます。(このフラグ用のビットは、そのスロットの値が非 <em>NULL</em> であることを示しているわけではありません。フラグはスロットの存在を示すのに使えますが、そのスロットはまだ埋まっていないかもしれないのです。)</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyNumberMethods</span>   <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
<span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
<span class="n">PyMappingMethods</span>  <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>
</pre></div>
</div>
<p>お使いのオブジェクトを数値やシーケンス、あるいは辞書のようにふるまうようにしたいならば、それぞれに C の <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></code></a> 構造体、 <a class="reference internal" href="../c-api/typeobj.html#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal"><span class="pre">PySequenceMethods</span></code></a> 構造体、または <a class="reference internal" href="../c-api/typeobj.html#c.PyMappingMethods" title="PyMappingMethods"><code class="xref c c-type docutils literal"><span class="pre">PyMappingMethods</span></code></a> 構造体のアドレスを入れます。これらに適切な値を入れても入れなくてもかまいません。これらを使った例は Python の配布ソースにある <code class="file docutils literal"><span class="pre">Objects</span></code> でみつけることができるでしょう。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
</pre></div>
</div>
<p>This function, if you choose to provide it, should return a hash number for an
instance of your data type. Here is a moderately pointless example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">long</span>
<span class="nf">newdatatype_hash</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、その型のインスタンスが「関数として呼び出される」ときに呼ばれます。たとえばもし <code class="docutils literal"><span class="pre">obj1</span></code> にそのインスタンスが入っていて、Python スクリプトで <code class="docutils literal"><span class="pre">obj1('hello')</span></code> を実行したとすると、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal"><span class="pre">tp_call</span></code></a> ハンドラが呼ばれます。</p>
<p>この関数は 3つの引数をとります:</p>
<ol class="arabic simple">
<li><em>arg1</em> is the instance of the data type which is the subject of the call. If
the call is <code class="docutils literal"><span class="pre">obj1('hello')</span></code>, then <em>arg1</em> is <code class="docutils literal"><span class="pre">obj1</span></code>.</li>
<li><em>arg2</em> is a tuple containing the arguments to the call.  You can use
<a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> to extract the arguments.</li>
<li><em>arg3</em> is a dictionary of keyword arguments that were passed. If this is
non-<em>NULL</em> and you support keyword arguments, use
<a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> to extract the arguments.  If you do not
want to support keyword arguments and this is non-<em>NULL</em>, raise a
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> with a message saying that keyword arguments are not supported.</li>
</ol>
<p>Here is a desultory example of the implementation of the call function.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Implement the call function.</span>
<span class="cm"> *    obj1 is the instance receiving the call.</span>
<span class="cm"> *    obj2 is a tuple containing the arguments to the call, in this</span>
<span class="cm"> *         case 3 strings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_call</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg2</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg3</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;sss:call&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg3</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span>
        <span class="s">&quot;Returning -- value: [\%d] arg1: [\%s] arg2: [\%s] arg3: [\%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
        <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Iterators */</span>
<span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
<span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>
</pre></div>
</div>
<p>These functions provide support for the iterator protocol.  Any object which
wishes to support iteration over its contents (which may be generated during
iteration) must implement the <code class="docutils literal"><span class="pre">tp_iter</span></code> handler.  Objects which are returned
by a <code class="docutils literal"><span class="pre">tp_iter</span></code> handler must implement both the <code class="docutils literal"><span class="pre">tp_iter</span></code> and <code class="docutils literal"><span class="pre">tp_iternext</span></code>
handlers. Both handlers take exactly one parameter, the instance for which they
are being called, and return a new reference.  In the case of an error, they
should set an exception and return <em>NULL</em>.</p>
<p>For an object which represents an iterable collection, the <code class="docutils literal"><span class="pre">tp_iter</span></code> handler
must return an iterator object.  The iterator object is responsible for
maintaining the state of the iteration.  For collections which can support
multiple iterators which do not interfere with each other (as lists and tuples
do), a new iterator should be created and returned.  Objects which can only be
iterated over once (usually due to side effects of iteration) should implement
this handler by returning a new reference to themselves, and should also
implement the <code class="docutils literal"><span class="pre">tp_iternext</span></code> handler.  File objects are an example of such an
iterator.</p>
<p>Iterator objects should implement both handlers.  The <code class="docutils literal"><span class="pre">tp_iter</span></code> handler should
return a new reference to the iterator (this is the same as the <code class="docutils literal"><span class="pre">tp_iter</span></code>
handler for objects which can only be iterated over destructively).  The
<code class="docutils literal"><span class="pre">tp_iternext</span></code> handler should return a new reference to the next object in the
iteration if there is one.  If the iteration has reached the end, it may return
<em>NULL</em> without setting an exception or it may set <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a>; avoiding
the exception can yield slightly better performance.  If an actual error occurs,
it should set an exception and return <em>NULL</em>.</p>
</div>
<div class="section" id="weak-reference-support">
<span id="weakref-support"></span><h3>2.2.6. 弱参照(Weak Reference)のサポート<a class="headerlink" href="#weak-reference-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>One of the goals of Python’s weak-reference implementation is to allow any type
to participate in the weak reference mechanism without incurring the overhead on
those objects which do not benefit by weak referencing (such as numbers).</p>
<p>For an object to be weakly referencable, the extension must include a
<a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> field in the instance structure for the use of the weak
reference mechanism; it must be initialized to <em>NULL</em> by the object’s
constructor.  It must also set the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> field of the
corresponding type object to the offset of the field. For example, the instance
type is defined with the following structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">in_class</span><span class="p">;</span>       <span class="cm">/* The class object */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_dict</span><span class="p">;</span>        <span class="cm">/* A dictionary */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">PyInstanceObject</span><span class="p">;</span>
</pre></div>
</div>
<p>The statically-declared type object for instances is defined this way:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyTypeObject</span> <span class="n">PyInstance_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="s">&quot;module.instance&quot;</span><span class="p">,</span>

    <span class="cm">/* Lots of stuff omitted for brevity... */</span>

    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>                         <span class="cm">/* tp_flags */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_richcompare */</span>
    <span class="n">offsetof</span><span class="p">(</span><span class="n">PyInstanceObject</span><span class="p">,</span> <span class="n">in_weakreflist</span><span class="p">),</span> <span class="cm">/* tp_weaklistoffset */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The type constructor is responsible for initializing the weak reference list to
<em>NULL</em>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_new</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Other initialization stuff omitted for brevity */</span>

    <span class="n">self</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The only further addition is that the destructor needs to call the weak
reference manager to clear any weak references.  This is only required if the
weak reference list is non-<em>NULL</em>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">instance_dealloc</span><span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Allocate temporaries if needed, but do not begin</span>
<span class="cm">       destruction just yet.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">PyObject_ClearWeakRefs</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">inst</span><span class="p">);</span>

    <span class="cm">/* Proceed with object destruction normally. */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="more-suggestions">
<h3>2.2.7. その他いろいろ<a class="headerlink" href="#more-suggestions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Remember that you can omit most of these functions, in which case you provide
<code class="docutils literal"><span class="pre">0</span></code> as a value.  There are type definitions for each of the functions you must
provide.  They are in <code class="file docutils literal"><span class="pre">object.h</span></code> in the Python include directory that
comes with the source distribution of Python.</p>
<p>In order to learn how to implement any specific method for your new data type,
do the following: Download and unpack the Python source distribution.  Go to
the <code class="file docutils literal"><span class="pre">Objects</span></code> directory, then search the C source files for <code class="docutils literal"><span class="pre">tp_</span></code> plus
the function you want (for example, <code class="docutils literal"><span class="pre">tp_richcompare</span></code>).  You will find examples
of the function you want to implement.</p>
<p>When you need to verify that an object is an instance of the type you are
implementing, use the <a class="reference internal" href="../c-api/object.html#c.PyObject_TypeCheck" title="PyObject_TypeCheck"><code class="xref c c-func docutils literal"><span class="pre">PyObject_TypeCheck()</span></code></a> function. A sample of its use
might be something like the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyObject_TypeCheck</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyType</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;arg #1 not a mything&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>This is true when we know that the object is a basic type, like a string or a
float.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>We relied on this in the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> handler in this example, because our
type doesn’t support garbage collection. Even if a type supports garbage
collection, there are calls that can be made to &quot;untrack&quot; the object from
garbage collection, however, these calls are advanced and not covered here.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>We now know that the first and last members are strings, so perhaps we could be
less careful about decrementing their reference counts, however, we accept
instances of string subclasses. Even though deallocating normal strings won’t
call back into our objects, we can’t guarantee that deallocating an instance of
a string subclass won’t call back into our objects.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Even in the third version, we aren’t guaranteed to avoid cycles.  Instances of
string subclasses are allowed and string subclasses could allow cycles even if
normal strings don’t.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. Defining New Types</a><ul>
<li><a class="reference internal" href="#the-basics">2.1. The Basics</a><ul>
<li><a class="reference internal" href="#adding-data-and-methods-to-the-basic-example">2.1.1. Adding data and methods to the Basic example</a></li>
<li><a class="reference internal" href="#providing-finer-control-over-data-attributes">2.1.2. Providing finer control over data attributes</a></li>
<li><a class="reference internal" href="#supporting-cyclic-garbage-collection">2.1.3. Supporting cyclic garbage collection</a></li>
<li><a class="reference internal" href="#subclassing-other-types">2.1.4. Subclassing other types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-methods">2.2. Type Methods</a><ul>
<li><a class="reference internal" href="#finalization-and-de-allocation">2.2.1. ファイナライズとメモリ解放</a></li>
<li><a class="reference internal" href="#object-presentation">2.2.2. オブジェクト表現</a></li>
<li><a class="reference internal" href="#attribute-management">2.2.3. 属性を管理する</a><ul>
<li><a class="reference internal" href="#generic-attribute-management">2.2.3.1. 総称的な属性を管理する</a></li>
<li><a class="reference internal" href="#type-specific-attribute-management">2.2.3.2. 特定の型に特化した属性の管理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#object-comparison">2.2.4. オブジェクトの比較</a></li>
<li><a class="reference internal" href="#abstract-protocol-support">2.2.5. 抽象的なプロトコルのサポート</a></li>
<li><a class="reference internal" href="#weak-reference-support">2.2.6. 弱参照(Weak Reference)のサポート</a></li>
<li><a class="reference internal" href="#more-suggestions">2.2.7. その他いろいろ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="extending.html"
                        title="前の章へ">1. C や C++ による Python の拡張</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="building.html"
                        title="次の章へ">3. C および C++ 拡張のビルド</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/extending/newtypes.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="3. C および C++ 拡張のビルド"
             >次へ</a> |</li>
        <li class="right" >
          <a href="extending.html" title="1. C や C++ による Python の拡張"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python インタプリタの拡張と埋め込み</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 4月 10, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>