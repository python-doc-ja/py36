
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3. Defining Extension Types: Assorted Topics &#8212; Python 3.6.5 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="4. C および C++ 拡張のビルド" href="building.html" />
    <link rel="prev" title="2. Defining Extension Types: Tutorial" href="newtypes_tutorial.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/extending/newtypes.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/extending/newtypes.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="4. C および C++ 拡張のビルド"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="newtypes_tutorial.html" title="2. Defining Extension Types: Tutorial"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python インタプリタの拡張と埋め込み</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="defining-extension-types-assorted-topics">
<h1>3. Defining Extension Types: Assorted Topics<a class="headerlink" href="#defining-extension-types-assorted-topics" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="dnt-type-methods">この節ではさまざまな実装可能なタイプメソッドと、それらが何をするものであるかについて、ざっと説明します。</p>
<p>以下は <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> の定義です。デバッグビルドでしか使われないいくつかのメンバは省いてあります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>

    <span class="cm">/* Methods to implement standard operations */</span>

    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
    <span class="n">getattrfunc</span> <span class="n">tp_getattr</span><span class="p">;</span>
    <span class="n">setattrfunc</span> <span class="n">tp_setattr</span><span class="p">;</span>
    <span class="n">PyAsyncMethods</span> <span class="o">*</span><span class="n">tp_as_async</span><span class="p">;</span> <span class="cm">/* formerly known as tp_compare (Python 2)</span>
<span class="cm">                                    or tp_reserved (Python 3) */</span>
    <span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>

    <span class="cm">/* Method suites for standard classes */</span>

    <span class="n">PyNumberMethods</span> <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
    <span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
    <span class="n">PyMappingMethods</span> <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

    <span class="cm">/* More standard operations (here for binary compatibility) */</span>

    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
    <span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>
    <span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>

    <span class="cm">/* Functions to access object as input/output buffer */</span>
    <span class="n">PyBufferProcs</span> <span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

    <span class="cm">/* Flags to define presence of optional/expanded features */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tp_flags</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span> <span class="cm">/* Documentation string */</span>

    <span class="cm">/* call function for all accessible objects */</span>
    <span class="n">traverseproc</span> <span class="n">tp_traverse</span><span class="p">;</span>

    <span class="cm">/* delete references to contained objects */</span>
    <span class="n">inquiry</span> <span class="n">tp_clear</span><span class="p">;</span>

    <span class="cm">/* rich comparisons */</span>
    <span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>

    <span class="cm">/* weak reference enabler */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_weaklistoffset</span><span class="p">;</span>

    <span class="cm">/* Iterators */</span>
    <span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
    <span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>

    <span class="cm">/* Attribute descriptor and subclassing stuff */</span>
    <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">tp_descr_get</span><span class="p">;</span>
    <span class="n">descrsetfunc</span> <span class="n">tp_descr_set</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_dictoffset</span><span class="p">;</span>
    <span class="n">initproc</span> <span class="n">tp_init</span><span class="p">;</span>
    <span class="n">allocfunc</span> <span class="n">tp_alloc</span><span class="p">;</span>
    <span class="n">newfunc</span> <span class="n">tp_new</span><span class="p">;</span>
    <span class="n">freefunc</span> <span class="n">tp_free</span><span class="p">;</span> <span class="cm">/* Low-level free-memory routine */</span>
    <span class="n">inquiry</span> <span class="n">tp_is_gc</span><span class="p">;</span> <span class="cm">/* For PyObject_IS_GC */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span> <span class="cm">/* method resolution order */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>
    <span class="n">destructor</span> <span class="n">tp_del</span><span class="p">;</span>

    <span class="cm">/* Type attribute cache version tag. Added in version 2.6 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tp_version_tag</span><span class="p">;</span>

    <span class="n">destructor</span> <span class="n">tp_finalize</span><span class="p">;</span>

<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
<p><em>たくさんの</em> メソッドがありますね。でもそんなに心配する必要はありません。定義したい型があるなら、実装するのはこのうちのごくわずかですむことがほとんどです。</p>
<p>すでに予想されているでしょうが、この構造体について入念に見ていき、様々なハンドラについてより詳しい情報を提供します。
しかしこれらのメンバが構造体中で定義されている順番は無視します。というのは、これらのメンバの現れる順序は歴史的な遺産によるものだからです。
多くの場合いちばん簡単なのは、必要とするメンバがすべて含まれている例をとってきて、新しく作る型に合わせて値を変更することです。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing */</span>
</pre></div>
</div>
<p>これは型の名前です。前の章で説明したように、これは色々な場面で現れ、ほとんどは診断目的で使われるものです。
それなので、そのような場面で役に立つであろう名前を選んでください!</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>
</pre></div>
</div>
<p>これらのフィールドは、この型のオブジェクトが新しく作成されるときにどれだけのメモリを割り当てればよいのかをランタイムに指示します。Python には可変長の構造体 (文字列やタプルなどを想像してください) に対する組み込みのサポートがある程度あり、ここで <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> メンバが使われます。これらについてはあとでふれます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span>
</pre></div>
</div>
<p>ここには Python スクリプトリファレンス <code class="docutils literal"><span class="pre">obj.__doc__</span></code> が doc string を返すときの文字列 (あるいはそのアドレス) を入れます。</p>
<p>では次に、型の基本的なメソッドに進みます。これはほとんどの拡張型が実装します。</p>
<div class="section" id="finalization-and-de-allocation">
<h2>3.1. ファイナライズとメモリ解放<a class="headerlink" href="#finalization-and-de-allocation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-c" id="index-0"><div class="highlight"><pre><span></span><span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
</pre></div>
</div>
<p>型のインスタンスの参照カウントがゼロになり、Python インタプリタがそれを潰して再利用したくなると、この関数が呼ばれます。解放すべきメモリをその型が保持していたり、それ以外にも実行すべき後処理がある場合は、それらをここに入れられます。オブジェクトそれ自体もここで解放される必要があります。この関数の例は、以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">newdatatype_dealloc</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="index-1">メモリ解放関数でひとつ重要なのは、処理待ちの例外にいっさい手をつけないことです。なぜなら、解放用の関数は Python インタプリタがスタックを元の状態に戻すときに呼ばれることが多いからです。そして (通常の関数からの復帰でなく) 例外のためにスタックが巻き戻されるときは、すでに発生している例外からメモリ解放関数を守るものはありません。解放用の関数がおこなう動作が追加の Python のコードを実行してしまうと、それらは例外が発生していることを検知するかもしれません。これはインタプリタが誤解させるエラーを発生させることにつながります。これを防ぐ正しい方法は、安全でない操作を実行する前に処理待ちの例外を保存しておき、終わったらそれを元に戻すことです。これは <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Fetch" title="PyErr_Fetch"><code class="xref c c-func docutils literal"><span class="pre">PyErr_Fetch()</span></code></a> および <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Restore" title="PyErr_Restore"><code class="xref c c-func docutils literal"><span class="pre">PyErr_Restore()</span></code></a> 関数を使うことによって可能になります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">my_dealloc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">cbresult</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">err_type</span><span class="p">,</span> <span class="o">*</span><span class="n">err_value</span><span class="p">,</span> <span class="o">*</span><span class="n">err_traceback</span><span class="p">;</span>

        <span class="cm">/* This saves the current exception state */</span>
        <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">cbresult</span> <span class="o">=</span> <span class="n">PyObject_CallObject</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cbresult</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">PyErr_WriteUnraisable</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">cbresult</span><span class="p">);</span>

        <span class="cm">/* This restores the saved exception state */</span>
        <span class="n">PyErr_Restore</span><span class="p">(</span><span class="n">err_type</span><span class="p">,</span> <span class="n">err_value</span><span class="p">,</span> <span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>メモリ解放関数の中で安全に行えることにはいくつか制限があります。
1つ目は、その型が (<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> を使って) ガベージコレクションをサポートしている場合、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> が呼び出されるまでに、消去されファイナライズされてしまうオブジェクトのメンバーが有り得ることです。
2つ目は、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> の中ではオブジェクトは不安定な状態にあることです: つまり参照カウントが0であるということです。
(上の例にあるような) 複雑なオブジェクトや API の呼び出しでは、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> を再度呼び出し、二重解放からクラッシュすることになるかもしれません。</p>
<p>Python 3.4 からは、複雑なファイナライズのコードは <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> に置かず、代わりに新しく導入された <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal"><span class="pre">tp_finalize</span></code></a> という型メソッドを使うことが推奨されています。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a> で新しいファイナライズの仕組みが説明されています。</p>
</div>
</div>
</div>
<div class="section" id="object-presentation">
<span id="index-3"></span><h2>3.2. オブジェクト表現<a class="headerlink" href="#object-presentation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python では、オブジェクトの文字列表現を生成するのに 2つのやり方があります: <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 関数を使う方法と、 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>  関数を使う方法です。 (<a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数は単に <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を呼び出します。) これらのハンドラはどちらも省略できます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>
<span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラは呼び出されたインスタンスの文字列表現を格納した文字列オブジェクトを返す必要があります。簡単な例は以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_repr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;Repr-ified_newdatatype{{size:%d}}&quot;</span><span class="p">,</span>
                                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラが指定されていなければ、インタプリタはその型の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal"><span class="pre">tp_name</span></code></a> とそのオブジェクトの一意な識別値をもちいて文字列表現を作成します。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> ハンドラと <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> の関係は、上の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラと <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> の関係に相当します。つまり、これは Python のコードがオブジェクトのインスタンスに対して <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を呼び出したときに呼ばれます。この関数の実装は <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラのそれと非常に似ていますが、得られる文字列表現は人間が読むことを意図されています。 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> が指定されていない場合、かわりに <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラが使われます。</p>
<p>以下は簡単な例です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_str</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;Stringified_newdatatype{{size:%d}}&quot;</span><span class="p">,</span>
                                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="attribute-management">
<h2>3.3. 属性を管理する<a class="headerlink" href="#attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>属性をもつどのオブジェクトに対しても、その型は、それらオブジェクトの属性をどのように解決するか制御する関数を提供する必要があります。必要な関数としては、属性を (それが定義されていれば) 取り出すものと、もうひとつは属性に (それが許可されていれば) 値を設定するものです。属性を削除するのは特殊なケースで、この場合は新しい値としてハンドラに <em>NULL</em> が渡されます。</p>
<p>Python は 2つの属性ハンドラの組をサポートしています。属性をもつ型はどちらか一組を実装するだけでよく、それらの違いは一方の組が属性の名前を <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> として受け取るのに対してもう一方の組は属性の名前を <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> として受け取る、というものです。それぞれの型はその実装にとって都合がよい方を使えます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">getattrfunc</span>  <span class="n">tp_getattr</span><span class="p">;</span>        <span class="cm">/* char * version */</span>
<span class="n">setattrfunc</span>  <span class="n">tp_setattr</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>       <span class="cm">/* PyObject * version */</span>
<span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>
</pre></div>
</div>
<p>オブジェクトの属性へのアクセスがつねに (すぐあとで説明する) 単純な操作だけならば、 <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> を使って属性を管理する関数として、総称的 (generic) な実装を使えます。特定の型に特化した属性ハンドラの必要性は Python 2.2 からほとんど完全になくなりました。しかし、多くの例はまだ、この新しく使えるようになった総称的なメカニズムを使うよう更新されてはいません。</p>
<div class="section" id="generic-attribute-management">
<span id="id1"></span><h3>3.3.1. 総称的な属性を管理する<a class="headerlink" href="#generic-attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ほとんどの型は <em>単純な</em> 属性を使うだけです。では、どのような属性が単純だといえるのでしょうか? それが満たすべき条件はごくわずかです:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が呼ばれたとき、すでに属性の名前がわかっていること。</li>
<li>属性を参照したり設定したりするときに、特別な記録のための処理が必要でなく、また参照したり設定した値に対してどんな操作も実行する必要がないこと。</li>
</ol>
<p>これらの条件は、属性の値や、値が計算されるタイミング、または格納されたデータがどの程度妥当なものであるかといったことになんら制約を課すものではないことに注意してください。</p>
<p><a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が呼ばれると、これはそのタイプオブジェクトに参照されている 3つのテーブルを使って、そのタイプオブジェクトの辞書中にデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>) を作成します。各デスクリプタは、インスタンスオブジェクトの属性に対するアクセスを制御します。それぞれのテーブルはなくてもかまいません。もしこれら 3つがすべて <em>NULL</em> だと、その型のインスタンスはその基底型から継承した属性だけを持つことになります。また、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> および <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> が <em>NULL</em> のままだった場合も、基底型にこれらの属性の操作がまかせられます。</p>
<p>テーブルはタイプオブジェクト中の 3つのメンバとして宣言されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> が <em>NULL</em> でない場合、これは <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal"><span class="pre">PyMethodDef</span></code></a> 構造体への配列を指している必要があります。テーブル中の各エントリは、つぎのような構造体のインスタンスです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_name</span><span class="p">;</span>       <span class="cm">/* method name */</span>
    <span class="n">PyCFunction</span>  <span class="n">ml_meth</span><span class="p">;</span>       <span class="cm">/* implementation function */</span>
    <span class="kt">int</span>          <span class="n">ml_flags</span><span class="p">;</span>      <span class="cm">/* flags */</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_doc</span><span class="p">;</span>        <span class="cm">/* docstring */</span>
<span class="p">}</span> <span class="n">PyMethodDef</span><span class="p">;</span>
</pre></div>
</div>
<p>その型が提供する各メソッドについてひとつのエントリを定義する必要があります。基底型から継承してきたメソッドについてはエントリは必要ありません。これの最後には、配列の終わりを示すための見張り番 (sentinel) として追加のエントリがひとつ必要です。この場合、 <code class="xref py py-attr docutils literal"><span class="pre">ml_name</span></code> メンバが sentinel として使われ、その値は <em>NULL</em> でなければなりません。</p>
<p>2番目のテーブルは、インスタンス中に格納されるデータと直接対応づけられた属性を定義するのに使います。いくつもの C の原始的な型がサポートされており、アクセスを読み出し専用にも読み書き可能にもできます。このテーブルで使われる構造体は次のように定義されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">doc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyMemberDef</span><span class="p">;</span>
</pre></div>
</div>
<p>このテーブルの各エントリに対してデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>)が作成され、値をインスタンスの構造体から抽出しうる型に対してそれらが追加されます。 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-attr docutils literal"><span class="pre">type</span></code></a> メンバは <code class="file docutils literal"><span class="pre">structmember.h</span></code> ヘッダで定義された型のコードをひとつ含んでいる必要があります。この値は Python における値と C における値をどのように変換しあうかを定めるものです。 <code class="xref py py-attr docutils literal"><span class="pre">flags</span></code> メンバはこの属性がどのようにアクセスされるかを制御するフラグを格納するのに使われます。</p>
<p>以下のフラグ用定数は <code class="file docutils literal"><span class="pre">structmember.h</span></code> で定義されており、これらはビットごとの OR を取って組み合わせられます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">定数</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">READONLY</span></code></td>
<td>絶対に変更できない。</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">READ_RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では参照できない。</td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">WRITE_RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では変更できない。</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では参照も変更もできない。</td>
</tr>
</tbody>
</table>
<p id="index-4"><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal"><span class="pre">tp_members</span></code></a> を使ったひとつの面白い利用法は、実行時に使われるデスクリプタを作成しておき、単にテーブル中にテキストを置いておくことによって、この方法で定義されたすべての属性に doc string を関連付けられるようにすることです。アプリケーションはこのイントロスペクション用 API を使って、クラスオブジェクトからデスクリプタを取り出し、その <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> 属性を使って doc string を得られます。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> テーブルと同じように、ここでも <code class="xref py py-attr docutils literal"><span class="pre">name</span></code> メンバの値を <em>NULL</em> にした見張り用エントリが必要です。</p>
</div>
<div class="section" id="type-specific-attribute-management">
<h3>3.3.2. 特定の型に特化した属性の管理<a class="headerlink" href="#type-specific-attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>話を単純にするため、ここでは <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> を使ったバージョンのみを示します。name パラメータの型はインターフェイスとして <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> を使うか <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> を使うかの違いしかありません。この例では、上の総称的な例と同じことを効率的にやりますが、 Python 2.2 で追加された総称的な型のサポートを使わずにやります。これはハンドラの関数がどのようにして呼ばれるのかを説明します。これで、たとえその機能を拡張する必要があるとき、何をどうすればいいかわかるでしょう。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> ハンドラはオブジェクトが属性への参照を要求するときに呼ばれます。これは、そのクラスの <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドが呼ばれるであろう状況と同じ状況下で呼び出されます。</p>
<p>以下に例を示します。:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_getattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;data&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                 <span class="s">&quot;&#39;%.50s&#39; object has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> ハンドラは、クラスのインスタンスの <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> または <a class="reference internal" href="../reference/datamodel.html#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal"><span class="pre">__delattr__()</span></code></a> メソッドが呼ばれるであろう状況で呼び出されます。ある属性が削除されるとき、3番目のパラメータは <em>NULL</em> になります。以下の例はたんに例外を発生させるものですが、もし本当にこれと同じことをしたいなら、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> ハンドラを <em>NULL</em> に設定すべきです。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">newdatatype_setattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span> <span class="s">&quot;Read-only attribute: %s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="object-comparison">
<h2>3.4. オブジェクトの比較<a class="headerlink" href="#object-comparison" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> ハンドラは比較処理が要求されたときに呼び出されます。
<a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> のような <a class="reference internal" href="../reference/datamodel.html#richcmpfuncs"><span class="std std-ref">拡張比較メソッド</span></a> に類似しており、 <a class="reference internal" href="../c-api/object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal"><span class="pre">PyObject_RichCompare()</span></code></a> と <a class="reference internal" href="../c-api/object.html#c.PyObject_RichCompareBool" title="PyObject_RichCompareBool"><code class="xref c c-func docutils literal"><span class="pre">PyObject_RichCompareBool()</span></code></a> からも呼び出されます。</p>
<p>この関数は 2 つの Python オブジェクトと演算子を引数に取り、演算子は <code class="docutils literal"><span class="pre">Py_EQ</span></code>, <code class="docutils literal"><span class="pre">Py_NE</span></code>, <code class="docutils literal"><span class="pre">Py_LE</span></code>, <code class="docutils literal"><span class="pre">Py_GT</span></code>, <code class="docutils literal"><span class="pre">Py_LT</span></code>, <code class="docutils literal"><span class="pre">Py_GT</span></code> のどれか 1 つです。関数は指定された演算子に従って 2 つのオブジェクトを比較し、比較に成功した場合の <code class="docutils literal"><span class="pre">Py_True</span></code> および <code class="docutils literal"><span class="pre">Py_False</span></code> か、比較処理が実装されておらず、もう一方のオブジェクトの比較処理を試行することを示す <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> か、例外が設定された場合の <em>NULL</em> のいづれかを返します。</p>
<p>これは内部ポインタのサイズが等しければ等しいと見なすデータ型のサンプル実装です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_richcmp</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">;</span>

    <span class="cm">/* code to make sure that both arguments are of type</span>
<span class="cm">       newdatatype omitted */</span>

    <span class="n">size1</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">size2</span> <span class="o">=</span> <span class="n">obj2</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">Py_LT</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&lt;</span>  <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_LE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&lt;=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_EQ</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">==</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_NE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">!=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_GT</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&gt;</span>  <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_GE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&gt;=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">c</span> <span class="o">?</span> <span class="nl">Py_True</span> <span class="p">:</span> <span class="n">Py_False</span><span class="p">;</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="abstract-protocol-support">
<h2>3.5. 抽象的なプロトコルのサポート<a class="headerlink" href="#abstract-protocol-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python はいくつもの <em>抽象的な</em> “プロトコル”をサポートしています。これらを使用する特定のインターフェイスについては <a class="reference internal" href="../c-api/abstract.html#abstract"><span class="std std-ref">抽象オブジェクトレイヤ (abstract objects layer)</span></a> で解説されています。</p>
<p>これら多数の抽象的なインターフェイスは、Python の実装が開発される初期の段階で定義されていました。とりわけ数値や辞書、そしてシーケンスなどのプロトコルは最初から Python の一部だったのです。それ以外のプロトコルはその後追加されました。型の実装にあるいくつかのハンドラルーチンに依存するようなプロトコルのために、古いプロトコルはハンドラの入ったオプションのブロックとして定義し、型オブジェクトから参照するようになりました。タイプオブジェクトの主部に追加のスロットをもつ新しいプロトコルについては、フラグ用のビットを立てることでそれらのスロットが存在しており、インタプリタがチェックすべきであることを指示できます。(このフラグ用のビットは、そのスロットの値が非 <em>NULL</em> であることを示しているわけではありません。フラグはスロットの存在を示すのに使えますが、そのスロットはまだ埋まっていないかもしれないのです。)</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyNumberMethods</span>   <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
<span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
<span class="n">PyMappingMethods</span>  <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>
</pre></div>
</div>
<p>お使いのオブジェクトを数値やシーケンス、あるいは辞書のようにふるまうようにしたいならば、それぞれに C の <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></code></a> 構造体、 <a class="reference internal" href="../c-api/typeobj.html#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal"><span class="pre">PySequenceMethods</span></code></a> 構造体、または <a class="reference internal" href="../c-api/typeobj.html#c.PyMappingMethods" title="PyMappingMethods"><code class="xref c c-type docutils literal"><span class="pre">PyMappingMethods</span></code></a> 構造体のアドレスを入れます。これらに適切な値を入れても入れなくてもかまいません。これらを使った例は Python の配布ソースにある <code class="file docutils literal"><span class="pre">Objects</span></code> でみつけることができるでしょう。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、もし使うことにしたならば、データ型のインスタンスのハッシュ番号を返すようにします。次のは単純な例です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">Py_hash_t</span>
<span class="nf">newdatatype_hash</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_hash_t</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">some_size</span> <span class="o">+</span> <span class="mi">32767</span> <span class="o">*</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">some_number</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
       <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref c c-type docutils literal"><span class="pre">Py_hash_t</span></code> is a signed integer type with a platform-varying width.
Returning <code class="docutils literal"><span class="pre">-1</span></code> from <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal"><span class="pre">tp_hash</span></code></a> indicates an error,
which is why you should be careful to avoid returning it when hash computation
is successful, as seen above.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、その型のインスタンスが「関数として呼び出される」ときに呼ばれます。たとえばもし <code class="docutils literal"><span class="pre">obj1</span></code> にそのインスタンスが入っていて、Python スクリプトで <code class="docutils literal"><span class="pre">obj1('hello')</span></code> を実行したとすると、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal"><span class="pre">tp_call</span></code></a> ハンドラが呼ばれます。</p>
<p>この関数は 3つの引数をとります:</p>
<ol class="arabic simple">
<li><em>self</em> は呼び出しの対象となるデータ型のインスタンスです。
たとえば呼び出しが <code class="docutils literal"><span class="pre">obj1('hello')</span></code> の場合、<em>self</em> は <code class="docutils literal"><span class="pre">obj1</span></code> になります。</li>
<li><em>args</em> は呼び出しの引数を格納しているタプルです。ここから引数を取り出すには <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> を使います。</li>
<li><em>kwds</em> はキーワード引数のための辞書です。これが <em>NULL</em> でなく、キーワード引数をサポートしている場合は、 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> をつかって引数を取り出せます。キーワード引数をサポートしていないのにこれが <em>NULL</em> でない場合は、キーワード引数はサポートしていない旨のメッセージとともに <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を発生させてください。</li>
</ol>
<p>以下は <code class="docutils literal"><span class="pre">tp_call</span></code> の簡易な実装です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_call</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg2</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg3</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;sss:call&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg3</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span>
        <span class="s">&quot;Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
        <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Iterators */</span>
<span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
<span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>
</pre></div>
</div>
<p>These functions provide support for the iterator protocol.  Both handlers
take exactly one parameter, the instance for which they are being called,
and return a new reference.  In the case of an error, they should set an
exception and return <em>NULL</em>.  <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> corresponds
to the Python <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> method, while <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a>
corresponds to the Python <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> method.</p>
<p>Any <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> object must implement the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a>
handler, which must return an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> object.  Here the same guidelines
apply as for Python classes:</p>
<ul class="simple">
<li>For collections (such as lists and tuples) which can support multiple
independent iterators, a new iterator should be created and returned by
each call to <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a>.</li>
<li>Objects which can only be iterated over once (usually due to side effects of
iteration, such as file objects) can implement <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a>
by returning a new reference to themselves – and should also therefore
implement the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a>  handler.</li>
</ul>
<p>Any <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> object should implement both <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a>
and <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a>.  An iterator’s
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> handler should return a new reference
to the iterator.  Its <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a> handler should
return a new reference to the next object in the iteration, if there is one.
If the iteration has reached the end, <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a>
may return <em>NULL</em> without setting an exception, or it may set
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> <em>in addition</em> to returning <em>NULL</em>; avoiding
the exception can yield slightly better performance.  If an actual error
occurs, <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a> should always set an exception
and return <em>NULL</em>.</p>
</div>
<div class="section" id="weak-reference-support">
<span id="weakref-support"></span><h2>3.6. 弱参照(Weak Reference)のサポート<a class="headerlink" href="#weak-reference-support" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>One of the goals of Python’s weak reference implementation is to allow any type
to participate in the weak reference mechanism without incurring the overhead on
performance-critical objects (such as numbers).</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">Documentation for the <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> module.</p>
</div>
<p>For an object to be weakly referencable, the extension type must do two things:</p>
<ol class="arabic simple">
<li>Include a <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> field in the C object structure dedicated to
the weak reference mechanism.  The object’s constructor should leave it
<em>NULL</em> (which is automatic when using the default
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a>).</li>
<li>Set the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> type member
to the offset of the aforementioned field in the C object structure,
so that the interpreter knows how to access and modify that field.</li>
</ol>
<p>Concretely, here is how a trivial object structure would be augmented
with the required field:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">weakreflist</span><span class="p">;</span>  <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">TrivialObject</span><span class="p">;</span>
</pre></div>
</div>
<p>And the corresponding member in the statically-declared type object:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">TrivialType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="cm">/* ... other members omitted for brevity ... */</span>
    <span class="p">.</span><span class="n">tp_weaklistoffset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">TrivialObject</span><span class="p">,</span> <span class="n">weakreflist</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The only further addition is that <code class="docutils literal"><span class="pre">tp_dealloc</span></code> needs to clear any weak
references (by calling <code class="xref c c-func docutils literal"><span class="pre">PyObject_ClearWeakRefs()</span></code>) if the field is
non-<em>NULL</em>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">Trivial_dealloc</span><span class="p">(</span><span class="n">TrivialObject</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Clear weakrefs first before calling any destructors */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">weakreflist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">PyObject_ClearWeakRefs</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">);</span>
    <span class="cm">/* ... remainder of destruction code omitted for brevity ... */</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="more-suggestions">
<h2>3.7. その他いろいろ<a class="headerlink" href="#more-suggestions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In order to learn how to implement any specific method for your new data type,
get the <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a> source code.  Go to the <code class="file docutils literal"><span class="pre">Objects</span></code> directory,
then search the C source files for <code class="docutils literal"><span class="pre">tp_</span></code> plus the function you want
(for example, <code class="docutils literal"><span class="pre">tp_richcompare</span></code>).  You will find examples of the function
you want to implement.</p>
<p>When you need to verify that an object is a concrete instance of the type you
are implementing, use the <a class="reference internal" href="../c-api/object.html#c.PyObject_TypeCheck" title="PyObject_TypeCheck"><code class="xref c c-func docutils literal"><span class="pre">PyObject_TypeCheck()</span></code></a> function.  A sample of
its use might be something like the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyObject_TypeCheck</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyType</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;arg #1 not a mything&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt>Download CPython source releases.</dt>
<dd><a class="reference external" href="https://www.python.org/downloads/source/">https://www.python.org/downloads/source/</a></dd>
<dt>The CPython project on GitHub, where the CPython source code is developed.</dt>
<dd><a class="reference external" href="https://github.com/python/cpython">https://github.com/python/cpython</a></dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Defining Extension Types: Assorted Topics</a><ul>
<li><a class="reference internal" href="#finalization-and-de-allocation">3.1. ファイナライズとメモリ解放</a></li>
<li><a class="reference internal" href="#object-presentation">3.2. オブジェクト表現</a></li>
<li><a class="reference internal" href="#attribute-management">3.3. 属性を管理する</a><ul>
<li><a class="reference internal" href="#generic-attribute-management">3.3.1. 総称的な属性を管理する</a></li>
<li><a class="reference internal" href="#type-specific-attribute-management">3.3.2. 特定の型に特化した属性の管理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#object-comparison">3.4. オブジェクトの比較</a></li>
<li><a class="reference internal" href="#abstract-protocol-support">3.5. 抽象的なプロトコルのサポート</a></li>
<li><a class="reference internal" href="#weak-reference-support">3.6. 弱参照(Weak Reference)のサポート</a></li>
<li><a class="reference internal" href="#more-suggestions">3.7. その他いろいろ</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="newtypes_tutorial.html"
                        title="前の章へ">2. Defining Extension Types: Tutorial</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="building.html"
                        title="次の章へ">4. C および C++ 拡張のビルド</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/extending/newtypes.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="4. C および C++ 拡張のビルド"
             >次へ</a> |</li>
        <li class="right" >
          <a href="newtypes_tutorial.html" title="2. Defining Extension Types: Tutorial"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.5</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python インタプリタの拡張と埋め込み</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 4月 10, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>