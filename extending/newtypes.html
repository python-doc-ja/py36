
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2. 新しい型を定義する &#8212; Python 3.6.3 ドキュメント</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="3. C および C++ 拡張のビルド" href="building.html" />
    <link rel="prev" title="1. C や C++ による Python の拡張" href="extending.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.jp/3/extending/newtypes.html" /><script type="text/javascript">
    $(document).ready(function() {
      var base = 'https://docs.python.org/3.6/extending/newtypes.html';
      $('a.headerlink').each(function() {
        var html = '<a href="' + base + $(this).attr('href') +
                   '" title="原文へのリンク"><small>(原文)</small></a>';
        $(this).after(html);
      })
    });
    </script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="3. C および C++ 拡張のビルド"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="extending.html" title="1. C や C++ による Python の拡張"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python インタプリタの拡張と埋め込み</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="defining-new-types">
<span id="id1"></span><h1>2. 新しい型を定義する<a class="headerlink" href="#defining-new-types" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>前の章でふれたように、Python では拡張モジュールを書くプログラマが Python のコードから操作できる、新しい型を定義できるようになっています。ちょうど Python の中核にある文字列やリストをつくれるようなものです。</p>
<p>これはそんなにむずかしくはありません。拡張型のためのコードにはすべて、一定のパターンが存在しています。しかし始める前に、いくつか細かいことを理解しておく必要があるでしょう。</p>
<div class="section" id="the-basics">
<span id="dnt-basics"></span><h2>2.1. 基本的なこと<a class="headerlink" href="#the-basics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python ランタイムは Python の全てのオブジェクトを <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> 型の変数と見なします。 <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> は Python の全てのオブジェクトの &quot;基礎型 (base type)&quot; となっています。 <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span></code></a> 自身は参照カウントと、オブジェクトの &quot;タイプオブジェクト (type object)&quot; へのポインタのみを持ちます。ここには動作が定義されています; 型オブジェクトは、例えば、ある属性があるオブジェクトから検索されたり、他のオブジェクトによって操作されたりしたときに、どの (C) 関数が呼ばれるのかを決定します。これらの C 関数は &quot;タイプメソッド (type method)&quot; と呼ばれます。</p>
<p>なので、新しいオブジェクトの型を定義したいときは、新しいタイプオブジェクトを作成すればよいわけです。</p>
<p>この手のことは例を見たほうが早いでしょうから、ここに最小限の、しかし完全な、新しい型を定義するモジュールをあげておきます:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="cm">/* Type-specific fields go here. */</span>
<span class="p">}</span> <span class="n">noddy_NoddyObject</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">noddy_NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span> <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddymodule</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">noddy_NoddyType</span><span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">PyType_GenericNew</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddymodule</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>さしあたって覚えておくことは以上ですが、これで前の章からすこしは説明がわかりやすくなっていることと思います。</p>
<p>最初に習うのは、つぎのようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
<span class="p">}</span> <span class="n">noddy_NoddyObject</span><span class="p">;</span>
</pre></div>
</div>
<p>これが Noddy オブジェクトの内容です — このケースでは、すべての Python オブジェクトが持っているものと何ら変わりはありません — <code class="docutils literal"><span class="pre">ob_base</span></code> と呼ばれる <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span></code></a> 型のフィールドです。さらに <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject</span></code></a> は、 <code class="docutils literal"><span class="pre">ob_refcnt</span></code> フィールドと型オブジェクトへのポインタを持っています。これらは、マクロ <a class="reference internal" href="../c-api/structures.html#c.Py_REFCNT" title="Py_REFCNT"><code class="xref c c-macro docutils literal"><span class="pre">Py_REFCNT</span></code></a> と <a class="reference internal" href="../c-api/structures.html#c.Py_TYPE" title="Py_TYPE"><code class="xref c c-macro docutils literal"><span class="pre">Py_TYPE</span></code></a> を使ってそれぞれアクセスできます。これらは <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal"><span class="pre">PyObject_HEAD</span></code></a> マクロによって展開されるメンバです。マクロを使う理由は、レイアウトを標準化するためと、デバッグ用ビルド時に特別なデバッグ用のメンバを定義できるようにするためです。</p>
<p>この <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal"><span class="pre">PyObject_HEAD</span></code></a> マクロの後にはセミコロンがないことに注意してください。セミコロンはすでにマクロ内に含まれています。うっかり後にセミコロンをつけてしまわないように気をつけて。これはお使いの機種では何の問題も起こらないかもしれませんが、機種によっては、おそらく問題になるのです! (Windows 上では、MS Visual C がこの手のエラーを出し、コンパイルできないことが知られています)</p>
<p>比較のため、以下に標準的な Python の浮動小数点数型の定義を見てみましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">double</span> <span class="n">ob_fval</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyFloatObject</span><span class="p">;</span>
</pre></div>
</div>
<p>では次にいってみます。かなめの部分、タイプオブジェクトです。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">noddy_NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span> <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_async */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">object.h</span></code> の中にある <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> の定義を見ると、実際にはここに挙げた以上の数のメンバがあるとわかるでしょう。これ以外のメンバは C コンパイラによってゼロに初期化されるので、必要な時を除いてふつうはそれらの値を明示的には指定せずにおきます。</p>
<p>次のものは非常に重要なので、とくに最初の最初に見ておきましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>これはちょっとぶっきらぼうですね。実際に書きたかったのはこうです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>この場合、タイプオブジェクトの型は「type」という名前になりますが、これは厳密には C の基準に従っておらず、コンパイラによっては文句を言われます。幸いにも、このメンバは <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が埋めてくれます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>              <span class="cm">/* tp_name */</span>
</pre></div>
</div>
<p>これは型の名前です。この名前はオブジェクトのデフォルトの表現形式と、いくつかのエラーメッセージ中で使われます。たとえば:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="n">noddy</span><span class="p">.</span><span class="n">new_noddy</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span><span class="o">:</span>
  <span class="n">File</span> <span class="s">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nl">TypeError</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">add</span> <span class="n">type</span> <span class="s">&quot;noddy.Noddy&quot;</span> <span class="n">to</span> <span class="n">string</span>
</pre></div>
</div>
<p>注意: この名前はドットで区切られた名前で、モジュール名とそのモジュール内での型名の両方を含んでいます。
この場合のモジュールは <code class="xref py py-mod docutils literal"><span class="pre">noddy</span></code> で型は <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> ですから、ここでの型名としては <code class="xref py py-class docutils literal"><span class="pre">noddy.Noddy</span></code> を指定するわけです。
ドットで区切られていない名前を使うと、文書ツールの pydoc がその新しい型をモジュールの文書に載せなくなるという副作用があります。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="p">(</span><span class="n">noddy_NoddyObject</span><span class="p">),</span>  <span class="cm">/* tp_basicsize */</span>
</pre></div>
</div>
<p>これによって Python は <a class="reference internal" href="../c-api/allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_New()</span></code></a> が呼ばれたときにどれくらいの量のメモリを割り当てればよいのか知ることができます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">あなたのタイプを Python でサブクラス化可能にしたい場合、そのタイプが基底タイプと同じ <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> をもっていると多重継承のときに問題が生じることがあります。そのタイプを Python のサブクラスにしたとき、その <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal"><span class="pre">__bases__</span></code></a> リストにはあなたのタイプが最初にくるようにしなければなりません。さもないとエラーの発生なしにあなたのタイプの <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> メソッドを呼び出すことはできなくなります。この問題を回避するには、つねにあなたのタイプの <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal"><span class="pre">tp_basicsize</span></code></a> をその基底タイプよりも大きくしておくことです。ほとんどの場合、あなたのタイプは <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> か、そうでなければ基底タイプにデータ用のメンバを追加したものでしょうから、したがって大きさはつねに増加するためこの条件は満たされています。</p>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="p">,</span>                          <span class="cm">/* tp_itemsize */</span>
</pre></div>
</div>
<p>これはリストや文字列などの可変長オブジェクトのためのものです。今のところ無視しましょう。</p>
<p>このあとのいくつかのタイプメソッドは使わないのでとばして、クラスのフラグ (flags) には <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_DEFAULT" title="Py_TPFLAGS_DEFAULT"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_DEFAULT</span></code></a> を入れます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>        <span class="cm">/* tp_flags */</span>
</pre></div>
</div>
<p>すべての型はフラグにこの定数を含めておく必要があります。これは最低でも Python 3.3 までに定義されているすべてのメンバを許可します。それ以上のメンバが必要なら、対応するフラグの OR をとる必要があります。</p>
<p>この型の docstring は <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_doc" title="PyTypeObject.tp_doc"><code class="xref c c-member docutils literal"><span class="pre">tp_doc</span></code></a> に入れます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
</pre></div>
</div>
<p>ここからタイプメソッドに入るわけですが。ここがあなたのオブジェクトが他と違うところです。でも今回のバージョンでは、これらはどれも実装しないでおき、あとでこの例をより面白いものに改造することにしましょう。</p>
<p>とりあえずやりたいのは、この <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> オブジェクトを新しく作れるようにすることです。
オブジェクトの作成を許可するには、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> の実装を提供する必要があります。
今回は、 API 関数によって提供されるデフォルトの実装 <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a> を使うだけにしましょう。
これを単に <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> スロットに代入すればよいのですが、これは互換上の理由からできません。プラットフォームやコンパイラによっては、構造体メンバの初期化に別の場所で定義されている C の関数を代入することはできないのです。なので、この <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> の値はモジュール初期化用の関数で代入します。
<a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> を呼ぶ直前です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">noddy_NoddyType</span><span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">PyType_GenericNew</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>これ以外のタイプメソッドはすべて <em>NULL</em> です。これらについては後ほどふれます!</p>
<p>このファイル中にある他のものは、どれもおなじみでしょう。 <code class="xref c c-func docutils literal"><span class="pre">PyInit_noddy()</span></code> のこれを除いて:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、上で <em>NULL</em> に指定していた <code class="xref py py-attr docutils literal"><span class="pre">ob_type</span></code> などのいくつものメンバを埋めて、 <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> 型を初期化します。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">noddy_NoddyType</span><span class="p">);</span>
</pre></div>
</div>
<p>これはこの型をモジュール中の辞書に埋め込みます。これで、 <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> クラスを呼べば <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> インスタンスを作れるようになりました:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">noddy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mynoddy</span> <span class="o">=</span> <span class="n">noddy</span><span class="p">.</span><span class="n">Noddy</span><span class="p">()</span>
</pre></div>
</div>
<p>これだけです! 残るはこれをどうやってビルドするかということです。上のコードを <code class="file docutils literal"><span class="pre">noddy.c</span></code> というファイルに入れて、以下のものを <code class="file docutils literal"><span class="pre">setup.py</span></code> というファイルに入れましょう</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">from</span> <span class="n">distutils</span><span class="p">.</span><span class="n">core</span> <span class="n">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy.c&quot;</span><span class="p">])])</span>
</pre></div>
</div>
<p>そして、シェルから以下のように入力します</p>
<div class="highlight-shell-session"><div class="highlight"><pre><span></span><span class="gp">$</span> python setup.py build
</pre></div>
</div>
<p>これでサブディレクトリの下にファイル <code class="file docutils literal"><span class="pre">noddy.so</span></code> が作成されます。このディレクトリに移動して Python を起動しましょう。 <code class="docutils literal"><span class="pre">import</span> <span class="pre">noddy</span></code> して Noddy オブジェクトで遊べるようになっているはずです。</p>
<p>そんなにむずかしくありません、よね?</p>
<p>もちろん、現在の Noddy 型はまだおもしろみに欠けています。何もデータを持ってないし、何もしてはくれません。継承してサブクラスを作ることさえできないのです。</p>
<div class="section" id="adding-data-and-methods-to-the-basic-example">
<h3>2.1.1. 基本のサンプルにデータとメソッドを追加する<a class="headerlink" href="#adding-data-and-methods-to-the-basic-example" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この基本のサンプルにデータとメソッドを追加してみましょう。ついでに、この型を基底クラスとしても利用できるようにします。ここでは新しいモジュール <code class="xref py py-mod docutils literal"><span class="pre">noddy2</span></code> をつくり、以下の機能を追加します:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;structmember.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span> <span class="cm">/* first name */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>  <span class="cm">/* last name */</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span>   <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddy2module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy2&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy2module</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このバージョンでは、いくつもの変更をおこないます。</p>
<p>以下の include を追加します:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;structmember.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>すこしあとでふれますが、この include には属性を扱うための宣言が入っています。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> オブジェクトの構造体の名前は <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> に縮めることにします。タイプオブジェクト名は <code class="xref py py-class docutils literal"><span class="pre">NoddyType</span></code> に縮めます。</p>
<p>これから <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> 型は 3つのデータ属性をもつようになります。 <em>first</em> 、 <em>last</em> 、および <em>number</em> です。 <em>first</em> と <em>last</em> 属性はファーストネームとラストネームを格納した Python 文字列で、 <em>number</em> 属性は整数の値です。</p>
<p>これにしたがうと、オブジェクトの構造体は次のようになります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>
</pre></div>
</div>
<p>いまや管理すべきデータができたので、オブジェクトの割り当てと解放に際してはより慎重になる必要があります。最低限、オブジェクトの解放メソッドが必要です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この関数は <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> メンバに代入されます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/*tp_dealloc*/</span>
</pre></div>
</div>
<p>このメソッドでやっているのは、ふたつの Python 属性の参照カウントを減らすことです。 <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> メンバと <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> メンバが <em>NULL</em> かもしれないため、ここでは <a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_XDECREF()</span></code></a> を使いました。このあとそのオブジェクトのタイプメソッドである <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal"><span class="pre">tp_free</span></code></a> メンバを呼び出しています。ここではオブジェクトの型が <code class="xref py py-class docutils literal"><span class="pre">NoddyType</span></code> とは限らないことに注意してください。なぜなら、このオブジェクトはサブクラス化したインスタンスかもしれないからです。</p>
<p>ファーストネームとラストネームを空文字列に初期化しておきたいので、新しいメソッドを追加することにしましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>そしてこれを <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> メンバとしてインストールします:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
</pre></div>
</div>
<p>この新しいメンバはその型のオブジェクトを (初期化するのではなく) 作成する責任を負っています。Python ではこのメンバは <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> メソッドとして見えています。 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> メソッドについての詳しい議論は &quot;Unifying types and classes in Python&quot; という題名の論文を見てください。 new メソッドを実装する理由のひとつは、インスタンス変数の初期値を保証するためです。この例でやりたいのは new メソッドが <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> メンバと  <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> メンバの値を <em>NULL</em> でないようにするということです。もしこれらの初期値が <em>NULL</em> でもよいのであれば、先の例でやったように、new メソッドとして <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a> を使うこともできたでしょう。 <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a> はすべてのインスタンス変数のメンバを <em>NULL</em> にします。</p>
<p>この new メソッドは静的なメソッドで、インスタンス化される型と、型が呼び出されたときの引数が渡され、新しいオブジェクトを作成して返します。
new メソッドは常に固定引数 (positional argument) とキーワード引数を取りますが、それらの引数は無視して初期化メソッドにそのまま渡すことがよくあります。
型がサブクラスをサポートしている場合、渡された型が定義している型でないかもしれないことに注意してください。
new メソッドはメモリ割り当てのために <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> メンバを呼び出します。
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> スロットをこちらで埋める必要はありません。
これは <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が基底クラス (デフォルトでは <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a>) をもとに埋めるものです。ほとんどの型ではデフォルトのメモリ割り当てを使っています。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">もし協力的な <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> (基底タイプの <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> または <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal"><span class="pre">__new__()</span></code></a> を呼んでいるもの) を作りたいのならば、実行時のメソッド解決順序をつかってどのメソッドを呼びだすかを決定しようとしては <em>いけません</em> 。つねに呼び出す型を静的に決めておき、直接その <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> を呼び出すか、あるいは <code class="docutils literal"><span class="pre">type-&gt;tp_base-&gt;tp_new</span></code> を経由してください。こうしないと、あなたが作成したタイプの Python サブクラスが他の Python で定義されたクラスも継承している場合にうまく動かない場合があります。 (とりわけ、そのようなサブクラスのインスタンスを <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を出さずに作ることが不可能になります。)</p>
</div>
<p>つぎに初期化用の関数を見てみましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> メンバに代入されます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>         <span class="cm">/* tp_init */</span>
</pre></div>
</div>
<p>Python では <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> メンバは <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドとして見えています。
このメソッドは、オブジェクトが作成されたあとに、それを初期化する目的で使われます。
new メソッドとはちがって、初期化メソッドは必ず呼ばれるとは限りません。
初期化メソッドはオブジェクトを非 pickle 化するときは呼ばれず、上書きもできます。
初期化メソッドは、インスタンスの初期値を提供するのに必要な引数を受けとります。
このメソッドはつねに固定引数とキーワード引数を受けとります。
初期化メソッドは成功のときは 0 、エラーのときは -1 を返すべきです。</p>
<p>初期化メソッドは複数回呼び出される可能性があります。あなたのオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> メソッドは、誰にでも呼び出すことができるからです。このため、新しい値を代入するさいには特別な注意を払う必要があります。たとえば、 <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> メンバには以下のように代入したくなるかもしれません:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>しかしこのやり方は危険です。このタイプでは <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> メンバに入るオブジェクトをなにも限定していないので、どんなオブジェクトでもとり得てしまうからです。それはこのコードが <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> メンバにアクセスしようとする前に、そのデストラクタが呼び出されてしまうかもしれないのです。このような可能性からパラノイア的に身をまもるため、ほとんどの場合メンバへの代入は,その参照カウントを減らす前におこなってください。こうする必要がないのはどんな場合でしょうか?</p>
<ul class="simple">
<li>その参照カウントが 1 より大きいと確信できる場合。</li>
<li>そのオブジェクトの解放があなたのタイプのコードにコールバックするようなことが決してない場合 <a class="footnote-reference" href="#id7" id="id2">[1]</a> 。</li>
<li>ガベージコレクションがサポートされていない場合に <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> ハンドラで参照カウントを減らすとき <a class="footnote-reference" href="#id8" id="id3">[2]</a> 。</li>
</ul>
<p>ここではインスタンス変数を属性として見えるようにしたいのですが、これにはいくつもの方法があります。もっとも簡単な方法は、メンバの定義を与えることです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>そして、この定義を <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal"><span class="pre">tp_members</span></code></a> スロットに入れましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
</pre></div>
</div>
<p>各メンバの定義はそれぞれ、メンバの名前、型、オフセット、アクセスフラグおよび docstring です。詳しくは後の &quot;総称的な属性を管理する&quot; (<a class="reference internal" href="#generic-attribute-management"><span class="std std-ref">総称的な属性を管理する</span></a>) の節をご覧ください。</p>
<p>この方法の欠点は、Python 属性に代入できるオブジェクトの型を制限する方法がないことです。ここではファーストネーム first とラストネーム last に、ともに文字列が入るよう期待していますが、今のやり方ではどんな Python オブジェクトも代入できてしまいます。加えてこの属性は削除 (del) できてしまい、その場合、 C のポインタには <em>NULL</em> が設定されます。たとえもしメンバが <em>NULL</em> 以外の値に初期化されるようにしてあったとしても、属性が削除されればメンバは <em>NULL</em> になってしまいます。</p>
<p>ここでは <code class="xref py py-meth docutils literal"><span class="pre">name()</span></code> と呼ばれるメソッドを定義しましょう。これはファーストネーム first とラストネーム last を連結した文字列をそのオブジェクトの名前として返します。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このメソッドは C 関数として実装され、 <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> (あるいは   <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> のサブクラス) のインスタンスを第一引数として受けとります。メソッドはつねにそのインスタンスを最初の引数として受けとらなければなりません。しばしば固定引数とキーワード引数も受けとりますが、今回はなにも必要ないので、固定引数のタプルもキーワード引数の辞書も取らないことにします。このメソッドは Python の以下のメソッドと等価です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">def</span> <span class="n">name</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
   <span class="k">return</span> <span class="s">&quot;%s %s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">last</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal"><span class="pre">first</span></code> メンバと <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> メンバがそれぞれ <em>NULL</em> かどうかチェックしなければならないことに注意してください。これらは削除される可能性があり、その場合値は <em>NULL</em> にセットされます。この属性の削除を禁止して、そこに入れられる値を文字列に限定できればなおいいでしょう。次の節ではこれについて扱います。</p>
<p>さて、メソッドを定義したので、ここでメソッド定義用の配列を作成する必要があります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>これを <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> スロットに入れましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
</pre></div>
</div>
<p>ここでの <a class="reference internal" href="../c-api/structures.html#METH_NOARGS" title="METH_NOARGS"><code class="xref py py-const docutils literal"><span class="pre">METH_NOARGS</span></code></a> フラグは、そのメソッドが引数を取らないことを宣言するのに使われています。</p>
<p>最後に、この型を基底クラスとして利用可能にしましょう。上のメソッドは注意ぶかく書かれているので、これはそのオブジェクトの型が作成されたり利用される場合についてどんな仮定も置いていません。なので、ここですべきことは <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_BASETYPE</span></code></a> をクラス定義のフラグに加えるだけです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="cm">/*tp_flags*/</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">PyInit_noddy()</span></code> の名前を <code class="xref c c-func docutils literal"><span class="pre">PyInit_noddy2()</span></code> に変更し、 <a class="reference internal" href="../c-api/module.html#c.PyModuleDef" title="PyModuleDef"><code class="xref c c-type docutils literal"><span class="pre">PyModuleDef</span></code></a> に渡されるモジュール名を更新します。</p>
<p>さいごに <code class="file docutils literal"><span class="pre">setup.py</span></code> ファイルを更新して新しいモジュールをビルドします:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">from</span> <span class="n">distutils</span><span class="p">.</span><span class="n">core</span> <span class="n">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&quot;1.0&quot;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
         <span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy.c&quot;</span><span class="p">]),</span>
         <span class="n">Extension</span><span class="p">(</span><span class="s">&quot;noddy2&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;noddy2.c&quot;</span><span class="p">]),</span>
         <span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="providing-finer-control-over-data-attributes">
<h3>2.1.2. データ属性をこまかく制御する<a class="headerlink" href="#providing-finer-control-over-data-attributes" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この節では、 <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> クラスの例にあった <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> と <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> の各属性にたいして、より精密な制御を提供します。以前のバージョンのモジュールでは、インスタンス変数の <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> と <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> には文字列以外のものも代入できてしまい、あまつさえ削除まで可能でした。ここではこれらの属性が必ず文字列を保持しているようにしましょう。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;structmember.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|SSi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_getfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_setfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the first attribute&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;The first attribute value must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_getlast</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_setlast</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the last attribute&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;The last attribute value must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyGetSetDef</span> <span class="n">Noddy_getseters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getfirst</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setfirst</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getlast</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setlast</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span>   <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="n">Noddy_getseters</span><span class="p">,</span>           <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddy3module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy3&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy3module</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal"><span class="pre">first</span></code> 属性と <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> 属性をよりこまかく制御するためには、カスタムメイドの getter 関数と setter 関数を使います。以下は <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> 属性から値を取得する関数 (getter) と、この属性に値を格納する関数 (setter) です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_getfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">Noddy_setfirst</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">closure</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;Cannot delete the first attribute&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                    <span class="s">&quot;The first attribute value must be a str&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
  <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>getter 関数には <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> オブジェクトと「閉包 (closure)」 (これは void型のポインタです) が渡されます。今回のケースでは閉包は無視します。 (閉包とは定義データが渡される setter や getter の高度な利用をサポートするためのもので、これを使うとたとえば getter と setter をひとまとめにした関数に、閉包のデータにもとづいて属性を get するか set するか決めさせる、といったことができます。)</p>
<p>setter 関数には <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> オブジェクトと新しい値、そして閉包が渡されます。新しい値は <em>NULL</em> かもしれず、その場合はこの属性が削除されます。ここでは属性が削除されたり、その値が文字列でないときにはエラーを発生させるようにします。</p>
<p>ここでは <a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></code></a> 構造体の配列をつくります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyGetSetDef</span> <span class="n">Noddy_getseters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getfirst</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setfirst</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span>
     <span class="p">(</span><span class="n">getter</span><span class="p">)</span><span class="n">Noddy_getlast</span><span class="p">,</span> <span class="p">(</span><span class="n">setter</span><span class="p">)</span><span class="n">Noddy_setlast</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">,</span>
     <span class="nb">NULL</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>そしてこれを <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code class="xref c c-member docutils literal"><span class="pre">tp_getset</span></code></a> スロットに登録します:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Noddy_getseters</span><span class="p">,</span>           <span class="cm">/* tp_getset */</span>
</pre></div>
</div>
<p>これで属性の getter と setter が登録できました。</p>
<p><a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal"><span class="pre">PyGetSetDef</span></code></a> 構造体の最後の要素が上で説明した閉包です。今回は閉包は使わないので <em>NULL</em> を渡しています。</p>
<p>また、メンバ定義からはこれらの属性を除いておきましょう:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>また、ここでは <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal"><span class="pre">tp_init</span></code></a> ハンドラも渡されるものとして文字列のみを許可するように修正する必要があります <a class="footnote-reference" href="#id9" id="id4">[3]</a>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|SSi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これらの変更によって、 <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> メンバと <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> メンバが決して <em>NULL</em> にならないと保証できました。
これでほとんどすべてのケースから <em>NULL</em> 値のチェックを除けます。
これは <a class="reference internal" href="../c-api/refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_XDECREF()</span></code></a> 呼び出しを <a class="reference internal" href="../c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_DECREF()</span></code></a> 呼び出しに変えられることを意味します。
唯一これを変えられないのはメモリ解放関数 (deallocator) で、なぜならここではコンストラクタによるメンバ初期化が失敗している可能性があるからです。</p>
<p>さて、先ほどもしたように、このモジュール初期化関数と初期化関数内にあるモジュール名を変更しましょう。そして <code class="file docutils literal"><span class="pre">setup.py</span></code> ファイルに追加の定義をくわえます。</p>
</div>
<div class="section" id="supporting-cyclic-garbage-collection">
<h3>2.1.3. 循環ガベージコレクションをサポートする<a class="headerlink" href="#supporting-cyclic-garbage-collection" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python は循環ガベージコレクション機能をもっており、これは不要なオブジェクトを、たとえ参照カウントがゼロでなくても、発見することができます。これはオブジェクトの参照が循環しているときに起こりえます。たとえば以下の例を考えてください:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">del</span> <span class="n">l</span>
</pre></div>
</div>
<p>この例では、自分自身をふくむリストをつくりました。たとえこのリストを del しても、それは自分自身への参照をまだ持ちつづけますから、参照カウントはゼロにはなりません。嬉しいことに Python には循環ガベージコレクション機能がありますから、最終的にはこのリストが不要であることを検出し、解放できます。</p>
<p>In the second version of the <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> example, we allowed any kind of
object to be stored in the <code class="xref py py-attr docutils literal"><span class="pre">first</span></code> or <code class="xref py py-attr docutils literal"><span class="pre">last</span></code> attributes. <a class="footnote-reference" href="#id10" id="id5">[4]</a> This
means that <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> objects can participate in cycles:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">noddy2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">noddy2</span><span class="p">.</span><span class="n">Noddy</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">l</span>
</pre></div>
</div>
<p>これは実にばかげた例ですが、すくなくとも <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> クラスに循環ガベージコレクション機能のサポートを加える口実を与えてくれます。循環ガベージコレクションをサポートするには 2つのタイプスロットを埋め、これらのスロットを許可するようにクラス定義のフラグを設定する必要があります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;structmember.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Noddy</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">vret</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Noddy_clear</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

    <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">PyUnicode_FromString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_init</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">first</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;|OOi&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMemberDef</span> <span class="n">Noddy_members</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">first</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;first name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;last&quot;</span><span class="p">,</span> <span class="n">T_OBJECT_EX</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">last</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;last name&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="n">T_INT</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">,</span> <span class="n">number</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s">&quot;noddy number&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Noddy_name</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span> <span class="s">&quot;last&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;%S %S&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Noddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Noddy_name</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="s">&quot;Return the name, combining the first and last name&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">}</span>  <span class="cm">/* Sentinel */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">NoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;noddy.Noddy&quot;</span><span class="p">,</span>             <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Noddy</span><span class="p">),</span>             <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">Noddy_dealloc</span><span class="p">,</span> <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_hash  */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span>    <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;Noddy objects&quot;</span><span class="p">,</span>           <span class="cm">/* tp_doc */</span>
    <span class="p">(</span><span class="n">traverseproc</span><span class="p">)</span><span class="n">Noddy_traverse</span><span class="p">,</span>   <span class="cm">/* tp_traverse */</span>
    <span class="p">(</span><span class="n">inquiry</span><span class="p">)</span><span class="n">Noddy_clear</span><span class="p">,</span>           <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_iternext */</span>
    <span class="n">Noddy_methods</span><span class="p">,</span>             <span class="cm">/* tp_methods */</span>
    <span class="n">Noddy_members</span><span class="p">,</span>             <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Noddy_init</span><span class="p">,</span>      <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                         <span class="cm">/* tp_alloc */</span>
    <span class="n">Noddy_new</span><span class="p">,</span>                 <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">noddy4module</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;noddy4&quot;</span><span class="p">,</span>
    <span class="s">&quot;Example module that creates an extension type.&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_noddy4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noddy4module</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Noddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>traversal メソッドは循環した参照に含まれる可能性のある内部オブジェクトへのアクセスを提供します:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">vret</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vret</span> <span class="o">=</span> <span class="n">visit</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>循環した参照に含まれるかもしれない各内部オブジェクトに対して、 traversal メソッドに渡された <code class="xref c c-func docutils literal"><span class="pre">visit()</span></code> 関数を呼びます。 <code class="xref c c-func docutils literal"><span class="pre">visit()</span></code> 関数は内部オブジェクトと、traversal メソッドに渡された追加の引数 <em>arg</em> を引数としてとります。この関数はこの値が非負の場合に返される整数の値を返します。</p>
<p>Python には、visit 関数の呼び出しを自動化する <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> マクロが用意されています。 <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> を使えば、 <code class="xref c c-func docutils literal"><span class="pre">Noddy_traverse()</span></code> は次のように簡略化できます:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">注意: <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> の実装で <a class="reference internal" href="../c-api/gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> を使うには、その引数に正確に <em>visit</em> および <em>arg</em> という名前をつける必要があります。これは、この退屈な実装に統一性を導入することを促進します。</p>
</div>
<p>We also need to provide a method for clearing any subobjects that can
participate in cycles.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></code> 中での一時変数の使い方に注目してください。ここでは、一時変数をつかって各メンバの参照カウントを減らす前にそれらに <em>NULL</em> を代入しています。これは次のような理由によります。すでにお話ししたように、もし参照カウントがゼロになると、このオブジェクトがコールバックされるようになってしまいます。さらに、いまやガベージコレクションをサポートしているため、ガベージコレクション時に実行されるコードについても心配しなくてはなりません。もしガベージコレクションが走っていると、あなたの <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> ハンドラが呼び出される可能性があります。メンバの参照カウントがゼロになった場合に、その値が <em>NULL</em> に設定されていないと <code class="xref c c-func docutils literal"><span class="pre">Noddy_traverse()</span></code> が呼ばれる機会はありません。</p>
<p>Python には、注意ぶかく参照カウントを減らすためのマクロ <a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></code></a> が用意されています。 <a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal"><span class="pre">Py_CLEAR()</span></code></a> を使えば、 <code class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></code> は次のように簡略化できます:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Noddy_clear</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that <code class="xref c c-func docutils literal"><span class="pre">Noddy_dealloc()</span></code> may call arbitrary functions through
<code class="docutils literal"><span class="pre">__del__</span></code> method or weakref callback. It means circular GC can be
triggered inside the function.  Since GC assumes reference count is not zero,
we need to untrack the object from GC by calling <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_UnTrack()</span></code></a>
before clearing members. Here is reimplemented deallocator which uses
<a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_UnTrack()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">Noddy_clear()</span></code>.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">Noddy_dealloc</span><span class="p">(</span><span class="n">Noddy</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Noddy_clear</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最後に、 <a class="reference internal" href="../c-api/typeobj.html#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> フラグをクラス定義のフラグに加えます:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span> <span class="cm">/* tp_flags */</span>
</pre></div>
</div>
<p>これで完了です。 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> スロットまたは <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal"><span class="pre">tp_free</span></code></a> スロットが書かれていれば、それらを循環ガベージコレクションに使えるよう修正すればよいのです。ほとんどの拡張機能は自動的に提供されるバージョンを使うでしょう。</p>
</div>
<div class="section" id="subclassing-other-types">
<h3>2.1.4. 他の型のサブクラスを作る<a class="headerlink" href="#subclassing-other-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>既存の型を継承した新しい拡張型を作成することができます。組み込み型から継承するのは特に簡単です。必要な <code class="xref py py-class docutils literal"><span class="pre">PyTypeObject</span></code> を簡単に利用できるからです。それに比べて、 <code class="xref py py-class docutils literal"><span class="pre">PyTypeObject</span></code> 構造体を拡張モジュール間で共有するのは難しいです。</p>
<p>次の例では、ビルトインの <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> 型を継承した <code class="xref py py-class docutils literal"><span class="pre">Shoddy</span></code> 型を作成しています。新しい型は通常のリスト型と完全に互換性がありますが、追加で内部のカウンタを増やす <code class="xref py py-meth docutils literal"><span class="pre">increment()</span></code> メソッドを持っています。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">import</span> <span class="n">shoddy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">shoddy</span><span class="p">.</span><span class="n">Shoddy</span><span class="p">(</span><span class="n">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="mi">6</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">increment</span><span class="p">())</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">increment</span><span class="p">())</span>
<span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyListObject</span> <span class="n">list</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Shoddy</span><span class="p">;</span>


<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">Shoddy_increment</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyMethodDef</span> <span class="n">Shoddy_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;increment&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyCFunction</span><span class="p">)</span><span class="n">Shoddy_increment</span><span class="p">,</span> <span class="n">METH_NOARGS</span><span class="p">,</span>
     <span class="n">PyDoc_STR</span><span class="p">(</span><span class="s">&quot;increment state counter&quot;</span><span class="p">)},</span>
    <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">Shoddy_init</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyList_Type</span><span class="p">.</span><span class="n">tp_init</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">ShoddyType</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;shoddy.Shoddy&quot;</span><span class="p">,</span>         <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">Shoddy</span><span class="p">),</span>          <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_itemsize */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_reserved */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span><span class="p">,</span> <span class="cm">/* tp_flags */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_iternext */</span>
    <span class="n">Shoddy_methods</span><span class="p">,</span>          <span class="cm">/* tp_methods */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_dictoffset */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">Shoddy_init</span><span class="p">,</span>   <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_alloc */</span>
    <span class="mi">0</span><span class="p">,</span>                       <span class="cm">/* tp_new */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">PyModuleDef</span> <span class="n">shoddymodule</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span>
    <span class="s">&quot;shoddy&quot;</span><span class="p">,</span>
    <span class="s">&quot;Shoddy module&quot;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_shoddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

    <span class="n">ShoddyType</span><span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shoddymodule</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Shoddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>見てわかるように、ソースコードは前の節の <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> の時と非常に似ています。違う部分をそれぞれを見ていきます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyListObject</span> <span class="n">list</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Shoddy</span><span class="p">;</span>
</pre></div>
</div>
<p>継承した型のオブジェクトの最初の違いは、親クラスのオブジェクト構造が最初に必要なことです。基底型が既に <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-func docutils literal"><span class="pre">PyObject_HEAD()</span></code></a> を構造体の先頭に持っています。</p>
<p>Python オブジェクトが <code class="xref py py-class docutils literal"><span class="pre">Shoddy</span></code> 型のインスタンスだった場合、その <em>PyObject*</em> ポインタは <em>PyListObject*</em> にも <em>Shoddy*</em> にも安全にキャストできます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">Shoddy_init</span><span class="p">(</span><span class="n">Shoddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyList_Type</span><span class="p">.</span><span class="n">tp_init</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
       <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この新しい型の <code class="xref py py-attr docutils literal"><span class="pre">__init__</span></code> メソッドで、基底型の <code class="xref py py-attr docutils literal"><span class="pre">__init__</span></code> メソッドを呼び出している様子を見ることができます。</p>
<p>このパターンは、カスタムの <code class="xref py py-attr docutils literal"><span class="pre">new</span></code> と <code class="xref py py-attr docutils literal"><span class="pre">dealloc</span></code> メソッドを実装するときには重要です。継承した型の <code class="xref py py-attr docutils literal"><span class="pre">new</span></code> メソッドは、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> を使ってメモリを割り当てるべきではありません。それは基底型の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal"><span class="pre">tp_new</span></code></a> を呼出たときに処理されるからです。</p>
<p><code class="xref py py-class docutils literal"><span class="pre">Shoddy</span></code> 型のために <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-func docutils literal"><span class="pre">PyTypeObject()</span></code></a> を埋めるとき、 <code class="xref c c-func docutils literal"><span class="pre">tp_base()</span></code> スロットを見つけることができます。クロスプラットフォームのコンパイラに対応するために、直接そのスロットを <a class="reference internal" href="../c-api/list.html#c.PyList_Type" title="PyList_Type"><code class="xref c c-func docutils literal"><span class="pre">PyList_Type()</span></code></a> で埋めてはいけません。代わりに、後でモジュールの <code class="xref c c-func docutils literal"><span class="pre">init()</span></code> 関数の中で行うことができます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyMODINIT_FUNC</span>
<span class="nf">PyInit_shoddy</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

    <span class="n">ShoddyType</span><span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shoddymodule</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Py_INCREF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="n">PyModule_AddObject</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Shoddy&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ShoddyType</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">PyType_Read()</span></code> を呼ぶ前に、型の構造は <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal"><span class="pre">tp_base</span></code></a> スロットは埋められていなければなりません。継承している新しい型を作るとき、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal"><span class="pre">tp_alloc</span></code></a> スロットを <a class="reference internal" href="../c-api/type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal"><span class="pre">PyType_GenericNew()</span></code></a> で埋める必要はありません。 – 基底型のアロケート関数が継承されます。</p>
<p>この後は、 <a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> 関数を呼び、タイプオブジェクトをモジュールへ追加するのは、基本的な <code class="xref py py-class docutils literal"><span class="pre">Noddy</span></code> の例と同じです。</p>
</div>
</div>
<div class="section" id="type-methods">
<span id="dnt-type-methods"></span><h2>2.2. タイプメソッド<a class="headerlink" href="#type-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節ではさまざまな実装可能なタイプメソッドと、それらが何をするものであるかについて、ざっと説明します。</p>
<p>以下は <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal"><span class="pre">PyTypeObject</span></code></a> の定義です。デバッグビルドでしか使われないいくつかのメンバは省いてあります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>

    <span class="cm">/* Methods to implement standard operations */</span>

    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
    <span class="n">getattrfunc</span> <span class="n">tp_getattr</span><span class="p">;</span>
    <span class="n">setattrfunc</span> <span class="n">tp_setattr</span><span class="p">;</span>
    <span class="n">PyAsyncMethods</span> <span class="o">*</span><span class="n">tp_as_async</span><span class="p">;</span> <span class="cm">/* formerly known as tp_compare (Python 2)</span>
<span class="cm">                                    or tp_reserved (Python 3) */</span>
    <span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>

    <span class="cm">/* Method suites for standard classes */</span>

    <span class="n">PyNumberMethods</span> <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
    <span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
    <span class="n">PyMappingMethods</span> <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

    <span class="cm">/* More standard operations (here for binary compatibility) */</span>

    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
    <span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>
    <span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>

    <span class="cm">/* Functions to access object as input/output buffer */</span>
    <span class="n">PyBufferProcs</span> <span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

    <span class="cm">/* Flags to define presence of optional/expanded features */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tp_flags</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span> <span class="cm">/* Documentation string */</span>

    <span class="cm">/* call function for all accessible objects */</span>
    <span class="n">traverseproc</span> <span class="n">tp_traverse</span><span class="p">;</span>

    <span class="cm">/* delete references to contained objects */</span>
    <span class="n">inquiry</span> <span class="n">tp_clear</span><span class="p">;</span>

    <span class="cm">/* rich comparisons */</span>
    <span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>

    <span class="cm">/* weak reference enabler */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_weaklistoffset</span><span class="p">;</span>

    <span class="cm">/* Iterators */</span>
    <span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
    <span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>

    <span class="cm">/* Attribute descriptor and subclassing stuff */</span>
    <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">tp_descr_get</span><span class="p">;</span>
    <span class="n">descrsetfunc</span> <span class="n">tp_descr_set</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_dictoffset</span><span class="p">;</span>
    <span class="n">initproc</span> <span class="n">tp_init</span><span class="p">;</span>
    <span class="n">allocfunc</span> <span class="n">tp_alloc</span><span class="p">;</span>
    <span class="n">newfunc</span> <span class="n">tp_new</span><span class="p">;</span>
    <span class="n">freefunc</span> <span class="n">tp_free</span><span class="p">;</span> <span class="cm">/* Low-level free-memory routine */</span>
    <span class="n">inquiry</span> <span class="n">tp_is_gc</span><span class="p">;</span> <span class="cm">/* For PyObject_IS_GC */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span> <span class="cm">/* method resolution order */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>
    <span class="n">destructor</span> <span class="n">tp_del</span><span class="p">;</span>

    <span class="cm">/* Type attribute cache version tag. Added in version 2.6 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tp_version_tag</span><span class="p">;</span>

    <span class="n">destructor</span> <span class="n">tp_finalize</span><span class="p">;</span>

<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
<p><em>たくさんの</em> メソッドがありますね。でもそんなに心配する必要はありません。定義したい型があるなら、実装するのはこのうちのごくわずかですむことがほとんどです。</p>
<p>すでに予想されているでしょうが、これらの多様なハンドラについて、これからより詳しい情報を提供します。しかしこれらのメンバが構造体中で定義されている順番は無視します。というのは、これらのメンバの現れる順序は歴史的な遺産によるものだからです。型を初期化するさいに、これらのメンバを正しい順序で並べるよう、くれぐれも注意してください。ふつういちばん簡単なのは、必要なメンバがすべて含まれている (たとえそれらが <code class="docutils literal"><span class="pre">0</span></code> に初期化されていても) 例をとってきて、自分の型に合わせるよう変更をくわえることです。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing */</span>
</pre></div>
</div>
<p>これは型の名前です。前節で説明したように、これはいろいろな場面で現れ、ほとんどは診断用の目的で使われるものです。なので、そのような場面で役に立つであろう名前を選んでください!</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>
</pre></div>
</div>
<p>これらのメンバは、この型のオブジェクトが作成されるときにどれだけのメモリを割り当てればよいのかをランタイムに指示します。Python には可変長の構造体 (文字列やリストなどを想像してください) に対する組み込みのサポートがある程度あり、ここで <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal"><span class="pre">tp_itemsize</span></code></a> メンバが使われます。これらについてはあとでふれます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span>
</pre></div>
</div>
<p>ここには Python スクリプトリファレンス <code class="docutils literal"><span class="pre">obj.__doc__</span></code> が doc string を返すときの文字列 (あるいはそのアドレス) を入れます。</p>
<p>では次に、ほとんどの拡張型が実装するであろう基本的なタイプメソッドに入っていきます。</p>
<div class="section" id="finalization-and-de-allocation">
<h3>2.2.1. ファイナライズとメモリ解放<a class="headerlink" href="#finalization-and-de-allocation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-c" id="index-0"><div class="highlight"><pre><span></span><span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
</pre></div>
</div>
<p>型のインスタンスの参照カウントがゼロになり、Python インタプリタがそれを潰して再利用したくなると、この関数が呼ばれます。解放すべきメモリをその型が保持していたり、それ以外にも実行すべき後処理がある場合は、それらをここに入れられます。オブジェクトそれ自体もここで解放される必要があります。この関数の例は、以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">newdatatype_dealloc</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="p">);</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="index-1">メモリ解放関数でひとつ重要なのは、処理待ちの例外にいっさい手をつけないことです。なぜなら、解放用の関数は Python インタプリタがスタックを元の状態に戻すときに呼ばれることが多いからです。そして (通常の関数からの復帰でなく) 例外のためにスタックが巻き戻されるときは、すでに発生している例外からメモリ解放関数を守るものはありません。解放用の関数がおこなう動作が追加の Python のコードを実行してしまうと、それらは例外が発生していることを検知するかもしれません。これはインタプリタが誤解させるエラーを発生させることにつながります。これを防ぐ正しい方法は、安全でない操作を実行する前に処理待ちの例外を保存しておき、終わったらそれを元に戻すことです。これは <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Fetch" title="PyErr_Fetch"><code class="xref c c-func docutils literal"><span class="pre">PyErr_Fetch()</span></code></a> および <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Restore" title="PyErr_Restore"><code class="xref c c-func docutils literal"><span class="pre">PyErr_Restore()</span></code></a> 関数を使うことによって可能になります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">my_dealloc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">cbresult</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">err_type</span><span class="p">,</span> <span class="o">*</span><span class="n">err_value</span><span class="p">,</span> <span class="o">*</span><span class="n">err_traceback</span><span class="p">;</span>

        <span class="cm">/* This saves the current exception state */</span>
        <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">cbresult</span> <span class="o">=</span> <span class="n">PyObject_CallObject</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cbresult</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">PyErr_WriteUnraisable</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">cbresult</span><span class="p">);</span>

        <span class="cm">/* This restores the saved exception state */</span>
        <span class="n">PyErr_Restore</span><span class="p">(</span><span class="n">err_type</span><span class="p">,</span> <span class="n">err_value</span><span class="p">,</span> <span class="n">err_traceback</span><span class="p">);</span>

        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">my_callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>メモリ解放関数の中で安全に行えることにはいくつか制限があります。
1つ目は、その型が (<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> および <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> を使って) ガベージコレクションをサポートしている場合、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> が呼び出されるまでに、消去されファイナライズされてしまうオブジェクトのメンバーが有り得ることです。
2つ目は、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> の中ではオブジェクトは不安定な状態にあることです: つまり参照カウントが0であるということです。
(上の例にあるような) 複雑なオブジェクトや API の呼び出しでは、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> を再度呼び出し、二重解放からクラッシュすることになるかもしれません。</p>
<p>Python 3.4 からは、複雑なファイナライズのコードは <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> に置かず、代わりに新しく導入された <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal"><span class="pre">tp_finalize</span></code></a> という型メソッドを使うことが推奨されています。</p>
<div class="last admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a> で新しいファイナライズの仕組みが説明されています。</p>
</div>
</div>
</div>
<div class="section" id="object-presentation">
<span id="index-3"></span><h3>2.2.2. オブジェクト表現<a class="headerlink" href="#object-presentation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python では、オブジェクトの文字列表現を生成するのに 2つのやり方があります: <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 関数を使う方法と、 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>  関数を使う方法です。 (<a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 関数は単に <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を呼び出します。) これらのハンドラはどちらも省略できます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>
<span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラは呼び出されたインスタンスの文字列表現を格納した文字列オブジェクトを返す必要があります。簡単な例は以下のようなものです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_repr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;Repr-ified_newdatatype{{size:\%d}}&quot;</span><span class="p">,</span>
                                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラが指定されていなければ、インタプリタはその型の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal"><span class="pre">tp_name</span></code></a> とそのオブジェクトの一意な識別値をもちいて文字列表現を作成します。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> ハンドラと <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> の関係は、上の <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラと <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> の関係に相当します。つまり、これは Python のコードがオブジェクトのインスタンスに対して <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> を呼び出したときに呼ばれます。この関数の実装は <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラのそれと非常に似ていますが、得られる文字列表現は人間が読むことを意図されています。 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal"><span class="pre">tp_str</span></code></a> が指定されていない場合、かわりに <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal"><span class="pre">tp_repr</span></code></a> ハンドラが使われます。</p>
<p>以下は簡単な例です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_str</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span><span class="s">&quot;Stringified_newdatatype{{size:\%d}}&quot;</span><span class="p">,</span>
                                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="attribute-management">
<h3>2.2.3. 属性を管理する<a class="headerlink" href="#attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>属性をもつどのオブジェクトに対しても、その型は、それらオブジェクトの属性をどのように解決するか制御する関数を提供する必要があります。必要な関数としては、属性を (それが定義されていれば) 取り出すものと、もうひとつは属性に (それが許可されていれば) 値を設定するものです。属性を削除するのは特殊なケースで、この場合は新しい値としてハンドラに <em>NULL</em> が渡されます。</p>
<p>Python は 2つの属性ハンドラの組をサポートしています。属性をもつ型はどちらか一組を実装するだけでよく、それらの違いは一方の組が属性の名前を <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> として受け取るのに対してもう一方の組は属性の名前を <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> として受け取る、というものです。それぞれの型はその実装にとって都合がよい方を使えます。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">getattrfunc</span>  <span class="n">tp_getattr</span><span class="p">;</span>        <span class="cm">/* char * version */</span>
<span class="n">setattrfunc</span>  <span class="n">tp_setattr</span><span class="p">;</span>
<span class="cm">/* ... */</span>
<span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>       <span class="cm">/* PyObject * version */</span>
<span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>
</pre></div>
</div>
<p>オブジェクトの属性へのアクセスがつねに (すぐあとで説明する) 単純な操作だけならば、 <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> を使って属性を管理する関数として、総称的 (generic) な実装を使えます。特定の型に特化した属性ハンドラの必要性は Python 2.2 からほとんど完全になくなりました。しかし、多くの例はまだ、この新しく使えるようになった総称的なメカニズムを使うよう更新されてはいません。</p>
<div class="section" id="generic-attribute-management">
<span id="id6"></span><h4>2.2.3.1. 総称的な属性を管理する<a class="headerlink" href="#generic-attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>ほとんどの型は <em>単純な</em> 属性を使うだけです。では、どのような属性が単純だといえるのでしょうか? それが満たすべき条件はごくわずかです:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が呼ばれたとき、すでに属性の名前がわかっていること。</li>
<li>属性を参照したり設定したりするときに、特別な記録のための処理が必要でなく、また参照したり設定した値に対してどんな操作も実行する必要がないこと。</li>
</ol>
<p>これらの条件は、属性の値や、値が計算されるタイミング、または格納されたデータがどの程度妥当なものであるかといったことになんら制約を課すものではないことに注意してください。</p>
<p><a class="reference internal" href="../c-api/type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal"><span class="pre">PyType_Ready()</span></code></a> が呼ばれると、これはそのタイプオブジェクトに参照されている 3つのテーブルを使って、そのタイプオブジェクトの辞書中にデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>) を作成します。各デスクリプタは、インスタンスオブジェクトの属性に対するアクセスを制御します。それぞれのテーブルはなくてもかまいません。もしこれら 3つがすべて <em>NULL</em> だと、その型のインスタンスはその基底型から継承した属性だけを持つことになります。また、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal"><span class="pre">tp_getattro</span></code></a> および <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal"><span class="pre">tp_setattro</span></code></a> が <em>NULL</em> のままだった場合も、基底型にこれらの属性の操作がまかせられます。</p>
<p>テーブルはタイプオブジェクト中の 3つのメンバとして宣言されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> が <em>NULL</em> でない場合、これは <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal"><span class="pre">PyMethodDef</span></code></a> 構造体への配列を指している必要があります。テーブル中の各エントリは、つぎのような構造体のインスタンスです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_name</span><span class="p">;</span>       <span class="cm">/* method name */</span>
    <span class="n">PyCFunction</span>  <span class="n">ml_meth</span><span class="p">;</span>       <span class="cm">/* implementation function */</span>
    <span class="kt">int</span>          <span class="n">ml_flags</span><span class="p">;</span>      <span class="cm">/* flags */</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">ml_doc</span><span class="p">;</span>        <span class="cm">/* docstring */</span>
<span class="p">}</span> <span class="n">PyMethodDef</span><span class="p">;</span>
</pre></div>
</div>
<p>その型が提供する各メソッドについてひとつのエントリを定義する必要があります。基底型から継承してきたメソッドについてはエントリは必要ありません。これの最後には、配列の終わりを示すための見張り番 (sentinel) として追加のエントリがひとつ必要です。この場合、 <code class="xref py py-attr docutils literal"><span class="pre">ml_name</span></code> メンバが sentinel として使われ、その値は <em>NULL</em> でなければなりません。</p>
<p>2番目のテーブルは、インスタンス中に格納されるデータと直接対応づけられた属性を定義するのに使います。いくつもの C の原始的な型がサポートされており、アクセスを読み出し専用にも読み書き可能にもできます。このテーブルで使われる構造体は次のように定義されています:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">type</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">doc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyMemberDef</span><span class="p">;</span>
</pre></div>
</div>
<p>このテーブルの各エントリに対してデスクリプタ(<a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>)が作成され、値をインスタンスの構造体から抽出しうる型に対してそれらが追加されます。 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-attr docutils literal"><span class="pre">type</span></code></a> メンバは <code class="file docutils literal"><span class="pre">structmember.h</span></code> ヘッダで定義された型のコードをひとつ含んでいる必要があります。この値は Python における値と C における値をどのように変換しあうかを定めるものです。 <code class="xref py py-attr docutils literal"><span class="pre">flags</span></code> メンバはこの属性がどのようにアクセスされるかを制御するフラグを格納するのに使われます。</p>
<p>以下のフラグ用定数は <code class="file docutils literal"><span class="pre">structmember.h</span></code> で定義されており、これらはビットごとの OR を取って組み合わせられます。</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">定数</th>
<th class="head">意味</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">READONLY</span></code></td>
<td>絶対に変更できない。</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">READ_RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では参照できない。</td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">WRITE_RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では変更できない。</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">RESTRICTED</span></code></td>
<td>制限モード (restricted mode) では参照も変更もできない。</td>
</tr>
</tbody>
</table>
<p id="index-4"><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal"><span class="pre">tp_members</span></code></a> を使ったひとつの面白い利用法は、実行時に使われるデスクリプタを作成しておき、単にテーブル中にテキストを置いておくことによって、この方法で定義されたすべての属性に doc string を関連付けられるようにすることです。アプリケーションはこのイントロスペクション用 API を使って、クラスオブジェクトからデスクリプタを取り出し、その <code class="xref py py-attr docutils literal"><span class="pre">__doc__</span></code> 属性を使って doc string を得られます。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal"><span class="pre">tp_methods</span></code></a> テーブルと同じように、ここでも <code class="xref py py-attr docutils literal"><span class="pre">name</span></code> メンバの値を <em>NULL</em> にした見張り用エントリが必要です。</p>
</div>
<div class="section" id="type-specific-attribute-management">
<h4>2.2.3.2. 特定の型に特化した属性の管理<a class="headerlink" href="#type-specific-attribute-management" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>話を単純にするため、ここでは <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> を使ったバージョンのみを示します。name パラメータの型はインターフェイスとして <code class="xref c c-type docutils literal"><span class="pre">char*</span></code> を使うか <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> を使うかの違いしかありません。この例では、上の総称的な例と同じことを効率的にやりますが、 Python 2.2 で追加された総称的な型のサポートを使わずにやります。これはハンドラの関数がどのようにして呼ばれるのかを説明します。これで、たとえその機能を拡張する必要があるとき、何をどうすればいいかわかるでしょう。</p>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal"><span class="pre">tp_getattr</span></code></a> ハンドラはオブジェクトが属性への参照を要求するときに呼ばれます。これは、そのクラスの <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドが呼ばれるであろう状況と同じ状況下で呼び出されます。</p>
<p>以下に例を示します。:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_getattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;data&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">PyLong_FromLong</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                 <span class="s">&quot;&#39;%.50s&#39; object has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> ハンドラは、クラスのインスタンスの <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal"><span class="pre">__setattr__()</span></code></a> または <a class="reference internal" href="../reference/datamodel.html#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal"><span class="pre">__delattr__()</span></code></a> メソッドが呼ばれるであろう状況で呼び出されます。ある属性が削除されるとき、3番目のパラメータは <em>NULL</em> になります。以下の例はたんに例外を発生させるものですが、もし本当にこれと同じことをしたいなら、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal"><span class="pre">tp_setattr</span></code></a> ハンドラを <em>NULL</em> に設定すべきです。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">newdatatype_setattr</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span> <span class="s">&quot;Read-only attribute: \%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="object-comparison">
<h3>2.2.4. オブジェクトの比較<a class="headerlink" href="#object-comparison" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal"><span class="pre">tp_richcompare</span></code></a> ハンドラは比較処理が要求されたときに呼び出されます。
<a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> のような <a class="reference internal" href="../reference/datamodel.html#richcmpfuncs"><span class="std std-ref">拡張比較メソッド</span></a> に類似しており、 <a class="reference internal" href="../c-api/object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal"><span class="pre">PyObject_RichCompare()</span></code></a> と <a class="reference internal" href="../c-api/object.html#c.PyObject_RichCompareBool" title="PyObject_RichCompareBool"><code class="xref c c-func docutils literal"><span class="pre">PyObject_RichCompareBool()</span></code></a> からも呼び出されます。</p>
<p>この関数は 2 つの Python オブジェクトと演算子を引数に取り、演算子は <code class="docutils literal"><span class="pre">Py_EQ</span></code>, <code class="docutils literal"><span class="pre">Py_NE</span></code>, <code class="docutils literal"><span class="pre">Py_LE</span></code>, <code class="docutils literal"><span class="pre">Py_GT</span></code>, <code class="docutils literal"><span class="pre">Py_LT</span></code>, <code class="docutils literal"><span class="pre">Py_GT</span></code> のどれか 1 つです。関数は指定された演算子に従って 2 つのオブジェクトを比較し、比較に成功した場合の <code class="docutils literal"><span class="pre">Py_True</span></code> および <code class="docutils literal"><span class="pre">Py_False</span></code> か、比較処理が実装されておらず、もう一方のオブジェクトの比較処理を試行することを示す <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> か、例外が設定された場合の <em>NULL</em> のいづれかを返します。</p>
<p>これは内部ポインタのサイズが等しければ等しいと見なすデータ型のサンプル実装です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_richcmp</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj1</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">;</span>

    <span class="cm">/* code to make sure that both arguments are of type</span>
<span class="cm">       newdatatype omitted */</span>

    <span class="n">size1</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">size2</span> <span class="o">=</span> <span class="n">obj2</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">Py_LT</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&lt;</span>  <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_LE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&lt;=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_EQ</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">==</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_NE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">!=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_GT</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&gt;</span>  <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">Py_GE</span><span class="p">:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">size1</span> <span class="o">&gt;=</span> <span class="n">size2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">c</span> <span class="o">?</span> <span class="nl">Py_True</span> <span class="p">:</span> <span class="n">Py_False</span><span class="p">;</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="abstract-protocol-support">
<h3>2.2.5. 抽象的なプロトコルのサポート<a class="headerlink" href="#abstract-protocol-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python はいくつもの <em>抽象的な</em> “プロトコル”をサポートしています。これらを使用する特定のインターフェイスについては <a class="reference internal" href="../c-api/abstract.html#abstract"><span class="std std-ref">抽象オブジェクトレイヤ (abstract objects layer)</span></a> で解説されています。</p>
<p>これら多数の抽象的なインターフェイスは、Python の実装が開発される初期の段階で定義されていました。とりわけ数値や辞書、そしてシーケンスなどのプロトコルは最初から Python の一部だったのです。それ以外のプロトコルはその後追加されました。型の実装にあるいくつかのハンドラルーチンに依存するようなプロトコルのために、古いプロトコルはハンドラの入ったオプションのブロックとして定義し、型オブジェクトから参照するようになりました。タイプオブジェクトの主部に追加のスロットをもつ新しいプロトコルについては、フラグ用のビットを立てることでそれらのスロットが存在しており、インタプリタがチェックすべきであることを指示できます。(このフラグ用のビットは、そのスロットの値が非 <em>NULL</em> であることを示しているわけではありません。フラグはスロットの存在を示すのに使えますが、そのスロットはまだ埋まっていないかもしれないのです。)</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyNumberMethods</span>   <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
<span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
<span class="n">PyMappingMethods</span>  <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>
</pre></div>
</div>
<p>お使いのオブジェクトを数値やシーケンス、あるいは辞書のようにふるまうようにしたいならば、それぞれに C の <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal"><span class="pre">PyNumberMethods</span></code></a> 構造体、 <a class="reference internal" href="../c-api/typeobj.html#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal"><span class="pre">PySequenceMethods</span></code></a> 構造体、または <a class="reference internal" href="../c-api/typeobj.html#c.PyMappingMethods" title="PyMappingMethods"><code class="xref c c-type docutils literal"><span class="pre">PyMappingMethods</span></code></a> 構造体のアドレスを入れます。これらに適切な値を入れても入れなくてもかまいません。これらを使った例は Python の配布ソースにある <code class="file docutils literal"><span class="pre">Objects</span></code> でみつけることができるでしょう。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、もし使うのならば、これはお使いの型のインスタンスのハッシュ番号を返すようにします。以下はやや的はずれな例ですが</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">long</span>
<span class="nf">newdatatype_hash</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
</pre></div>
</div>
<p>この関数は、その型のインスタンスが「関数として呼び出される」ときに呼ばれます。たとえばもし <code class="docutils literal"><span class="pre">obj1</span></code> にそのインスタンスが入っていて、Python スクリプトで <code class="docutils literal"><span class="pre">obj1('hello')</span></code> を実行したとすると、 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal"><span class="pre">tp_call</span></code></a> ハンドラが呼ばれます。</p>
<p>この関数は 3つの引数をとります:</p>
<ol class="arabic simple">
<li><em>arg1</em> にはその呼び出しの対象となる、そのデータ型のインスタンスが入ります。たとえば呼び出しが <code class="docutils literal"><span class="pre">obj1('hello')</span></code> の場合、 <em>arg1</em> は <code class="docutils literal"><span class="pre">obj1</span></code> になります。</li>
<li><em>arg2</em> は呼び出しの引数を格納しているタプルです。ここから引数を取り出すには <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> を使います。</li>
<li><em>arg3</em> はキーワード引数のための辞書です。これが <em>NULL</em> 以外でキーワード引数をサポートしているなら、 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> をつかって引数を取り出せます。キーワード引数をサポートしていないのにこれが <em>NULL</em> 以外の場合は、キーワード引数はサポートしていない旨のメッセージとともに <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を発生させてください。</li>
</ol>
<p>以下はこの call 関数をてきとうに使った例です。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Implement the call function.</span>
<span class="cm"> *    obj1 is the instance receiving the call.</span>
<span class="cm"> *    obj2 is a tuple containing the arguments to the call, in this</span>
<span class="cm"> *         case 3 strings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">newdatatype_call</span><span class="p">(</span><span class="n">newdatatypeobject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg2</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">arg3</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;sss:call&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg3</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">PyUnicode_FromFormat</span><span class="p">(</span>
        <span class="s">&quot;Returning -- value: [\%d] arg1: [\%s] arg2: [\%s] arg3: [\%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">obj_UnderlyingDatatypePtr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
        <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* Iterators */</span>
<span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
<span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>
</pre></div>
</div>
<p>これらの関数はイテレータ用プロトコルをサポートします。オブジェクトが、その (ループ中に順に生成されていくかもしれない) 内容を巡回 (訳注: イテレータでひとつずつ要素をたどっていくこと) するイテレータをサポートしたい場合は、 <code class="docutils literal"><span class="pre">tp_iter</span></code> ハンドラを実装する必要があります。 <code class="docutils literal"><span class="pre">tp_iter</span></code> ハンドラによって返されるオブジェクトは <code class="docutils literal"><span class="pre">tp_iter</span></code> と <code class="docutils literal"><span class="pre">tp_iternext</span></code> の両方を実装する必要があります。どちらのハンドラも、それが呼ばれたインスタンスをひとつだけ引数としてとり、新しい参照を返します。エラーが起きた場合には例外を設定してから <em>NULL</em> を返す必要があります。</p>
<p>巡回可能な要素を表現するオブジェクトに対しては、 <code class="docutils literal"><span class="pre">tp_iter</span></code> ハンドラがイテレータオブジェクトを返す必要があります。イテレータオブジェクトは巡回中の状態を保持する責任をもっています。お互いに干渉しない複数のイテレータの存在を許すようなオブジェクト (リストやタプルがそうです) の場合は、新しいイテレータを作成して返す必要があります。 (巡回の結果生じる副作用のために) 一回だけしか巡回できないオブジェクトの場合は、それ自身への参照を返すようなハンドラと、 <code class="docutils literal"><span class="pre">tp_iternext</span></code> ハンドラも実装する必要があります。ファイルオブジェクトはそのようなイテレータの例です。</p>
<p>イテレータオブジェクトは両方のハンドラを実装する必要があります。 <code class="docutils literal"><span class="pre">tp_iter</span></code> ハンドラはそのイテレータへの新しい参照を返します (これは破壊的にしか巡回できないオブジェクトに対する <code class="docutils literal"><span class="pre">tp_iter</span></code> ハンドラと同じです)。 <code class="docutils literal"><span class="pre">tp_iternext</span></code> ハンドラはその次のオブジェクトがある場合、それへの新しい参照を返します。巡回が終端に達したときは例外を出さずに <em>NULL</em> を返してもいいですし、 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を放出してもかまいません。例外を使わないほうがやや速度が上がるかもしれません。実際のエラーが起こったときには、例外を放出して <em>NULL</em> を返す必要があります。</p>
</div>
<div class="section" id="weak-reference-support">
<span id="weakref-support"></span><h3>2.2.6. 弱参照(Weak Reference)のサポート<a class="headerlink" href="#weak-reference-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pythonの弱参照実装のひとつのゴールは、どのような（数値のような弱参照による利益を得ない）タイプでもオーバーヘッドなしで弱参照のメカニズムに組み込めるようにすることです。</p>
<p>弱参照可能なオブジェクトの拡張では、弱参照メカニズムのために <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> フィールドをインスタンス構造体に含む必要があります。これはオブジェクトのコンストラクタで <em>NULL</em> に初期化する必要があります。これは対応するタイプの <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal"><span class="pre">tp_weaklistoffset</span></code></a> フィールドをフィールドのオフセットに設定しなければいけません。たとえば、インスタンスタイプは以下の構造体で定義されます:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">in_class</span><span class="p">;</span>       <span class="cm">/* The class object */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_dict</span><span class="p">;</span>        <span class="cm">/* A dictionary */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">PyInstanceObject</span><span class="p">;</span>
</pre></div>
</div>
<p>インスタンス用に静的に宣言されたタイプオブジェクトはこのように定義されます:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyTypeObject</span> <span class="n">PyInstance_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="s">&quot;module.instance&quot;</span><span class="p">,</span>

    <span class="cm">/* Lots of stuff omitted for brevity... */</span>

    <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>                         <span class="cm">/* tp_flags */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_richcompare */</span>
    <span class="n">offsetof</span><span class="p">(</span><span class="n">PyInstanceObject</span><span class="p">,</span> <span class="n">in_weakreflist</span><span class="p">),</span> <span class="cm">/* tp_weaklistoffset */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>タイプのコンストラクタは弱参照を <em>NULL</em> に初期化する責任があります:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_new</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Other initialization stuff omitted for brevity */</span>

    <span class="n">self</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ほかに追記すべきことは、デストラクタは弱参照を消すために弱参照のマネージャを呼ぶ必要があることくらいです。これは弱参照リストが <em>NULL</em> でない場合にだけ必要です:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">instance_dealloc</span><span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Allocate temporaries if needed, but do not begin</span>
<span class="cm">       destruction just yet.</span>
<span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">PyObject_ClearWeakRefs</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">inst</span><span class="p">);</span>

    <span class="cm">/* Proceed with object destruction normally. */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="more-suggestions">
<h3>2.2.7. その他いろいろ<a class="headerlink" href="#more-suggestions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上にあげたほとんどの関数は、その値として <code class="docutils literal"><span class="pre">0</span></code> を与えれば省略できることを忘れないでください。それぞれの関数で提供しなければならない型の定義があり、これらは Python の include 用ディレクトリの <code class="file docutils literal"><span class="pre">object.h</span></code> というファイルにおさめられています。これは Python の配布ソースに含まれています。</p>
<p>新しいデータ型に何らかのメソッドを実装するやりかたを学ぶには、以下の方法がおすすめです: Python の配布されているソースをダウンロードして展開する。 <code class="file docutils literal"><span class="pre">Objects</span></code> ディレクトリへ行き、C のソースファイルから「 <code class="docutils literal"><span class="pre">tp_</span></code> 欲しい名前」の文字列で検索する (たとえば <code class="docutils literal"><span class="pre">tp_print</span></code> とか <code class="docutils literal"><span class="pre">tp_richcompare</span></code> のように)。こうすれば実装したい例がみつかるでしょう。</p>
<p>あるオブジェクトが、いま実装している型のインスタンスであるかどうかを確かめたい場合には、 <a class="reference internal" href="../c-api/object.html#c.PyObject_TypeCheck" title="PyObject_TypeCheck"><code class="xref c c-func docutils literal"><span class="pre">PyObject_TypeCheck()</span></code></a> 関数を使ってください。使用例は以下のようなかんじです:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">PyObject_TypeCheck</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyType</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;arg #1 not a mything&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>これはそのオブジェクトが文字列や実数などの基本タイプであるような時に成り立ちます。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>ここで出てきたタイプではガベージコレクションをサポートしていないので、この例では <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> ハンドラに依存しています。このハンドラはそのタイプがたとえガベージコレクションをサポートしている場合でも、そのオブジェクトの「追跡を解除する」ために呼ばれることがありますが、これは高度な話題でありここでは扱いません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>first および last メンバが文字列であるということはわかっているので、いまやそれらの参照カウントを減らすときにはそれほど注意する必要はないように思えるかもしれません。しかし文字列型のサブクラスは依然として受けつけられています。通常の文字列型ならば、解放時にあなたのオブジェクトがコールバックされることはありませんが、文字列型のサブクラスがそうしないという保証はありません。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>3番目のバージョンでさえ、循環を回避できるという保証はされていません。たとえ通常の文字列型なら循環しない場合でも、文字列型のサブクラスをとることが許されていれば、そのタイプでは循環が発生しうるからです。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. 新しい型を定義する</a><ul>
<li><a class="reference internal" href="#the-basics">2.1. 基本的なこと</a><ul>
<li><a class="reference internal" href="#adding-data-and-methods-to-the-basic-example">2.1.1. 基本のサンプルにデータとメソッドを追加する</a></li>
<li><a class="reference internal" href="#providing-finer-control-over-data-attributes">2.1.2. データ属性をこまかく制御する</a></li>
<li><a class="reference internal" href="#supporting-cyclic-garbage-collection">2.1.3. 循環ガベージコレクションをサポートする</a></li>
<li><a class="reference internal" href="#subclassing-other-types">2.1.4. 他の型のサブクラスを作る</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-methods">2.2. タイプメソッド</a><ul>
<li><a class="reference internal" href="#finalization-and-de-allocation">2.2.1. ファイナライズとメモリ解放</a></li>
<li><a class="reference internal" href="#object-presentation">2.2.2. オブジェクト表現</a></li>
<li><a class="reference internal" href="#attribute-management">2.2.3. 属性を管理する</a><ul>
<li><a class="reference internal" href="#generic-attribute-management">2.2.3.1. 総称的な属性を管理する</a></li>
<li><a class="reference internal" href="#type-specific-attribute-management">2.2.3.2. 特定の型に特化した属性の管理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#object-comparison">2.2.4. オブジェクトの比較</a></li>
<li><a class="reference internal" href="#abstract-protocol-support">2.2.5. 抽象的なプロトコルのサポート</a></li>
<li><a class="reference internal" href="#weak-reference-support">2.2.6. 弱参照(Weak Reference)のサポート</a></li>
<li><a class="reference internal" href="#more-suggestions">2.2.7. その他いろいろ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="extending.html"
                        title="前の章へ">1. C や C++ による Python の拡張</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="building.html"
                        title="次の章へ">3. C および C++ 拡張のビルド</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/extending/newtypes.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="building.html" title="3. C および C++ 拡張のビルド"
             >次へ</a> |</li>
        <li class="right" >
          <a href="extending.html" title="1. C や C++ による Python の拡張"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="version_switcher_placeholder">3.6.3</span>
          <a href="../index.html">ドキュメント</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python インタプリタの拡張と埋め込み</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, Python Software Foundation.
    <br />
    Python Software Foundation は非営利団体です。
    <a href="https://www.python.org/psf/donations/">寄付</a>
    <br />
    最終更新日時: 1月 10, 2018
    <a href="../bugs.html">バグを見つけたら</a>?
    <br />
    このドキュメントは <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 を使って作成されました。
    </div>

  </body>
</html>